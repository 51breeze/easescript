var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// lib/core/EventDispatcher.js
var require_EventDispatcher = __commonJS({
  "lib/core/EventDispatcher.js"(exports, module) {
    var events = __require("events");
    var keySymbol = Symbol("keySymbol");
    events.EventEmitter.defaultMaxListeners = 1e5;
    var EventDispatcher = class {
      constructor() {
        this[keySymbol] = new events.EventEmitter();
      }
      addListener(event, listener) {
        return this[keySymbol].addListener(event, listener);
      }
      on(event, listener) {
        return this[keySymbol].on(event, listener);
      }
      once(event, listener) {
        return this[keySymbol].once(event, listener);
      }
      removeListener(event, listener) {
        return this[keySymbol].removeListener(event, listener);
      }
      off(event, listener) {
        return this[keySymbol].off(event, listener);
      }
      removeAllListeners(event, listener) {
        return this[keySymbol].removeAllListeners(event, listener);
      }
      dispatcher(event, ...args) {
        return this[keySymbol].emit(event, ...args);
      }
    };
    module.exports = EventDispatcher;
  }
});

// lib/core/Scope.js
var require_Scope = __commonJS({
  "lib/core/Scope.js"(exports, module) {
    var EventDispatcher = require_EventDispatcher();
    var scopeParents = ["block", "function", "class", "top"];
    module.exports = class Scope extends EventDispatcher {
      static is(value2) {
        return value2 ? value2 instanceof Scope : false;
      }
      constructor(parent) {
        super();
        this.parent = parent;
        this.children = [];
        this.level = 0;
        if (parent) {
          parent.children.push(this);
          this.level = parent.level + 1;
          this.asyncParentScopeOf = parent.async ? parent : parent.asyncParentScopeOf;
        }
        if (parent && parent.topDeclarations) {
          this.topDeclarations = parent.topDeclarations;
          this.gathers = parent.gathers;
        } else {
          this.topDeclarations = /* @__PURE__ */ new Set();
          this.gathers = /* @__PURE__ */ Object.create(null);
        }
        this.declarations = /* @__PURE__ */ new Map();
        this.proxyScope = null;
        this.isStatic = false;
        this._predicates = null;
        this._validates = null;
      }
      removeChild(childScope) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.removeChild(childScope);
        }
        const index = this.children.indexOf(childScope);
        if (index >= 0) {
          return this.children.splice(index, 1);
        }
        return null;
      }
      hasChildDeclared(name) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.hasChildDeclared(name);
        }
        const check = (item2) => {
          if (item2.isDefine(name)) {
            return true;
          } else {
            return item2.children.some(check);
          }
        };
        return check(this);
      }
      generateVarName(name, flag = false) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.generateVarName(name, flag);
        }
        let count = 0;
        let ref = name;
        while (this.declarations.has(ref) || flag === false && this.topDeclarations.has(ref) || flag === true && this.hasChildDeclared(ref)) {
          count++;
          ref = name + count;
        }
        this.define(ref, this);
        return ref;
      }
      type(name) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.type(name);
        }
        return false;
      }
      getScopeByType(name) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.getScopeByType(name);
        }
        let obj = this;
        while (obj && obj instanceof Scope && !obj.type(name)) {
          obj = obj.parent;
        }
        return obj;
      }
      getScopeByCallback(callback) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.getScopeByCallback(callback);
        }
        let obj = this;
        while (obj && !callback(obj)) {
          obj = obj.parent;
        }
        return obj;
      }
      define(name, stack, noTopFlag = false) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.define(name, stack);
        }
        if (stack === void 0) {
          let def = this.declarations.get(name);
          if (def === this)
            def = null;
          if (!def) {
            let parentScope = this.parent;
            while (parentScope && parentScope instanceof Scope) {
              if (parentScope.declarations.has(name)) {
                const res = parentScope.declarations.get(name);
                return res === parentScope ? null : res;
              } else {
                parentScope = parentScope.parent;
              }
            }
            return null;
          }
          return def;
        }
        const gathers = this.gathers[name] || (this.gathers[name] = []);
        gathers.push(this);
        this.declarations.set(name, stack);
        if (!noTopFlag && this.topDeclarations) {
          this.topDeclarations.add(name);
        }
      }
      getDefine(name, context) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.getDefine(name, context);
        }
        let def = this.declarations.get(name);
        if (def === this)
          def = null;
        if (!def) {
          let parentScope = this.parent;
          while (parentScope && parentScope instanceof Scope) {
            if (parentScope.declarations.has(name)) {
              const res = parentScope.declarations.get(name);
              return res === parentScope ? null : res;
            } else {
              if (context && (parentScope.type(context) || context === "block" && parentScope.type("function"))) {
                return false;
              }
              parentScope = parentScope.parent;
            }
          }
          return null;
        }
        return def;
      }
      getKeys(context = null) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.getKeys(context);
        }
        let keys = /* @__PURE__ */ new Set();
        let pushKeys = (object) => {
          object.declarations.forEach((def, name) => {
            if (def !== object) {
              keys.add(name);
            }
          });
        };
        {
          pushKeys(this);
        }
        let parent = this.parent;
        while (parent) {
          const is = !context || context.some((name) => !!parent.type(name));
          if (is) {
            pushKeys(parent);
            parent = parent.parent;
          } else {
            break;
          }
        }
        return Array.from(keys.values());
      }
      getValues(context = null) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.getValues(context);
        }
        let dataset = /* @__PURE__ */ new Map();
        let push = (object) => {
          object.declarations.forEach((def, name) => {
            if (def !== object) {
              if (!dataset.has(name)) {
                dataset.set(name, def);
              }
            }
          });
        };
        {
          push(this);
        }
        let parent = this.parent;
        while (parent) {
          const is = !context || context.some((name) => !!parent.type(name));
          if (is) {
            push(parent);
            parent = parent.parent;
          } else {
            break;
          }
        }
        return dataset;
      }
      checkDocumentDefineScope(name, excludes = []) {
        const gathers = this.gathers[name];
        if (gathers) {
          if (excludes && excludes.length > 0) {
            return gathers.some((scope) => !excludes.some((name2) => scope.type(name2)));
          } else {
            return true;
          }
        }
        return false;
      }
      getDocumentDefineScopes(name, excludes = []) {
        const gathers = this.gathers[name];
        if (gathers) {
          if (excludes && excludes.length > 0) {
            return gathers.filter((scope) => !excludes.some((name2) => scope.type(name2)));
          }
        }
        return gathers || [];
      }
      isDefine(name, endContext) {
        let proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return this.proxyScope.isDefine(name, endContext);
        }
        let parentScope = this;
        while (parentScope && parentScope instanceof Scope) {
          let def = parentScope.declarations.get(name);
          if (def && parentScope !== def) {
            return true;
          } else {
            if (endContext) {
              if (parentScope.type(endContext)) {
                return false;
              }
              const at = scopeParents.indexOf(endContext);
              if (at >= 0) {
                const scopes = scopeParents.slice(at + 1);
                if (scopes.length > 0 && scopes.some((name2) => parentScope.type(name2))) {
                  return false;
                }
              }
            }
            parentScope = parentScope.parent;
          }
        }
        return false;
      }
      allowInsertionPredicate() {
        return this.isBlockScope || this.isTopScope || this.isFunctionScope || this.isBlankScope;
      }
      get predicates() {
        return this._predicates || (this._predicates = /* @__PURE__ */ new Map());
      }
      get validates() {
        return this._validates || (this._validates = /* @__PURE__ */ new Map());
      }
      setPredicate(descriptor, type2) {
        this.predicates.set(descriptor, type2);
      }
      getPredicate(descriptor, onlyFlag = false) {
        let type2 = this.predicates.get(descriptor);
        if (!type2 && !onlyFlag) {
          let parentScope = this.parent;
          while (parentScope) {
            if (parentScope.isClassScope || parentScope.isInterfaceScope || parentScope.isDeclaratorScope)
              break;
            if (parentScope.allowInsertionPredicate()) {
              type2 = parentScope.predicates.get(descriptor);
              if (type2)
                return type2;
            }
            parentScope = parentScope.parent;
          }
        }
        return type2 || null;
      }
      getValidateState(descriptor, onlyFlag = false) {
        let info = this.validates.get(descriptor);
        if (!info && !onlyFlag) {
          let parentScope = this.parent;
          while (parentScope) {
            if (parentScope.isClassScope || parentScope.isInterfaceScope || parentScope.isDeclaratorScope)
              break;
            if (parentScope.allowInsertionPredicate()) {
              info = parentScope.validates.get(descriptor);
              if (info)
                return info;
            }
            parentScope = parentScope.parent;
          }
        }
        return info || null;
      }
      setValidateState(descriptor, type2, value2, expr, block, isAlternate = false) {
        this.validates.set(descriptor, { type: type2, value: value2, expr, scope: this, stack: block, isAlternate });
      }
    };
  }
});

// lib/scope/TopScope.js
var require_TopScope = __commonJS({
  "lib/scope/TopScope.js"(exports, module) {
    var Scope = require_Scope();
    module.exports = class TopScope extends Scope {
      constructor(parentScope) {
        super(parentScope);
        this.isTopScope = true;
      }
      type(name) {
        return name === "top";
      }
    };
  }
});

// lib/core/Parser.js
var require_Parser = __commonJS({
  "lib/core/Parser.js"(exports, module) {
    var acorn = __require("acorn");
    var jsx = __require("acorn-jsx");
    var SCOPE_TOP = 1;
    var SCOPE_FUNCTION = 2;
    var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION;
    var SCOPE_ASYNC = 4;
    var SCOPE_GENERATOR = 8;
    var SCOPE_ARROW = 16;
    var SCOPE_SUPER = 64;
    var SCOPE_DIRECT_SUPER = 128;
    var BIND_LEXICAL = 2;
    var FUNC_STATEMENT = 1;
    var FUNC_NULLABLE_ID = 4;
    var Parser = acorn.Parser;
    var TokenType = Parser.acorn.TokenType;
    var tokTypes = Parser.acorn.tokTypes;
    var keywordTypes = Parser.acorn.keywordTypes;
    var tokContexts = Parser.acorn.tokContexts;
    function functionFlags(async, generator) {
      return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
    }
    function DestructuringErrors() {
      this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.parenthesizedBindParam = this.doubleProto = -1;
    }
    keywordTypes["is"] = new TokenType("is", { beforeExpr: true, binop: 7, keyword: "is" });
    tokTypes._is = keywordTypes["is"];
    keywordTypes["as"] = new TokenType("as", { beforeExpr: true, binop: 7, keyword: "as" });
    tokTypes._as = keywordTypes["as"];
    keywordTypes["package"] = new TokenType("package", { startsExpr: true, keyword: "package" });
    tokTypes._package = keywordTypes["package"];
    keywordTypes["implements"] = new TokenType("implements", { startsExpr: true, keyword: "implements" });
    tokTypes._implements = keywordTypes["implements"];
    keywordTypes["private"] = new TokenType("private", { startsExpr: true, keyword: "private" });
    tokTypes._private = keywordTypes["private"];
    keywordTypes["protected"] = new TokenType("protected", { startsExpr: true, keyword: "protected" });
    tokTypes._protected = keywordTypes["protected"];
    keywordTypes["public"] = new TokenType("public", { startsExpr: true, keyword: "public" });
    tokTypes._public = keywordTypes["public"];
    keywordTypes["internal"] = new TokenType("internal", { startsExpr: true, keyword: "internal" });
    tokTypes._internal = keywordTypes["internal"];
    keywordTypes["final"] = new TokenType("final", { startsExpr: true, keyword: "final" });
    tokTypes._final = keywordTypes["final"];
    keywordTypes["static"] = new TokenType("static", { startsExpr: true, keyword: "static" });
    tokTypes._static = keywordTypes["static"];
    keywordTypes["when"] = new TokenType("when", { startsExpr: true, keyword: "when" });
    tokTypes._when = keywordTypes["when"];
    keywordTypes["then"] = new TokenType("then", { startsExpr: true, keyword: "then" });
    tokTypes._then = keywordTypes["then"];
    keywordTypes["enum"] = new TokenType("enum", { startsExpr: true, keyword: "enum" });
    tokTypes._enum = keywordTypes["enum"];
    keywordTypes["interface"] = new TokenType("interface", { startsExpr: true, keyword: "interface" });
    tokTypes._interface = keywordTypes["interface"];
    keywordTypes["abstract"] = new TokenType("abstract", { startsExpr: true, keyword: "abstract" });
    tokTypes._abstract = keywordTypes["abstract"];
    keywordTypes["struct"] = new TokenType("struct", { startsExpr: true, keyword: "struct" });
    tokTypes._struct = keywordTypes["struct"];
    tokTypes._declarator = new TokenType("declarator", { startsExpr: true, keyword: "declarator" });
    tokTypes._annotation = new TokenType("@", { startsExpr: false });
    var tokenModifiers = [
      tokTypes._public,
      tokTypes._internal,
      tokTypes._protected,
      tokTypes._private,
      tokTypes._final,
      tokTypes._static
    ];
    var JSXParser = Parser.extend(jsx({ allowNamespaces: true, allowNamespacedObjects: true }));
    var acornJsx = JSXParser.acornJsx;
    var tok = acornJsx.tokTypes;
    var tt = tokTypes;
    var tc_type_statement = new acorn.TokContext("disabled-expr-context", false, false);
    tc_type_statement.updateContext = function() {
      if (this.curContext() === tc_type_statement) {
        this.context.pop();
      }
    };
    tt.colon.updateContext = function() {
      if (this.curContext() === tc_type_statement) {
        this.exprAllowed = false;
      } else if (this.curContext() === tokContexts.b_expr) {
        this.exprAllowed = true;
      }
    };
    tt.name.updateContext = function(prevType) {
      if (this.context[this.context.length - 2] === tc_type_statement || this.curContext() === tc_type_statement) {
        this.exprAllowed = false;
        return;
      }
      var allowed = false;
      if (this.options.ecmaVersion >= 6 && prevType !== tokTypes.dot) {
        if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
          allowed = true;
        }
      }
      this.exprAllowed = allowed;
    };
    var tc_cdata_expr = new acorn.TokContext("<![CDATA[...]]>", true, true);
    var tt_cdata_start = new TokenType("tt_cdata_start", { startsExpr: true });
    var tt_cdata_end = new TokenType("tt_cdata_end");
    var tt_content_text = new TokenType("cssOrScriptText");
    tt_cdata_start.updateContext = function() {
      this.context.push(tc_cdata_expr);
      this.exprAllowed = false;
    };
    tt_cdata_end.updateContext = function(prevType) {
      if (this.curContext() === tc_cdata_expr) {
        this.context.pop();
      }
      if (this.curContext() === tc_script_expr) {
        this.context.pop();
      }
      this.exprAllowed = this.curContext() === acornJsx.tokContexts.tc_expr;
    };
    tt_content_text.updateContext = function(prevType) {
      if (this.curContext() === tc_style_expr) {
        this.context.pop();
      }
    };
    tokTypes.parenR.updateContext = tokTypes.braceR.updateContext = function(prevType) {
      if (this.context.length === 1) {
        this.exprAllowed = true;
        return;
      }
      var out = this.context.pop();
      if (this.curContext() === tc_type_statement) {
        this.context.pop();
      }
      if (out === tokContexts.b_stat && this.curContext().token === "function") {
        out = this.context.pop();
      }
      if (this.curContext() === tc_type_statement) {
        this.exprAllowed = false;
      } else {
        this.exprAllowed = !out.isExpr;
      }
      if (this.context.length === 1 && this.context[0] === tokContexts.b_stat) {
        this.exprAllowed = true;
      }
    };
    tokTypes.braceL.updateContext = function(prevType) {
      let ctx = this.braceIsBlock(prevType) ? tokContexts.b_stat : tokContexts.b_expr;
      if (this.disabledJSXExpressionFlag) {
        this.disabledJSXExpressionFlag = false;
        this.context.push(tc_type_statement);
      }
      this.context.push(ctx);
      this.exprAllowed = true;
    };
    tokTypes.parenL.updateContext = function(prevType) {
      var statementParens = prevType === tokTypes._if || prevType === tokTypes._for || prevType === tokTypes._with || prevType === tokTypes._while || prevType === tokTypes._when;
      this.context.push(statementParens ? tokContexts.p_stat : tokContexts.p_expr);
      this.exprAllowed = true;
    };
    var tc_script_expr = new acorn.TokContext("<script>...</script>", true, false);
    var tc_style_expr = new acorn.TokContext("<style>...</style>", true, true);
    var tt_whitespace = new TokenType("whitespace");
    function getQualifiedJSXName(object) {
      if (!object)
        return object;
      if (object.type === "JSXIdentifier")
        return object.name;
      if (object.type === "JSXNamespacedName")
        return object.namespace.name + ":" + object.name.name;
      if (object.type === "JSXMemberExpression")
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }
    var SyntaxParser = class extends JSXParser {
      constructor(options, input, startPos) {
        super(options, input, startPos);
        this.onErrorCallback = options.onErrorCallback;
        this.testTokens = [];
        this.stackComments = [];
        this.keywords = new RegExp(this.keywords.source.replace(")$", "|is|package|implements|static|final|public|internal|protected|private|when|then|enum|interface|abstract|struct)$"));
        if (Array.isArray(options.reserved) && options.reserved.length > 0) {
          this.reservedWords = new RegExp(this.reservedWords.source.replace(")$", "|" + options.reserved.join("|") + ")$"));
        }
      }
      raiseRecoverable(pos, message) {
        const onError = this.onErrorCallback;
        if (onError) {
          if (message.endsWith("has already been declared")) {
            return;
          }
        }
        this.raise(pos, message);
      }
      next(ignoreEscapeSequenceInKeyword) {
        if (this.testTokens.length > 0) {
          this.applyTestToken(this.testTokens.shift());
        } else {
          super.next(ignoreEscapeSequenceInKeyword);
        }
      }
      step() {
        this.testTokens.push(this.createTestToken());
        super.next();
        return this.type;
      }
      createTestToken() {
        return {
          type: this.type,
          value: this.value,
          start: this.start,
          startLoc: this.startLoc,
          endLoc: this.endLoc,
          lastTokEnd: this.lastTokEnd,
          lastTokStart: this.lastTokStart,
          lastTokEndLoc: this.lastTokEndLoc,
          lastTokStartLoc: this.lastTokStartLoc,
          pos: this.pos,
          context: this.context.slice(0),
          exprAllowed: this.exprAllowed
        };
      }
      applyTestToken(token) {
        this.pos = token.pos;
        this.type = token.type;
        this.value = token.value;
        this.start = token.start;
        this.startLoc = token.startLoc;
        this.endLoc = token.endLoc;
        this.lastTokEnd = token.lastTokEnd;
        this.lastTokStart = token.lastTokStart;
        this.lastTokEndLoc = token.lastTokEndLoc;
        this.lastTokStartLoc = token.lastTokStartLoc;
        this.context.splice(0, this.context.length, ...token.context);
        this.exprAllowed = token.exprAllowed;
      }
      apply(num) {
        const len = this.testTokens.length;
        if (num && num < 0) {
          const index = Math.min(Math.max(len + num, 0), len - 1);
          const [node2] = this.testTokens.splice(index, 1);
          this.testTokens.push(this.createTestToken());
          this.applyTestToken(node2);
        } else {
          this.testTokens.length = 0;
        }
      }
      isContextual(name) {
        if (this.parseInterfaceElementFlag && name === "of") {
          return true;
        }
        return super.isContextual(name);
      }
      parseMaybeConditional(noIn, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(noIn, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(tokTypes.question)) {
          if (refDestructuringErrors && refDestructuringErrors.parenthesizedBindParam >= 1) {
            refDestructuringErrors.parenthesizedBindParam = 2;
            if (this.type === tokTypes.comma || this.type === tokTypes.parenR) {
              refDestructuringErrors.parenthesizedBindParam = 3;
              expr.question = true;
              return expr;
            } else if (this.type === tokTypes.colon) {
              this.next();
              refDestructuringErrors.parenthesizedBindParam = 3;
              expr.question = true;
              expr.acceptType = this.parseTypeDefinition();
              return expr;
            }
          }
          if (!this._parseMaybeConditionaCount) {
            this._parseMaybeConditionaCount = 0;
          }
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.test = expr;
          this._parseMaybeConditionaCount++;
          node2.consequent = this.parseMaybeAssign();
          this.expect(tokTypes.colon);
          node2.alternate = this.parseMaybeAssign(noIn);
          this._parseMaybeConditionaCount--;
          return this.finishNode(node2, "ConditionalExpression");
        }
        return expr;
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          refDestructuringErrors.parenthesizedBindParam = 1;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== tokTypes.parenR) {
            first ? first = false : this.expect(tokTypes.comma);
            if (allowTrailingComma && this.afterTrailingComma(tokTypes.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === tokTypes.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === tokTypes.comma) {
                this.raise(this.start, "Comma is not permitted after the rest element");
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.start, innerEndLoc = this.startLoc;
          this.expect(tokTypes.parenR);
          let returnType = null;
          if (!(this._parseMaybeConditionaCount > 0) && canBeArrow && this.eat(tokTypes.colon)) {
            returnType = this.parseTypeDefinition();
          }
          if (canBeArrow && !this.canInsertSemicolon() && this.eat(tokTypes.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            const node2 = this.parseParenArrowList(startPos, startLoc, exprList);
            node2.returnType = returnType;
            return node2;
          }
          if (returnType) {
            this.unexpected(returnType.start);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        var par = this.startNodeAt(startPos, startLoc);
        if (val.type !== "SequenceExpression" && !this.canInsertSemicolon() && (this.type === tokTypes._this || this.type === tokTypes.name)) {
          let node2 = this.startNodeAt(startPos, startLoc);
          node2.value = val;
          this.finishNode(node2, "TypeDefinition");
          startPos = this.start, startLoc = this.startLoc;
          par.expression = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc);
          par.argument = node2;
          val = this.finishNode(par, "TypeTransformExpression");
        } else {
          par.expression = val;
          val = this.finishNode(par, "ParenthesizedExpression");
        }
        return val;
      }
      parseExprAtom(refDestructuringErrors) {
        if (this.type === tokTypes._annotation) {
          return this.parseAnnotation(true);
        }
        if (this._exportAssignmentDeclaration) {
          if (tokTypes._internal === this.type || tokTypes._package === this.type || tokTypes._struct === this.type || tokTypes._when === this.type || tokTypes._then === this.type) {
            return this.parseIdent(false);
          }
        }
        return super.parseExprAtom(refDestructuringErrors);
      }
      parseParenItem(item2) {
        if (super.eat(tokTypes.colon)) {
          item2.acceptType = this.parseTypeDefinition();
        }
        return item2;
      }
      readToken(code) {
        const context = this.curContext();
        if (context === tc_style_expr) {
          return this.jsx_readCDATAToken(code) || this.jsx_readTextToken("style");
        }
        if (code === 60 && (this.disabledJSXExpressionFlag || this.__parseTypeStatement || this.parseDeclaratorContext || this.parseInterfaceContext)) {
          return super.readToken_lt_gt(code);
        }
        if (code === 64 && context !== acornJsx.tokContexts.tc_expr) {
          const nextCode = this.input.charCodeAt(this.pos + 1);
          if (nextCode >= 97 && nextCode <= 122 || nextCode >= 65 && nextCode <= 90) {
            ++this.pos;
            return this.finishToken(tokTypes._annotation);
          }
        }
        if (context === tc_script_expr) {
          return this.jsx_readCDATAToken(code) || super.readToken(code);
        } else if (context === tc_cdata_expr) {
          return this.jsx_readTextToken();
        } else if (!this.jsx_readCDATAToken(code)) {
          if (!this.exprAllowed && this.curContext() === acornJsx.tokContexts.tc_expr) {
            this.exprAllowed = true;
          }
          return super.readToken(code);
        }
      }
      finishToken(type2, word) {
        if (tokTypes.string !== type2 && word === "as") {
          type2 = tokTypes._as;
        }
        return super.finishToken(type2, word);
      }
      initFunction(node2) {
        if (this.type === tokTypes.star) {
          this.raise(this.lastTokStart, `Function generator unsupported`);
        }
        super.initFunction(node2);
      }
      parseClassSuper(node2) {
        node2.superClass = null;
        if (this.eat(tokTypes._extends)) {
          if (this.isStaticClass) {
            this.raise(this.lastTokStart, "Static class cannot extends super class.");
          }
          node2.extends = [];
          do {
            const _extends = this.parseChainIdentifier();
            if (_extends) {
              _extends.genericity = this.getGenerics(true);
              node2.extends.push(_extends);
            }
          } while (this.eat(tokTypes.comma));
          node2.superClass = node2.extends[0];
        }
        node2.implements = null;
        if (this.eat(tokTypes._implements)) {
          if (this.isStaticClass) {
            this.raise(this.lastTokStart, "Static class cannot implements interfaces.");
          }
          node2.implements = [];
          do {
            const imp = this.parseChainIdentifier();
            if (imp) {
              imp.genericity = this.getGenerics(true);
              node2.implements.push(imp);
            }
          } while (this.eat(tokTypes.comma));
        }
      }
      parseClassId(node2, isStatement) {
        if (this.type === tokTypes._internal) {
          node2.id = this.parseIdent();
        } else {
          super.parseClassId(node2, isStatement);
        }
        node2.genericity = this.parseGenericType();
      }
      parseMethod(isGenerator, isAsync, allowDirectSuper) {
        const generics = this.parseGenericType();
        const node2 = super.parseMethod(isGenerator, isAsync, allowDirectSuper);
        node2.genericity = generics;
        return node2;
      }
      parseFunctionParams(node2) {
        node2.genericity = this.parseGenericType();
        super.parseFunctionParams(node2);
      }
      parseBindingList(close, allowEmpty, allowTrailingComma) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(tokTypes.comma);
          }
          let annotations = null;
          let annot = null;
          while (annot = this.parseStatementAnnotation(true)) {
            if (!annotations)
              annotations = [];
            annotations.push(annot);
          }
          if (allowEmpty && this.type === tokTypes.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === tokTypes.ellipsis) {
            var rest = this.parseRestBinding();
            rest.annotations = annotations;
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === tokTypes.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            var elem = this.parseMaybeDefault(this.start, this.startLoc);
            elem.annotations = annotations;
            this.parseBindingListItem(elem);
            elts.push(elem);
          }
        }
        return elts;
      }
      parseBlock(createNewLexicalScope, node2) {
        if (createNewLexicalScope === void 0) {
          createNewLexicalScope = true;
        }
        if (node2 === void 0) {
          node2 = this.startNode();
        }
        const scope = this.currentScope();
        switch (scope.flags & SCOPE_FUNCTION) {
          case SCOPE_ARROW:
          case SCOPE_FUNCTION:
          case SCOPE_ASYNC:
          case SCOPE_GENERATOR:
            if (this.eat(tokTypes.colon)) {
              node2.acceptType = this.parseTypeDefinition();
            }
            break;
        }
        return super.parseBlock(createNewLexicalScope, node2);
      }
      checkUnreserved(ref) {
        if (this.__parseBindingAtom && ref.name !== "default") {
          super.checkUnreserved(ref);
        }
      }
      parseBindingAtom() {
        this.__parseBindingAtom = true;
        const node2 = this.type === tokTypes._this ? this.parseIdent(true) : super.parseBindingAtom();
        this.__parseBindingAtom = false;
        if (!this.__parseVarIdFlag) {
          if (this.eat(tokTypes.question)) {
            node2.question = true;
          }
          if (this.eat(tokTypes.colon)) {
            node2.acceptType = this.parseTypeDefinition();
          }
        }
        return node2;
      }
      parseVarId(decl2, kind) {
        this.__parseVarIdFlag = true;
        super.parseVarId(decl2, kind);
        this.__parseVarIdFlag = false;
        if (this.eat(tokTypes.colon)) {
          decl2.acceptType = this.parseTypeDefinition();
        }
      }
      parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        const generics = this.parseGenericType();
        super.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        if (prop.value && prop.value.type === "FunctionExpression") {
          prop.value.genericity = generics;
        } else if (generics) {
          this.unexpected(generics.start);
        }
      }
      parseMaybeAssign(noIn, refDestructuringErrors, afterLeftParse) {
        const generics = this.parseGenericType();
        const node2 = super.parseMaybeAssign(noIn, refDestructuringErrors, afterLeftParse);
        if (node2.type === "ArrowFunctionExpression") {
          node2.genericity = generics;
        } else if (generics) {
          this.unexpected(generics.start);
        }
        return node2;
      }
      parseArrowExpression(node2, params, isAsync) {
        let type2 = null;
        if (this.arrowReturnType && this.arrowReturnType[this.lastTokStart]) {
          type2 = this.arrowReturnType[this.lastTokStart];
          delete this.arrowReturnType[this.lastTokStart];
        }
        const fn = super.parseArrowExpression(node2, params, isAsync);
        fn.returnType = type2;
        return fn;
      }
      parseFunctionBody(node2, isArrowFunction, isMethod) {
        if (!isArrowFunction && this.type === tokTypes.colon) {
          this.next();
          node2.returnType = this.parseTypeDefinition();
        }
        if (this.parseInterfaceElementFlag || this.parseDeclareModuleContext) {
          this.parseInterfaceElementFlag = false;
          this.semicolon();
          this.checkParams(node2);
          this.exitScope();
          return node2;
        }
        super.parseFunctionBody(node2, isArrowFunction, isMethod);
      }
      parseNew() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node2 = this.startNode();
        var meta = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(tokTypes.dot)) {
          node2.meta = meta;
          var containsEsc = this.containsEsc;
          node2.property = this.parseIdent(true);
          if (node2.property.name !== "target") {
            this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
          }
          if (!this.inNonArrowFunction()) {
            this.raiseRecoverable(node2.start, "'new.target' can only be used in functions");
          }
          return this.finishNode(node2, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc, isImport = this.type === tokTypes._import;
        node2.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
        if (isImport && node2.callee.type === "ImportExpression") {
          this.raise(startPos, "Cannot use new with import()");
        }
        startPos = this.start;
        node2.genericity = this.getGenerics(true);
        if (node2.genericity && !(node2.genericity.length > 0)) {
          this.raise(startPos, "Missing generics arguments.");
        }
        if (this.eat(tokTypes.parenL)) {
          node2.arguments = this.parseExprList(tokTypes.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node2.arguments = [];
        }
        return this.finishNode(node2, "NewExpression");
      }
      parseExprList(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(tokTypes.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === tokTypes.comma) {
            elt = null;
          } else if (this.type === tokTypes.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === tokTypes.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          if (refDestructuringErrors && tokTypes.parenR === close && this.eat(tokTypes.colon)) {
            elt.acceptType = this.parseTypeDefinition();
          }
          elts.push(elt);
        }
        return elts;
      }
      parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
        const _startPos = this.start;
        const generics = !noCalls ? this.getGenerics(false) : null;
        const start = this.start;
        let optional = false;
        if (generics) {
          optionalChained = this.options.ecmaVersion >= 11 && this.eat(tokTypes.questionDot);
          optional = optionalChained;
        }
        const node2 = super.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);
        if (node2.type === "CallExpression") {
          if (optional) {
            node2.optional = true;
          }
          if (base !== node2) {
            if (generics && !(generics.length > 0)) {
              this.raise(_startPos, "Missing generics arguments.");
            }
            node2.genericity = generics;
          } else if (generics) {
            this.unexpected(start);
          }
        } else if (generics) {
          this.raise(start, "'(' expected.");
        }
        return node2;
      }
      parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
        if (this.type === tokTypes._as) {
          this.next();
          const node3 = this.startNodeAt(leftStartPos, leftStartLoc);
          node3.left = left;
          node3.right = this.parseTypeDefinition();
          return this.finishNode(node3, "TypeAssertExpression");
        }
        if (this.__parseTypeStatement) {
          if (this.type === tokTypes.bitwiseAND || this.type === tokTypes.bitwiseOR || this.type === tokTypes.comma) {
            return left;
          }
        }
        const endToken = this.__$endToken;
        if (endToken && endToken.length > 0) {
          const token = endToken[endToken.length - 1];
          if (this.type === token.value && this.value.charCodeAt(0) === token.endCode) {
            return left;
          }
        }
        var prec = this.type.binop;
        if (prec != null && (!noIn || this.type !== tokTypes._in)) {
          if (prec > minPrec) {
            var logical = this.type === tokTypes.logicalOR || this.type === tokTypes.logicalAND;
            var coalesce = this.type === tokTypes.coalesce;
            if (coalesce) {
              prec = tokTypes.logicalAND.binop;
            }
            var op = this.value;
            var isOp = this.type === tokTypes._is;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = isOp ? this.parseTypeDefinition() : this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
            var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === tokTypes.coalesce || coalesce && (this.type === tokTypes.logicalOR || this.type === tokTypes.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, noIn);
          }
        }
        return left;
      }
      parseExpression(noIn, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
        if (!this.__parseTypeStatement && this.type === tokTypes.comma) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.expressions = [expr];
          while (this.eat(tokTypes.comma)) {
            node2.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
          }
          return this.finishNode(node2, "SequenceExpression");
        }
        return expr;
      }
      parseStatement(context, topLevel, exports2, isDeclaredModule = false) {
        switch (this.type) {
          case tokTypes._package:
            if (!topLevel || isDeclaredModule) {
              this.unexpected();
            }
            return this.parsePackage(this.startNode(), true);
          case tokTypes._abstract:
            if (!topLevel) {
              this.unexpected();
            }
            var abstract = this.startNode();
            abstract.name = "abstract";
            this.next();
            if (this.type !== tokTypes._class) {
              this.unexpected();
            }
            this.finishNode(abstract, "ModifierDeclaration");
            var node2 = this.parseClass(this.startNode(), true);
            node2.abstract = abstract;
            return node2;
          case tokTypes._public:
            if (!topLevel) {
              this.unexpected();
            }
            this.next();
            var modifier = this.finishNode(this.startNode(), "ModifierDeclaration");
            modifier.name = "public";
            var node2 = this.parseStatement(null, topLevel, exports2);
            node2.modifier = modifier;
            return node2;
          case tokTypes._internal:
            if (!topLevel) {
              this.unexpected();
            }
            this.next();
            var modifier = this.finishNode(this.startNode(), "ModifierDeclaration");
            modifier.name = "internal";
            var node2 = this.parseStatement(null, topLevel, exports2);
            node2.modifier = modifier;
            return node2;
          case tokTypes._private:
            if (!topLevel) {
              this.unexpected();
            }
            this.next();
            var modifier = this.finishNode(this.startNode(), "ModifierDeclaration");
            modifier.name = "private";
            var node2 = this.parseStatement(null, topLevel, exports2);
            node2.modifier = modifier;
            return node2;
          case tokTypes._final:
            if (!topLevel) {
              this.unexpected();
            }
            this.next();
            var modifier = this.finishNode(this.startNode(), "ModifierDeclaration");
            modifier.name = "final";
            var node2 = this.parseStatement(null, topLevel, exports2);
            node2.final = modifier;
            return node2;
          case tokTypes._protected:
            if (!topLevel) {
              this.unexpected();
            }
            this.next();
            var modifier = this.finishNode(this.startNode(), "ModifierDeclaration");
            modifier.name = "protected";
            var node2 = this.parseStatement(null, topLevel, exports2);
            node2.modifier = modifier;
            return node2;
          case tokTypes._static:
            if (!topLevel) {
              this.unexpected();
            }
            this.next();
            var modifier = this.finishNode(this.startNode(), "ModifierDeclaration");
            modifier.name = "static";
            var node2 = tokTypes._class === this.type ? this.parseClass(this.startNode(), true) : this.parseStatement(null, topLevel, exports2);
            node2.static = modifier;
            return node2;
          case tokTypes._import:
            if (!topLevel) {
              return super.parseStatement(context, topLevel, exports2);
            }
            return this.parseImport(this.startNode());
          case tokTypes._when:
            return this.parseWhenStatement(this.startNode());
          case tokTypes._enum:
            return this.parseEnumStatement(this.startNode(), topLevel);
          case tokTypes._interface:
            if (this.parseDeclareModuleContext) {
              return this.parseDeclarator(this.startNode(), false);
            }
            if (!topLevel) {
              this.unexpected();
            }
            return this.parseInterface(this.startNode(), topLevel);
          case tokTypes._annotation:
            if (topLevel) {
              let node3 = this.startNode();
              this.next();
              if (this.type === tokTypes._interface) {
                node3 = this.parseStatement(context, topLevel, exports2, isDeclaredModule);
                node3.decorator = true;
                return node3;
              }
              node3.name = this.value;
              node3.id = this.parseChainIdentifier();
              return this.parseAnnotation(false, node3);
            }
            break;
          case tokTypes._struct:
            if (topLevel) {
              this.next();
              if (!isDeclaredModule && this.type === tokTypes.name && this.value === "table") {
                return this.parseStructTableDeclarator();
              } else {
                this.unexpected();
              }
            } else {
              this.unexpected();
            }
            break;
          case tokTypes._function:
          case tokTypes._class:
          case tokTypes._const:
          case tokTypes._var:
            if (this.parseDeclaratorContext || this.parseDeclareModuleContext) {
              return this.parseDeclarator(this.startNode());
            }
            break;
          default:
        }
        if (this.parseDeclareModuleContext && this.type === tokTypes.name && this.value === "namespace") {
          return this.parseDeclareModuleNamespace();
        }
        if (topLevel && this.value === "declare") {
          this.next();
          let abstract2 = null;
          if (this.type === tokTypes._abstract) {
            abstract2 = this.parseIdent(true);
          } else if (this.type === tokTypes._annotation) {
            this.next();
            if (this.type === tokTypes._interface) {
              let node4 = this.parseStatement(context, topLevel, exports2, true);
              node4.decorator = true;
              return node4;
            } else {
              this.unexpected();
            }
          }
          let node3 = this.startNode();
          node3.abstract = abstract2;
          return this.parseDeclarator(node3);
        } else if (this.type === tokTypes.name && this.value === "await" && !this.inAsync) {
          return this.parseAwait();
        } else if (this.type === tokTypes.name && this.value === "type" && !this.isAsyncFunction()) {
          if (this.parseDeclaratorContext || this.parseDeclareModuleContext) {
            return this.parseDeclarator(this.startNode());
          }
          var node2 = this.startNode();
          var maybeName = this.value, expr = this.parseExpression();
          if (expr.type === "Identifier") {
            if (this.eat(tokTypes.colon)) {
              return this.parseLabeledStatement(node2, maybeName, expr, context);
            } else if (this.type === tokTypes.name) {
              return this.parseTypeStatement(node2);
            }
          }
          return this.parseExpressionStatement(node2, expr);
        }
        return super.parseStatement(context, topLevel, exports2);
      }
      parseTypeStatement(node2) {
        this.disabledJSXExpressionFlag = true;
        node2.id = this.parseIdent(false);
        node2.genericity = this.parseGenericType();
        this.expect(tokTypes.eq);
        node2.kind = "statement";
        if (node2.genericity) {
          node2.left = node2.id;
          node2.right = this.parseTypeDefinition();
          this.finishNode(node2, "DeclaratorTypeAlias");
        } else {
          node2.init = this.parseTypeDefinition();
          this.finishNode(node2, "TypeStatement");
        }
        this.disabledJSXExpressionFlag = false;
        this.semicolon();
        return node2;
      }
      parseStructTableDeclarator(node2 = null) {
        this.disabledJSXExpressionFlag = true;
        this.next();
        node2 = node2 || this.startNode();
        node2.id = this.parseIdent(false);
        node2.extends = [];
        node2.body = [];
        if (this.eat(tokTypes._extends)) {
          do {
            node2.extends.push(this.parseChainIdentifier());
          } while (this.eat(tokTypes.comma));
        }
        this.expect(tokTypes.braceL);
        const parseNode = () => {
          let node3 = null;
          if (this.type === tokTypes.backQuote) {
            node3 = this.startNode();
            const start = this.start;
            this.next();
            node3.value = this.value;
            this.next();
            this.expect(tokTypes.backQuote);
            node3.raw = this.input.slice(start, this.lastTokEnd);
            node3.isBackQuote = true;
            this.finishNode(node3, "Literal");
            return node3;
          } else if (this.type === tokTypes.name || this.type.keyword) {
            return this.parseChainIdentifier();
          } else if (this.type === tokTypes.string || this.type === tokTypes.num) {
            return this.parseLiteral(this.value);
          } else {
            this.raise(this.start, "Expected literal");
          }
        };
        const parseToken = () => {
          const start = this.start, startLoc = this.startLoc;
          let value2 = parseNode();
          if (value2.type === "Identifier" || value2.type === "MemberExpression" || value2.type === "Literal" && value2.isBackQuote) {
            if (this.eat(tokTypes.parenL)) {
              const token = this.startNodeAt(start, startLoc);
              token.key = value2;
              token.params = [];
              while (tokTypes.parenR !== this.type) {
                token.params.push(parseNode());
                this.eat(tokTypes.comma);
              }
              this.expect(tokTypes.parenR);
              return this.finishNode(token, "StructTableMethodDefinition");
            } else {
              const key = value2.name.toLowerCase();
              if (key === "default" || key === "character" || key === "collate" || key === "comment" || key === "using") {
                const token = this.startNodeAt(start, startLoc);
                token.assignment = false;
                token.key = value2;
                token.init = parseNode();
                return this.finishNode(token, "StructTablePropertyDefinition");
              } else if (key === "unsigned") {
                this.raise(start, "The `unsigned` keywords must follow `column-type`");
              }
            }
          }
          return value2;
        };
        const parseProperties = () => {
          const items = [];
          while (true) {
            if (this.eat(tokTypes.comma) || this.eat(tokTypes.semi) || this.canInsertSemicolon()) {
              break;
            }
            items.push(parseToken());
          }
          return items;
        };
        const check = (token, start, id, message) => {
          if (!(token && token.type === "StructTableMethodDefinition" && (id === "*" || token.key.name.toLowerCase() === id))) {
            this.raise(start, message);
            return false;
          }
          return true;
        };
        while (tokTypes.braceR !== this.type) {
          if (this.type === tokTypes._annotation) {
            node2.body.push(this.parseAnnotation());
          }
          const column = this.startNode();
          const key = parseNode(true);
          const question = this.eat(tokTypes.question);
          const start = this.start;
          if (this.eat(tokTypes.colon)) {
            column.key = key;
            column.question = question;
            column.typename = parseToken();
            if (check(column.typename, start, "*", "Expect token is `column-type(...)`")) {
              if (this.type === tokTypes.name && this.value.toLowerCase() === "unsigned") {
                column.typename.unsigned = true;
                this.next();
              }
            }
            column.properties = parseProperties();
            node2.body.push(column);
            this.finishNode(column, "StructTableColumnDefinition");
          } else if (!question) {
            const name = key.name.toLowerCase();
            column.key = key;
            if (name === "primary" || name === "unique" || name === "fulltext" || name === "key") {
              if (!(name === "key" || name === "primary")) {
                if (!(this.type === tokTypes.name && this.value.toLowerCase() === "key")) {
                  this.raise(this.start, "Expect token is `key` keywords.");
                } else {
                  this.next();
                }
              }
              column.local = parseToken();
              if (name === "primary") {
                check(column.local, start, "key", "Expect token is `primary key(column-name...)`");
              } else {
                check(column.local, start, "*", "Expect token is `key name(column-name...)`");
              }
              column.properties = parseProperties();
              this.finishNode(column, "StructTableKeyDefinition");
              node2.body.push(column);
            } else {
              column.properties = parseProperties();
              this.finishNode(column, "StructTableKeyDefinition");
              node2.body.push(column);
            }
          } else {
            this.unexpected(start);
          }
        }
        this.disabledJSXExpressionFlag = false;
        this.expect(tokTypes.braceR);
        while (this.type === tokTypes.name || this.type === tokTypes.backQuote) {
          const property = this.startNode();
          property.key = parseNode(true);
          property.init = null;
          if (this.eat(tokTypes.eq)) {
            property.assignment = true;
            property.init = parseNode();
          }
          node2.body.push(property);
          this.finishNode(property, "StructTablePropertyDefinition");
        }
        this.semicolon();
        return this.finishNode(node2, "StructTableDeclaration");
      }
      shouldParseExportStatement() {
        if (this.parseDeclareModuleContext) {
          if (this.type === tokTypes.name && (this.value === "declare" || this.value === "type" || this.value === "namespace") || this.type.keyword === "interface" || this.type.keyword === "abstract" || this.type.keyword === "public" || this.type.keyword === "internal" || this.type.keyword === "protected" || this.type.keyword === "struct" || this.type.keyword === "enum" || this.type.keyword === "static") {
            return true;
          }
        }
        return super.shouldParseExportStatement();
      }
      parseUseStatement() {
        this.disabledJSXExpressionFlag = true;
        const node2 = this.startNode();
        node2.keywords = [this.parseIdent(true)];
        node2.extends = [];
        if (this.eat(tokTypes.comma)) {
          node2.keywords.push(this.parseIdent(true));
        }
        if (this.eat(tokTypes._extends)) {
          do {
            const object = this.startNode();
            object.id = this.parseChainIdentifier();
            object.genericity = this.getGenerics(true);
            object.modifier = [];
            while (this.eat(tokTypes.colon)) {
              const token = this.parseIdent(true);
              object.modifier.push(token);
            }
            node2.extends.push(this.finishNode(object, "UseExtendSpecifier"));
          } while (this.eat(tokTypes.comma));
        }
        const body = [];
        if (this.eat(tokTypes.braceL)) {
          while (this.type !== tokTypes.braceR) {
            this.parseInterfaceElementFlag = true;
            const element = this.parseClassElement(false, true, true);
            this.parseInterfaceElementFlag = false;
            if (element) {
              body.push(element);
            }
          }
          this.disabledJSXExpressionFlag = false;
          this.expect(tokTypes.braceR);
        } else {
          this.disabledJSXExpressionFlag = false;
        }
        node2.body = body;
        this.semicolon();
        return this.finishNode(node2, "UseExtendStatement");
      }
      parseWhenStatement(node2) {
        const currentScope = this.currentScope();
        const inherit = (scope, inherit2) => {
          scope.var = scope.var.concat(inherit2.var);
          scope.lexical = scope.lexical.concat(inherit2.lexical);
          scope.functions = scope.functions.concat(inherit2.functions);
        };
        const parseCondition = (node3 = null) => {
          if (tokTypes.parenR !== this.type) {
            let startNode = this.startNode();
            let test2 = node3 || this.parseExprOps(true);
            if (this.type === tokTypes.name) {
              let name = this.value.toLowerCase();
              if (name === "and" || name === "or") {
                this.next();
                startNode.left = test2;
                startNode.right = this.parseExprOps(true);
                startNode.operator = name;
                this.finishNode(startNode, "LogicalConditionStatement");
                return parseCondition(startNode);
              }
            }
            return test2;
          }
          return node3;
        };
        this.next();
        this.expect(tokTypes.parenL);
        let test = parseCondition();
        this.expect(tokTypes.parenR);
        node2.test = test;
        this.enterScope(SCOPE_FUNCTION | SCOPE_SUPER);
        const whenScope = this.currentScope();
        inherit(whenScope, currentScope);
        node2.consequent = super.parseStatement("when");
        this.exitScope();
        this.enterScope(SCOPE_FUNCTION | SCOPE_SUPER);
        const thenScope = this.currentScope();
        inherit(thenScope, currentScope);
        node2.alternate = this.eat(tokTypes._then) ? super.parseStatement("then") : null;
        this.exitScope();
        inherit(currentScope, whenScope);
        inherit(currentScope, thenScope);
        return this.finishNode(node2, "WhenStatement");
      }
      parseEnumProperty(isDeclare) {
        const modifier = this.parseModifier();
        if (modifier[0] || modifier[1] || modifier[2] || this.type === tokTypes.bracketL) {
          const element = this.parseClassElement(false, isDeclare, false, true);
          if (modifier[0]) {
            element.modifier = modifier[0];
          }
          if (modifier[1]) {
            element.static = modifier[1];
          }
          if (modifier[2]) {
            element.final = modifier[2];
          }
          return element;
        }
        if (this.type === tokTypes.name) {
          if (this.step() === tokTypes.parenL) {
            this.apply(-1);
            const element = super.parseClassElement(false, isDeclare, false, true);
            const generics = this.tryPropertyContextualGenerics;
            if (generics && element.type === "MethodDefinition") {
              element.value.genericity = generics;
            }
            return element;
          } else {
            this.apply(-1);
          }
        }
        const node2 = this.startNode();
        if (this.type === tokTypes.name || this.type.keyword) {
          node2.key = this.startNode();
          node2.key.name = this.type === tokTypes.name ? this.value : this.type.keyword;
          this.checkUnreserved(node2.key);
          this.next();
          this.finishNode(node2.key, "Identifier");
        } else {
          this.unexpected();
        }
        if (this.eat(tokTypes.eq)) {
          if (this.type === tokTypes.plusMin) {
            node2.init = this.parseLiteralMinus();
          } else {
            node2.init = this.parseExprOps(true);
          }
        }
        this.finishNode(node2, "EnumProperty");
        if (this.type === tokTypes.comma || this.type === tokTypes.semi) {
          this.next();
        }
        return node2;
      }
      parseLiteralMinus() {
        let minus = String(this.value).charCodeAt(0) === 45;
        var node2 = this.startNode();
        let start = this.start;
        this.next();
        if (this.type === tokTypes.num) {
          let value2 = minus ? -this.value : this.value;
          node2.value = value2;
          node2.raw = this.input.slice(start, this.end);
          if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
            node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
          }
          this.next();
          return this.finishNode(node2, "Literal");
        } else {
          this.unexpected();
        }
      }
      parseEnumStatement(node2, isDeclare = false) {
        this.disabledJSXExpressionFlag = true;
        this.next();
        node2.key = this.parseIdent(false);
        if (this.type === tokTypes._extends) {
          this.next();
          node2.extends = [];
          do {
            const _extends = this.parseChainIdentifier();
            if (_extends) {
              _extends.genericity = this.getGenerics(true);
              node2.extends.push(_extends);
            }
          } while (this.eat(tokTypes.comma));
        }
        if (this.eat(tokTypes._implements)) {
          node2.implements = [];
          do {
            const imp = this.parseChainIdentifier();
            if (imp) {
              imp.genericity = this.getGenerics(true);
              node2.implements.push(imp);
            }
          } while (this.eat(tokTypes.comma));
        }
        this.expect(tokTypes.braceL);
        this.enterScope(1);
        const properties = [];
        const body = [];
        while (this.type !== tokTypes.braceR) {
          let property = this.parseEnumProperty(isDeclare);
          if (property) {
            if (property.type === "EnumProperty") {
              properties.push(property);
            } else {
              body.push(property);
            }
          }
        }
        node2.properties = properties;
        node2.body = body;
        this.disabledJSXExpressionFlag = false;
        this.expect(tokTypes.braceR);
        this.semicolon();
        this.exitScope();
        return this.finishNode(node2, "EnumDeclaration");
      }
      parseClass(node2, isStatement) {
        this.disabledJSXExpressionFlag = true;
        node2 = super.parseClass(node2, isStatement);
        this.disabledJSXExpressionFlag = false;
        return node2;
      }
      parseInterface(node2) {
        this.disabledJSXExpressionFlag = true;
        this.parseInterfaceContext = true;
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node2, true);
        if (this.type === tokTypes._extends) {
          this.next();
          node2.extends = [];
          do {
            const _extends = this.parseChainIdentifier();
            if (_extends) {
              _extends.genericity = this.getGenerics(true);
              node2.extends.push(_extends);
            }
          } while (this.eat(tokTypes.comma));
        }
        if (this.eat(tokTypes._implements)) {
          node2.implements = [];
          do {
            const imp = this.parseChainIdentifier();
            if (imp) {
              imp.genericity = this.getGenerics(true);
              node2.implements.push(imp);
            }
          } while (this.eat(tokTypes.comma));
        }
        var body = [];
        this.expect(tokTypes.braceL);
        this.enterScope(1);
        while (this.type !== tokTypes.braceR) {
          this.parseInterfaceElementFlag = true;
          var element = this.parseClassElement(false);
          if (element) {
            body.push(element);
          }
        }
        node2.body = body;
        this.strict = oldStrict;
        this.parseInterfaceContext = false;
        this.disabledJSXExpressionFlag = false;
        this.expect(tokTypes.braceR);
        this.exitScope();
        return this.finishNode(node2, "InterfaceDeclaration");
      }
      parseDeclaratorDone(node2, semi = false) {
        this.disabledJSXExpressionFlag = false;
        this.parseDeclaratorContext = false;
        if (semi)
          this.semicolon();
        return node2;
      }
      parseDeclarator(node2, isDeclare = true) {
        this.disabledJSXExpressionFlag = true;
        this.parseDeclaratorContext = true;
        var oldStrict = this.strict;
        this.strict = true;
        node2.kind = "class";
        var [modifier, staticNode, finalNode] = this.parseModifier();
        node2.modifier = modifier;
        node2.static = staticNode;
        node2.final = finalNode;
        if (this.type === tokTypes._const || this.type === tokTypes._var || this.isLet()) {
          const kind = this.value;
          node2.expression = this.parseVarStatementDefinition(node2, "var", false, true);
          node2.expression.kind = kind;
          node2.kind = kind;
          node2.id = node2.expression.declarations[0].id;
          return this.parseDeclaratorDone(this.finishNode(node2, "DeclaratorVariable"), true);
        } else if (this.type === tokTypes._function) {
          this.next();
          node2.kind = "function";
          node2.id = this.parseIdent();
          const generics = this.parseGenericType();
          this.expect(tokTypes.parenL);
          node2.genericity = generics;
          node2.params = this.parseBindingList(tokTypes.parenR, false, true);
          if (this.eat(tokTypes.colon)) {
            node2.returnType = this.parseTypeDefinition();
          }
          return this.parseDeclaratorDone(this.finishNode(node2, "DeclaratorFunction"), true);
        } else if (this.type === tokTypes._class) {
          this.next();
          node2.kind = "class";
        } else if (this.type === tokTypes._interface) {
          this.next();
          node2.kind = "interface";
        } else if (this.type === tokTypes._enum) {
          node2.kind = "enum";
          return this.parseDeclaratorDone(this.parseEnumStatement(node2, isDeclare));
        } else if (this.type === tokTypes._struct) {
          node2.kind = "struct";
          return this.parseDeclaratorDone(this.parseStructTableDeclarator());
        } else if (this.value === "module") {
          node2.kind = "module";
          return this.parseDeclaratorDone(this.parseDeclareModule(node2));
        } else if (this.value === "namespace") {
          return this.parseDeclaratorDone(this.parseDeclareModuleNamespace());
        }
        this.parseClassId(node2, false);
        if (this.type === tokTypes._extends) {
          this.next();
          node2.extends = [];
          do {
            const _extends = this.parseChainIdentifier();
            if (_extends) {
              _extends.genericity = this.getGenerics(true);
              node2.extends.push(_extends);
            }
          } while (this.eat(tokTypes.comma));
        }
        if (this.eat(tokTypes._implements)) {
          node2.implements = [];
          do {
            const imp = this.parseChainIdentifier();
            if (imp) {
              imp.genericity = this.getGenerics(true);
              node2.implements.push(imp);
            }
          } while (this.eat(tokTypes.comma));
        }
        if (this.type !== tokTypes.braceL && node2.id && node2.id.name === "type") {
          if (!isDeclare) {
            return this.parseDeclaratorDone(this.parseTypeStatement(node2));
          }
          node2.left = this.parseIdent(true);
          node2.id = node2.left;
          node2.genericity = this.parseGenericType();
          node2.kind = "declare";
          if (this.eat(tokTypes.eq)) {
            node2.right = this.parseTypeDefinition(false);
          } else {
            this.unexpected();
          }
          return this.parseDeclaratorDone(this.finishNode(node2, "DeclaratorTypeAlias"), true);
        }
        var body = [];
        this.expect(tokTypes.braceL);
        this.enterScope(1);
        while (this.type !== tokTypes.braceR) {
          this.parseInterfaceElementFlag = true;
          var element = this.parseClassElement(node2.kind === "class", true);
          if (element) {
            body.push(element);
          }
        }
        this.parseDeclaratorContext = false;
        this.disabledJSXExpressionFlag = false;
        this.expect(tokTypes.braceR);
        this.strict = oldStrict;
        node2.body = body;
        this.exitScope();
        return this.finishNode(node2, "DeclaratorDeclaration");
      }
      eatContextual(k) {
        if (k === "as" && this.eat(tokTypes._as))
          return true;
        const result = super.eatContextual(k);
        if (result && (k === "get" || k === "set") && this.tryPropertyContextualFlag) {
          this.tryPropertyContextualGenerics = this.parseGenericType();
          this.tryPropertyContextualFlag = false;
        }
        return result;
      }
      parseChainIdentifier(base = null, isImporter = false) {
        const startPos = this.start, startLoc = this.startLoc;
        base = base || super.parseIdent(true);
        while (this.eat(tokTypes.dot)) {
          if (isImporter && this.canInsertSemicolon()) {
            if (this.keywords.test(this.value) && this.input.charCodeAt(this.start + this.value.length) === 32) {
              this.unexpected(this.lastTokEnd);
            }
          }
          const node2 = this.startNodeAt(startPos, startLoc);
          node2.object = base;
          node2.property = this.parseIdent(true);
          base = this.finishNode(node2, "MemberExpression");
        }
        return base;
      }
      parseGenericType() {
        if (this.type === tokTypes.relational && this.value && this.value.charCodeAt(0) === 60) {
          const generics = this.startNode();
          const elements = [];
          const endToken = this.__$endToken || (this.__$endToken = []);
          endToken.push({ token: tokTypes.bitShift, value: tokTypes.relational, endCode: 62 });
          this.next();
          do {
            if (this.type === tokTypes.relational && this.value.charCodeAt(0) === 62) {
              break;
            }
            let start = this.start, startLoc = this.startLoc;
            let left = this.parseTypeDefinition(null, true, true);
            let type2 = left;
            if (this.eat(tokTypes.eq)) {
              type2 = this.startNodeAt(start, startLoc);
              type2.left = left;
              type2.right = this.parseTypeDefinition();
              this.finishNode(type2, "GenericTypeAssignmentDeclaration");
            } else {
              if (this.eat(tokTypes._extends)) {
                let _extends = this.parseTypeDefinition();
                if (this.eat(tokTypes.eq)) {
                  type2 = this.startNodeAt(start, startLoc);
                  type2.left = left;
                  type2.extends = _extends;
                  type2.right = this.parseTypeDefinition();
                  this.finishNode(type2, "GenericTypeAssignmentDeclaration");
                } else {
                  left.extends = _extends;
                  this.finishNode(type2, "GenericTypeDeclaration");
                }
              } else {
                this.finishNode(type2, "GenericTypeDeclaration");
              }
            }
            elements.push(type2);
          } while (this.eat(tokTypes.comma));
          if (!(this.type === tokTypes.relational && this.value.charCodeAt(0) === 62)) {
            this.unexpected();
          } else {
            this.next();
          }
          endToken.pop();
          generics.elements = elements;
          return this.finishNode(generics, "GenericDeclaration");
        }
        return null;
      }
      testTupleUnion() {
        const content = this.input;
        let index = this.start;
        let balancer = 1;
        let comment = false;
        while (index < content.length) {
          const code = content.charCodeAt(index);
          if (comment === false && code === 47 && content.charCodeAt(index + 1) === 42) {
            comment = 47;
            index++;
          } else if (code === 42 && content.charCodeAt(index + 1) === comment) {
            comment = false;
            index++;
          } else if (comment === false && code === 47 && content.charCodeAt(index + 1) === 47) {
            comment = 10;
            index++;
          } else if (comment === code) {
            comment = false;
          } else if (comment === false) {
            if (code === 40) {
              balancer++;
            } else if (code === 41) {
              balancer--;
            }
            if (code === 59 || balancer === 0) {
              break;
            }
          }
          index++;
        }
        if (balancer === 0) {
          while (index < content.length && content.charCodeAt(index + 1) === 32 && index++)
            ;
          return {
            arrow: content.charCodeAt(index + 1) === 61 && content.charCodeAt(index + 2) === 62,
            array: content.charCodeAt(index + 1) === 91
          };
        }
        return null;
      }
      testGenericsContext() {
        const content = this.input;
        let index = this.start;
        let comment = false;
        let token = [];
        let matched = false;
        while (index < content.length) {
          const code = content.charCodeAt(index);
          if (comment === false && code === 47 && content.charCodeAt(index + 1) === 42) {
            comment = 47;
            index++;
          } else if (code === 42 && content.charCodeAt(index + 1) === comment) {
            comment = false;
            index++;
          } else if (comment === false && code === 47 && content.charCodeAt(index + 1) === 47) {
            comment = 10;
            index++;
          } else if (comment === code) {
            comment = false;
          } else if (comment === false) {
            if (matched) {
              if (code === 63 && content.charCodeAt(index + 1) === 46) {
                return true;
              }
              return code === 40;
            }
            if (code === 59) {
              return false;
            }
            if (code === 60) {
              if (content.charCodeAt(index + 1) === 61) {
                return false;
              }
              token.push(62);
            } else if (code === 123) {
              token.push(125);
            } else if (code === 91) {
              token.push(93);
            } else if (code === 40) {
              token.push(41);
            } else if (code === 61 && content.charCodeAt(index + 1) === 62) {
              index++;
            } else if (code === 38 && content.charCodeAt(index + 1) === 38) {
              return false;
            } else if (code === 124 && content.charCodeAt(index + 1) === 124) {
              return false;
            } else if (code === 62 || code === 125 || code === 93 || code === 41) {
              if (code === 62 && content.charCodeAt(index + 1) === 61) {
                return false;
              }
              if (token.pop() !== code) {
                return false;
              }
              if (token.length === 0 && code === 62) {
                matched = true;
              }
            } else {
              const allow = code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 44 || code === 9 || code === 13 || code === 10 || code === 36 || code === 32 || code === 95 || code === 46 || code === 92 || code === 58 || code === 38 || code === 124 || code === 61 || code === 63;
              code === 34 || code === 39 || code === 96 || code === 47;
              if (!allow) {
                return false;
              }
            }
          }
          index++;
        }
        return false;
      }
      getGenerics(flag, node2) {
        if (this.type === tokTypes.relational && this.value && this.value.charCodeAt(0) === 60) {
          if (!flag) {
            flag = this.testGenericsContext();
          }
          if (flag) {
            this.next();
            const generics = [];
            const endToken = this.__$endToken || (this.__$endToken = []);
            endToken.push({ token: tokTypes.bitShift, value: tokTypes.relational, endCode: 62 });
            while (!(this.type === tokTypes.relational && this.value.charCodeAt(0) === 62 && this.value.length === 1)) {
              const type2 = this.parseTypeDefinition();
              if (type2.restElement) {
                this.raise(type2.start, "Rest type can only appear in tuple types");
              }
              generics.push(type2);
              if (!this.eat(tokTypes.comma)) {
                break;
              }
            }
            endToken.pop();
            if (this.type === tokTypes.relational && this.value.charCodeAt(0) === 62 && this.value.length === 1) {
              this.next();
            } else {
              this.raise(this.start, `Expected '>'`);
            }
            if (node2) {
              node2.typeElements = generics;
              this.finishNode(node2, "TypeGenericDefinition");
            }
            return generics;
          }
        }
        return null;
      }
      readToken_lt_gt(code) {
        if (code === 62) {
          const endToken = this.__$endToken;
          if (endToken && endToken.length > 0) {
            return super.finishOp(tokTypes.relational, 1);
          }
        }
        return super.readToken_lt_gt(code);
      }
      parseTypeDefinition(prefix, isRoot = true, isGeneric = false) {
        if (isRoot) {
          this.__parseTypeStatement = true;
          this.eat(tokTypes.bitwiseOR);
          this.eat(tokTypes.bitwiseAND);
        }
        let readonly = null;
        if (this.type === tokTypes.name && this.value === "readonly") {
          readonly = super.parseIdent(true);
        }
        let start = this.start, startLoc = this.startLoc;
        let node2 = this.parseTypeDefinitionItem(prefix, readonly);
        if (!isRoot)
          return node2;
        let unions = [node2];
        let _startLoc = this.startLoc;
        while (true) {
          if (this.eat(tokTypes.bitwiseOR)) {
            node2.readonly = !!readonly;
            unions.push(this.parseTypeDefinition(null, false, isGeneric));
            readonly = null;
          } else if (this.eat(tokTypes.bitwiseAND)) {
            const left = unions.pop();
            const intersection = this.startNodeAt(left.start, _startLoc);
            intersection.left = left;
            intersection.right = this.parseTypeDefinition(null, false, isGeneric);
            left.readonly = !!readonly;
            unions.push(intersection);
            this.finishNode(intersection, "TypeIntersectionDefinition");
            _startLoc = this.startLoc;
            readonly = null;
          } else {
            break;
          }
        }
        this.__parseTypeStatement = false;
        if (unions.length > 1) {
          const unionNode = this.startNodeAt(start, startLoc);
          unionNode.elements = unions;
          node2 = this.finishNode(unionNode, "TypeUnionDefinition");
        } else {
          node2 = unions[0];
        }
        node2.readonly = !!readonly;
        if (!isGeneric && tokTypes._extends === this.type && (node2.type === "TypeDefinition" && node2.value.type === "Identifier" || node2.type === "TypeInferDefinition")) {
          const make = (_name, start2, startLoc2) => {
            if (!_name) {
              _name = this.parseTypeDefinition();
            }
            if (this.eat(tokTypes._extends)) {
              let infer = _name.type === "TypeInferDefinition";
              let conditional = this.startNodeAt(start2, startLoc2);
              let condition = this.startNodeAt(start2, startLoc2);
              condition.argument = infer ? _name.argument : _name.value;
              condition.extends = this.parseTypeDefinition();
              this.finishNode(condition, "TypeConditionDefinition");
              this.expect(tokTypes.question);
              conditional.condition = condition;
              conditional.consequent = make(null, this.start, this.startLoc);
              this.expect(tokTypes.colon);
              conditional.alternate = make(null, this.start, this.startLoc);
              this.finishNode(conditional, "TypeConditionalExpression");
              if (infer) {
                let inferNode = this.startNodeAt(_name.start, _name.loc?.end ?? 0);
                inferNode.argument = _name.argument;
                inferNode.expression = conditional;
                conditional = this.finishNode(inferNode, "TypeInferDefinition");
              }
              _name = conditional;
            }
            return _name;
          };
          return make(node2, start, startLoc);
        }
        return node2;
      }
      parseTypeDefinitionItem(prefix, readonlyNode = null) {
        let node2 = prefix ? this.startNodeAt(prefix.start, prefix.loc ? prefix.loc.start : 0) : this.startNode();
        if (tokTypes._typeof === this.type) {
          this.next();
          node2.value = this.parseExpression();
          return this.finishNode(node2, "TypeTypeofDefinition");
        }
        let typeName = "TypeDefinition";
        let declGenerics = this.parseGenericType();
        if (this.type === tokTypes._void) {
          node2.value = this.parseChainIdentifier();
          this.finishNode(node2, typeName);
        } else if (this.type === tokTypes.name || this.type === tokTypes._class || this.type === tokTypes._this) {
          if (this.value === "keyof") {
            this.next();
            node2.value = this.parseTypeDefinition();
            this.finishNode(node2, "TypeKeyofDefinition");
          } else {
            node2.value = this.parseChainIdentifier();
            if (node2.value.name === "infer" && this.type === tokTypes.name) {
              delete node2.value;
              node2.argument = this.parseIdent();
              typeName = "TypeInferDefinition";
            } else {
              if (node2.value.type === "Identifier" && this.type === tokTypes._is && !this.canInsertSemicolon()) {
                this.next();
                node2.argument = node2.value;
                node2.value = this.parseTypeDefinition();
                this.finishNode(node2, "TypePredicateDefinition");
                return node2;
              }
              if (!this.canInsertSemicolon()) {
                const generics = this.getGenerics(true);
                if (generics) {
                  node2.typeElements = generics;
                  typeName = "TypeGenericDefinition";
                }
              }
              if (node2.value.type === "Identifier" && typeName === "TypeDefinition" && node2.value.name === "unique" && this.type === tokTypes.name) {
                node2.value = this.parseTypeDefinition();
                this.finishNode(node2, "TypeUniqueDefinition");
                return node2;
              }
            }
            this.finishNode(node2, typeName);
            if (this.type === tokTypes.bracketL && !this.canInsertSemicolon()) {
              node2 = this.parseTypeDefinition(node2);
            }
          }
        } else if (this.eat(tokTypes.bracketL)) {
          const elements = [];
          while (!(this.type === tokTypes.bracketR)) {
            const start = this.start, startLoc = this.startLoc;
            const restElement = !!this.eat(tokTypes.ellipsis);
            let nodeType = this.parseTypeDefinition();
            if (this.eat(tokTypes.colon)) {
              if (nodeType.type !== "TypeDefinition") {
                this.unexpected();
              } else {
                const propertyNode = this.startNodeAt(start, startLoc);
                nodeType.type = "Identifier";
                propertyNode.key = nodeType;
                propertyNode.init = this.parseTypeDefinition();
                nodeType = propertyNode;
                this.finishNode(propertyNode, "TypeTupleElementDefinition");
              }
            }
            if (restElement) {
              const restNode = this.startNodeAt(start, startLoc);
              restNode.value = nodeType;
              this.finishNode(restNode, "TypeTupleRestDefinition");
              nodeType = restNode;
            }
            elements.push(nodeType);
            if (!this.eat(tokTypes.comma)) {
              break;
            }
          }
          this.expect(tokTypes.bracketR);
          if (prefix && elements.length === 1) {
            node2.object = prefix;
            node2.property = elements[0];
            typeName = "TypeComputeDefinition";
          } else {
            node2.prefix = prefix;
            node2.elements = elements;
            typeName = "TypeTupleDefinition";
          }
          this.finishNode(node2, typeName);
          if (this.type === tokTypes.bracketL && !this.canInsertSemicolon()) {
            node2 = this.parseTypeDefinition(node2);
          }
        } else if (this.eat(tokTypes.braceL)) {
          let first = true;
          node2.properties = [];
          const propHash = /* @__PURE__ */ Object.create(null);
          const parseProperty = () => {
            const prop = this.startNode();
            let start = this.start, startLoc = this.startLoc;
            let declGenerics2 = this.parseGenericType();
            let method = null;
            let readonly = null;
            if (this.eat(tokTypes.parenL)) {
              prop.key = this.startNodeAt(start, startLoc);
              prop.key.name = "#call#";
              this.finishNode(prop.key, "Identifier");
              method = this.startNodeAt(start, startLoc);
              method.genericity = declGenerics2;
              method.params = this.parseBindingList(tokTypes.parenR, false, true);
            } else {
              if (this.type === tokTypes.name && this.value === "readonly") {
                readonly = this.parseIdent(false);
              }
              if (this.eat(tokTypes.bracketL)) {
                prop.key = this.parseIdent(false);
                prop.key.computed = true;
                if (this.eat(tokTypes.colon)) {
                  prop.key.acceptType = this.parseTypeDefinition();
                } else if (tokTypes.dot === this.type) {
                  prop.key = this.parseSubscripts(prop.key, prop.key.start, prop.key.loc);
                }
                this.expect(tokTypes.bracketR);
              } else {
                if (readonly && tokTypes.colon === this.type) {
                  prop.key = readonly;
                  readonly = null;
                } else {
                  if (this.type === tokTypes.string || this.type === tokTypes.num) {
                    prop.key = this.parseLiteral(this.value);
                  } else {
                    prop.key = this.parseIdent(true);
                    if (prop.key.name === "new") {
                      prop.key.name = "#new#";
                    }
                  }
                }
              }
              declGenerics2 = this.parseGenericType();
              if (this.eat(tokTypes.parenL)) {
                method = this.startNodeAt(start, startLoc);
                method.genericity = declGenerics2;
                method.params = this.parseBindingList(tokTypes.parenR, false, true);
              } else if (declGenerics2) {
                this.unexpected();
              }
              if (this.eat(tokTypes.question)) {
                prop.key.question = true;
              }
            }
            if (this.eat(tokTypes.colon)) {
              if (method) {
                method.value = this.parseTypeDefinition();
                prop.value = method;
                this.finishNode(method, "TypeFunctionDefinition");
              } else {
                prop.value = this.parseTypeDefinition();
              }
            } else if (method) {
              prop.value = method;
              this.finishNode(method, "TypeFunctionDefinition");
            }
            if (!(prop.key.computed || prop.key.name === "#new#" || prop.key.name === "#call#")) {
              let key = prop.key.name || prop.key.value;
              if (propHash[key] === true) {
                this.raiseRecoverable(prop.key.start, "Redefinition of property");
              }
              propHash[key] = true;
            }
            prop.readonly = !!readonly;
            return this.finishNode(prop, "TypeObjectPropertyDefinition");
          };
          while (!this.eat(tokTypes.braceR)) {
            if (!first) {
              if (this.type === tokTypes.semi) {
                this.next();
              } else {
                this.expect(tokTypes.comma);
              }
              if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(tokTypes.braceR)) {
                break;
              }
            } else {
              first = false;
            }
            node2.properties.push(parseProperty());
          }
          this.finishNode(node2, "TypeObjectDefinition");
          if (this.type === tokTypes.bracketL && !this.canInsertSemicolon()) {
            node2 = this.parseTypeDefinition(node2);
          }
        } else if (this.eat(tokTypes.parenL)) {
          let isParenR = false;
          if (this.type === tokTypes.parenL) {
            node2 = this.parseTypeDefinition();
            this.expect(tokTypes.parenR);
            isParenR = true;
          } else {
            const result = this.testTupleUnion();
            if (result && result.arrow) {
              const params = this.parseBindingList(tokTypes.parenR, false, this.options.ecmaVersion >= 8);
              this.expect(tokTypes.arrow);
              node2.params = params;
              node2.value = this.parseTypeDefinition();
              node2.genericity = declGenerics;
              typeName = "TypeFunctionDefinition";
              this.finishNode(node2, typeName);
            } else {
              node2 = this.parseTypeDefinition();
              this.expect(tokTypes.parenR);
              isParenR = true;
            }
          }
          if (isParenR) {
            if (this.type === tokTypes.bracketL) {
              node2 = this.parseTypeDefinition(node2);
            }
          }
        } else if (tokTypes.num === this.type || tokTypes.string === this.type || tokTypes._null === this.type || tokTypes._true === this.type || tokTypes._false === this.type) {
          node2.value = this.parseExprAtom();
          this.finishNode(node2, typeName);
        } else if (tokTypes.plusMin === this.type) {
          node2.value = this.parseLiteralMinus();
          this.finishNode(node2, typeName);
        } else {
          if (readonlyNode) {
            return this.finishNode(readonlyNode, "TypeDefinition");
          }
          this.unexpected();
        }
        if (declGenerics && node2.type !== "TypeFunctionDefinition") {
          this.unexpected();
        }
        return node2;
      }
      parseAnnotation(nonStatement = false, node2 = null, inline = false) {
        if (!node2) {
          node2 = this.startNode();
          this.next();
          node2.name = this.value;
          node2.id = this.parseChainIdentifier();
        }
        node2.isCallee = false;
        if (this.eat(tokTypes.parenL)) {
          node2.isCallee = true;
          node2.body = [];
          const getParamNode = () => {
            var startPos = this.start, startLoc = this.startLoc;
            switch (this.type) {
              case tokTypes.string:
              case tokTypes.num:
              case tokTypes._null:
              case tokTypes._true:
              case tokTypes._false:
                return super.parseExprAtom();
              default:
                const node3 = this.parseMaybeDefault(startPos, startLoc);
                if (node3.type === "Identifier") {
                  return this.parseSubscripts(node3, startPos, startLoc, true);
                } else if (node3.type === "AssignmentPattern" || node3.type === "ArrayPattern" || node3.type === "ObjectPattern") {
                  return node3;
                } else {
                  this.raise(this.pos, `Annotation expression parameters can only is scalar type`);
                }
            }
          };
          while (this.type !== tokTypes.parenR) {
            const param = getParamNode();
            if (param) {
              node2.body.push(param);
            }
            if (!this.eat(tokTypes.comma)) {
              break;
            }
          }
          this.expect(tokTypes.parenR);
        }
        if (nonStatement === true) {
          this.finishNode(node2, "AnnotationExpression");
          if (this.canInsertSemicolon()) {
            this.semicolon();
          }
          return node2;
        } else {
          if (!inline)
            this.semicolon();
          return this.finishNode(node2, "AnnotationDeclaration");
        }
      }
      parseMetatype() {
        const node2 = this.startNode();
        node2.name = this.value;
        this.next();
        if (this.eat(tokTypes.parenL)) {
          node2.body = [];
          while (this.type !== tokTypes.parenR) {
            const elem = this.startNode();
            const left = this.startNode();
            elem.name = this.value;
            left.name = this.value;
            this.next();
            if (this.eat(tokTypes.eq)) {
              elem.left = this.finishNode(left, "Identifier");
              elem.right = this.parseMaybeAssign();
            }
            node2.body.push(elem);
            if (elem.right) {
              this.finishNode(elem, "AssignmentPattern");
            } else {
              this.finishNode(elem, "Identifier");
            }
            if (!this.eat(tokTypes.comma)) {
              break;
            }
          }
          this.expect(tokTypes.parenR);
        }
        this.expect(tokTypes.bracketR);
        this.semicolon();
        return this.finishNode(node2, "MetatypeDeclaration");
      }
      parseModifier() {
        const modifierItems = Array(3);
        while (tokenModifiers.includes(this.type)) {
          const name = this.type.label;
          this.step();
          if (this.type === tokTypes.name || this.type.keyword) {
            this.apply();
          } else {
            this.apply(-1);
            break;
          }
          const modifier = this.startNode();
          modifier.name = name;
          this.finishNode(modifier, "ModifierDeclaration");
          if (name === "final") {
            modifierItems[2] = modifier;
          } else if (name === "static") {
            modifierItems[1] = modifier;
          } else {
            modifierItems[0] = modifier;
          }
        }
        return modifierItems;
      }
      parseClassProperty(node2, kind, bracketStarted, isDeclareInterface) {
        node2 = this.parseVarStatementDefinition(node2, kind, bracketStarted, isDeclareInterface);
        if (isDeclareInterface && node2.type === "MethodDefinition" && bracketStarted) {
          return node2;
        }
        if (node2.declarations && node2.declarations.length > 1) {
          this.raise(node2.start, `Only one class property member can be defined in a declaration`);
        }
        if (kind === "readonly")
          kind = "const";
        if (kind === "get" || kind === "set")
          kind = "var";
        node2.kind = kind;
        return this.finishNode(node2, "PropertyDefinition");
      }
      parseVarStatementDefinition(node2, kind, bracketStarted, isDeclareInterface) {
        let isSetOrGet = kind === "get" || kind === "set";
        if (isSetOrGet)
          kind = "var";
        if (!(bracketStarted || isSetOrGet)) {
          this.next();
        }
        let start = this.start;
        let startLoc = this.startLoc;
        const dynamic = this.eat(tokTypes.bracketL);
        let decl2 = this.startNodeAt(start, startLoc);
        start = this.start;
        startLoc = this.startLoc;
        let id = this.parseIdent(false);
        decl2.dynamic = dynamic;
        if (dynamic) {
          if (this.eat(tokTypes.colon)) {
            id.acceptType = this.parseTypeDefinition();
          } else if (tokTypes.dot === this.type) {
            id = this.parseSubscripts(id, start, startLoc);
          }
          this.expect(tokTypes.bracketR);
        }
        if (this.eat(tokTypes.question)) {
          decl2.question = true;
        }
        if (bracketStarted) {
          let genericity = this.parseGenericType();
          if (this.type === tokTypes.parenL) {
            decl2.key = id;
            this.tryPropertyContextualGenerics = genericity;
            return this.parseClassMethod(decl2);
          } else if (genericity) {
            this.unexpected();
          }
        }
        if (this.eat(tokTypes.colon)) {
          decl2.acceptType = this.parseTypeDefinition();
        }
        if (this.eat(tokTypes.eq)) {
          decl2.init = this.parseMaybeAssign();
        }
        decl2.id = id;
        node2.declarations = [this.finishNode(decl2, "VariableDeclarator")];
        this.semicolon();
        return this.finishNode(node2, "VariableDeclaration");
      }
      parseClassElement(constructorAllowsSuper = true, isDeclareInterface = false, isUseStatement = false, isEnum = false) {
        if (this.type === tokTypes._annotation) {
          return this.parseAnnotation();
        }
        if (this.eat(tokTypes.semi)) {
          return null;
        }
        var start = this.start, startLoc = this.startLoc;
        if (!isEnum) {
          var isNew = this.eat(tokTypes._new);
          const declGenerics = this.parseGenericType();
          if (tokTypes.parenL === this.type || isNew) {
            const node2 = this.startNodeAt(start, startLoc);
            node2.genericity = declGenerics;
            this.enterScope(functionFlags(true));
            super.parseFunctionParams(node2);
            if (this.eat(tokTypes.colon)) {
              node2.returnType = this.parseTypeDefinition();
            }
            if (tokTypes.braceL === this.type) {
              this.raise(this.start, `Definition '${isNew ? "new" : "call"}' description can only is abstracts`);
            }
            this.exitScope();
            return this.finishNode(node2, isNew ? "NewDefinition" : "CallDefinition");
          }
        }
        const modifier = this.parseModifier();
        const isBracket = this.type === tokTypes.bracketL;
        let readonly = this.type === tokTypes.name && this.value === "readonly";
        let isProperty = isBracket || this.type === tokTypes._const || this.type === tokTypes._var || readonly;
        let kind = isBracket ? "var" : this.value;
        this.tryPropertyContextualFlag = true;
        this.isDeclareInterfaceFlag = isDeclareInterface;
        if (readonly) {
          this.step();
          if (this.type === tokTypes.parenL || this.type === tokTypes.relational || this.type === tokTypes.colon) {
            readonly = false;
            isProperty = false;
          }
          this.apply(-1);
        }
        this.isUseStatement = isUseStatement;
        if (!isUseStatement && !isProperty && this.value === "use" && !modifier.some((item2) => !!item2)) {
          const type2 = this.step();
          if (type2 === tokTypes._static || type2 === tokTypes._this) {
            this.apply();
            return this.parseUseStatement();
          } else {
            this.apply(-1);
          }
        }
        if (!isProperty && this.type === tokTypes.name && this.value === "get" || this.value === "set") {
          this.step();
          if (this.type !== tokTypes.name && this.type !== tokTypes.parenL && this.type !== tokTypes.relational) {
            if (this.type === tokTypes.question) {
              this.step();
              if (this.type === tokTypes.colon) {
                isProperty = true;
              }
              this.apply(-2);
            } else {
              if (this.type === tokTypes.colon) {
                isProperty = true;
              }
              this.apply(-1);
            }
          } else {
            this.apply(-1);
          }
        }
        const element = isProperty ? this.parseClassProperty(this.startNode(), kind, isBracket, isDeclareInterface || isUseStatement) : super.parseClassElement(constructorAllowsSuper);
        if (element && element.kind === "method" && element.isPropertyDefinition) {
          var decl2 = this.startNodeAt(start, startLoc);
          var key = element.key;
          decl2.id = key;
          decl2.question = !!key.question;
          decl2.acceptType = key.acceptType;
          decl2.init = key.init;
          element.declarations = [decl2];
          element.kind = "var";
          this.finishNode(decl2, "VariableDeclarator");
          this.finishNode(element, "PropertyDefinition");
          delete key.init;
          delete key.acceptType;
          delete key.question;
          delete element.key;
          delete element.isPropertyDefinition;
        }
        const generics = this.tryPropertyContextualGenerics;
        if (generics && element.type === "MethodDefinition") {
          element.value.genericity = generics;
        }
        this.tryPropertyContextualGenerics = null;
        if (modifier[0]) {
          element.modifier = modifier[0];
        }
        if (modifier[1]) {
          element.static = modifier[1];
        }
        if (modifier[2]) {
          element.final = modifier[2];
        }
        return element;
      }
      parsePropertyName(prop) {
        if (!prop.key && (prop.kind === "get" || prop.kind === "set")) {
          if (this.type === tokTypes.question || this.type === tokTypes.parenL) {
            const node3 = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
            node3.question = this.type === tokTypes.question;
            node3.name = prop.kind;
            prop.kind = "method";
            prop.key = node3;
            this.finishNode(node3, "Identifier");
            this.next();
            return node3;
          }
        }
        const node2 = super.parsePropertyName(prop);
        if (prop.kind === "method") {
          if (this.eat(tokTypes.question)) {
            node2.question = true;
          }
          if (prop.key) {
            if (this.eat(tokTypes.colon)) {
              prop.isPropertyDefinition = true;
              prop.key.acceptType = this.parseTypeDefinition();
            }
            if (this.eat(tokTypes.eq)) {
              prop.isPropertyDefinition = true;
              prop.key.init = super.parseMaybeAssign();
            }
            if (tokTypes.parenL !== this.type) {
              if (tokTypes.semi === this.type || this.canInsertSemicolon()) {
                prop.isPropertyDefinition = true;
              }
            }
            if (prop.isPropertyDefinition) {
              if (this.isDeclareInterfaceFlag) {
                this.isDeclareInterfaceFlag = false;
                this.eat(tokTypes.comma);
              }
              this.semicolon();
            }
          }
        }
        return node2;
      }
      parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper) {
        if (method.isPropertyDefinition) {
          return method;
        } else {
          if (method.kind === "get" || method.kind === "set") {
            method.key.question = this.eat(tokTypes.question);
          }
          return super.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
        }
      }
      parseImportSpecifiers() {
        var nodes = [], first = true;
        if (this.type === tokTypes.name) {
          var node2 = this.startNode();
          node2.local = this.parseChainIdentifier(null, true);
          nodes.push(this.finishNode(node2, "ImportDefaultSpecifier"));
          if (!this.eat(tokTypes.comma)) {
            return nodes;
          }
          this.checkLVal(node2.local, BIND_LEXICAL);
        }
        if (this.type === tokTypes.star) {
          var node$1 = this.startNode();
          this.next();
          this.expect(tokTypes._as);
          node$1.local = this.parseIdent();
          this.checkLVal(node$1.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
          return nodes;
        }
        this.expect(tokTypes.braceL);
        while (!this.eat(tokTypes.braceR)) {
          if (!first) {
            this.expect(tokTypes.comma);
            if (this.afterTrailingComma(tokTypes.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var node$2 = this.startNode();
          node$2.imported = this.parseIdent(true);
          if (this.eat(tokTypes._as)) {
            node$2.local = this.parseIdent();
          } else {
            this.checkUnreserved(node$2.imported);
            node$2.local = node$2.imported;
          }
          this.checkLVal(node$2.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node$2, "ImportSpecifier"));
        }
        return nodes;
      }
      checkLocalExport() {
      }
      parseImport(node2) {
        this.next();
        if (this.type === tokTypes.string) {
          node2.specifiers = [];
          node2.source = this.parseExprAtom();
        } else {
          this.enterScope(SCOPE_TOP);
          const specifiers = this.parseImportSpecifiers();
          if (this.eatContextual("from")) {
            node2.specifiers = specifiers;
            node2.source = this.type === tokTypes.string ? this.parseExprAtom() : this.unexpected();
          } else {
            if (specifiers.length === 1 && specifiers[0].type === "ImportDefaultSpecifier") {
              node2.specifiers = [];
              node2.source = specifiers[0].local;
              if (this.eat(tokTypes._as)) {
                if (this.type !== tokTypes.name) {
                  this.unexpected();
                }
                node2.alias = super.parseIdent();
              }
            } else {
              this.unexpected();
            }
          }
          this.exitScope();
        }
        this.semicolon();
        return this.finishNode(node2, "ImportDeclaration");
      }
      parseStatementAnnotation(inline = false) {
        if (this.type === tokTypes._annotation) {
          let node2 = this.startNode();
          this.next();
          if (!inline && this.type === tokTypes._interface) {
            node2 = this.parseStatement(null, true);
            node2.decorator = true;
            return node2;
          }
          node2.name = this.value;
          node2.id = this.parseChainIdentifier();
          return this.parseAnnotation(false, node2, inline);
        }
        return null;
      }
      parsePackage(node2) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        node2.body = [];
        node2.id = null;
        if (this.type === tokTypes.semi) {
          this.next();
        } else if (tokTypes.braceL !== this.type) {
          node2.id = this.parseChainIdentifier();
          if (this.type === tokTypes.semi) {
            this.next();
          }
        }
        if (this.eat(tokTypes.braceL)) {
          node2.isBlock = true;
          while (!this.eat(tokTypes.braceR)) {
            const item2 = this.parseStatementAnnotation();
            if (item2) {
              node2.body.push(item2);
            } else {
              if (this.type === tokTypes._export) {
                node2.body.push(this.parseExport(this.startNode()));
              } else {
                node2.body.push(this.parseStatement(null, true));
              }
            }
          }
        } else {
          node2.isBlock = false;
          while (!(tokTypes.eof === this.type || tokTypes._package === this.type)) {
            const item2 = this.parseStatementAnnotation();
            if (item2) {
              node2.body.push(item2);
            } else {
              if (this.type === tokTypes._export) {
                node2.body.push(this.parseExport(this.startNode()));
              } else {
                node2.body.push(this.parseStatement(null, true));
              }
            }
          }
        }
        this.strict = oldStrict;
        return this.finishNode(node2, "PackageDeclaration");
      }
      parseDeclareModule(node2) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        node2.body = [];
        node2.id = null;
        this.parseDeclareModuleContext = true;
        if (this.type === tokTypes.semi) {
          this.raise(this.start, "Declared module identifier cannot is empty.");
        } else if (tokTypes.braceL !== this.type) {
          node2.id = this.parseExprSubscripts();
          if (this.type === tokTypes.semi) {
            this.next();
          }
        }
        if (!node2.id) {
          this.raise(this.start, "Declared module missing identifier.");
        }
        if (this.eat(tokTypes.braceL)) {
          node2.isBlock = true;
          while (!this.eat(tokTypes.braceR)) {
            const item2 = this.parseStatementAnnotation();
            if (item2) {
              node2.body.push(item2);
            } else {
              if (this.type === tokTypes._export) {
                node2.body.push(this.parseExport(this.startNode()));
              } else if (this.type === tokTypes._import) {
                node2.body.push(this.parseImport(this.startNode()));
              } else {
                let isDeclare = false;
                if (this.value === "declare") {
                  isDeclare = true;
                  this.next();
                }
                if (this.value === "namespace" || this.value === "global") {
                  node2.body.push(this.parseDeclareModuleNamespace(this.value === "global"));
                } else {
                  node2.body.push(this.parseDeclarator(this.startNode(), isDeclare));
                }
              }
            }
          }
        } else {
          this.unexpected();
        }
        this.strict = oldStrict;
        this.parseDeclareModuleContext = false;
        return this.finishNode(node2, "ModuleDeclaration");
      }
      parseExport(node2, exports2) {
        this.next();
        if (this.eat(tokTypes.eq)) {
          this._exportAssignmentDeclaration = true;
          node2.expression = this.parseExprSubscripts();
          this._exportAssignmentDeclaration = false;
          this.semicolon();
          return this.finishNode(node2, "ExportAssignmentDeclaration");
        }
        if (this.eat(tokTypes.star)) {
          if (this.options.ecmaVersion >= 11) {
            if (this.eatContextual("as")) {
              node2.exported = this.parseIdent(true);
              this.checkExport(exports2, node2.exported.name, this.lastTokStart);
            } else {
              node2.exported = null;
            }
          }
          if (this.eatContextual("from")) {
            if (this.type !== tokTypes.string) {
              this.unexpected();
            }
            node2.source = this.parseExprAtom();
          }
          this.semicolon();
          return this.finishNode(node2, "ExportAllDeclaration");
        }
        if (this.eat(tokTypes._default)) {
          this.checkExport(exports2, "default", this.lastTokStart);
          var isAsync;
          if (this.type === tokTypes._function || (isAsync = this.isAsyncFunction())) {
            var fNode = this.startNode();
            this.next();
            if (isAsync) {
              this.next();
            }
            node2.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
          } else if (this.type === tokTypes._class) {
            var cNode = this.startNode();
            node2.declaration = this.parseClass(cNode, "nullableID");
          } else {
            node2.declaration = this.parseMaybeAssign();
            this.semicolon();
          }
          return this.finishNode(node2, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node2.declaration = this.parseStatement(null, true);
          if (node2.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports2, node2.declaration.declarations);
          } else {
            this.checkExport(exports2, node2.declaration.id.name, node2.declaration.id.start);
          }
          node2.specifiers = [];
          node2.source = null;
        } else {
          node2.declaration = null;
          node2.specifiers = this.parseExportSpecifiers(exports2);
          if (this.eatContextual("from")) {
            if (this.type !== tokTypes.string) {
              this.unexpected();
            }
            node2.source = this.parseExprAtom();
          } else {
            for (var i = 0, list = node2.specifiers; i < list.length; i += 1) {
              var spec = list[i];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
            }
            node2.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node2, "ExportNamedDeclaration");
      }
      parseDeclareModuleNamespace(isGlobal = false) {
        if (!isGlobal)
          this.next();
        const node2 = this.startNode();
        node2.body = [];
        node2.id = this.parseChainIdentifier();
        this.expect(tokTypes.braceL);
        while (!this.eat(tokTypes.braceR)) {
          const item2 = this.parseStatementAnnotation();
          if (item2) {
            node2.body.push(item2);
          } else {
            if (this.type === tokTypes._export) {
              node2.body.push(this.parseExport(this.startNode()));
            } else if (this.type === tokTypes._import) {
              node2.body.push(this.parseImport(this.startNode()));
            } else {
              let isDeclare = false;
              if (this.value === "declare") {
                isDeclare = true;
                this.next();
              }
              if (this.value === "namespace") {
                node2.body.push(this.parseDeclareModuleNamespace());
              } else {
                node2.body.push(this.parseDeclarator(this.startNode(), isDeclare));
              }
            }
          }
        }
        this.finishNode(node2, "NamespaceDeclaration");
        return node2;
      }
      hasBacklash(pos) {
        let num = 0;
        while (this.input.charCodeAt(pos--) === 92 && pos > 0) {
          num++;
        }
        return num % 2 === 1;
      }
      jsx_readWhitespaceToken(code) {
        const start = this.pos;
        let isNewLine = false;
        while (code === 32 || (isNewLine = acorn.isNewLine(code))) {
          ++this.pos;
          if (isNewLine) {
            isNewLine = false;
            if (code === 13 && this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
          }
          code = this.input.charCodeAt(this.pos);
        }
        if (this.pos !== start) {
          this.finishToken(tt_whitespace, this.input.slice(start, this.pos));
          return true;
        }
        return false;
      }
      jsx_readTextToken(endTag) {
        let out = "", chunkStart = this.pos;
        this.start = chunkStart;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated JSX contents");
          }
          let ch = this.input.charCodeAt(this.pos);
          if (acorn.isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.jsx_readNewLine(true);
            chunkStart = this.pos;
          } else if (endTag) {
            if (ch === 60 && this.input.charCodeAt(this.pos + 1) === 47) {
              if (!this.hasBacklash(this.pos - 1)) {
                if (this.input.substr(this.pos + 2, endTag.length).toLowerCase() === endTag) {
                  out += this.input.slice(chunkStart, this.pos);
                  return this.finishToken(tt_content_text, out);
                }
              }
            }
            ++this.pos;
          } else {
            if (ch === 93 && this.input.charCodeAt(this.pos + 1) === 93 && this.input.charCodeAt(this.pos + 2) === 62) {
              if (!this.hasBacklash(this.pos - 1)) {
                out += this.input.slice(chunkStart, this.pos);
                return this.finishToken(tt_content_text, out);
              }
            }
            ++this.pos;
          }
        }
      }
      jsx_parseOpeningElementAt(startPos, startLoc) {
        let node2 = this.startNodeAt(startPos, startLoc);
        node2.attributes = [];
        let nodeName = this.jsx_parseElementName();
        if (nodeName)
          node2.name = nodeName;
        while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)
          node2.attributes.push(this.jsx_parseAttribute());
        node2.selfClosing = this.eat(tt.slash);
        if (nodeName && typeof nodeName.name === "string" && !node2.selfClosing) {
          const name = nodeName.name.toLowerCase();
          if (name === "script" || name === "style") {
            if (name === "script") {
              this.context.push(tc_script_expr);
            } else {
              this.context.push(tc_style_expr);
            }
          }
        }
        this.expect(tok.jsxTagEnd);
        return this.finishNode(node2, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
      }
      jsx_parseElementAt(startPos, startLoc) {
        let node2 = this.startNodeAt(startPos, startLoc);
        let children = [];
        let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
        let closingElement = null;
        let scriptType = null;
        if (openingElement.name) {
          const tagName = getQualifiedJSXName(openingElement.name).toLowerCase();
          if (tagName === "style") {
            scriptType = "Style";
          } else if (tagName === "script") {
            scriptType = "Script";
          }
        }
        if (!openingElement.selfClosing) {
          const curCtx = this.curContext();
          if (curCtx === tc_style_expr && this.type !== tt_cdata_start) {
            const scriptNode = this.startNode();
            scriptNode.body = [];
            while (this.type !== tok.jsxTagStart) {
              switch (this.type) {
                case tt_whitespace:
                case tt_content_text:
                case tok.jsxText:
                  children.push(this.finishNode(this.parseLiteral(this.value), "JSXText"));
                  break;
                default:
                  this.unexpected();
              }
            }
            scriptType = "Style";
            startPos = this.start;
            startLoc = this.startLoc;
            this.expect(tok.jsxTagStart);
            this.expect(tt.slash);
            closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
          } else if (curCtx === tc_script_expr && this.type !== tt_cdata_start) {
            this.enterScope(1);
            while (this.type !== tok.jsxTagStart) {
              if (this.type === tokTypes._import) {
                children.push(this.parseImport(this.startNode()));
              } else {
                children.push(this.parseClassElement(true));
              }
            }
            this.exitScope();
            scriptType = "Script";
            startPos = this.start;
            startLoc = this.startLoc;
            this.expect(tok.jsxTagStart);
            this.expect(tt.slash);
            closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
          } else {
            contents:
              for (; ; ) {
                switch (this.type) {
                  case tok.jsxTagStart:
                    startPos = this.start;
                    startLoc = this.startLoc;
                    this.next();
                    if (this.eat(tt.slash)) {
                      closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                      break contents;
                    }
                    children.push(this.jsx_parseElementAt(startPos, startLoc));
                    break;
                  case tok.jsxText:
                    children.push(this.parseExprAtom());
                    break;
                  case tt.braceL:
                    children.push(this.jsx_parseExpressionContainer());
                    break;
                  case tt_cdata_start:
                    this.next();
                    children.push(this.finishNode(this.parseLiteral(this.value), "JSXCdata"));
                    this.expect(tt_cdata_end);
                    break;
                  case tt_content_text:
                    children.push(this.finishNode(this.parseLiteral(this.value), "JSXText"));
                    break;
                  case tt_whitespace:
                    children.push(this.finishNode(this.parseLiteral(this.value), "JSXText"));
                    break;
                  default:
                    this.unexpected();
                }
              }
          }
          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
            this.raise(
              closingElement.start,
              "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">"
            );
          }
        }
        let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
        node2["opening" + fragmentOrElement] = openingElement;
        node2["closing" + fragmentOrElement] = closingElement;
        node2.children = children;
        if (this.type === tt.relational && this.value === "<") {
          this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
        }
        if (scriptType) {
          return this.finishNode(node2, "JSX" + scriptType);
        } else {
          return this.finishNode(node2, "JSX" + fragmentOrElement);
        }
      }
      jsx_readCDATAToken(code, noSkip) {
        if (!noSkip && this.jsx_readWhitespaceToken(code)) {
          return true;
        }
        if (this.disabledJSXExpressionFlag || this.__parseTypeStatement || this.parseDeclaratorContext || this.parseInterfaceContext) {
          return false;
        }
        let pos = this.pos;
        if (code === 60 && this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 91 && this.input.charCodeAt(pos + 8) === 91 && this.input.substr(pos + 3, 5) === "CDATA") {
          this.pos += 9;
          this.finishToken(tt_cdata_start);
          return true;
        } else if (code === 93 && this.input.charCodeAt(pos + 1) === 93 && this.input.charCodeAt(pos + 2) === 62) {
          this.pos += 3;
          this.finishToken(tt_cdata_end);
          return true;
        }
      }
      updateContext(prevType) {
        if (this.type === tt.slash && prevType === tok.jsxTagStart) {
          const context = this.context[this.context.length - 3];
          if (context === tc_script_expr || context === tc_style_expr) {
            this.context.splice(this.context.length - 3, 1);
          }
        } else if (prevType === tt_cdata_start && this.curContext() === tc_cdata_expr) {
          this.context.pop();
        }
        super.updateContext(prevType);
        if (this.exprAllowed && this.context[this.context.length - 2] === tc_type_statement) {
          this.exprAllowed = false;
        } else if (!this.exprAllowed) {
          const ctx = this.curContext();
          if (ctx === tc_script_expr) {
            this.exprAllowed = this.type === tt.braceR || this.type === tok.jsxTagEnd;
          } else if (ctx === tokContexts.b_stat || ctx === tokContexts.b_expr) {
            this.exprAllowed = this.type === tok.jsxTagEnd;
          }
        }
      }
    };
    Parser.extend(function() {
      return SyntaxParser;
    });
    SyntaxParser.parse = function parse(input, options) {
      options = Object.assign({ preserveParens: true }, options || {});
      const obj = new SyntaxParser(options, input);
      const res = obj.parse();
      return res;
    };
    SyntaxParser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
      options = Object.assign({ preserveParens: true }, options || {});
      var parser = new SyntaxParser(options, input, pos);
      if (options.isMethod) {
        parser.enterScope(functionFlags(!!options.isAsync, !!options.generator) | SCOPE_SUPER | (!!options.allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      }
      parser.nextToken();
      return parser.parseExpression();
    };
    SyntaxParser.parseBindingAtom = function parseBindingAtom(input, pos = 0, options = {}) {
      options = Object.assign({ preserveParens: true }, options || {});
      var parser = new SyntaxParser(options, input, pos);
      parser.nextToken();
      return parser.parseBindingAtom();
    };
    var parseJSX = Parser.extend(jsx({ allowNamespaces: true, allowNamespacedObjects: true }));
    SyntaxParser.jsx = function jsx2(input, options) {
      return parseJSX.parse(input, options);
    };
    module.exports = {
      acorn,
      parseJSX,
      Parser: SyntaxParser
      // lessParser:(function(){
      //     const less = require('less');
      //     const defaultOptions = lodash.merge({}, less.options);
      //     return {
      //         _options:defaultOptions,
      //         input:'',
      //         option( options ){
      //             if( options ){
      //                 this._options = lodash.merge(this._options, options);
      //             }
      //             return this._options;
      //         },
      //         render(input){
      //         },
      //         getRangeByNode(node){
      //             if( node && this.input && node._index >= 0 ){
      //                const liens = this.input.substr(0,node._index).split(/\n/);
      //                return {
      //                    line:liens.length,
      //                    column:liens[liens.length].length
      //                }
      //             }
      //             return null;
      //         },
      //         toCSS( rootNode, imports){
      //             const tree = new less.ParseTree(rootNode, imports || this.imports )
      //             return tree.toCSS(this.callOptions || this._options);
      //         },
      //         parse(input, callback){
      //             this.input = input;
      //             less.parse(input, this._options, (err, root, imports, options)=>{
      //                 this.imports = imports;
      //                 this.callOptions = options;
      //                 callback(err, root, imports, options)
      //             })
      //         }
      //     };
      // }())
    };
  }
});

// lib/core/AutoImporter.js
var require_AutoImporter = __commonJS({
  "lib/core/AutoImporter.js"(exports, module) {
    var AutoImporter = class {
      static is(value2) {
        return value2 && value2 instanceof AutoImporter;
      }
      static create(source, local2, imported, extract = false, isDefault = false, origin = null) {
        return new AutoImporter(source, local2, imported, extract, isDefault, origin);
      }
      #source = null;
      #local = null;
      #imported = null;
      #extract = false;
      #isDefault = false;
      #compilation = null;
      #origin = null;
      #description = null;
      #owner = null;
      #origins = /* @__PURE__ */ new Set();
      constructor(source, local2, imported, extract = false, isDefault = false, origin = null) {
        this.#source = source;
        this.#local = local2;
        this.#imported = imported;
        this.#extract = !!extract;
        this.#isDefault = isDefault;
        this.#origin = origin;
        if (origin) {
          this.#compilation = origin.compilation;
        }
      }
      get description() {
        return this.#description;
      }
      set description(value2) {
        if (value2) {
          this.#description = value2;
        }
      }
      get owner() {
        return this.#owner;
      }
      set owner(value2) {
        if (value2) {
          this.#owner = value2;
        }
      }
      get origin() {
        return this.#origin;
      }
      set origin(value2) {
        this.#origin = value2;
        if (value2) {
          this.#compilation = value2.compilation;
          this.#origins.add(value2);
        }
      }
      get origins() {
        return this.#origins;
      }
      get compilation() {
        return this.#compilation;
      }
      get source() {
        return this.#source;
      }
      get local() {
        return this.#local;
      }
      get imported() {
        return this.#imported;
      }
      get extract() {
        return this.#extract;
      }
      get namespace() {
        return this.#imported === "*";
      }
      get isDefault() {
        return this.#isDefault;
      }
    };
    module.exports = AutoImporter;
  }
});

// lib/core/Lang.js
var require_Lang = __commonJS({
  "lib/core/Lang.js"(exports, module) {
    var chalk = __require("chalk");
    var chalkInfo = chalk.keyword("orange");
    var chalkBgWarn = chalk.bgMagenta;
    var chalkWarn = chalk.magenta;
    var messages = {};
    var langIndexs = [0, 1];
    var langId = 0;
    function define(code, value2) {
      messages[code] = value2;
    }
    define("note", [
      chalk.bgRed("[\u63D0\u793A]"),
      chalk.bgRed("[Note]")
    ]);
    define("error", [
      `${chalk.red("\u2718")} ${chalk.bgRed("[\u9519\u8BEF]")}`,
      `${chalk.red("\u2718")} ${chalk.bgRed("[Error]")}`
    ]);
    define("warn", [
      `${chalkWarn("\u203B")} ${chalkBgWarn("[\u8B66\u544A]")}`,
      `${chalkWarn("\u203B")} ${chalkBgWarn("[Warn]")}`
    ]);
    define("info", [
      chalkInfo("\u261E [\u4FE1\u606F]"),
      chalkInfo("\u261E [Info]")
    ]);
    define(100, [
      `\u6709${chalk.red(" %s ")}\u4E2A\u7F16\u8BD1\u9519\u8BEF\u9700\u8981\u4FEE\u590D\u3002\u8BF7\u5173\u6CE8\u8F93\u51FA\u4FE1\u606F`,
      `there ${chalk.red("has %s errors")} compilation that need to be fixed. please review the output`
    ]);
    define(101, [
      `\u5728\u7F16\u8BD1\u8FC7\u7A0B\u4E2D\u53D1\u73B0\u4E86\u4E00\u4E9B\u9519\u8BEF\uFF0C\u9700\u8981\u5148\u66F4\u6B63\u4E4B\u540E\u518D\u6784\u5EFA`,
      `There has errors found during compilation that need to corrected before building`
    ]);
    function getMessage(langId2, code, args = []) {
      let dataset = messages[code];
      let value2 = dataset ? dataset[langId2] : null;
      if (!value2) {
        value2 = "unknown";
        if (typeof code === "string") {
          value2 = code;
        }
        return value2;
      }
      let index = 0;
      return value2.replace(/(?<!\\)(%([s|S]|\d+))/g, (name) => {
        const at = parseInt(name.substr(1, 1));
        const result = at > 0 ? args[at - 1] : args[index++];
        return result === void 0 ? "unknown" : result;
      });
    }
    module.exports = {
      setLangId(value2) {
        if (langIndexs.includes(value2)) {
          langId = value2;
        } else {
          throw new Error(`Lang index invaild. allow indexs [${langIndexs.join(",")}]`);
        }
      },
      getLangId() {
        return langId;
      },
      define,
      get(code, ...args) {
        return getMessage(langId, code, args);
      },
      fetch(id, code, ...args) {
        return getMessage(id, code, args);
      },
      has(code) {
        return Object.prototype.hasOwnProperty.call(messages, code);
      },
      make(langId2) {
        if (!langIndexs.includes(langId2)) {
          throw new Error(`Lang index invaild. allow indexs [${langIndexs.join(",")}]`);
        }
        return (code, ...args) => {
          return getMessage(langId2, code, args);
        };
      }
    };
  }
});

// lib/core/Utils.js
var require_Utils = __commonJS({
  "lib/core/Utils.js"(exports, module) {
    var fs = __require("fs");
    var path = __require("path");
    var Lang = require_Lang();
    var chalk = __require("chalk");
    var directiveMap = {
      "Runtime": true,
      "Syntax": true
    };
    var globalShortenTypeMaps = {
      "int": true,
      "uint": true,
      "double": true,
      "number": true,
      "float": true,
      "array": true,
      "string": true,
      "boolean": true,
      "regexp": true,
      "object": true,
      "class": true,
      "any": true,
      "null": true,
      "void": true,
      "undefined": true,
      "never": true
    };
    var scalarTypeMaps = {
      "int": true,
      "uint": true,
      "double": true,
      "number": true,
      "float": true,
      "string": true,
      "boolean": true,
      "regexp": true,
      "null": true,
      "undefined": true
    };
    var structTableMappingTypeName = {
      "tinyint": "int",
      "smallint": "int",
      "mediumint": "int",
      "int": "int",
      "bigint": "int",
      "double": "float",
      "float": "float",
      "decimal": "float",
      "numberic": "number",
      "time": "number",
      "timestamp": "string",
      "datetime": "string",
      "year": "string",
      "real": "string",
      "bit": "string",
      "char": "string",
      "varchar": "string",
      "varbinary": "string",
      "text": "string",
      "tinytext": "string",
      "mediumtext": "string",
      "longtext": "string",
      "binary": "string",
      "tinyblob": "string",
      "blob": "string",
      "mediumblob": "string",
      "longblob": "string",
      "geometry": "string",
      "point": "string",
      "linestring": "string",
      "polygon": "string",
      "multipoint": "string",
      "multilinestring": "string",
      "multipolygon": "string",
      "geometrycollectic": "string",
      "set": "string",
      "enum": "string",
      "email": "string",
      "range": "string"
    };
    var mergeTypeKey = Symbol("type is merged");
    var Utils = {
      IS_STACK: Symbol("this is stack"),
      IS_COMPILATION: Symbol("this is compilation"),
      IS_MODULE: Symbol("this is module"),
      IS_TYPE: Symbol("this is type"),
      IS_CONTEXT: Symbol("this is context"),
      IS_INFERENCE: Symbol("this is inference"),
      isStack(value2) {
        return value2 ? !!value2[this.IS_STACK] : false;
      },
      isCompilation(value2) {
        return value2 ? !!value2[this.IS_COMPILATION] : false;
      },
      isModule(value2) {
        return value2 ? !!value2[this.IS_MODULE] : false;
      },
      isType(value2) {
        return value2 ? !!value2[this.IS_TYPE] : false;
      },
      isContext(value2) {
        return value2 ? !!value2[this.IS_CONTEXT] : false;
      },
      checkDirective(name) {
        return directiveMap[name];
      },
      getPropertyModifierName(method) {
        return method.modifier ? method.modifier.value() : "public";
      },
      existsSync(file) {
        return fs.existsSync(file);
      },
      getFileStatSync(file) {
        return fs.statSync(file);
      },
      readdir(dir, isFull) {
        if (!fs.existsSync(dir)) {
          return null;
        }
        if (!fs.statSync(dir).isDirectory()) {
          return null;
        }
        dir = path.isAbsolute(dir) ? dir : path.resolve(dir);
        var files = fs.readdirSync(dir);
        files = files.filter(function(a) {
          return !(a === "." || a === "..");
        });
        if (isFull) {
          return files.map(function(name) {
            return path.join(dir, name);
          });
        }
        return files;
      },
      getStackByName(name) {
        const stacks = this.getStacks();
        return stacks[name] || null;
      },
      isStackByName(target, name, flag) {
        const fn = this.getStackByName(name);
        const result = fn && target instanceof fn;
        return result && flag ? target : result;
      },
      info(msg) {
        console.info(msg);
      },
      log(msg) {
        console.log(msg);
      },
      debug(msg) {
        msg = String(msg);
        const orange = chalk.keyword("orange");
        console.trace(orange("[Debug]") + " " + msg + "\n");
      },
      warn(msg) {
        console.warn(`${Lang.get("warn")} ${chalk.yellow(msg)}
`);
      },
      error(msg) {
        console.error(`${Lang.get("error")} ${chalk.red(msg)}
`);
      },
      reportDiagnosticMessage(diagno) {
        const file = diagno.file;
        const range = diagno.range;
        const kind = diagno.kind;
        const message = diagno.message;
        const code = diagno.code;
        if (kind >= 0) {
          const lightGray = chalk.rgb(240, 240, 240);
          const blackGray = chalk.rgb(50, 50, 50);
          let mes = lightGray(file ? `(${file}:${range.start.line}:${range.start.column}) ${code}` : `${code}`);
          if (kind === 0) {
            console.error(`${Lang.get("error")} ${blackGray(message)} ${mes}
`);
          } else if (kind === 1) {
            console.warn(`${Lang.get("warn")} ${blackGray(message)} ${mes}
`);
          } else {
            console.info(`${Lang.get("info")} ${blackGray(message)} ${mes}
`);
          }
        }
      },
      scalarMap: ["number", "boolean", "float", "int", "uint", "double", "regexp", "string"],
      isScalar(type2) {
        return type2 && !this.isModule(type2) && !type2.isInstanceofType && (type2.isLiteralType || type2.isAliasType && scalarTypeMaps[type2.id] === true);
      },
      isTypeModule(type2) {
        return type2 && this.isModule(type2) && (type2.isClass || type2.isInterface || type2.isStructTable || type2.isEnum) === true;
      },
      isWrapType(type2) {
        return type2 && this.isType(type2) && (type2.isTupleType || type2.isGenericType || type2.isClassGenericType || type2.isInstanceofType || type2.isCircularType || type2.isPredicateType || type2.isLiteralType || type2.isLiteralObjectType || type2.isLiteralArrayType || type2.isFunctionType || type2.isAliasType) === true;
      },
      isLiteralObjectType(type2, flag = false) {
        if (!this.isType(type2))
          return false;
        if (type2.isTypeofType) {
          return this.isLiteralObjectType(type2.origin.type());
        }
        if (type2.isAliasType || type2.isClassGenericType) {
          return this.isLiteralObjectType(type2.inherit.type());
        }
        if (flag && (type2.isTupleType || type2.isLiteralArrayType) === true) {
          return true;
        }
        return type2.isLiteralObjectType === true;
      },
      isLiteralArrayType(type2) {
        if (!this.isType(type2))
          return false;
        if (type2.isTypeofType) {
          return this.isLiteralArrayType(type2.origin.type());
        }
        if (type2.isAliasType || type2.isClassGenericType) {
          return this.isLiteralArrayType(type2.inherit.type());
        }
        return (type2.isTupleType || type2.isLiteralArrayType) === true;
      },
      isClassType(type2) {
        if (type2 && this.isModule(type2) && (type2.isClass || type2.isEnum)) {
          return true;
        }
        return false;
      },
      isLocalModule(module2) {
        if (!this.isTypeModule(module2))
          return false;
        const compilation = module2.compilation;
        return compilation && compilation.isLocalDocument();
      },
      isGlobalModule(module2) {
        return module2 && module2.isDeclaratorModule && this.isTypeModule(module2);
      },
      isInterface(module2) {
        return module2 && module2.isInterface && this.isTypeModule(module2);
      },
      checkTypeForBoth(left, right, isStrict = true, context = null) {
        if (left === right) {
          return true;
        } else if (!left || !right) {
          return false;
        }
        if (left.isAnyType) {
          return right.isAnyType === true;
        } else if (right.isAnyType) {
          return left.isAnyType === true;
        } else if (left.isVoidType || right.isVoidType) {
          return left.isVoidType === right.isVoidType;
        } else if (left.isNullableType || right.isNullableType) {
          return left.isNullableType === right.isNullableType;
        } else if (left.isUndefinedType || right.isUndefinedType) {
          return left.isUndefinedType === right.isUndefinedType;
        } else if (left.isLiteralObjectType) {
          if (!right.isLiteralObjectType)
            return false;
          if (left.attributes.size !== right.attributes.size)
            return false;
          let lD = left.dynamicProperties;
          let rD = right.dynamicProperties;
          if (Boolean(lD) !== Boolean(rD))
            return false;
          if (lD && rD) {
            if (lD.size !== rD.size)
              return false;
            if (Array.from(lD.keys()).some((key) => !rD.has(key))) {
              return false;
            }
          }
          return left.check(right, context);
        } else if (left.isLiteralArrayType) {
          if (!right.isLiteralArrayType)
            return false;
          if (left.elements.length !== right.elements.length)
            return false;
          return left.check(right, context);
        } else if (left.isTupleType) {
          if (!right.isTupleType)
            return false;
          if (left.prefix !== right.prefix)
            return false;
          if (left.isTupleUnion !== right.isTupleUnion)
            return false;
          if (left.rest !== right.rest)
            return false;
          if (left.requireCount !== right.requireCount)
            return false;
          return left.check(right, context);
        } else if (left.isLiteralType || left.isEnumType || left.isClassType || left.isVoidType || left.isUnknownType || left.isNullableType || left.isNeverType) {
          if (!isStrict && left.isLiteralType) {
            return right.check(left, context);
          }
          return left.check(right, context);
        } else if (left.isFunctionType) {
          if (!right.isFunctionType)
            return false;
          const lParams = left.params;
          const rParams = right.params;
          if (lParams.length !== rParams.length)
            return false;
          const lReturnType = left.inferReturnType();
          const rReturnType = right.inferReturnType();
          if (lReturnType && !rReturnType)
            return false;
          if (!lReturnType && rReturnType)
            return false;
          if (!this.checkTypeForBoth(lReturnType, rReturnType, isStrict))
            return false;
          return lParams.every((item2, index) => {
            let rItem = rParams[index];
            if (!rItem)
              return false;
            if (item2.isRestElement !== rItem.isRestElement) {
              return false;
            }
            const lType = item2.type();
            if (!isStrict && lType.isTupleType && lType.rest) {
              return true;
            }
            return this.checkTypeForBoth(lType, rItem.type(), isStrict, context);
          });
        } else if (left.isUnionType) {
          if (!right.isUnionType)
            return false;
          if (left.elements.length !== right.elements.length)
            return false;
          return left.elements.every((item2) => {
            const lType = item2.type();
            return right.elements.some((el) => this.checkTypeForBoth(lType, el.type(), isStrict, context));
          });
        } else if (left.isTupleType) {
          if (!right.isTupleType || left.prefix !== right.prefix || left.isTupleUnion !== right.isTupleUnion)
            return false;
          return left.elements.every((item2, index) => {
            if (!right.elements[index])
              return false;
            return this.checkTypeForBoth(item2.type(), right.elements[index].type(), isStrict, context);
          });
        } else if (left.isInstanceofType) {
          if (left.isThisType) {
            return left.isThisType === right.isThisType;
          }
          if (!right.isInstanceofType || left.isThisType !== right.isThisType || left.generics.length !== right.generics.length)
            return false;
          if (this.checkTypeForBoth(left.inherit.type(), right.inherit.type(), isStrict, context)) {
            return left.generics.every((item2, index) => {
              if (!right.generics[index])
                return false;
              return this.checkTypeForBoth(item2.type(), right.generics[index].type(), isStrict, context);
            });
          }
          return false;
        } else if (left.isClassGenericType) {
          if (!right.isClassGenericType || left.isClassType !== right.isClassType || left.isThisType !== right.isThisType)
            return false;
          if (left.types.length !== right.types.length)
            return false;
          if (this.checkTypeForBoth(left.inherit.type(), right.inherit.type(), isStrict, context)) {
            return left.elements.every((item2, index) => {
              if (!right.elements[index])
                return false;
              return this.checkTypeForBoth(item2.type(), right.elements[index].type(), isStrict, context);
            });
          }
          return false;
        } else if (left.isIntersectionType) {
          if (!right.isIntersectionType)
            return false;
          const lItems = [left.left, left.right];
          const rItems = [right.left, right.right];
          return lItems.every((item2) => {
            const type2 = item2.type();
            return rItems.some((item3) => this.checkTypeForBoth(type2, item3.type(), isStrict, context));
          });
        } else if (left.isAliasType) {
          if (!right.isAliasType)
            return false;
          return this.checkTypeForBoth(left.inherit.type(), right.inherit.type(), isStrict, context);
        } else if (left.isKeyofType) {
          if (!right.isKeyofType)
            return false;
          return this.checkTypeForBoth(left.referenceType.type(), right.referenceType.type(), isStrict, context);
        } else if (left.isGenericType) {
          if (context) {
            return left.check(right, context);
          }
          if (!right.isGenericType || left.hasConstraint !== right.hasConstraint)
            return false;
          if (left.hasConstraint) {
            return this.checkTypeForBoth(left.inherit.type(), right.inherit.type(), isStrict, context);
          }
          return true;
        } else if (left.isTypeofType) {
          if (!right.isTypeofType)
            return false;
          return this.checkTypeForBoth(left.origin.type(), right.origin.type(), isStrict);
        }
        return left.id === right.id && left.namesapce === right.namesapce;
      },
      isArray(type2) {
        return type2 && type2.id === "Array" && type2.isDeclaratorModule && this.isModule(type2) && type2.isClass;
      },
      isObject(type2) {
        return type2 && type2.id === "Object" && type2.isDeclaratorModule && this.isModule(type2) && type2.isClass;
      },
      isFunction(stack) {
        if (!stack || !stack.isStack)
          return false;
        if (stack.isCallExpression || stack.isAccessor) {
          return false;
        }
        if (stack.isProperty && stack.init) {
          stack = stack.init;
        }
        if (stack.isFunctionExpression || stack.isMethodDefinition || stack.isTypeFunctionDefinition) {
          return true;
        }
        return false;
      },
      firstToUpper(name) {
        return name.substr(0, 1).toUpperCase() + name.substr(1);
      },
      checkDepend(module2, depModule) {
        if (!module2 || !depModule)
          return false;
        if (!this.isModule(module2) || !this.isModule(depModule))
          return false;
        if (module2 === depModule)
          return true;
        if (depModule.inherit) {
          return this.checkDepend(module2, depModule.inherit.type());
        }
        const stacks = depModule.getStacks(true);
        for (let i = 0; i < stacks.length; i++) {
          const classStack = stacks[i];
          if (!classStack || classStack.compilation.isDestroyed) {
            continue;
          }
          const inherit = classStack.inherit;
          if (inherit) {
            const inheritModule = classStack.getReferenceModuleType();
            if (inheritModule) {
              return this.checkDepend(module2, inheritModule);
            }
          }
        }
        return false;
      },
      getShortType(type2) {
        if (!type2)
          return type2;
        if (type2.isTypeofType) {
          return this.getShortType(type2.origin.type());
        } else if (type2.isAliasType) {
          return this.getShortType(type2.inherit.type());
        }
        return type2;
      },
      getOriginType(type2, exclude = null) {
        if (!this.isType(type2))
          return type2;
        if (type2.isTypeofType) {
          return this.getOriginType(type2.origin.type());
        }
        let origin = type2;
        if (type2.isClassGenericType && type2.isClassType && type2.types[0]) {
          type2 = type2.types[0].type();
        }
        while (this.isWrapType(type2) && type2.extends && type2.extends[0]) {
          if (exclude) {
            if (exclude === type2)
              break;
            if (typeof exclude === "function" && exclude(type2))
              break;
          }
          type2 = type2.extends[0].type();
          if (type2.isClassGenericType && type2.isClassType && type2.types[0]) {
            type2 = type2.types[0].type();
          }
        }
        return this.isModule(type2) ? type2.type() : type2 || origin;
      },
      getFunctionType(type2) {
        if (!type2)
          return type2;
        if (type2.isFunctionType)
          return type2;
        if (type2.isAliasType) {
          return this.getFunctionType(type2.inherit.type());
        } else if (type2.isUnionType) {
          return type2.elements.find((el) => !!this.getFunctionType(el.type()).isFunctionType);
        }
        return type2;
      },
      toTypeUniqueArray(array) {
        const data = /* @__PURE__ */ new Set();
        const items = [];
        array.forEach((value2) => {
          const key = value2.type().toString();
          if (!data.has(key)) {
            data.add(key);
            items.push(value2);
          }
        });
        return items;
      },
      toTypeString(type2, inference) {
        return this.inferTypeValue(type2, inference).toString();
      },
      inferTypeValue(type2, inference) {
        if (!type2)
          return type2;
        type2 = type2.hasGenericType ? type2.clone(inference) : type2;
        if (type2.isComputeType) {
          type2 = type2.getComputeType().clone(inference);
        }
        return type2;
      },
      isModifierPublic(stack) {
        return this.getModifierValue(stack) === "public";
      },
      isModifierProtected(stack) {
        return stack && stack.isStack && stack.modifier && stack.modifier.value() === "protected";
      },
      isModifierPrivate(stack) {
        return stack && stack.isStack && stack.modifier && stack.modifier.value() === "private";
      },
      isModifierInternal(stack) {
        return stack && stack.isStack && stack.modifier && stack.modifier.value() === "internal";
      },
      getModifierValue(stack) {
        if (stack && stack.isStack) {
          if (stack.modifier) {
            return stack.modifier.value();
          } else if (stack.isMethodDefinition || stack.isPropertyDefinition || stack.isClassDeclaration || stack.isInterfaceDeclaration || stack.isEnumDeclaration && !stack.isExpressionDeclare) {
            return "public";
          }
        }
        return null;
      },
      isIterableIteratorType(type2, iteratorType) {
        if (!type2 || type2.isAnyType)
          return false;
        if (type2 === iteratorType)
          return true;
        if (iteratorType && iteratorType.isModule && iteratorType.is(type2)) {
          return type2.isInstanceofType || this.getOriginType(type2) === iteratorType;
        }
        type2 = this.getOriginType(type2);
        return type2.isModule && type2.getName() === "Iterator" && type2.isDeclaratorModule;
      },
      isStaticDescriptor(desc) {
        if (!desc)
          return false;
        const module2 = (desc.isStack ? desc.module : desc) || desc;
        if (this.isClassType(module2) && module2.static) {
          return true;
        }
        if (!(desc.isMethodDefinition || desc.isPropertyDefinition))
          return false;
        return !!desc.static;
      },
      extractFunTypeFromType(type2, ctx = null, assigmentGenerics = null, declareGenerics = null) {
        if (!type2)
          return null;
        if (type2.isFunctionType) {
          return [type2, ctx, assigmentGenerics, declareGenerics || type2.generics];
        } else if (type2.isAliasType) {
          return this.extractFunTypeFromType(type2.inherit.type(), ctx, assigmentGenerics, declareGenerics);
        } else if (type2.isClassGenericType) {
          const inherit = type2.inherit.type();
          if (inherit.isAliasType) {
            if (inherit.target.isDeclaratorTypeAlias && inherit.target.genericity) {
              const declareGenerics2 = inherit.target.genericity.elements;
              if (declareGenerics2 && declareGenerics2.length > 0) {
                const target = inherit.inherit.type();
                if (type2.elements.length === 1) {
                  if (target === declareGenerics2[0].type()) {
                    return this.extractFunTypeFromType(type2.elements[0].type(), ctx, assigmentGenerics, declareGenerics2);
                  }
                }
                return this.extractFunTypeFromType(target, ctx, assigmentGenerics || type2.types, declareGenerics2);
              }
            }
            return this.extractFunTypeFromType(inherit, ctx, assigmentGenerics || type2.types, declareGenerics);
          }
        } else if (type2.isUnionType) {
          for (let el of type2.elements) {
            const res = this.extractFunTypeFromType(el.type(), ctx, assigmentGenerics, declareGenerics);
            if (res) {
              return res;
            }
          }
        } else if (type2.isIntersectionType) {
          return this.extractFunTypeFromType(type2.left.type(), ctx, assigmentGenerics, declareGenerics) || this.extractFunTypeFromType(type2.right.type(), ctx, assigmentGenerics, declareGenerics);
        }
        return null;
      },
      isGlobalShortenType(type2) {
        if (type2 && (type2.isAliasType || type2.isVoidType || type2.isUnknownType || type2.isUndefinedType || type2.isNullableType || type2.isNeverType || type2.isAnyType)) {
          return globalShortenTypeMaps[type2.id] === true;
        }
        return false;
      },
      isGlobalTypeName(name) {
        return globalShortenTypeMaps[name];
      },
      setMergedType(type2) {
        if (type2) {
          type2[mergeTypeKey] = true;
        }
        return type2;
      },
      isMergedType(type2) {
        if (!type2)
          return false;
        if (type2.isTypeofType && type2.origin) {
          return this.isMergedType(type2.origin.type());
        }
        return type2[mergeTypeKey] === true;
      },
      isNullType(type2) {
        if (!type2)
          return false;
        return type2.isNullableType || type2.isUndefinedType || type2.isVoidType;
      },
      inferNotNullType(type2) {
        const infer = (type3) => {
          if (!type3)
            return null;
          if (type3.isTypeofType)
            return infer(type3.origin.type());
          if (type3.isAliasType)
            return infer(type3.inherit.type());
          if (type3.isUnionType) {
            const els = type3.elements.filter((el) => !this.isNullType(el.type()));
            return els.length === 1 ? els[0].type() : null;
          }
        };
        return infer(type2) || type2;
      },
      incrementCharacter(value2) {
        if (typeof value2 === "number") {
          return value2 + 1;
        } else if (typeof value2 === "string") {
          const regexp = /(\d+[\.\d+]?|[a-zA-Z]+)$/;
          if (!regexp.test(value2)) {
            return false;
          }
          return value2.replace(regexp, (value3) => {
            let code = value3.charCodeAt(value3.length - 1);
            if (code >= 48 && code <= 57) {
              return parseFloat(value3) + 1;
            } else {
              let carry = code === 90 || code === 122;
              if (carry) {
                let words = value3.split("");
                let len = words.length - 1;
                words[len] = code === 90 ? "A" : "a";
                while (len > 0) {
                  code = value3.charCodeAt(--len);
                  carry = code === 90 || code === 122;
                  if (carry) {
                    words[len] = code === 90 ? "A" : "a";
                  } else {
                    words[len] = String.fromCharCode(code + 1);
                    break;
                  }
                }
                if (carry) {
                  words.unshift(code === 90 ? "A" : "a");
                }
                return words.join("");
              } else {
                return value3.substring(0, value3.length - 1) + String.fromCharCode(code + 1);
              }
            }
          });
        }
        return false;
      },
      normalizePath(file) {
        if (!file)
          return file;
        if (file.includes("\\")) {
          return path.sep === "\\" ? file.replace(/\\/g, "/") : file;
        }
        return file;
      },
      isEqualModule(left, right) {
        if (!Utils.isModule(left) || !Utils.isModule(right))
          return false;
        left = left.type();
        right = right.type();
        return left === right;
      },
      extractArrayPatternItem(type2, index) {
        if (type2) {
          if (type2.isLiteralArrayType || type2.isTupleType) {
            return type2.attribute(index);
          } else if (type2.isUnionType) {
            const els = type2.elements;
            for (let i = 0; i < els.length; i++) {
              let res = Utils.extractArrayPatternItem(els[i].type(), index);
              if (res) {
                return res;
              }
            }
          } else if (type2.isIntersectionType) {
            return Utils.extractArrayPatternItem(type2.left.type(), index) || Utils.extractArrayPatternItem(type2.right.type(), index);
          }
        }
        return null;
      },
      getStructTableMethodTypeName(method) {
        if (!method)
          return null;
        return structTableMappingTypeName[String(method).toLowerCase()] || null;
      }
    };
    module.exports = Utils;
  }
});

// lib/core/Logger.js
var require_Logger = __commonJS({
  "lib/core/Logger.js"(exports, module) {
    var path = __require("path");
    var fs = __require("fs");
    var memoryUsed = process.memoryUsage().heapUsed;
    var activeLogger = null;
    var defaultUsage = { current: 0, total: 0 };
    var defaultOptions = {
      enable: true,
      outFile: true,
      outDir: ".es-client-log",
      outServiceDir: ".es-service-log",
      threshold: 60,
      service: false,
      time: false,
      limitSize: 1024 * 1024 * 2
    };
    var Logger = class {
      static print(info, group = "") {
        if (activeLogger) {
          activeLogger.print(info, group);
        }
      }
      static mark(key) {
        if (activeLogger) {
          activeLogger.mark(key);
        }
      }
      static getMemoryUsage(key) {
        if (activeLogger) {
          return activeLogger.getMemoryUsage(key);
        }
        return defaultUsage;
      }
      #compiler = null;
      #active = false;
      #memoryRecords = null;
      #outDir = false;
      #limitSize = -1;
      #threshold = 60;
      #lastFile = null;
      #lastTime = null;
      #formatDate = false;
      constructor(compiler) {
        this.#compiler = compiler;
        this.init(compiler);
      }
      init(compiler) {
        let options = compiler.options.logger;
        if (typeof options === "object") {
          if (options) {
            this.#active = options.enable;
          } else {
            options = defaultOptions;
          }
        } else {
          this.#active = !!options;
          options = defaultOptions;
        }
        if (compiler.options.service && !options.service) {
          this.#active = false;
        }
        if (this.#active) {
          if (options.outFile) {
            let dir = compiler.options.service ? options.outServiceDir : options.outDir;
            if (!dir) {
              if (compiler.options.service) {
                dir = defaultOptions.outServiceDir;
              } else {
                dir = defaultOptions.outDir;
              }
            }
            let cwd = compiler.options.cwd || process.cwd();
            if (options.limitSize > 0) {
              this.#limitSize = options.limitSize;
            }
            if (options.threshold >= -1) {
              this.#threshold = options.threshold;
            }
            this.#formatDate = !!options.formatDate;
            if (!dir)
              dir = cwd;
            if (!path.isAbsolute(dir)) {
              dir = path.resolve(cwd, dir);
              if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir);
              }
            }
            if (!fs.statSync(dir).isDirectory()) {
              throw new Error("Logger dir is not exists.");
            } else {
              this.#outDir = this.#compiler.normalizePath(dir);
            }
          }
          this.#memoryRecords = /* @__PURE__ */ new Map();
          activeLogger = this;
        }
      }
      getDate(flag = false) {
        let time = parseFloat(Date.now() / 1e3);
        let key = flag ? time + "-" : time;
        let same = this[key];
        if (same)
          return same;
        const now = /* @__PURE__ */ new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, "0");
        const day = String(now.getDate()).padStart(2, "0");
        if (flag) {
          const hours = String(now.getHours()).padStart(2, "0");
          const min = String(now.getMinutes()).padStart(2, "0");
          const sec = String(now.getSeconds()).padStart(2, "0");
          return this[key] = `${year}-${month}-${day} ${hours}:${min}:${sec}`;
        }
        return this[key] = `${year}-${month}-${day}`;
      }
      getOutFile(fileName) {
        return path.join(this.#outDir || process.cwd(), fileName);
      }
      getFile() {
        const outDir = this.#outDir;
        if (outDir) {
          let last = this.#lastFile;
          let sec = parseFloat(Date.now() / 1e3);
          if (last) {
            let threshold = this.#threshold;
            let lastTime = this.#lastTime;
            if (threshold > 0 && threshold > sec - lastTime) {
              return last;
            }
          }
          let date = this.getDate();
          let file = path.join(outDir, date + ".log");
          let limitSize = this.#limitSize;
          if (limitSize > 0 && fs.existsSync(file)) {
            let index = 0;
            while (index < 500) {
              let size = fs.statSync(file).size;
              if (size >= limitSize) {
                file = path.join(outDir, date + `-${++index}.log`);
                if (!fs.existsSync(file)) {
                  break;
                }
              } else {
                break;
              }
            }
          }
          this.#lastTime = sec;
          this.#lastFile = file;
          return file;
        }
        return null;
      }
      print(info, group = "") {
        if (this.#active) {
          let log = group ? `[${group}] ${info}` : info;
          let file = this.getFile();
          if (file) {
            if (this.#formatDate) {
              let time = this.getDate(true);
              log = `[${time}] ${log} 
`;
            } else {
              log = `[${parseFloat(Date.now() / 1e3).toFixed()}] ${log} 
`;
            }
            this.write(file, log);
          } else {
            console.log(log);
          }
        }
      }
      write(file, log, append = true) {
        try {
          if (append) {
            fs.appendFileSync(file, log, { encoding: "utf-8" });
          } else {
            fs.writeFileSync(file, log, { encoding: "utf-8" });
          }
        } catch (e) {
          try {
            let dir = path.dirname(file);
            if (!fs.existsSync(dir)) {
              fs.mkdirSync(dir);
            }
            if (append) {
              fs.appendFileSync(file, log, { encoding: "utf-8" });
            } else {
              fs.writeFileSync(file, log, { encoding: "utf-8" });
            }
          } catch (e2) {
            console.error(`Logger write failed. file: ${file}
 ${e2.message} 
 ${e2.stack}`);
          }
        }
      }
      mark(key) {
        if (this.#active) {
          this.#memoryRecords.set(key, process.memoryUsage().heapUsed);
        }
      }
      getMemoryUsage(key) {
        if (this.#active) {
          const mark = this.#memoryRecords.get(key);
          if (mark) {
            const current = process.memoryUsage().heapUsed;
            return {
              current: current > mark ? parseFloat((current - mark) / 1024 / 1024).toFixed(2) : 0,
              total: current > memoryUsed ? parseFloat((current - memoryUsed) / 1024 / 1024).toFixed(2) : 0
            };
          }
        }
        return defaultUsage;
      }
      getTotalMemoryUsage() {
        const current = process.memoryUsage().heapUsed;
        return current > memoryUsed ? parseFloat((current - memoryUsed) / 1024 / 1024).toFixed(2) : 0;
      }
    };
    module.exports = Logger;
  }
});

// lib/core/Namespace.js
var require_Namespace = __commonJS({
  "lib/core/Namespace.js"(exports, module) {
    var AutoImporter = require_AutoImporter();
    var Utils = require_Utils();
    var Logger = require_Logger();
    var privateKey = Symbol("key");
    var NamespaceGlobal = class {
      constructor() {
        this.globals = /* @__PURE__ */ new Map();
      }
      getKey(name) {
        return name && name.substring(0, 7) === "global." ? name.substring(7) : name;
      }
      set(name, value2) {
        this.globals.set(this.getKey(name), value2);
      }
      get(name) {
        let key = this.getKey(name);
        let result = this.globals.get(key);
        if (!result)
          return null;
        if (!result.isType && result.isStack) {
          if (result.isDeclaratorVariable) {
            return null;
          }
          result = result.type();
        }
        return result;
      }
      raw(name) {
        return this.globals.get(this.getKey(name));
      }
      has(name) {
        return this.globals.has(this.getKey(name));
      }
      delete(name) {
        this.globals.delete(this.getKey(name));
      }
    };
    var globals = new NamespaceGlobal();
    var Namespace = class {
      static is(value2) {
        return value2 ? value2 instanceof Namespace : false;
      }
      static get globals() {
        return globals;
      }
      static get top() {
        return _top;
      }
      static get dataset() {
        return _top;
      }
      static clearAll() {
        const clear = (ns) => {
          ns.children.forEach(clear);
          ns.modules.clear();
          ns.children.clear();
          ns.descriptors.clear();
        };
        clear(Namespace.dataset);
        globals.globals.clear();
      }
      constructor(id) {
        this.modules = /* @__PURE__ */ new Map();
        this.children = /* @__PURE__ */ new Map();
        this.identifier = id;
        this.id = id;
        this.fullName = id;
        this.parent = null;
        this.isNamespace = true;
        this.stack = null;
        this.chainItems = null;
        this.descriptors = /* @__PURE__ */ new Map();
        this.exports = /* @__PURE__ */ new Map();
        this.imports = /* @__PURE__ */ new Map();
      }
      isTop() {
        return this.parent === null;
      }
      set(name, value2) {
        const flag = this.addDescriptor(name, value2);
        if (!flag && value2) {
          this.modules.set(name, value2);
          if (this.fullName) {
            globals.set(`${this.fullName}.${name}`, value2);
          } else {
            globals.set(`${name}`, value2);
          }
        }
        return flag;
      }
      has(name) {
        return this.modules.has(name);
      }
      del(name) {
        if (this.fullName) {
          globals.delete(`${this.fullName}.${name}`);
        } else {
          globals.delete(`${name}`);
        }
        return this.modules.delete(name);
      }
      get(name) {
        let result = this.modules.get(name);
        if (!result)
          return null;
        if (!result.isType && result.isStack) {
          if (result.isDeclaratorVariable) {
            return null;
          }
          result = result.type();
        }
        return result;
      }
      raw(name) {
        return this.modules.get(name);
      }
      addDescriptor(name, descriptor, flag = false) {
        if (!descriptor || !(flag || descriptor.isDeclaratorFunction || descriptor.isDeclaratorVariable))
          return false;
        let dataset = this.descriptors.get(name);
        if (!dataset) {
          dataset = [];
          this.descriptors.set(name, dataset);
        }
        dataset.push(descriptor);
        return true;
      }
      checkDescriptors(name, descriptor) {
        let dataset = this.descriptors.get(name);
        if (dataset && dataset.length > 1) {
          if (descriptor.isDeclaratorTypeAlias)
            return false;
          return !dataset.some((item2) => {
            if (item2 === descriptor)
              return false;
            if (!item2.isSameSource(descriptor))
              return false;
            if (descriptor.isDeclaratorFunction && item2.isDeclaratorFunction) {
              const oldP = item2.params;
              const newP = descriptor.params;
              if (oldP && newP && oldP.length === newP.length) {
                const oldG = item2.genericity;
                const newG = descriptor.genericity;
                if (Boolean(oldG) !== Boolean(newG))
                  return false;
                if (oldG && newG && oldG.elements.length !== newG.elements.length)
                  return false;
                const oldR = item2.getReturnedType();
                const newR = descriptor.getReturnedType();
                if (Boolean(oldR) !== Boolean(newR))
                  return false;
                if (oldR && newR && !Utils.checkTypeForBoth(oldR.type(), newR.type()))
                  return false;
                return oldP.every((oldT, index) => {
                  const newT = newP[index];
                  if (oldT && newT) {
                    if (oldT.question !== newT.question)
                      return false;
                    if (oldT.isRestElement !== newT.isRestElement)
                      return false;
                    return Utils.checkTypeForBoth(oldT.type(), newT.type());
                  }
                });
              }
            } else if (descriptor.isDeclaratorVariable && item2.isDeclaratorVariable) {
              return Utils.checkTypeForBoth(descriptor.type(), item2.type());
            }
            return false;
          });
        }
        return true;
      }
      sorting(dataset) {
        const priority = (item2) => {
          const type2 = item2.type();
          if (!type2 || type2.isGenericType)
            return 1;
          if (type2.isLiteralType && type2.isLiteralValueType) {
            return 6;
          } else if (type2.isIntersectionType) {
            return 5;
          } else if (type2.isClassGenericType) {
            const wrap = type2.inherit.type();
            if (wrap && wrap.target && wrap.target.isDeclaratorTypeAlias && wrap.target.genericity) {
              return 4;
            }
          } else if (type2.isUnionType) {
            return 2;
          }
          return 3;
        };
        dataset.sort((a, b) => {
          if (!a.isDeclaratorFunction) {
            if (!b.isDeclaratorFunction)
              return 0;
            return 1;
          }
          if (!b.isDeclaratorFunction) {
            if (!a.isDeclaratorFunction)
              return 0;
            return -1;
          }
          if (a.isDeclaratorVariable) {
            if (b.isDeclaratorVariable)
              return 0;
            return -1;
          }
          if (b.isDeclaratorVariable) {
            if (a.isDeclaratorVariable)
              return 0;
            return 1;
          }
          if (a.params.length < b.params.length) {
            return -1;
          } else if (a.params.length > b.params.length) {
            return 1;
          }
          const a1 = a.params.reduce((acc, item2) => {
            if (item2.question)
              acc--;
            return acc + priority(item2);
          }, 0);
          const b1 = b.params.reduce((acc, item2) => {
            if (item2.question)
              acc--;
            return acc + priority(item2);
          }, 0);
          if (a1 === b1)
            return 0;
          return a1 > b1 ? -1 : 1;
        });
        return dataset;
      }
      hasDescriptor(name) {
        return this.descriptors.has(name);
      }
      getDescriptor(name, filter, { isNew, isCall } = {}, result = null) {
        const dataset = this.descriptors.get(name);
        if (dataset) {
          if (!filter) {
            return dataset[0] || result;
          } else {
            if (!dataset[privateKey]) {
              dataset[privateKey] = true;
              this.sorting(dataset);
            }
            for (let i = 0; i < dataset.length; i++) {
              const desc = dataset[i];
              const value2 = filter(desc, result, i, dataset);
              if (value2) {
                if (value2 === true) {
                  return desc;
                } else {
                  result = value2;
                }
              }
            }
          }
        }
        if (isCall) {
          const module2 = this.modules.get(name);
          if (module2 && module2.isModule) {
            if (isNew) {
              result = module2.getDescriptor(`constructor`, filter, { isNew, isCall }, result);
            } else {
              result = module2.getDescriptor(`#${module2.id}`, filter, { isNew, isCall }, result);
            }
          }
        }
        return result;
      }
      clear(compilation) {
        if (!compilation)
          return;
        this.descriptors.forEach((items, key) => {
          items.slice(0).forEach((descriptor) => {
            if (descriptor.compilation === compilation) {
              const index = items.indexOf(descriptor);
              if (index >= 0) {
                let named = descriptor.namespace ? descriptor.namespace.toString() : "";
                Logger.print(`clear-descriptor: ${named ? named + "." + key : key}, file:${compilation.file}`, "namespace");
                items.splice(index, 1);
              }
            }
          });
          if (!items.length) {
            this.descriptors.delete(key);
          }
        });
        this.modules.forEach((module2, key) => {
          if (module2.compilation === compilation) {
            if (Utils.isModule(module2)) {
              Logger.print(`clear-module: ${module2.getName()}, file:${compilation.file}`, "namespace");
            } else if (module2.isDeclaratorTypeAlias || module2.isTypeStatement) {
              Logger.print(`clear-type: ${module2.value()}, file:${compilation.file}`, "namespace");
            }
            this.del(key);
          }
        });
        this.exports.forEach((desc, key) => {
          if (desc.compilation === compilation) {
            Logger.print(`clear-export: ${key}, file:${compilation.file}`, "namespace");
            this.exports.delete(key);
          }
        });
        this.imports.forEach((desc, key) => {
          if (AutoImporter.is(desc)) {
            const origins = desc.origins;
            origins.forEach((desc2) => {
              if (desc2.compilation === compilation) {
                Logger.print(`clear-auto-importer: ${key}, file:${compilation.file}`, "namespace");
                this.imports.delete(key);
              }
            });
          } else if (desc.compilation === compilation) {
            Logger.print(`clear-imports: ${key}, file:${compilation.file}`, "namespace");
            this.imports.delete(key);
          }
        });
      }
      toString() {
        return this.getChain().join(".");
      }
      definition() {
        const kind = "namespace";
        return {
          expre: `${kind} ${this.toString()}`
        };
      }
      hover() {
        const kind = "namespace";
        return {
          expre: `${kind} ${this.toString()}`
        };
      }
      getChain() {
        if (this.chainItems)
          return this.chainItems;
        if (this.parent) {
          return this.chainItems = this.parent.getChain().concat(this.identifier);
        }
        return this.chainItems = [];
      }
      getChildrenKeys() {
        const children = [];
        this.children.forEach((value2, key) => {
          const obj = {};
          obj[key] = value2.getChildrenKeys();
          children.push(obj);
        });
        return children;
      }
      static create(identifier, flag = false) {
        if (!identifier) {
          return Namespace.dataset;
        }
        const items = identifier.split(".");
        let key = null;
        let base = flag ? new Namespace() : Namespace.dataset;
        if (items[0] === "global") {
          items.shift();
        }
        while (key = items.shift()) {
          if (base.children.has(key)) {
            base = base.children.get(key);
          } else {
            const np = new Namespace(key);
            np.parent = base;
            base.children.set(key, np);
            base = np;
          }
        }
        base.fullName = identifier;
        return base;
      }
      static fetch(id, base = null, onlyNs = false, isDescriptor = false) {
        if (!id) {
          return Namespace.dataset;
        }
        const items = (id + "").split(".");
        const name = items.pop();
        let key = null;
        base = base || Namespace.dataset;
        if (items[0] === "global") {
          items.shift();
        }
        while ((key = items.shift()) && base) {
          base = base.children.has(key) ? base.children.get(key) : null;
        }
        if (!base || !(base instanceof Namespace)) {
          return null;
        }
        if (isDescriptor) {
          return base.descriptors.get(name);
        }
        if (onlyNs) {
          return base.children.get(name);
        }
        return base.has(name) ? base.get(name) : base.children.get(name);
      }
    };
    var _top = new Namespace("");
    module.exports = Namespace;
  }
});

// lib/types/Type.js
var require_Type = __commonJS({
  "lib/types/Type.js"(exports, module) {
    var EventDispatcher = require_EventDispatcher();
    var Utils = require_Utils();
    var emptyMap = /* @__PURE__ */ new Map();
    var Type = class extends EventDispatcher {
      [Utils.IS_TYPE] = true;
      static is(value2) {
        return value2 ? value2 instanceof Type : false;
      }
      constructor(id, inherit) {
        super();
        this._id = id;
        this._extends = null;
        this.extends = inherit;
        this.alias = null;
        this.isType = true;
        this.mtime = null;
      }
      set id(name) {
        this._id = name;
      }
      get id() {
        return this._id;
      }
      set extends(_extends) {
        if (_extends) {
          if (_extends instanceof Array) {
            if (_extends.length > 0) {
              this._extends = _extends;
            }
          } else if (_extends) {
            this._extends = [_extends];
          }
        }
      }
      get extends() {
        return this._extends || (this._extends = []);
      }
      get inherit() {
        return this._extends ? this._extends[0] : null;
      }
      isSameSource(type2) {
        if (!type2)
          return false;
        const aCompilation = this.compilation || this.target && this.target.compilation;
        const bCompilation = type2.compilation || type2.target && type2.target.compilation;
        return aCompilation === bCompilation && type2.mtime === this.mtime;
      }
      clone(inference) {
        if (this.isGenericType && inference) {
          return inference(this);
        }
        return this;
      }
      definition(ctx) {
        if (Utils.isStack(this.target)) {
          return this.target.definition(ctx);
        }
        return {
          expre: `type ${this.toString(ctx)}`
        };
      }
      hover(ctx) {
        if (Utils.isStack(this.target)) {
          return this.target.hover(ctx);
        }
        return {
          expre: `type ${this.toString(ctx)}`
        };
      }
      signature() {
        return this.definition();
      }
      check(stack, context, options = {}) {
        return this.is(stack && stack.type(), context, options);
      }
      type(ctx) {
        return this;
      }
      isNeedCheckType(type2) {
        if (type2 === this || type2.isNullableType || type2.isAnyType || type2.isInstanceofType && type2.inherit.type().isAnyType || this.target && type2.target === this.target) {
          return false;
        }
        if (this.isAliasType && this.target && this.target.isDeclaratorTypeAlias && this.target.genericity) {
          if (type2 && type2.isClassGenericType) {
            let assign = type2.inherit.type();
            if (assign.isAliasType && assign.inherit.type() === this.inherit.type()) {
              return false;
            }
          }
        }
        return true;
      }
      getInferResult(context, records) {
        return null;
      }
      inferType(type2, context) {
        if (type2 && Utils.isContext(context)) {
          if (type2.isGenericType) {
            return context.infer(type2) || type2;
          }
        }
        return type2;
      }
      getModuleDeclareGenerics(flag = false, onlyread = false, origin = false) {
        if (this.isAliasType) {
          const inherit = this.inherit.type();
          if (inherit.isAliasType && inherit.target.isDeclaratorTypeAlias && inherit.target.genericity) {
            const declareGenerics = inherit.target.genericity.elements;
            if (origin) {
              return [inherit.target, declareGenerics];
            }
            if (flag) {
              return [inherit.target, declareGenerics.map((item2) => item2.type())];
            }
            if (onlyread) {
              return inherit.target.genericity;
            }
            return declareGenerics.map((item2) => item2.type());
          }
        }
        return [];
      }
      getWrapAssignType(type2) {
        if (type2 && type2.isTypeofType)
          type2 = type2.origin;
        if (!type2 || !(type2.isClassGenericType || type2.isInstanceofType))
          return type2;
        const inherit = type2.inherit.type();
        if (inherit.isAliasType && inherit.target.isDeclaratorTypeAlias && inherit.target.genericity) {
          const declareGenerics = inherit.target.genericity.elements;
          if (declareGenerics && declareGenerics.length > 0) {
            const target = inherit.inherit.type();
            const generics = type2.isInstanceofType ? type2.generics : type2.elements;
            if (generics.length === 1) {
              if (target === declareGenerics[0].type()) {
                return this.getWrapAssignType(generics[0].type());
              }
            }
            const ctx = inherit.target.newContext();
            ctx.append(type2);
            return ctx.apply(target);
          }
        }
        return type2;
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        if (this === type2)
          return true;
        while (type2 && (type2 = type2.inherit)) {
          if (this === type2) {
            return true;
          }
        }
        return false;
      }
      pushToStringChain(context = {}, options = {}) {
        options.chain = options.chain || [];
        if (options.chain.includes(this)) {
          options.onlyTypeName = true;
          options.hasExists = true;
          context = {};
        } else {
          options.chain.push(this);
        }
        return context;
      }
      attributes() {
        return emptyMap;
      }
      attribute() {
        return null;
      }
      dynamicAttribute() {
        return null;
      }
      getTypeKeys() {
        return [];
      }
      toString() {
        return this._id;
      }
    };
    module.exports = Type;
  }
});

// lib/core/Constant.js
var require_Constant = __commonJS({
  "lib/core/Constant.js"(exports, module) {
    var Constant = {};
    Constant.POLICY_NONE = 1;
    Constant.POLICY_SERVER = 2;
    Constant.POLICY_CLIENT = 4;
    Constant.POLICY_ALL = 7;
    Constant.MODULE_YES_WEB_COMPONENT = 1;
    Constant.MODULE_NO_WEB_COMPONENT = 2;
    Constant.MODULE_YES_SKIN_COMPONENT = 4;
    Constant.MODULE_NO_SKIN_COMPONENT = 8;
    module.exports = Constant;
  }
});

// lib/core/Module.js
var require_Module = __commonJS({
  "lib/core/Module.js"(exports, module) {
    var Type = require_Type();
    var Namespace = require_Namespace();
    var Utils = require_Utils();
    var symbolKey = Symbol("key");
    var Constant = require_Constant();
    var Logger = require_Logger();
    var Module = class extends Type {
      [Utils.IS_MODULE] = true;
      static is(value2) {
        return value2 ? value2 instanceof Module : false;
      }
      constructor(compilation) {
        super(null, null);
        this.compilation = compilation;
        this.id = null;
        this.static = false;
        this.abstract = false;
        this.isFinal = false;
        this.isClass = false;
        this.isInterface = false;
        this.isStructTable = false;
        this.isPrivate = false;
        this.isInterfaceDecorator = false;
        this.isEnum = false;
        this.namespace = null;
        this._implements = [];
        this.methods = /* @__PURE__ */ Object.create(null);
        this.members = /* @__PURE__ */ Object.create(null);
        this.annotations = [];
        this.metatypes = [];
        this.making = false;
        this.dependencies = /* @__PURE__ */ new Set();
        this.imports = /* @__PURE__ */ new Map();
        this.importAlias = /* @__PURE__ */ new Map();
        this.isModule = true;
        this.methodConstructor = null;
        this.file = null;
        this.files = [];
        this.used = false;
        this.callable = false;
        this.children = [];
        this.policy = null;
        this.dynamic = false;
        this.dynamicProperties = /* @__PURE__ */ new Map();
        this.isFragment = false;
        this.required = false;
        this.assets = /* @__PURE__ */ new Map();
        this.requires = /* @__PURE__ */ new Map();
        this.isValid = true;
        this.fullname = null;
        this.metadataFlags = 0;
        this.jsxDeclaredSlots = null;
        this.callMethods = [];
        this.callMembers = [];
        this[symbolKey] = {
          stacks: [],
          stack: null
        };
        this.removedNamedDescriptors = /* @__PURE__ */ Object.create(null);
        this.deprecatedNamedDescriptors = /* @__PURE__ */ Object.create(null);
        this.annotationDescriptors = /* @__PURE__ */ Object.create(null);
        this.descriptors = /* @__PURE__ */ new Map();
      }
      setAssignGenerics(module2, assignments) {
        if (!Utils.isModule(module2) || !(assignments && assignments.length > 0))
          return;
        if (module2.inherit) {
          this.setAssignGenerics(module2.inherit.type(), assignments);
        }
        const declareGenerics = module2.getModuleDeclareGenerics();
        if (declareGenerics && declareGenerics.length > 0) {
          let dataset = this[symbolKey].assignGenerics || (this[symbolKey].assignGenerics = /* @__PURE__ */ new Map());
          declareGenerics.forEach((declare, index) => {
            const value2 = assignments[index];
            if (value2) {
              dataset.set(declare.getUniKey(), value2.type());
            }
          });
        }
        module2.implements.forEach((imp) => {
          this.setAssignGenerics(imp.type(), assignments);
        });
      }
      getAssignGenerics(declared) {
        let dataset = this[symbolKey].assignGenerics;
        if (dataset) {
          let key = declared.getUniKey();
          if (dataset.has(key)) {
            return dataset.get(key);
          }
        }
        let inherit = this.inherit;
        if (inherit && Module.is(inherit)) {
          let res = inherit.type().getAssignGenerics(declared);
          if (res)
            return res;
        }
        let impls = this.implements;
        for (let item2 of impls) {
          let res = item2.type().getAssignGenerics(declared);
          if (res)
            return res;
        }
        return null;
      }
      getAllAssignGenerics() {
        let records = /* @__PURE__ */ new Map();
        let fetch = (module2) => {
          let dataset = module2[symbolKey].assignGenerics;
          if (dataset) {
            dataset.forEach((value2, key) => {
              records.set(key, value2);
            });
          }
          let inherit = module2.inherit;
          if (inherit && Module.is(inherit)) {
            fetch(inherit.type());
          }
          let impls = module2.implements;
          for (let item2 of impls) {
            fetch(item2.type());
          }
          return records;
        };
        return fetch(this);
      }
      get moduleStack() {
        return this[symbolKey].stack || null;
      }
      set moduleStack(value2) {
        if (value2 && value2.isStack) {
          this[symbolKey].stacks.push(value2);
          this[symbolKey].stack = value2;
        }
      }
      addStack(value2, isDefault = false) {
        if (value2 && value2.isStack) {
          this[symbolKey].stacks.push(value2);
          if (isDefault || !this[symbolKey].stack) {
            this[symbolKey].stack = value2;
          }
        }
      }
      getStacks(flag = false) {
        if (flag)
          return this[symbolKey].stacks;
        return this[symbolKey].stacks.filter((stack) => !stack.compilation.isDestroyed);
      }
      getInheritContextStack(compilation) {
        let stacks = this.getStacks();
        if (stacks.length === 1) {
          return stacks[0];
        }
        stacks = stacks.slice(0).sort((a, b) => {
          let a1 = a.isDestroyed ? 9 : 0;
          let b1 = b.isDestroyed ? 9 : 0;
          if (!a.isDestroyed) {
            if (a.compilation === compilation) {
              a1 = -1;
            } else if (a.compilation.isDescriptorDocument()) {
              a1 = 1;
            }
          }
          if (!b.isDestroyed) {
            if (b.compilation === compilation) {
              b1 = -1;
            } else if (a.compilation.isDescriptorDocument()) {
              b1 = 1;
            }
          }
          return a1 - b1;
        });
        return stacks[0] || null;
      }
      isDecorator() {
        if (this.isInterfaceDecorator)
          return true;
        if (this.implements.some((item2) => {
          if (item2.isDecorator())
            return true;
          return item2.extends.some((extend) => extend.isDecorator());
        })) {
          return true;
        }
        return this.extends.some((extend) => extend.isDecorator());
      }
      isWebComponent() {
        if (!this.isClass)
          return false;
        if (this.metadataFlags > 0) {
          if ((Constant.MODULE_YES_WEB_COMPONENT & this.metadataFlags) === Constant.MODULE_YES_WEB_COMPONENT) {
            return true;
          } else if ((Constant.MODULE_NO_WEB_COMPONENT & this.metadataFlags) === Constant.MODULE_NO_WEB_COMPONENT) {
            return false;
          }
        }
        let result = false;
        const stacks = this.getStacks();
        for (let i = 0; i < stacks.length; i++) {
          const stack = stacks[i];
          if (stack.findAnnotation((annotation) => annotation.getLowerCaseName() === "webcomponent")) {
            result = true;
            break;
          }
        }
        this.metadataFlags |= result ? Constant.MODULE_YES_WEB_COMPONENT : Constant.MODULE_NO_WEB_COMPONENT;
        return result;
      }
      isSkinComponent() {
        if (!this.isClass)
          return false;
        if (this.metadataFlags > 0) {
          if ((Constant.MODULE_YES_SKIN_COMPONENT & this.metadataFlags) === Constant.MODULE_YES_SKIN_COMPONENT) {
            return true;
          } else if ((Constant.MODULE_NO_SKIN_COMPONENT & this.metadataFlags) === Constant.MODULE_NO_SKIN_COMPONENT) {
            return false;
          }
        }
        let result = false;
        const stacks = this.getStacks();
        for (let i = 0; i < stacks.length; i++) {
          const stack = stacks[i];
          if (stack.findAnnotation((annotation) => annotation.getLowerCaseName() === "skinclass")) {
            result = true;
            break;
          }
        }
        this.metadataFlags |= result ? Constant.MODULE_YES_SKIN_COMPONENT : Constant.MODULE_NO_SKIN_COMPONENT;
        return result;
      }
      getAnnotations(filter, inheritFlag = true) {
        const stacks = this.getStacks();
        for (let i = 0; i < stacks.length; i++) {
          const stack = stacks[i];
          const result = stack.findAnnotation(filter, inheritFlag);
          if (result) {
            return result;
          }
        }
        return null;
      }
      getImportDeclarations() {
        return this.getStacks().map((stack) => stack._imports || []).flat();
      }
      get implements() {
        return this._implements;
      }
      set implements(value2) {
        if (Array.isArray(value2)) {
          this._implements = value2;
        }
      }
      addImplement(value2) {
        if (!this._implements.includes(value2)) {
          this._implements.push(value2);
        }
      }
      isRemoved(name, descriptor) {
        if (!descriptor)
          return false;
        if (descriptor && descriptor.isStack && descriptor.isRemoved) {
          return true;
        }
        if (this.removedNamedDescriptors[name]) {
          return this.removedNamedDescriptors[name].some((item2) => {
            return !!descriptor.static === !!item2.static;
          });
        }
        if (this.extends.some((item2) => item2.isRemoved(name, descriptor))) {
          return true;
        }
        if (this.implements.some((item2) => item2.isRemoved(name, descriptor))) {
          return true;
        }
        if (this.getUsingExtendsModules().some((item2) => item2.isRemoved(name, descriptor))) {
          return true;
        }
        return false;
      }
      isDeprecated(name, descriptor) {
        if (!descriptor)
          return false;
        if (descriptor && descriptor.isStack && descriptor.isDeprecated) {
          return true;
        }
        if (this.deprecatedNamedDescriptors[name]) {
          return this.deprecatedNamedDescriptors[name].some((item2) => {
            return !!descriptor.static === !!item2.static;
          });
        }
        if (this.extends.some((item2) => item2.isDeprecated(name, descriptor))) {
          return true;
        }
        if (this.implements.some((item2) => item2.isDeprecated(name, descriptor))) {
          return true;
        }
        if (this.getUsingExtendsModules().some((item2) => item2.isDeprecated(name, descriptor))) {
          return true;
        }
        return false;
      }
      getUsingExtendsModules() {
        const result = [];
        const fetch = (usingExtends) => {
          if (usingExtends && usingExtends.length > 0) {
            for (let i = 0; i < usingExtends.length; i++) {
              const ctx = usingExtends[i];
              for (let b = 0; b < ctx.extends.length; b++) {
                const ext = ctx.extends[b];
                if (ext.module && ext.module !== this && !result.includes(ext.module)) {
                  if (!this.extends.includes(ext.module) && !this.implements.includes(ext.module)) {
                    result.push(ext.module);
                  }
                }
              }
            }
          }
        };
        fetch(this.callMethods);
        fetch(this.callMembers);
        return result;
      }
      addDescriptor(name, descriptor) {
        let dataset = this.descriptors.get(name);
        if (!dataset) {
          dataset = [];
          this.descriptors.set(name, dataset);
        }
        dataset.push(descriptor);
        return true;
      }
      compareDescriptor(left, right) {
        if (!left || !right)
          return false;
        const token = right.toString();
        if (left.isPropertyDefinition) {
          if (token === "PropertyDefinition") {
            const oldT = left.type();
            const newT = right.type();
            if (oldT && newT) {
              return Utils.checkTypeForBoth(oldT.type(), newT.type());
            }
          }
        } else if (left.isMethodGetterDefinition) {
          if (token === "MethodGetterDefinition") {
            const oldT = left.getReturnedType();
            const newT = right.getReturnedType();
            if (oldT && newT) {
              return Utils.checkTypeForBoth(oldT.type(), newT.type());
            }
          }
        } else if (left.isMethodSetterDefinition) {
          if (token === "MethodSetterDefinition") {
            const oldP = left.params[0];
            const newP = right.params[0];
            if (oldP && newP) {
              const oldG = left.genericity;
              const newG = right.genericity;
              if (Boolean(oldG) !== Boolean(newG))
                return false;
              if (oldG && newG && oldG.elements.length !== newG.elements.length)
                return false;
              return Utils.checkTypeForBoth(oldP.type(), newP.type());
            }
          }
        } else if (left.isMethodDefinition) {
          if (right.isMethodDefinition) {
            const oldP = left.params;
            const newP = right.params;
            if (oldP && newP && oldP.length === newP.length) {
              const oldG = left.genericity;
              const newG = right.genericity;
              if (Boolean(oldG) !== Boolean(newG))
                return false;
              if (oldG && newG && oldG.elements.length !== newG.elements.length)
                return false;
              const oldR = left.getReturnedType();
              const newR = right.getReturnedType();
              if (Boolean(oldR) !== Boolean(newR))
                return false;
              if (oldR && newR && !Utils.checkTypeForBoth(oldR.type(), newR.type()))
                return false;
              return oldP.every((oldT, index) => {
                const newT = newP[index];
                if (oldT && newT) {
                  if (oldT.question !== newT.question)
                    return false;
                  if (oldT.isRestElement !== newT.isRestElement)
                    return false;
                  return Utils.checkTypeForBoth(oldT.type(), newT.type());
                }
              });
            }
          }
        }
        return false;
      }
      checkDescriptors(descriptors) {
        if (descriptors && descriptors.length > 1) {
          const sameitems = [];
          const push = (desc, result2) => {
            if (result2) {
              sameitems.push(...desc);
            }
            return result2;
          };
          const result = descriptors.every((descriptor) => {
            const has = descriptors.some((item2) => {
              if (item2 === descriptor)
                return false;
              if (!!descriptor.static != !!item2.static)
                return false;
              if (!item2.isSameSource(descriptor))
                return false;
              return push([descriptor, item2], this.compareDescriptor(item2, descriptor));
            });
            return !has;
          });
          return [result, sameitems];
        }
        return [true, []];
      }
      ckeckAllDescriptors() {
        this.descriptors.forEach((list, name) => {
          list.forEach((item2) => {
            if (item2.isRemoved) {
              const removed = this.removedNamedDescriptors[name] || (this.removedNamedDescriptors[name] = []);
              removed.push(item2);
            }
            if (item2.isDeprecated) {
              const deprecated = this.deprecatedNamedDescriptors[name] || (this.deprecatedNamedDescriptors[name] = []);
              deprecated.push(item2);
            }
          });
          const [result, sameitems] = this.checkDescriptors(list);
          if (!result) {
            sameitems.forEach((desc) => {
              desc.error(1045, name);
            });
          }
        });
      }
      isCallable() {
        if (this.callable)
          return true;
        return !!this.getDescriptor(`#${this.id}`);
      }
      getDescriptor(name, filter, ctx = {}, defaultResult = null) {
        var isBreak = false;
        var cache = null;
        let isPound = name === "#" + this.id;
        const findExtends = (name2, usingExtends, result2 = null) => {
          if (isBreak)
            return result2;
          if (usingExtends && usingExtends.length > 0) {
            cache = cache || /* @__PURE__ */ new WeakSet();
            for (let i = 0; i < usingExtends.length; i++) {
              const ctx2 = usingExtends[i];
              for (let b = 0; b < ctx2.extends.length; b++) {
                const ext = ctx2.extends[b];
                const classModule = ext.module;
                if (!cache.has(classModule) && Utils.isModule(classModule)) {
                  cache.add(classModule);
                  result2 = findAll(name2, classModule, result2, ctx2);
                  if (isBreak) {
                    return result2;
                  }
                }
              }
            }
          }
          return result2;
        };
        const findAll = (name2, module2, result2 = null, extendsContext = null, isSelf = false) => {
          module2 = module2.type();
          if (name2 === "*") {
            const keys = Array.from(module2.descriptors.keys());
            for (let index = 0; index < keys.length; index++) {
              result2 = findAll(keys[index], module2, result2, extendsContext, isSelf);
              if (result2 && !filter)
                return result2;
              if (isBreak)
                return result2;
            }
            return result2;
          }
          const dataset = module2.descriptors.get(name2);
          if (dataset) {
            if (!filter) {
              return dataset[0] || result2;
            } else {
              if (!dataset[symbolKey]) {
                dataset[symbolKey] = true;
                const priority = (item2) => {
                  const type2 = item2.type();
                  if (!type2 || type2.isGenericType)
                    return 1;
                  if (type2.isLiteralType && type2.isLiteralValueType) {
                    return 6;
                  } else if (type2.isIntersectionType) {
                    return 5;
                  } else if (type2.isClassGenericType) {
                    const wrap = type2.inherit.type();
                    if (wrap && wrap.target && wrap.target.isDeclaratorTypeAlias && wrap.target.genericity) {
                      return 4;
                    }
                  } else if (type2.isUnionType) {
                    return 2;
                  }
                  return 3;
                };
                dataset.sort((a, b) => {
                  if (!a.isMethodDefinition) {
                    if (!b.isMethodDefinition)
                      return 0;
                    return 1;
                  }
                  if (!b.isMethodDefinition) {
                    if (!a.isMethodDefinition)
                      return 0;
                    return -1;
                  }
                  if (a.params.length < b.params.length) {
                    return -1;
                  } else if (a.params.length > b.params.length) {
                    return 1;
                  }
                  const a1 = a.params.reduce((acc, item2) => {
                    if (item2.question)
                      acc--;
                    return acc + priority(item2);
                  }, 0);
                  const b1 = b.params.reduce((acc, item2) => {
                    if (item2.question)
                      acc--;
                    return acc + priority(item2);
                  }, 0);
                  if (a1 === b1)
                    return 0;
                  return a1 > b1 ? -1 : 1;
                });
              }
              for (let i = 0; i < dataset.length; i++) {
                const desc = dataset[i];
                if (!isSelf && Utils.isModifierPrivate(desc)) {
                  continue;
                }
                const value2 = filter(desc, result2, i, dataset, extendsContext);
                if (value2) {
                  if (value2 === true) {
                    isBreak = true;
                    return desc;
                  } else {
                    result2 = value2;
                  }
                }
              }
            }
            if ("constructor" === name2) {
              return result2;
            }
          }
          const items = module2.extends.concat(module2.implements);
          for (let i = 0; i < items.length; i++) {
            const mod = items[i];
            if (Utils.isModule(mod)) {
              result2 = findAll(isPound ? `#${mod.id}` : name2, mod, result2, extendsContext);
              if (isBreak) {
                return result2;
              }
            }
          }
          if ("constructor" !== name2) {
            result2 = findExtends(name2, module2.callMethods, result2);
            if (!isBreak) {
              result2 = findExtends(name2, module2.callMembers, result2);
            }
          }
          return result2;
        };
        let result = findAll(name, this, defaultResult, null, true);
        if (result || "constructor" === name) {
          return result;
        }
        result = findExtends(name, this.callMethods, result);
        if (!isBreak) {
          result = findExtends(name, this.callMembers, result);
        }
        if (result) {
          return result;
        }
        const base = Namespace.globals.get("Object");
        return base && base !== this ? findAll(name, base) : null;
      }
      get isDeclaratorModule() {
        const value2 = this[symbolKey].isDeclaratorModule;
        if (value2 != null)
          return value2;
        const stacks = this.getStacks();
        if (stacks.length > 0) {
          return this[symbolKey].isDeclaratorModule = stacks.every((stack) => {
            return stack.isDeclaratorDeclaration;
          });
        } else if (this.compilation) {
          return this.compilation.isDescriptorDocument();
        }
        return false;
      }
      get isLocalModule() {
        const value2 = this[symbolKey].isLocalModule;
        if (value2 != null)
          return value2;
        const stacks = this.getStacks();
        if (stacks.length > 0) {
          return this[symbolKey].isLocalModule = stacks.some((stack) => {
            return stack.compilation.isLocalDocument();
          });
        } else if (this.compilation) {
          return this.compilation.isLocalDocument();
        }
        return false;
      }
      get comments() {
        const comments = this[symbolKey].comments;
        if (comments)
          return comments;
        return this[symbolKey].comments = this[symbolKey].stacks.map((stack) => stack.comments).flat();
      }
      isEntityModule() {
        if (this.isDeclaratorModule) {
          return this.getImportDeclarations().some((item2) => {
            if (item2.isImportDeclaration && item2.source.isLiteral) {
              return item2.specifiers.some((spec) => spec.value() === module.id);
            }
            return false;
          });
        }
        return true;
      }
      clear(compilation) {
        const isSelf = !compilation || this.getStacks(true).some((stack) => stack.compilation === compilation);
        if (!compilation)
          compilation = this.compilation;
        if (isSelf) {
          Logger.print(`clear: ${this.getName()}, file:${compilation ? compilation.file : this.file}`, "module");
          this.imports = /* @__PURE__ */ new Map();
          this.importAlias = /* @__PURE__ */ new Map();
          this._implements.length = 0;
          this._extends = null;
          this.methodConstructor = null;
          this.dynamic = null;
          this.isFragment = false;
          this.isValid = false;
          this.jsxDeclaredSlots = null;
          this.making = false;
          this.dependencies = /* @__PURE__ */ new Set();
          this.metadataFlags = 0;
          this[symbolKey].comments = void 0;
          this[symbolKey].isLocalModule = void 0;
          this[symbolKey].isDeclaratorModule = void 0;
        }
        this.dynamicProperties.forEach((desc, key) => {
          if (desc.compilation === compilation) {
            this.dynamicProperties.delete(key);
          }
        });
        this.assets.forEach((desc, key) => {
          if (desc.stack && desc.stack.compilation === compilation) {
            this.assets.delete(key);
          }
        });
        this.requires.forEach((desc, key) => {
          if (desc.stack && desc.stack.compilation === compilation) {
            this.requires.delete(key);
          }
        });
        const clearMember = (key, target) => {
          const dataset = target[key];
          if (!dataset)
            return;
          if (dataset.isAccessor) {
            if (dataset.get && dataset.get.compilation === compilation) {
              delete dataset.get;
            }
            if (dataset.set && dataset.set.compilation === compilation) {
              delete dataset.set;
            }
            if (!(dataset.set || dataset.get)) {
              delete target[key];
            }
          } else if (dataset.compilation === compilation) {
            delete target[key];
          }
        };
        const clearList = (list, callback) => {
          if (!Array.isArray(list))
            return;
          for (let i = 0; i < list.length; ) {
            const desc = list[i];
            if (desc.compilation === compilation) {
              list.splice(i, 1);
              if (list.length === 0) {
                if (callback)
                  callback(desc);
              }
            } else {
              i++;
            }
          }
        };
        this.descriptors.forEach((items, key) => {
          clearList(items, (desc) => {
            clearMember(key, desc.static ? this.methods : this.members);
          });
        });
        clearList(this.metatypes);
        clearList(this.annotations);
        const clearExtend = (extendMethods) => {
          const len = extendMethods.length;
          for (let index = 0; index < len; index++) {
            const item2 = extendMethods[index];
            const methods = item2.methods;
            const dynamic = item2.dynamic;
            if (methods) {
              Object.keys(methods).forEach((key) => {
                clearMember(key, methods);
              });
            }
            clearList(dynamic);
          }
        };
        clearExtend(this.callMethods);
        clearExtend(this.callMembers);
        const clearCache = (target) => {
          if (!target)
            return;
          Object.keys(target).forEach((key) => {
            clearList(target[key]);
          });
        };
        clearCache(this.removedNamedDescriptors);
        clearCache(this.deprecatedNamedDescriptors);
        clearCache(this.annotationDescriptors);
        const stacks = this[symbolKey].stacks;
        if (stacks) {
          if (this.required) {
            if (stacks.some((stack) => stack.isAnnotationDeclaration && stack.compilation === compilation)) {
              this.required = false;
            }
          }
          clearList(stacks);
        }
      }
      addAsset(resolve, file, content, type2, assign, attrs = null, stack = null) {
        let key = resolve;
        const old = this.assets.get(key);
        const cacheId = this.compilation.cacheId;
        if (!old) {
          const obj = {
            file,
            resolve,
            content,
            type: type2,
            assign,
            id: this.getName(),
            index: this.assets.size,
            attrs,
            cacheId,
            stack
          };
          this.assets.set(key, obj);
          return obj;
        } else if (old.cacheId !== cacheId) {
          old.cacheId = cacheId;
          return old;
        }
        return false;
      }
      addRequire(key, name, from, resolve, extract, stack = null, isAutoImporter = false) {
        let cacheKey = name + ":" + resolve;
        let old = this.requires.get(cacheKey);
        const cacheId = this.compilation.cacheId;
        if (!old) {
          const obj = {
            key,
            name,
            from,
            resolve,
            extract,
            stack,
            isAutoImporter,
            namespaced: key === "*",
            id: this.getName(),
            cacheId,
            index: this.requires.size
          };
          this.requires.set(cacheKey, obj);
          return obj;
        } else if (old.cacheId !== cacheId) {
          old.cacheId = cacheId;
          return old;
        }
        return false;
      }
      getModuleKind() {
        return this.isInterface ? "interface" : this.isEnum ? "enum" : this.isStructTable ? "struct" : "class";
      }
      definition(context) {
        return this.getStacks().map((stack) => stack.definition(context));
      }
      hover(context) {
        let stacks = this.getStacks();
        if (stacks.length > 0) {
          let stack = stacks[0];
          let def = stack.hover(context);
          let items = stacks.slice(1).map((stack2) => stack2.hover(context));
          return stack.formatHover(def, items);
        }
        let kind = this.getModuleKind();
        return {
          text: `${kind} ${this.getName()}`
        };
      }
      getName(segment = ".") {
        if (segment === ".") {
          return this.getFullName();
        }
        let name = this.id;
        if (this.namespace) {
          name = this.namespace.getChain().concat(this.id).join(segment);
        }
        return name;
      }
      getFullName() {
        let fullname = this.fullname;
        if (fullname) {
          return fullname;
        }
        let name = this.id;
        if (this.namespace) {
          name = this.namespace.getChain().concat(name).join(".");
        }
        return this.fullname = name;
      }
      getInheritModule() {
        const inherit = this.inherit;
        if (inherit) {
          return inherit.type();
        }
        return null;
      }
      type() {
        if (!this.isValid) {
          return this.namespace.get(this.id) || this;
        }
        return this;
      }
      is(type2, context) {
        if (!this.isValid) {
          const newType = this.type();
          if (newType !== this) {
            return newType.is(type2, context);
          }
        }
        if (!Utils.isType(type2))
          return false;
        if (this.id === "VNode" && Module.is(type2) && type2.id === "VNode") {
          return true;
        }
        type2 = this.inferType(type2, context);
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context));
        }
        if (!this.isNeedCheckType(type2))
          return true;
        if (this.id === "Interface" && (!this.namespace || this.namespace.identifier === "") && Utils.isInterface(type2)) {
          return true;
        }
        if (type2.isEnumType) {
          return type2.owner === this || type2.inherit === this || type2.inherit.is(this, context);
        }
        if (this.isEnum && type2.isLiteralType) {
          const members = this.methods;
          for (let key in members) {
            const item2 = members[key];
            if (item2 && item2.isEnumProperty && item2.init && item2.init.value() === type2.value) {
              return true;
            }
          }
          let inherit = this.getInheritModule();
          if (inherit) {
            inherit = inherit.type();
          }
          return inherit && inherit.isEnum ? inherit.is(type2, context) : false;
        }
        if (type2.isIntersectionType) {
          return this.is(type2.left.type(), context) ? true : this.is(type2.right.type(), context);
        }
        const nullType = Namespace.globals.get("nullable");
        const objectType = Namespace.globals.get("Object");
        const classType = Namespace.globals.get("Class");
        if (this === objectType && !Utils.isScalar(type2)) {
          return true;
        }
        if (this === classType) {
          if (type2.isClassGenericType && type2.extends[0]) {
            type2 = type2.extends[0].type();
          }
          return type2 === this || !!(type2 instanceof Module && type2.isClass);
        }
        if ((this.isInterface || this.isStructTable) && type2.isLiteralObjectType) {
          const dynamic = this.dynamicProperties;
          if (dynamic && dynamic.size > 0) {
            return dynamic.has(Namespace.globals.get("string"));
          }
          const properties = Object.keys(this.members);
          const errorHandler = context && context.errorHandler || ((result2) => result2);
          const result = properties.every((propName) => {
            const attr = type2.attribute(propName);
            let property = this.members[propName];
            if (property.isAccessor) {
              if (property.set && property.set.isMethodSetterDefinition) {
                if (!attr)
                  return !!property.set.question;
                const param = property.set.params[0];
                if (param) {
                  const acceptType = param.type();
                  if (!errorHandler(acceptType.check(attr, context), acceptType, attr.key, attr.type())) {
                    return false;
                  }
                }
              }
              if (property.get && property.get.isMethodGetterDefinition) {
                if (!attr)
                  return !!property.get.question;
                const acceptType = property.get.type();
                if (!errorHandler(acceptType.check(attr, context), acceptType, attr.key, attr.type())) {
                  return false;
                }
              }
              return true;
            }
            if (attr) {
              const acceptType = property.type();
              return errorHandler(acceptType.check(attr, context), acceptType, attr.key, attr.type());
            }
            return !!property.question;
          });
          if (!result)
            return false;
          if (this.extends.length > 0 && !this.extends.every((item2) => {
            const mType = item2.type();
            return mType !== this && mType.is(type2);
          })) {
            return false;
          }
          if (this.implements.length > 0 && !this.implements.every((item2) => item2.type().is(type2))) {
            return false;
          }
          return true;
        }
        type2 = Utils.getOriginType(type2);
        if (type2 === nullType || type2 === this) {
          return true;
        }
        if (!Module.is(type2)) {
          return false;
        }
        if (this.isInterface && type2.id === "Array") {
          const result = this.getDescriptor("length", (desc) => !!desc.isPropertyDefinition);
          if (result && result.isPropertyDefinition) {
            return true;
          }
        }
        if (this[symbolKey]._processing === type2) {
          return this.toString() === type2.toString();
        }
        this[symbolKey]._processing = type2;
        const check = (left, right, notCheckProperty = false) => {
          if (!right || !left)
            return false;
          left = left.type();
          right = right.type();
          if (left === right) {
            return true;
          }
          if (right.extends.some((right2) => check(left, right2))) {
            return true;
          }
          if (right.implements && right.implements.length > 0) {
            if (right.implements.some((right2) => check(left, right2))) {
              return true;
            }
          }
          if (!notCheckProperty && !this[symbolKey].checkImpls && left.isInterface && right.members) {
            const properties = Object.keys(left.members);
            const errorHandler = context && context.errorHandler || ((result2) => result2);
            const _check = (leftMember, rightMember) => {
              if (rightMember) {
                const acceptType = leftMember.type();
                return errorHandler(acceptType.check(rightMember, context), acceptType, rightMember.key, rightMember.type());
              }
              return !!leftMember.question;
            };
            const result = properties.every((propName) => {
              let rightMember = right.members[propName];
              let leftMember = left.members[propName];
              if (leftMember.isAccessor || rightMember && rightMember.isAccessor) {
                if (rightMember) {
                  if (rightMember.isAccessor && !leftMember.isAccessor)
                    return false;
                  if (!rightMember.isAccessor)
                    return false;
                  if (leftMember.get && !_check(leftMember.get, rightMember.get)) {
                    return false;
                  }
                  if (leftMember.set && !_check(leftMember.set, rightMember.set)) {
                    return false;
                  }
                  return true;
                } else {
                  return [leftMember.get, leftMember.set].every((item2) => item2 ? _check(item2) : true);
                }
              }
              return _check(leftMember, rightMember);
            });
            if (left.dynamicProperties && left.dynamicProperties.size > 0) {
              if (!(right.dynamicProperties && right.dynamicProperties.size > 0))
                return false;
              const keys = left.dynamicProperties.keys();
              for (let key of keys) {
                if (!right.dynamicProperties.has(key.type())) {
                  return false;
                }
              }
            }
            if (result)
              return true;
          }
          return false;
        };
        let _res = check(this, type2);
        this[symbolKey]._processing = null;
        return _res;
      }
      isof(type2, context) {
        this[symbolKey].checkImpls = true;
        let result = this.is(type2, context);
        this[symbolKey].checkImpls = false;
        return result;
      }
      publish() {
        const alias = this.metatypes.find((item2) => item2.name === "Alias");
        if (alias) {
          const metatype = {};
          alias.params.forEach((item2) => {
            const name = item2.value ? item2.name : "name";
            const value2 = item2.value ? item2.value : item2.name;
            metatype[name] = value2;
          });
          this.alias = metatype.name;
          this.namespace.set(metatype.name, this);
          if (Boolean(metatype.origin) !== false) {
            this.namespace.set(this.id, this);
          }
        } else {
          this.namespace.set(this.id, this);
        }
      }
      getUseExtendMethod(name, kind, isStatic) {
        const extendMethods = isStatic ? this.callMethods : this.callMembers;
        const len = extendMethods.length;
        for (let index = 0; index < len; index++) {
          const item2 = extendMethods[index];
          const methods = item2.methods;
          const dynamic = item2.dynamic;
          let result = null;
          if (methods && Object.prototype.hasOwnProperty.call(methods, name)) {
            let desc = methods[name];
            if (desc.isAccessor) {
              desc = kind == "set" ? desc.set : desc.get;
            }
            if (desc) {
              if (!isStatic && !desc.static) {
                return desc;
              } else if (isStatic) {
                return desc;
              }
            }
          }
          const _extends = item2.extends;
          const _len = _extends.length;
          for (let i = 0; i < _len; i++) {
            const target = _extends[i];
            const classModule = target && target.module ? target.module.type() : null;
            if (classModule && Utils.isModule(classModule)) {
              result = target.mode === "class" ? classModule.getMethod(name, kind) : classModule.getMember(name, kind);
              if (result) {
                if (target.modifier.length > 0) {
                  if (target.modifier.includes(Utils.getModifierValue(result))) {
                    return result;
                  }
                } else {
                  return result;
                }
              }
            }
          }
          if (dynamic && dynamic.length > 0) {
            const stringType = Namespace.globals.get("String");
            result = stringType ? dynamic.find((method) => {
              if (method.isMethodDefinition && method.dynamicType) {
                const acceptType = method.dynamicType;
                return acceptType && stringType.is(acceptType.type());
              }
              return false;
            }) : false;
            if (result) {
              return result;
            }
          }
        }
        const imps = this.extends.concat(this.implements);
        const total = imps.length;
        for (let i = 0; i < total; i++) {
          let module2 = imps[i];
          module2 = module2.type();
          if (module2 && module2 !== this && Utils.isModule(module2) && !(this.namespace === module2.namespace && this.id === module2.id)) {
            if (!module2.extends.includes(this)) {
              const result = module2.getUseExtendMethod(name, kind, isStatic);
              if (result) {
                return result;
              }
            }
          }
        }
        return null;
      }
      getAnnotationCallMethodAllConfig(isMember = true) {
        const data = isMember ? this.callMembers.slice(0) : this.callMethods.slice(0);
        const imps = this.extends.concat(this.implements);
        const total = imps.length;
        for (let i = 0; i < total; i++) {
          let module2 = imps[i];
          module2 = module2.type();
          if (module2 && module2 !== this && Utils.isModule(module2) && !(this.namespace === module2.namespace && this.id === module2.id)) {
            if (!module2.extends.includes(this)) {
              data.push(...module2.getAnnotationCallMethodAllConfig(isMember));
            }
          }
        }
        return data;
      }
      getAnnotationCallMethods(isMember = true) {
        const configs = this.getAnnotationCallMethodAllConfig(isMember);
        const len = configs.length;
        const properties = /* @__PURE__ */ new Set();
        const excludes = isMember ? this.getMemberKeys() : Object.keys(this.methods);
        const merge = (classModule, mode, modifier, methods) => {
          if (!classModule || classModule === this)
            return;
          const dataset = mode === "class" ? classModule.methods : classModule.members;
          for (let name in dataset) {
            if (excludes.includes(name))
              continue;
            if (methods && Object.prototype.hasOwnProperty.call(methods, name))
              continue;
            let desc = dataset[name];
            if (desc.isAccessor) {
              if (desc.get)
                properties.add(desc.get);
              if (desc.set)
                properties.add(desc.set);
            } else {
              properties.add(desc);
            }
          }
          classModule.extends.concat(classModule.implements).forEach((item2) => merge(item2.type(), mode, modifier));
        };
        for (let index = 0; index < len; index++) {
          const item2 = configs[index];
          const methods = item2.methods;
          for (let name in methods) {
            let desc = methods[name];
            if (desc.isAccessor) {
              if (desc.get)
                properties.add(desc.get);
              if (desc.set)
                properties.add(desc.set);
            } else {
              properties.add(desc);
            }
          }
          item2.extends.forEach((specifier) => {
            const module2 = specifier.module;
            const mode = specifier.mode;
            const modifier = specifier.modifier;
            if (module2) {
              merge(module2.type(), mode, modifier, methods);
            }
          });
        }
        return Array.from(properties);
      }
      getMethod(name, kind = null) {
        const target = Object.prototype.hasOwnProperty.call(this.methods, name) ? this.methods[name] : null;
        if (target && target.isAccessor) {
          return kind == "set" ? target.set : target.get;
        }
        if (!target) {
          return this.getUseExtendMethod(name, kind, true);
        }
        return target;
      }
      hasMember(name) {
        const members = this.members;
        if (Object.prototype.hasOwnProperty.call(members, name)) {
          return true;
        }
        for (var i = 0; i < this.extends.length; i++) {
          const inherit = this.extends[i].type();
          if (inherit !== this && Utils.isModule(inherit) && !inherit.extends.includes(this)) {
            const result2 = inherit.hasMember(name);
            if (result2) {
              return true;
            }
          }
        }
        const result = this.hasInterfaceMember(name);
        if (result) {
          return true;
        }
        const base = Namespace.globals.get("Object");
        if (base && base !== this) {
          const result2 = base.hasMember(name);
          if (result2) {
            return true;
          }
        }
        return false;
      }
      getMember(name, kind = null, excludeInterface = false, useExtendFlag = true) {
        const members = this.members;
        if (Object.prototype.hasOwnProperty.call(members, name)) {
          const target = members[name];
          if (target && target.isAccessor) {
            return kind == "set" ? target.set : target.get;
          }
          return target;
        }
        for (var i = 0; i < this.extends.length; i++) {
          let inherit = this.extends[i];
          inherit = inherit ? inherit.type() : null;
          if (inherit !== this) {
            if (Utils.isModule(inherit) && !inherit.extends.includes(this)) {
              const result2 = inherit.getMember(name, kind, excludeInterface, useExtendFlag);
              if (result2) {
                return result2;
              }
            }
          }
        }
        const result = excludeInterface ? null : this.getInterfaceMember(name, kind);
        if (result) {
          return result;
        }
        const base = Namespace.globals.get("Object");
        if (base && base !== this) {
          const result2 = base.getMember(name, kind, excludeInterface, useExtendFlag);
          if (result2) {
            return result2;
          }
        }
        if (useExtendFlag) {
          return this.getUseExtendMethod(name, kind);
        }
        return null;
      }
      dynamicAttribute(propertyType, context = null) {
        const properties = this.dynamicProperties;
        for (let [key, value2] of properties) {
          if (key.check(propertyType, context)) {
            return value2;
          }
        }
        const inherit = this.inherit;
        if (inherit && inherit !== this && Utils.isModule(inherit) && !inherit.extends.includes(this)) {
          const result = inherit.dynamicAttribute(propertyType, context);
          if (result) {
            return result;
          }
        }
        if (this.implements) {
          for (const impl of this.implements) {
            const result = Utils.isModule(impl) && impl.dynamicAttribute(propertyType, context);
            if (result) {
              return result;
            }
          }
        }
        return null;
      }
      getMemberKeys() {
        const members = this.members;
        const keys = Object.keys(members);
        for (var i = 0; i < this.extends.length; i++) {
          let inherit = this.extends[i];
          inherit = inherit.type();
          if (inherit && inherit !== this && Utils.isModule(inherit) && !inherit.extends.includes(this)) {
            keys.push(...inherit.getMemberKeys());
          }
        }
        if (this.implements) {
          for (const impl of this.implements) {
            keys.push(...impl.getMemberKeys());
          }
        }
        return keys;
      }
      getTypeKeys() {
        return Array.from(this.getProperties().keys());
      }
      getProperties(propertyMap) {
        propertyMap = propertyMap || /* @__PURE__ */ new Map();
        let members = this.members;
        for (var name in members) {
          let member = members[name];
          if (member.isAccessor)
            member = member.get;
          if (member) {
            const modifier = Utils.getModifierValue(member);
            if (modifier === "public") {
              propertyMap.set(name, member);
            }
          }
        }
        const inherit = this.inherit;
        if (inherit && inherit !== this && Utils.isModule(inherit) && !inherit.extends.includes(this)) {
          inherit.getProperties(propertyMap);
        }
        if (this.isInterface) {
          this.implements.forEach((imp) => imp.getProperties(propertyMap));
        }
        return propertyMap;
      }
      getInterfaceMember(name, kind = null) {
        const imps = this.implements;
        const len = imps.length;
        for (let i = 0; i < len; i++) {
          let impModule = imps[i];
          impModule = impModule ? impModule.type() : null;
          if (impModule && impModule !== this && Utils.isModule(impModule) && !impModule.extends.includes(this)) {
            const result = impModule.getMember(name, kind);
            if (result) {
              return result;
            }
          }
        }
        return null;
      }
      hasInterfaceMember(name) {
        const imps = this.implements;
        const len = imps.length;
        for (let i = 0; i < len; i++) {
          let impModule = imps[i];
          impModule = impModule.type();
          if (impModule && impModule !== this && Utils.isModule(impModule) && !impModule.extends.includes(this)) {
            const result = impModule.hasInterfaceMember(name);
            if (result) {
              return true;
            }
          }
        }
        return false;
      }
      getConstructMethod(flag) {
        if (!flag) {
          return this.methodConstructor || null;
        }
        let inherit = this;
        while (inherit) {
          let method = inherit.methodConstructor;
          if (method) {
            return method;
          }
          ;
          inherit = inherit.getInheritModule();
        }
        return null;
      }
      addDepend(module2) {
        if (module2 !== this) {
          module2.used = true;
          this.dependencies.add(module2);
        }
      }
      getReferenceNameByModule(module2, flag = false) {
        if (!module2 || !module2.isModule)
          return null;
        if (module2 === this) {
          return module2.id;
        }
        if (this.importAlias.has(module2)) {
          return this.importAlias.get(module2);
        }
        if (module2.required || this.imports.has(module2.id)) {
          return module2.id;
        }
        const req = this.requires.get(module2.id);
        if (req && req.isAutoImporter) {
          return req.name;
        }
        if (module2.compilation === this.compilation && this.compilation.modules.has(module2.getName())) {
          return module2.id;
        }
        const stacks = this.getStacks(true);
        for (let i = 0; i < stacks.length; i++) {
          const stack = stacks[i];
          if (stack && stack.isClassDeclaration) {
            const compi = stack.compilation;
            if (compi && !compi.isDestroyed) {
              if (compi.importModuleNameds.has(module2)) {
                return compi.importModuleNameds.get(module2);
              }
            }
          }
        }
        if (flag) {
          return null;
        }
        return module2.namespace.getChain().concat(module2.id).join("_");
      }
      addMember(name, desc, flag = false) {
        if (desc && desc.isConstructor) {
          const result = this.addDescriptor("constructor", desc);
          if (!result) {
            if (this.methodConstructor && desc.isSameSource(this.methodConstructor)) {
              desc.error(1045, "constructor");
            }
          }
          this.methodConstructor = desc;
        } else {
          this.addDescriptor(name, desc);
          const isStatic = !!(desc.static || this.static);
          const target = isStatic || flag ? this.methods : this.members;
          if (desc.kind === "get" || desc.kind === "set") {
            const obj = Object.prototype.hasOwnProperty.call(target, name) ? target[name] : target[name] = { isAccessor: true };
            if (!this.isDeclaratorModule) {
              if (!obj.isAccessor && Utils.isStack(obj)) {
                desc.error(1045, name);
                obj.error(1045, name);
              }
            }
            if (!obj[desc.kind] || !desc.isSameSource(obj[desc.kind])) {
              obj[desc.kind] = desc;
            }
          } else {
            if (!this.isDeclaratorModule) {
              if (Object.prototype.hasOwnProperty.call(target, name)) {
                let old = target[name];
                if (old && old.toString() !== desc.toString()) {
                  desc.error(1045, name);
                  old.error(1045, name);
                }
              }
            }
            if (!target[name] || !desc.isSameSource(target[name])) {
              target[name] = desc;
            }
          }
        }
      }
      addImport(name, module2, isAlias = false, topScope = null) {
        if (module2 === this) {
          return false;
        }
        if (isAlias) {
          this.importAlias.set(module2, name);
        }
        this.imports.set(name, module2);
        return true;
      }
      getModuleAlias(module2) {
        if (Module.is(module2) && this.importAlias.size > 0) {
          for (let m of this.importAlias.keys()) {
            if (m.getName() === module2.getName()) {
              return this.importAlias.get(m);
            }
          }
        }
        return null;
      }
      getImport(name) {
        return this.imports.get(name);
      }
      getModuleGenerics() {
        const result = this.getModuleDeclareGenerics();
        return result.length > 0 ? result : null;
      }
      getModuleDeclareGenerics(flag = false, onlyread = false, origin = false) {
        const statcks = this.getStacks().filter((stack) => !!stack.genericity).sort((a, b) => {
          let a1 = a.genericity.elements.length;
          let b1 = b.genericity.elements.length;
          return a1 > b1 ? -1 : a1 < b1 ? 1 : 0;
        });
        if (statcks.length > 0) {
          if (origin) {
            return [statcks[0], statcks[0].genericity.elements];
          }
          if (flag) {
            return [statcks[0], statcks[0].genericity.elements.map((item2) => item2.type())];
          }
          if (onlyread) {
            return statcks[0].genericity;
          }
          return statcks[0].genericity.elements.map((item2) => item2.type());
        }
        return [];
      }
      toString(context = {}, options = {}) {
        if (!options.__recursion) {
          options.__recursion = 0;
        }
        if (options.__recursion > 20) {
          return "Circular";
        }
        options.__recursion++;
        const name = this.namespace.getChain().concat(this.id).join(".");
        const stacks = this.getStacks();
        options.complete = false;
        if (context && context.stack) {
          if (stacks.some((item2) => item2.id === context.stack)) {
            options.complete = true;
          }
        }
        const [stackModule, declareGenerics] = this.getModuleDeclareGenerics(true);
        if (stackModule && declareGenerics && declareGenerics.length > 0) {
          const ctx = context && context.isContext ? context : stackModule.getContext();
          const elements = declareGenerics.map((item2) => {
            if (options.fetchDeclareGenericsDefaultValue && options.inbuild) {
              if (item2.type().assignType) {
                return item2.type().assignType.type().toString({}, Object.create(options));
              }
              return "any";
            }
            const type2 = ctx.fetch(item2.type(), true);
            if (type2 === this) {
              return type2.id;
            }
            if (options.complete) {
              return type2.toString({}, Object.create(options));
            } else {
              return stackModule.getTypeDisplayName(type2, context, Object.create(options));
            }
          });
          options.__recursion = null;
          return `${name}<${elements.join(",")}>`;
        }
        options.__recursion = null;
        return name;
      }
    };
    module.exports = Module;
  }
});

// lib/core/Diagnostic.js
var require_Diagnostic = __commonJS({
  "lib/core/Diagnostic.js"(exports, module) {
    var Lang = require_Lang();
    var constant = {};
    var define = (code, name, message) => {
      if (Lang.has(code)) {
        throw new Error(`code '${code}' already exists.`);
      } else {
        Lang.define(code, message);
        if (name) {
          constant[name] = code;
        }
      }
    };
    var registereds = {};
    var Diagnostic = class {
      constructor(file, message, range, kind, node2, code) {
        this.file = file;
        this.message = message;
        this.range = range;
        this.kind = kind;
        if (message === code && typeof code === "string") {
          code = "";
        }
        this.node = node2;
        this.code = code;
      }
      toString() {
        let message = this.message;
        let range = this.range;
        if (this.file) {
          message += ` (${this.file}:${range.start.line}:${range.start.column}) ${this.code}`;
        } else {
          message += ` (${range.start.line}:${range.start.column}) ${this.code}`;
        }
        return message;
      }
      static register(key, callback) {
        if (!registereds[key]) {
          registereds[key] = true;
          callback((code, cn, en = null) => {
            if (!cn) {
              throw new Error("Language message can not is emty");
            }
            if (!en && cn)
              en = cn;
            Diagnostic.defineError(code, "", [cn, en]);
          });
        }
      }
      static defineError(code, name, value2) {
        if (code >= 1e4) {
          define(code, name, value2);
        } else {
          throw new Error(`code '${code}' already exists.`);
        }
      }
      static getCodeByName(name) {
        return constant[name];
      }
      static getMessage(code, args = []) {
        return Lang.get(code, ...args);
      }
    };
    Diagnostic.LANG_CN = 0;
    Diagnostic.LANG_EN = 1;
    Diagnostic.ERROR = 0;
    Diagnostic.WARN = 1;
    Diagnostic.DEPRECATED = 2;
    Diagnostic.UNNECESSARY = 3;
    define(1e3, "", [
      "\u51FD\u6570\u53C2\u6570\u671F\u671B\u6709%s\u4E2A\uFF0C\u5F53\u524D\u7ED9\u4E86%s\u4E2A",
      "Expected %s arguments, but got %s"
    ]);
    define(1001, "", [
      "\u51FD\u6570\u53C2\u6570\u671F\u671B\u6709%s\u4E2A\uFF0C\u5F53\u524D\u7ED9\u4E86%s\u4E2A",
      "Expected %s arguments, but got %s"
    ]);
    define(1002, "", [
      "\u6307\u5B9A\u7684\u5B9E\u53C2\u7C7B\u578B(%s), \u4E0D\u80FD\u5206\u914D\u7ED9\u58F0\u660E\u7684\u5F62\u53C2\u7C7B\u578B(%s)",
      `Argument of type '%s' is not assignable to parameter of type '%s'`
    ]);
    define(1003, "", [
      "\u6307\u5B9A\u7684\u7C7B\u578B(%s)\u4E0D\u80FD\u6EE1\u8DB3\u58F0\u660E\u7684\u7EA6\u675F\u7C7B\u578B(%s)",
      "Type '%s' does not satisfy the constraint '%s'"
    ]);
    define(1004, "", [
      "\u6CDB\u578B\u53C2\u6570\u671F\u671B\u662F %s \u4E2A\uFF0C\u4F46\u6307\u5B9A\u4E86 %s \u4E2A",
      "Expected %s type arguments, but got %s"
    ]);
    define(1005, "", [
      "\u6CDB\u578B\u53C2\u6570\u671F\u671B\u662F %s-%s \u4E2A\uFF0C\u4F46\u6307\u5B9A\u4E86 %s \u4E2A",
      "Expected %s-%s type arguments, but got %s"
    ]);
    define(1006, "", [
      "\u5F15\u7528\u540D(%s)\uFF0C\u4E0D\u662F\u4E00\u4E2A\u53EF\u8C03\u7528\u7684\u65B9\u6CD5",
      "'%s' is not callable"
    ]);
    define(1007, "", [
      "\u53D8\u91CF\u4E0D\u80FD\u91CD\u590D\u58F0\u660E(%s)",
      "Variable '%s' cannot redeclare"
    ]);
    define(1008, "", [
      "\u58F0\u660E\u7684\u53D8\u91CF\u540D(%s)\u4E0E\u7C7B\u540D\u51B2\u7A81",
      "Variable '%s' conflicts with the current class name."
    ]);
    define(1009, "", [
      "\u5F15\u7528\u7684\u8868\u8FBE\u5F0F\u7C7B\u578B(%s)\u4E0D\u80FD\u5206\u914D\u7ED9\u6307\u5B9A\u7684\u7C7B\u578B(%s)",
      "Type '%s' is not assignable to assignment of type '%s'"
    ]);
    define(1010, "", [
      "\u6307\u5B9A\u5F15\u7528\u7684\u53D8\u91CF\u4E0D\u80FD\u662F\u81EA\u8EAB(%s)",
      "Variable '%s' cannot reference to itself."
    ]);
    define(1011, "", [
      "\u53D8\u91CF\u540D(%s),\u9690\u542B\u7740(any)\u7C7B\u578B,\u4F46\u662F\u53EF\u4EE5\u4E3A\u5176\u8D4B\u503C\u540E\u80FD\u63A8\u65AD\u51FA\u66F4\u9002\u5408\u7684\u7C7B\u578B",
      "Variable '%s' implicitly has an 'any' type, but a better type may is inferred from usage."
    ]);
    define(1012, "", [
      "\u5C55\u5F00\u6570\u7EC4\u8868\u8FBE\u5F0F(%s)\u7684\u7C7B\u578B\u5FC5\u987B\u662F\u4E00\u4E2A\u6570\u7EC4\uFF0C\u5F53\u524D\u5F15\u7528\u7684\u7C7B\u578B(%s)",
      "Spread '%s' expression, must is an array type. give %s"
    ]);
    define(1013, "", [
      "\u5F15\u7528\u540D(%s)\u6CA1\u6709\u5B9A\u4E49",
      "'%s' is not defined"
    ]);
    define(1014, "", [
      "\u5C55\u5F00\u6570\u7EC4(%s[%s]),\u5DF2\u8D85\u51FA\u7D22\u5F15\u4E0B\u6807",
      "Spread %s[%s] out of range, is not assign initial value."
    ]);
    define(1015, "", [
      "\u5F15\u7528\u540D(%s)\u662F\u4E00\u4E2A\u4E0D\u53EF\u5199\u7684\u58F0\u660E",
      "'%s' is not writable"
    ]);
    define(1016, "", [
      "\u6709\u521D\u59CB\u503C\u7684\u53C2\u6570\u4E0D\u9700\u8981\u6807\u8BB0\u4E3A\u53EF\u9009\u53C2\u6570",
      "Parameter with a initial value cannot is marked as optional"
    ]);
    define(1017, "", [
      "\u8868\u8FBE\u5F0F(await),\u53EA\u80FD\u5F15\u7528\u58F0\u660E\u4E3A\u540C\u6B65\u7684\u51FD\u6570",
      "Await expression are only allowed within async function"
    ]);
    define(1018, "", [
      "\u8868\u8FBE\u5F0F(await),\u53EA\u80FD\u5F15\u7528\u58F0\u660E\u4E3A\u540C\u6B65\u7684\u51FD\u6570",
      "Await expression needs to return a promise type"
    ]);
    define(1019, "", [
      "\u5F15\u7528(%s),\u4E0D\u662F\u4E00\u4E2A\u5B9E\u4F8B\u5BF9\u8C61",
      "The refs '%s' is not instance object"
    ]);
    define(1020, "", [
      "\u5F15\u7528(%s),\u53EF\u80FD\u4E0D\u662F\u4E00\u4E2A\u5B9E\u4F8B\u5BF9\u8C61",
      "The refs '%s' maybe is not instance object"
    ]);
    define(1021, "", [
      "\u5B9E\u4F8B\u8FD0\u7B97\u7B26(%s),\u5728\u53F3\u8FB9\u8868\u8FBE\u5F0F\u4E2D\u5FC5\u987B\u662F\u4E00\u4E2A\u7C7B\u578B\u5F15\u7528",
      "Operator the '%s' right-hand refs is not class type"
    ]);
    define(1022, "", [
      "\u8BED\u6CD5(Break)\u6307\u5B9A\u7684\u6807\u7B7E(%s)\u8868\u8FBE\u5F0F\u4E0D\u5B58\u5728\u6216\u8005\u5DF2\u8DE8\u8D8A\u8FB9\u754C",
      "Jump target is not exists or has crossed boundary"
    ]);
    define(1023, "", [
      "\u8BED\u6CD5(Break)\u53EA\u80FD\u51FA\u73B0\u5728\u5FAA\u73AF\u8BED\u53E5\u4E2D",
      "Break must is contain in the 'switch,while,do,for'"
    ]);
    define(1024, "", [
      "%s\u662F\u4E00\u4E2A\u5FAA\u73AF\u5F15\u7528. %s > %s > %2",
      "%s to circular dependency. %s > %s > %2"
    ]);
    define(1025, "", [
      "\u5BFC\u5165\u7684\u6A21\u5757(%s)\u5DF2\u7ECF\u5B58\u5728",
      "Import '%s' module already exists."
    ]);
    define(1026, "", [
      "\u5BFC\u5165\u7684\u6A21\u5757(%s)\u6CA1\u6709\u627E\u5230",
      "Import '%s' is not exists."
    ]);
    define(1027, "", [
      "\u5F15\u7528\u7684\u7C7B(%s)\u4E0D\u5B58\u5728",
      "Class '%s' is not exists"
    ]);
    define(1028, "", [
      "\u5728\u7C7B\u7684(implements)\u8868\u8FBE\u5F0F\u4E2D,\u6307\u5B9A\u7684\u6807\u8BC6\u7B26\u4E0D\u662F\u63A5\u53E3\u7C7B\u578B",
      "Implements '%s' is not interface"
    ]);
    define(1029, "", [
      "\u5728\u7C7B\u7684(implements)\u8868\u8FBE\u5F0F\u4E2D,\u6307\u5B9A\u7684\u63A5\u53E3\u7C7B\u578B\u4E0D\u5B58\u5728",
      "Implements '%s' is not exists"
    ]);
    define(1030, "", [
      "\u6307\u5B9A\u7684\u6CDB\u7C7B\u578B(%s)\u9700\u8981\u6709 %s \u4E2A\u7C7B\u578B\u53C2\u6570",
      "Generic '%s' requires %s type arguments"
    ]);
    define(1031, "", [
      "\u7C7B\u6CDB\u578B(%s)\u9700\u8981\u6709 %s-%s \u4E2A\u7C7B\u578B\u53C2\u6570",
      "Generic '%s' requires %s-%s type arguments"
    ]);
    define(1032, "", [
      "\u6307\u5B9A\u7684\u63A5\u53E3\u6210\u5458(%1),\u6CA1\u6709\u5728\u6B64\u7C7B\u4E2D\u5B9E\u73B0",
      "The '%s' %s in the %s is not implemented in the %s"
    ]);
    define(1033, "", [
      "\u5B9E\u73B0\u63A5\u53E3\u6210\u5458(%s)\u7684\u7C7B\u578B\u4E0D\u5339\u914D",
      "Implementing the type mismatch of the interface member '%s'. must is '%s' type"
    ]);
    define(1034, "", [
      "\u5B9E\u73B0\u63A5\u53E3\u6210\u5458(%1)\u4E0D\u517C\u5BB9",
      "The '%s' inconformity with the %s in the '%s'"
    ]);
    define(1035, "", [
      "\u5B9E\u73B0\u63A5\u53E3(%1)\u4E2D,\u53C2\u6570\u7F3A\u5931",
      "The '%s' %s params missing with the %s params in the '%s'"
    ]);
    define(1036, "", [
      "\u5B9E\u73B0\u63A5\u53E3(%1)\u4E2D\uFF0C\u53C2\u6570\u7684\u7C7B\u578B\u4E0D\u5339\u914D",
      "The '%s' %s params type not matched with the %s params in the '%s3'"
    ]);
    define(1037, "", [
      "\u5B9E\u73B0\u63A5\u53E3(%1)\u4E2D\uFF0C\u6CDB\u578B\u7684\u6570\u76EE\u4E0D\u4E00\u81F4",
      "The '%s' %s declare generics number inconsistency in the '%s'"
    ]);
    define(1038, "", [
      "\u5B9E\u73B0\u63A5\u53E3(%1),\u6CDB\u578B\u7EA6\u675F\u7C7B\u578B\u4E0D\u5339\u914D",
      "The '%s' %s generics does not satisfy constraint with the '%s'"
    ]);
    define(1039, "", [
      "\u5B9E\u73B0\u63A5\u53E3(%1)\u4E2D,\u8BBF\u95EE\u547D\u540D\u7A7A\u95F4\u7684\u4FEE\u9970\u7B26\u4E0D\u4E00\u81F4",
      "the '%s' %s modifier is not consistent with the %s modifier in the '%1'"
    ]);
    define(1040, "", [
      "\u58F0\u660E\u7684\u522B\u540D\u7C7B\u578B(%s)\u5FC5\u987B\u6307\u5B9A\u4E00\u4E2A\u7C7B\u578B\u503C",
      "Declare '%s' alias type must assignment a type"
    ]);
    define(1041, "", [
      "\u7F3A\u5C11\u6761\u4EF6",
      "Missing condition"
    ]);
    define(1042, "", [
      "\u5FAA\u73AF\u8BED\u53E5\u4F53\u4E2D\u7F3A\u5C11\u9000\u51FA\u8BED\u53E5\uFF0C\u53EF\u80FD\u4F1A\u5BFC\u81F4\u65E0\u9650\u5FAA\u73AF",
      "The absence of an exit statement in the body of a do while statement may result in an infinite loop"
    ]);
    define(1043, "", [
      "\u65E0\u6548\u7684\u6807\u8BC6\u7B26",
      "Token(%s) invalid"
    ]);
    define(1044, "", [
      "\u679A\u4E3E\u5C5E\u6027(%s)\u7684\u521D\u59CB\u503C\u53EA\u80FD\u662F\u6570\u5B57\u6216\u8005\u5B57\u7B26\u4E32",
      "Enum property the '%s' initial value of can only is number or string"
    ]);
    define(1045, "", [
      "\u5C5E\u6027(%s)\u5DF2\u7ECF\u5B58\u5728\uFF0C\u4E0D\u80FD\u91CD\u590D\u5B9A\u4E49",
      "Property the '%s' already exists. cannot redefined"
    ]);
    define(1046, "", [
      "\u5F15\u7528\u7684\u503C\u5FC5\u987B\u662F\u5BF9\u8C61",
      "The refs value of '%s' is not an object"
    ]);
    define(1047, "", [
      "\u5FAA\u73AF(%s)\u4E2D\u53EA\u80FD\u58F0\u660E\u5355\u4E2A\u53D8\u91CF",
      "Only a single variable declaration is allowed in a '%s' statement"
    ]);
    define(1048, "", [
      "\u5FAA\u73AF(%s)\u58F0\u660E\u7684\u53D8\u91CF\u4E0D\u80FD\u6709\u521D\u59CB\u503C",
      "The variable declaration of a '%s' statement cannot have an initial"
    ]);
    define(1049, "", [
      "\u5F15\u7528\u7684\u503C\u53EF\u80FD\u4E0D\u662F\u5BF9\u8C61\u503C",
      "The refs value of '%s' maybe is not an object"
    ]);
    define(1050, "", [
      "\u5E26\u6709\u521D\u59CB\u503C\u7684\u53C2\u6570(\u53EF\u9009\u53C2\u6570)\u53EA\u80FD\u8DDF\u5728\u5FC5\u586B\u53C2\u6570\u7684\u540E\u9762",
      "The '%s' parameter with an initial value in method can only is declared after the parameter"
    ]);
    define(1051, "", [
      "\u5269\u4F59\u53C2\u6570\u53EA\u80FD\u5728\u53C2\u6570\u7684\u7ED3\u5C3E",
      "The '%s' rest parameter can only appear at the end of the params"
    ]);
    define(1052, "", [
      "\u6784\u9020\u51FD\u6570\u4E2D\u4E0D\u9700\u8981\u6709\u8FD4\u56DE\u503C",
      "Constructor does not need to return value"
    ]);
    define(1053, "", [
      "\u6784\u9020\u51FD\u6570\u4E2D\u5FC5\u987B\u5148\u8C03\u7528\u8D85\u7C7B\u65B9\u6CD5(super)",
      "Constructor must first call super"
    ]);
    define(1054, "", [
      "\u51FD\u6570\u58F0\u660E\u7684\u7C7B\u578B\u5FC5\u987B\u6709\u8FD4\u56DE\u503C",
      "A function whose declared type is neither 'void' nor 'any' must return a value"
    ]);
    define(1055, "", [
      "\u58F0\u660E\u4E3A\u5F02\u6B65\u7684\u51FD\u6570\u5FC5\u987B\u8FD4\u56DE\u4E13\u6709\u7C7B\u578B(%s)",
      "The return type of an async function or method must is the '%s' type"
    ]);
    define(1056, "", [
      "\u58F0\u660E\u7684\u6CDB\u578B\u5DF2\u7ECF\u5B58\u5728",
      "Generic '%s' is already exists"
    ]);
    define(1057, "", [
      "\u58F0\u660E\u7684\u6CDB\u578B\u4E0E\u7C7B\u578B\u540D\u51B2\u7A81",
      "Generic '%s' conflicts with type name."
    ]);
    define(1058, "", [
      "\u58F0\u660E\u6CDB\u578B\u7684\u53C2\u6570\uFF0C\u4E0D\u80FD\u8DDF\u5728\u53EF\u9009\u53C2\u6570\u7684\u540E\u9762",
      "Required type parameters may not follow optional type parameters"
    ]);
    define(1059, "", [
      "\u5F53\u524D\u7684\u5F15\u7528(%s)\u6307\u5411\u4E00\u4E2A\u7C7B\u578B\uFF0C\u4E0D\u80FD\u5F53\u4F5C\u503C\u4F20\u9012",
      "'%s' only refers to a type, but is being used as a value here."
    ]);
    define(1060, "", [
      "\u5F15\u7528(%s)\u4E0D\u5B58\u5728",
      "'%s' does not exist."
    ]);
    define(1061, "", [
      "\u5F15\u7528(%s)\u4E0D\u53EF\u8BBF\u95EE",
      "'%s' is not accessible."
    ]);
    define(1062, "", [
      "\u4E0D\u80FD\u5728\u6784\u9020\u51FD\u6570\u4E0A\u58F0\u660E\u6CDB\u578B",
      "Generic cannot is declared on constructor"
    ]);
    define(1063, "", [
      "\u7C7B\u4E2D\u6210\u5458\u65B9\u6CD5(%1)\u5728\u7236\u7C7B\u4E2D\u4E0D\u5B58\u5728\uFF0C\u4E0D\u9700\u8981\u6807\u8BB0\u91CD\u5199(@Override))\u6CE8\u89E3\u7B26",
      "The '%s' %s does not exists in the superclass. remove the '@Override' annotator if not overwrite."
    ]);
    define(1064, "", [
      "\u7C7B\u4E2D\u6210\u5458\u65B9\u6CD5(%1)\u5728\u7236\u7C7B\u4E2D\u5B58\u5728\uFF0C\u9700\u8981\u6807\u8BB0\u91CD\u5199(@Override)\u6CE8\u89E3\u7B26",
      "the '%s' %s already exists in the superclass. use the '@Override' annotator if need overwrite"
    ]);
    define(1065, "", [
      "\u83B7\u53D6\u8BBF\u95EE\u5668(%s)\u4E0D\u9700\u8981\u58F0\u660E\u53C2\u6570",
      "'%s' getter does not defined param"
    ]);
    define(1066, "", [
      "\u83B7\u53D6\u8BBF\u95EE\u5668(%s)\u9700\u8981\u8FD4\u56DE\u503C",
      "'%s' getter accessor must have a return value"
    ]);
    define(1067, "", [
      "\u8BBE\u7F6E\u8BBF\u95EE\u5668(%s)\u9700\u8981\u58F0\u660E\u4E00\u4E2A\u53C2\u6570",
      "'%s' setter must have one param"
    ]);
    define(1068, "", [
      "\u8BBF\u95EE\u5668(%s)\u7684\u63A5\u6536\u7C7B\u578B\u4E0D\u5339\u914D",
      "'%s' setter and getter parameter types do not match"
    ]);
    define(1069, "", [
      "\u5F53\u524D\u5F15\u7528(%s)\u4E0D\u662F\u4E00\u4E2A\u53EF\u88AB\u5B9E\u4F8B\u5316\u7684\u7C7B\u5BF9\u8C61",
      "Reference the '%s' is not an instantiable class object"
    ]);
    define(1070, "", [
      "\u5F53\u524D\u5F15\u7528(%s)\u662F\u4E00\u4E2A\u62BD\u8C61\u7C7B\uFF0C\u4E0D\u80FD\u88AB\u5B9E\u4F8B\u5316\u5BF9\u8C61",
      "'%s' is an abstract class. cannot is instantiated."
    ]);
    define(1071, "", [
      "\u5269\u4F59\u53C2\u6570\u53EA\u80FD\u662F\u4E00\u4E2A\u5143\u7EC4\u7C7B\u578B",
      "Rest accept type must is tuple type"
    ]);
    define(1072, "", [
      "\u8FD4\u56DE\u8868\u8FBE\u5F0F\u53EA\u80FD\u5728\u51FD\u6570\u4F53\u4E2D",
      "Return expression must in function body"
    ]);
    define(1073, "", [
      "\u5F53\u524D\u7684\u5F15\u7528\u4E0D\u80FD\u8F6C\u6362\u4E3A\u4E00\u4E2A\u6570\u7EC4",
      "The '%s' cannot convert a reference to an array"
    ]);
    define(1074, "", [
      "\u5F53\u524D\u7684\u5F15\u7528\u4E0D\u80FD\u8F6C\u6362\u4E3A\u4E00\u4E2A\u5BF9\u8C61",
      "The '%s' cannot convert a reference to an object"
    ]);
    define(1075, "", [
      "\u8C03\u7528\u8D85\u7C7B(super)\u65B9\u6CD5\u9700\u8981\u5728\u5B50\u7C7B\u4E2D",
      "'super' no inherit parent class"
    ]);
    define(1076, "", [
      "\u8D85\u7C7B\u65B9\u6CD5(super)\u53EA\u80FD\u5728\u7C7B\u65B9\u6CD5\u4E2D\u8C03\u7528",
      "'super' can only is called in class methods"
    ]);
    define(1077, "", [
      "\u5143\u7EC4\u7C7B\u578B\u4E2D\u58F0\u660E\u7684\u5269\u4F59\u7C7B\u578B\u53EA\u80FD\u51FA\u73B0\u5728\u5143\u7D20\u7684\u7ED3\u5C3E",
      "Tuple type rest parameter must follow the end"
    ]);
    define(1078, "", [
      "\u58F0\u660E\u7684\u7C7B\u578B(%s)\u5DF2\u7ECF\u5B58\u5728",
      "Declare type '%s' already exists"
    ]);
    define(1079, "", [
      "\u7F3A\u5C11\u7C7B\u578B\u5F15\u7528",
      "Missing type expression"
    ]);
    define(1080, "", [
      "\u5C5E\u6027\u540D(%s)\u4E0D\u5B58\u5728",
      "Property '%s' is not exists"
    ]);
    define(1081, "", [
      "\u5C55\u5F00\u5BF9\u8C61\u8868\u8FBE\u5F0F\u5FC5\u987B\u8BBE\u7F6E\u4E00\u4E2A\u521D\u59CB\u503C",
      "Spread object expression, must have initial"
    ]);
    define(1082, "", [
      "\u5F53\u524D\u5C5E\u6027(%s)\u4E0E\u7236\u7C7B\u4E2D\u7684\u6210\u5458\u6709\u51B2\u7A81",
      "Property '%s' conflicts with a member of the parent class"
    ]);
    define(1083, "", [
      "\u5F15\u7528(%s)\u7684\u7C7B\u578B\u4E0D\u5B58\u5728",
      "Type '%s' is not exists"
    ]);
    define(1084, "", [
      "\u58F0\u660E\u7684\u53C2\u6570\uFF0C\u4E0D\u80FD\u8DDF\u5728\u53EF\u9009\u53C2\u6570\u7684\u540E\u9762",
      "Required parameters may not follow optional type parameters"
    ]);
    define(1085, "ERROR", [
      "\u89E3\u6790\u8BED\u6CD5\u9519\u8BEF",
      "Parsing syntax error"
    ]);
    define(1086, "", [
      "\u6307\u5B9A\u7C7B\u578B\u4E3A(%s)\u7684\u6570\u7EC4\u5143\u7D20\uFF0C\u4E0D\u80FD\u5728\u6570\u7EC4\u7D22\u5F15\u4F4D\u7F6E\u6307\u5B9A\u7C7B\u578B",
      "Specifies an array element of '%s' type. the type cannot is specified at the array index"
    ]);
    define(1087, "", [
      "\u66F4\u65B0\u8868\u8FBE\u5F0F(%s)\u7684\u5F15\u7528\u7C7B\u578B\u5FC5\u987B\u662F\u4E00\u4E2A\u6570\u5B57\u7C7B\u578B",
      "The reference type of the update expression '%s' must is a numeric type"
    ]);
    define(1088, "", [
      "\u9700\u8981\u91CD\u5199\u7684\u65B9\u6CD5(%s)\u53C2\u6570\u6570\u76EE\u4E0D\u4E00\u81F4",
      "Inconsistent number of the '%s' method arguments to override"
    ]);
    define(1089, "", [
      "\u9700\u8981\u91CD\u5199\u7684\u5B58\u50A8\u5668(%s)\u53C2\u6570\u6570\u76EE\u4E0D\u4E00\u81F4",
      "Inconsistent number of the '%s' setter arguments to override"
    ]);
    define(1090, "", [
      "\u5B9E\u73B0\u63A5\u53E3(%s)\u4E2D\u7684\u53C2\u6570\u4E0D\u517C\u5BB9",
      "Implemented interface parameters is not compatible in the '%s' method"
    ]);
    define(1091, "", [
      "\u7247\u6BB5\u8868\u8FBE\u5F0F\u53EA\u80FD\u51FA\u73B0\u5728\u7ED3\u5C3E",
      "fragment expressions can only appear at the end"
    ]);
    define(1092, "", [
      "\u6CE8\u89E3Runtime\u65B9\u6CD5\u53C2\u6570\u503C\u53EA\u80FD\u662F'server,client'",
      "Annotations runtime method parameters can only is 'server' or 'client'"
    ]);
    define(1093, "", [
      "\u6CE8\u89E3\u65B9\u6CD5\u5728\u6B64\u4F4D\u7F6E\u672A\u751F\u6548",
      "Annotation method not in effect at this location"
    ]);
    define(1094, "", [
      "\u5728\u6B64\u5904\u58F0\u660E\u7684\u5BFC\u5165\u8BED\u65E0\u6548",
      "The import declared here is invalid"
    ]);
    define(1095, "", [
      "\u6307\u5B9A\u52A0\u8F7D\u7684\u7C7B\u578B\u63CF\u8FF0\u6587\u4EF6\u65E0\u6548",
      "The type description file specified to load is invalid"
    ]);
    define(1096, "", [
      "\u58F0\u660E\u7684\u5168\u5C40\u51FD\u6570(%s)\u5DF2\u7ECF\u5B58\u5728",
      "Declare globals function '%s' already exists"
    ]);
    define(1097, "", [
      "\u58F0\u660E\u7684\u5C5E\u6027(%s)\u5DF2\u7ECF\u5B58\u5728",
      "Declare globals property '%s' already exists"
    ]);
    define(1098, "", [
      "\u6307\u5B9A\u7684XML\u547D\u540D\u7A7A\u95F4(%s)\u6CA1\u6709\u5B9A\u4E49",
      "The specified XML namespace '%s' is not defined"
    ]);
    define(1099, "", [
      "\u5F15\u7528\u7684\u547D\u540D\u7A7A\u95F4\u4E0D\u5B58\u5728",
      "The '%s' namespace does not exist"
    ]);
    define(1100, "", [
      "\u5D4C\u5165\u7684\u6587\u4EF6\u6CA1\u6709\u627E\u5230",
      "Embed file '%s' not found"
    ]);
    define(1101, "", [
      "\u7F3A\u5931\u5D4C\u5165\u7684\u6587\u4EF6",
      "Embed file missing"
    ]);
    define(1102, "", [
      "\u5D4C\u5165\u6CE8\u89E3\u7B26\u53EA\u80FD\u5B9A\u4E49\u5728\u5305\u6216\u8005\u9876\u7EA7\u57DF\u4E2D",
      "Embed annotations can only is defined in a package or top-level scope"
    ]);
    define(1103, "", [
      "\u6CE8\u89E3\u7B26(%s)\u53EA\u80FD\u5B9A\u4E49\u5728\u9876\u7EA7\u57DF\u3001\u5305\u6216\u8005\u7C7B\u4E2D",
      "%s annotations can only is defined in a top-level scope or package or class"
    ]);
    define(1104, "", [
      "\u6CE8\u89E3\u7B26(%s)\u53EA\u80FD\u5B9A\u4E49\u5728\u65B9\u6CD5\u6216\u8005\u5C5E\u6027\u4E0A",
      "%s annotations can only is defined in a methods or property of class members"
    ]);
    define(1105, "", [
      "\u6CE8\u89E3\u7B26(%s)\u53EA\u80FD\u5B9A\u4E49\u5728\u7C7B\u4E0A",
      "%s annotations can only is defined in a class"
    ]);
    define(1106, "", [
      "\u5D4C\u5165\u6CE8\u89E3\u7B26\u6307\u5B9A\u7684\u8D44\u6E90\u5DF2\u7ECF\u5B58\u5728",
      "Embed annotations '%s' assets already exists"
    ]);
    define(1107, "", [
      "\u58F0\u660E\u7684\u5F15\u7528(%s)\u5DF2\u7ECF\u5B58\u5728",
      "Declare refs '%s' already exists"
    ]);
    define(1108, "", [
      "\u5143\u7D20\u6807\u7B7E\u540D\u4E0D\u7B26\u5408\u6807\u51C6",
      "JSX element tag name does not is standard"
    ]);
    define(1109, "", [
      "\u5B50\u7C7B\u7684\u7236\u7EA7\u5FC5\u987B\u662F\u4E00\u4E2A\u6839\u5143\u7D20\u7EC4\u4EF6",
      "JSX the parent of subclass must is root element components"
    ]);
    define(1110, "", [
      "\u4E0D\u652F\u6301\u7684\u4EE3\u7801\u5757",
      "JSX Unsupported"
    ]);
    define(1111, "", [
      "\u5143\u7D20\u7EC4\u4EF6(%s)\u4E0D\u5B58\u5728",
      "Component '%s' is not exists"
    ]);
    define(1112, "", [
      "\u5728\u6839\u5143\u7D20\u7EC4\u4EF6\u4E2D\u7684\u5B50\u7C7B\u5DF2\u7ECF\u5B58\u5728",
      "JSX subclass already exist in the root element components"
    ]);
    define(1113, "", [
      "\u5143\u7D20\u5C5E\u6027\u7684\u5B50\u7EA7\u53EA\u80FD\u662F\u4E00\u4E2A\u8868\u8FBE\u5F0F",
      "JSX the value of element properties can only is a expression"
    ]);
    define(1114, "", [
      "\u5143\u7D20\u6307\u4EE4\u65E0\u6548",
      "JSX element directive '%s' invalid"
    ]);
    define(1115, "", [
      "\u6839\u5143\u7D20\u4E0A\u4E0D\u80FD\u4F7F\u7528\u6307\u4EE4",
      "JSX directives cannot is used on the root element"
    ]);
    define(1116, "", [
      "\u5143\u7D20\u6307\u4EE4(each)\u8868\u8FBE\u5F0F\u9519\u8BEF, \u6B63\u786E\u5199\u6CD5\u662F:'item of fromArray'",
      "JSX element directives 'each' expression error, correct be: 'item of fromArray'"
    ]);
    define(1117, "", [
      "XML\u547D\u540D\u7A7A\u95F4\u53EA\u80FD\u5B9A\u4E49\u5728\u6839\u5143\u7D20\u4E0A",
      "JSX namespaces can only is defined on the root element"
    ]);
    define(1118, "", [
      "\u6CA1\u6709\u627E\u5230\u6307\u5B9A\u7684\u6587\u4EF6",
      "Not found the '%s'"
    ]);
    define(1119, "", [
      "\u6307\u4EE4(EACH)\u7684\u5F15\u7528\u53EA\u80FD\u662F\u4E00\u4E2A\u6570\u7EC4. \u5F53\u524D\u4E3A(%s)",
      "JSX references to the 'each' directive can only is an array. but got '%s'"
    ]);
    define(1120, "", [
      "\u6307\u4EE4(FOR)\u7684\u5F15\u7528\u7C7B\u578B\u5FC5\u987B\u662F\u4E00\u4E2A\u53EF\u8FED\u4EE3\u7684\u5BF9\u8C61",
      "JSX references to the 'for' directive must is an iterator object. but got '%s'"
    ]);
    define(1121, "", [
      "\u5143\u7D20\u6307\u4EE4(for)\u8868\u8FBE\u5F0F\u9519\u8BEF, \u6B63\u786E\u5199\u6CD5\u662F:'value in fromIteration'",
      "JSX element directives 'for' expression error, correct be: '(value,key[optional],index[optional]) in fromIteration'"
    ]);
    define(1122, "", [
      "\u52A0\u8F7D\u4F9D\u8D56(%s)\u6587\u4EF6\u4E0D\u5B58\u5728\u3002\u8BF7\u5148\u5B89\u88C5\u6B64\u4F9D\u8D56",
      "Require '%s' does not exist. try npm install %1"
    ]);
    define(1123, "", [
      "\u591A\u4E2A\u5143\u7D20\u5FC5\u987B\u5305\u88F9\u5728\u4E00\u4E2A\u5BB9\u5668\u4E2D",
      "JSX Multiple elements must is wrapped in a container"
    ]);
    define(1124, "", [
      "'%s' \u662F\u4E00\u4E2A\u88AB\u4FDD\u7559\u7684\u6807\u8BC6\u7B26",
      "The '%s' is a reserved identifier"
    ]);
    define(1125, "", [
      "\u6307\u5B9A\u7684\u547D\u540D\u7A7A\u95F4\u4E0B\u53EF\u7528\u5143\u7D20\u4E3A:%s",
      "JSX the '%s' available elements in the specified namespace"
    ]);
    define(1126, "", [
      "\u5F15\u7528\u63D2\u69FD(%s)\u5728\u7236\u7EC4\u4EF6\u4E2D\u6CA1\u6709\u5B9A\u4E49",
      "JSX refs of the slot '%s' is not defined in the parent component"
    ]);
    define(1127, "", [
      "\u63D2\u69FD(%s)\u7684\u7236\u7EA7\u4E0D\u662F\u4E00\u4E2Aweb\u7EC4\u4EF6",
      "JSX parent of the slot '%s' is not web-component"
    ]);
    define(1128, "", [
      "\u63D2\u69FD(%s)\u4F7F\u7528\u7684\u53C2\u6570\u5728\u7236\u7EA7\u7EC4\u4EF6\u7684\u63D2\u69FD\u4E2D\u6CA1\u6709\u5B9A\u4E49",
      "JSX the slot '%s' used parameters is not defined in the slot of the parent component"
    ]);
    define(1129, "", [
      "\u63D2\u69FD(%s)\u5DF2\u7ECF\u5B9A\u4E49\u8FC7",
      "JSX the slot (%s) is already defined"
    ]);
    define(1130, "", [
      "\u63D2\u69FD(%s)\u6CA1\u6709\u58F0\u660E\u4F5C\u7528\u57DF",
      "JSX the slot '%s' does not declared scope"
    ]);
    define(1131, "", [
      "\u7EC4\u4EF6\u5143\u7D20\u6CA1\u6709\u58F0\u660E\u9ED8\u8BA4\u63D2\u69FD\u6765\u63A5\u6536\u6216\u8005\u5904\u7406\u5B50\u5143\u7D20\uFF0C\u662F\u5426\u8003\u8651\u5C06\u5176\u5220\u9664\uFF1F",
      "Component is not declared default slots to receive or process child elements. would you consider delete them?"
    ]);
    define(1132, "", [
      "\u5F15\u7528\u7684\u6587\u4EF6(%s)\u4E0D\u5B58\u5728",
      "References file '%s' does not exist"
    ]);
    define(1133, "", [
      "\u7F3A\u5C11\u8FD4\u56DE\u8868\u8FBE\u5F0F",
      "Missing return expression"
    ]);
    define(1134, "", [
      "JSX \u7EC4\u4EF6\u5143\u7D20(%s)\u5FC5\u987B\u7EE7\u627F'web-component'",
      "JSX the '%s' element components must inherit 'web-component'"
    ]);
    define(1135, "", [
      "\u6CE8\u89E3(%s)\u8868\u8FBE\u5F0F\u53C2\u6570\u65E0\u6548",
      "The '%s' annotation expression arguments is invalid"
    ]);
    define(1136, "", [
      "\u6210\u5458\u5C5E\u6027(%s)\u4E0D\u80FD\u88AB\u91CD\u5199",
      "The '%s' members property cannot is overridden"
    ]);
    define(1137, "", [
      "\u6CE8\u89E3\u7B26(%s)\u4E0D\u80FD\u7ED1\u5B9A\u591A\u4E2A\u5165\u53E3\u65B9\u6CD5",
      "Annotation the '%s' cannot bind multiple entry methods in an class"
    ]);
    define(1138, "", [
      "\u6CE8\u89E3\u7B26(%s)\u53EA\u80FD\u7ED1\u5B9A\u5728\u516C\u5F00\u4E14\u4E3A\u9759\u6001\u7684\u65B9\u6CD5\u4E0A",
      "Annotation the '%s' can only is bound to public and static methods"
    ]);
    define(1139, "", [
      "\u52A8\u6001\u5C5E\u6027\u7684\u7D22\u5F15(%s)\u7C7B\u578B\u53EA\u80FD\u662F\u5B57\u7B26\u4E32\u6216\u8005\u6570\u5B57\u7C7B\u578B",
      "The '%s' index type of dynamic property can only is string or number"
    ]);
    define(1140, "", [
      "\u6CE8\u89E3\u7B26(%s)\u4E0D\u5B58\u5728\u3002\u53EF\u4EE5\u5728(compiler.options.annotations)\u4E2D\u6DFB\u52A0\u6CE8\u89E3\u7B26",
      "Annotation the '%s' does not exist. but you can also register annotations through 'compiler.options.annotations'"
    ]);
    define(1141, "", [
      "\u7C7B\u578B(%s)\u662F\u4E00\u4E2A\u5FAA\u73AF\u5F15\u7528",
      "Type '%s' refs to circular"
    ]);
    define(1142, "", [
      "\u6210\u5458(%s)\u662F\u4E00\u4E2A\u53EA\u8BFB\u5C5E\u6027",
      "The '%s' property is readonly"
    ]);
    define(1143, "", [
      "\u5BB9\u5668\u6307\u4EE4\u4E0D\u80FD\u518D\u6307\u5B9A\u5C5E\u6027\u6307\u4EE4",
      "Directives container can no longer set attribute directive"
    ]);
    define(1144, "", [
      "\u5BB9\u5668\u6307\u4EE4\u7F3A\u5C11\u5C5E\u6027",
      "Directives container missing attributes. expect '%s'"
    ]);
    define(1145, "", [
      "\u5BB9\u5668\u6307\u4EE4\u5C5E\u6027\u671F\u671B%s\u4E2A,\u4F46\u8BBE\u7F6E\u4E86%s\u4E2A\u3002\u671F\u671B\u5C5E\u6027(%s)",
      "Directives container attributes expect %s. but got %s. available attributes the '%s'"
    ]);
    define(1146, "", [
      "\u5BB9\u5668\u6307\u4EE4\u5C5E\u6027\u7684\u503C\u53EA\u652F\u6301\u8868\u8FBE\u5F0F",
      "Only expressions is supported for value of container directive properties"
    ]);
    define(1147, "", [
      "\u7C7B\u578B(%s)\u4E0D\u80FD\u7EE7\u627F\u4E3A\u7EC8\u6001\u7C7B(%s)\u7684\u5B50\u7C7B",
      "Type '%s' cannot is inherited as a subclass of the final class '%s'"
    ]);
    define(1148, "", [
      "\u7EC8\u6001\u65B9\u6CD5(%s)\u4E0D\u80FD\u88AB\u91CD\u5199",
      "The final method '%s' cannot is overridden"
    ]);
    define(1149, "", [
      "\u7EC8\u6001\u5C5E\u6027(%s)\u4E0D\u80FD\u88AB\u91CD\u5199",
      "The final property '%s' cannot is overridden"
    ]);
    define(1150, "", [
      "\u7C7B\u578B(%s)\u4E0D\u80FD\u7528\u4F5C\u7D22\u5F15\u7C7B\u578B",
      "Type '%s' cannot is used as an index type"
    ]);
    define(1151, "", [
      "\u4E0D\u80FD\u5728\u6269\u5C55\u53C2\u6570\u4F53\u4E4B\u5916\u6307\u5B9A\u7C7B\u578B",
      "Type cannot is specified outside of an spread parameter body"
    ]);
    define(1152, "", [
      "\u7F3A\u5C11\u5BF9\u8C61\u5C5E\u6027(%s)",
      "Missing object property the '%s'"
    ]);
    define(1153, "", [
      "\u679A\u4E3E\u6210\u5458\u5FC5\u987B\u5177\u6709\u521D\u59CB\u503C",
      "Enum member must have initial value"
    ]);
    define(1154, "", [
      "\u6269\u5C55\u53C2\u6570\u5FC5\u987B\u5177\u6709\u5143\u7EC4\u7C7B\u578B\u6216\u4F20\u9012\u7ED9\u5269\u4F59\u53C2\u6570",
      "A spread argument must either have a tuple type or is passed to a rest parameter"
    ]);
    define(1155, "", [
      "\u957F\u5EA6\u4E3A'%s'\u7684\u5143\u7EC4\u7C7B\u578B'%s',\u5728\u7D22\u5F15'%s'\u5904\u6CA1\u6709\u5143\u7D20",
      "Tuple type '%s' of length '%s' has no element at index '%s'"
    ]);
    define(1156, "", [
      "\u6307\u4EE4'else'\u53EA\u80FD\u51FA\u73B0\u5728'if'\u6761\u4EF6\u4E4B\u540E",
      "Directives the 'else' can only appear after the 'if' condition"
    ]);
    define(1157, "", [
      "\u6307\u5B9A\u5177\u6709\u63D2\u69FD(%s)\u5143\u7D20\u7684\u7236\u7EA7\u5FC5\u987B\u662F\u4E00\u4E2Aweb\u7EC4\u4EF6\u7C7B\u578B",
      "Specifies that the parent with slot(%s) elements must is a Web component type"
    ]);
    define(1158, "", [
      "\u5C5E\u6027(%s)\u662F\u4E00\u4E2A\u5FAA\u73AF\u5F15\u7528",
      "The '%s' is a circular references"
    ]);
    define(1159, "", [
      "\u5BFC\u51FA\u8BED\u53E5\u53EA\u80FD\u51FA\u73B0\u5728\u9876\u7EA7\u5757\u4E2D",
      "Export statements can only appear in top-level blocks"
    ]);
    define(1160, "", [
      "\u975E\u63CF\u8FF0\u6587\u4EF6\u548C\u7247\u6BB5\u6587\u4EF6\u4E2D\u7684\u5BFC\u51FA\u8BED\u53E5\u4F1A\u88AB\u5FFD\u7565",
      "Export statements in non-description and fragment files are ignored"
    ]);
    define(1161, "", [
      "\u6A21\u5757(%s)\u4E0D\u80FD\u88AB\u5BFC\u5165,\u56E0\u4E3A(%1)\u4E0D\u662F\u4E3B\u6A21\u5757",
      "The '%s' cannot is imported. because '%1' is not the main module."
    ]);
    define(1162, "", [
      "\u6307\u5B9A\u7684\u6765\u6E90(%s)\u6CA1\u6709\u5BFC\u51FA\u5185\u5BB9",
      "The specified source does not have an export statement. in '%s'"
    ]);
    define(1163, "", [
      "\u4E00\u4E2A\u6A21\u5757\u4E2D\u4E0D\u80FD\u6709\u591A\u4E2A\u9ED8\u8BA4\u5BFC\u51FA",
      "A module cannot have multiple default exports"
    ]);
    define(1164, "", [
      "\u6A21\u5757(%s)\u6CA1\u6709\u5BFC\u51FA\u6210\u5458(%s),\u60A8\u662F\u5426\u6253\u7B97\u4F7F\u7528`import %2 from '%1'`\u6765\u66FF\u6362",
      "Module '%s' has no exported member '%s'. Did you mean to use `import %2 from '%1'` instead?"
    ]);
    define(1165, "", [
      "\u5F15\u7528\u5143\u8BED\u53E5(%s)\u4E0D\u5B58\u5728, \u53EF\u7528\u7684\u65B9\u6CD5:%2",
      "Reference meta statement '%s' does not exist, available methods:'%2'"
    ]);
    define(1166, "", [
      "\u5F15\u7528\u7684\u5B57\u6BB5\u540D(%s)\u4E0D\u5B58\u5728",
      "The '%s' field name does not exist"
    ]);
    define(1167, "", [
      "\u81F3\u5C11\u9700\u8981\u6307\u5B9A\u4E00\u4E2A\u5B57\u6BB5\u540D",
      "Least one field name needs to is specified"
    ]);
    define(1168, "", [
      "\u7D22\u5F15\u540D\u4E0D\u80FD\u91CD\u590D\u5B9A\u4E49",
      "The index name already defined"
    ]);
    define(1169, "", [
      "\u63D2\u69FD\u7684\u4F5C\u7528\u57DF\u53C2\u6570\u540D\u5FC5\u987B\u662F\u4E00\u4E2A\u5B57\u9762\u91CF\u6807\u8BC6\u7B26",
      "The scope parameter name of the slot must is literal identifier"
    ]);
    define(1170, "", [
      "\u58F0\u660E\u63D2\u69FD\u7684\u4F5C\u7528\u57DF\u53C2\u6570(%s)\u5FC5\u987B\u7ED9\u4E00\u4E2A\u521D\u59CB\u503C\u6216\u8005\u5F15\u7528",
      "Slots scope arguments the '%s' must have a initial value when declared"
    ]);
    define(1171, "", [
      "\u5C5E\u6027\u6307\u4EE4\u8868\u8FBE\u5F0F\u5FC5\u987B\u662F\u4E00\u4E2A\u5B57\u9762\u5BF9\u8C61\u7C7B\u578B",
      "Attributes directive-expression must is a literal-object and contains 'name,value' properties."
    ]);
    define(1172, "", [
      "\u7F3A\u5C11\u5C5E\u6027\u503C",
      "Missing attribute value"
    ]);
    define(1173, "", [
      "\u81EA\u5B9A\u4E49\u6307\u4EE4\u5FC5\u987B\u5305\u542B'name'\u548C'value'\u5C5E\u6027",
      "Custom directives must contains name and value properties."
    ]);
    define(1174, "", [
      "\u6307\u4EE4\u7EC4\u4EF6\u7684\u5B50\u7EA7\u53EA\u80FD\u662F\u4E00\u4E2AVNode\u7684\u7C7B\u578B",
      "Child of directive-component can only is of a VNode"
    ]);
    define(1175, "", [
      "\u5F15\u7528\u7684\u7C7B\u578B(%s)\u4E0D\u5B58\u5728",
      "Reference type '%s' does not exist"
    ]);
    define(1176, "", [
      "\u4E0D\u652F\u6301\u7684\u8868\u8FBE\u5F0F(%s)",
      "Expression the '%s' is not supported"
    ]);
    define(1177, "", [
      "\u4E0D\u652F\u6301\u540C\u7C7B\u578B\u5D4C\u5957\u5206\u914D",
      "Nested assignments of the same type '%s' is not supported"
    ]);
    define(1178, "", [
      '\u8868\u8FBE\u5F0F"%s"\u5DF2\u88AB\u8BBE\u7F6E\u4E3A\u4E13\u6709\u8BED\u6CD5\u4F5C\u7528\u57DF\uFF0C\u5728\u5F53\u524D\u4EE3\u7801\u4E2D\u53EA\u80FD\u5F53\u7C7B\u578B\u5F15\u7528\u3002\u4F46\u662F\u60A8\u53EF\u4EE5\u901A\u8FC7\u914D\u7F6E\u4F5C\u7528\u57DF\u6765\u6539\u53D8\u8FD9\u79CD\u884C\u4E3A',
      "The '%s' was set proprietary syntax scope. so it can only be referenced as a type in this coding. but you can change this behavior by configure the scope"
    ]);
    define(1179, "", [
      "\u6839\u5143\u7D20\u7EC4\u4EF6(%s)\u5FC5\u987B\u7EE7\u627F'web.components.Skin' \u6216\u8005 'web.components.Component'",
      "the '%s' root element components must inherit 'web.components.Skin' or 'web.components.Component'"
    ]);
    define(1180, "", [
      "\u58F0\u660E\u7684\u6A21\u5757(%s)\u7C7B\u578B\u5FC5\u987B\u5728\u6587\u6863\u7684\u9876\u7EA7\u4F5C\u7528\u57DF\u4E2D",
      "Declared module type the '%s' must is in the top-level scope of the document"
    ]);
    define(1181, "", [
      "\u5F15\u7528\u7684\u65B9\u6CD5\u6216\u8005\u5C5E\u6027\u5DF2\u88AB\u6807\u8BB0\u4E3A\u5DF2\u5220\u9664",
      "Referenced the '%s' method or property is removed"
    ]);
    define(1182, "", [
      "\u5F15\u7528\u7684\u65B9\u6CD5\u6216\u8005\u5C5E\u6027\u5DF2\u5F03\u7528",
      "Referenced the '%s' method or property is deprecated. %s"
    ]);
    define(1183, "", [
      "'%s'\u5DF2\u58F0\u660E\uFF0C\u4F46\u662F\u6CA1\u6709\u4EFB\u4F55\u5F15\u7528",
      "'%s' is declared but its value is never read"
    ]);
    define(1184, "", [
      "\u68C0\u6D4B\u5230\u4E0D\u4F1A\u6267\u884C\u7684\u4EE3\u7801",
      "Unreachable code detected"
    ]);
    define(1185, "", [
      "\u8C03\u7528\u4E86\u4E00\u4E2A\u7A7A\u64CD\u4F5C\u7684\u51FD\u6570",
      "A meaningless function was called"
    ]);
    define(1186, "", [
      "\u5728\u540C\u6761\u4EF6\u4E2D\u5DF2\u7ECF\u5B58\u5728\u76F8\u540C\u7C7B\u578B\u7684\u65AD\u8A00\uFF0C\u8868\u8FBE\u5F0F(%s)\u53EF\u4EE5\u53BB\u6389",
      "An assertions of the same type already exists in the same conditions, the '%s' expression is meaningless"
    ]);
    define(1187, "", [
      `"\u903B\u8F91\u4E0E"\u7C7B\u578B\u65AD\u8A00\u5F15\u7528\u4E86\u76F8\u540C\u8868\u8FBE\u5F0F\uFF0C\u53EF\u80FD\u65E0\u6CD5\u540C\u65F6\u6EE1\u8DB3\u6761\u4EF6\u662F\u5426\u9700\u8981\u4FEE\u6B63\uFF1F`,
      `The 'logical and' type assertions refers to the same expressions and may not satisfy conditions. are you to fix it?`
    ]);
    define(1188, "", [
      `\u5F15\u7528\u7684\u5BF9\u8C61\u5B58\u5728\u6B67\u4E49\uFF0C\u5E94\u5F53\u5728\u5F15\u7528\u524D\u65AD\u8A00\u5BF9\u8C61\u7C7B\u578B`,
      `Refers object have ambiguous. use type-assertion for this object on before refers it`
    ]);
    define(1189, "", [
      `\u6682\u4E0D\u652F\u6301\u7684\u8BED\u6CD5\u8282\u70B9(%s)`,
      `Unrecognized token '%s'`
    ]);
    define(1190, "", [
      `\u5F15\u7528\u7684\u5BF9\u8C61\u6709\u53EF\u80FD\u662F\u7A7A\u503C\uFF0C\u5E94\u5F53\u5728\u5F15\u7528\u524D\u5224\u65AD\u5BF9\u8C61\u4E0D\u4E3A\u7A7A\u6216\u8005\u4F7F\u7528\u53EF\u9009\u94FE(?.)\u8FD0\u7B97\u7B26\u83B7\u53D6\u5C5E\u6027(%s)\u503C`,
      `Refers object may be null should check this object is not null on before refers it or use optional-chain operator(?.) that gets the value of this '%s' property`
    ]);
    define(1191, "", [
      `\u6761\u4EF6\u5224\u65AD\u5B58\u5728\u4E92\u65A5\u7684\u8868\u8FBE\u5F0F`,
      `Conditional test existed mutually exclusive expressions`
    ]);
    define(1192, "", [
      `\u5BFC\u51FA\u8D4B\u503C\u4E0D\u80FD\u4E0E\u5176\u5B83\u5BFC\u51FA\u5143\u7D20\u4E00\u8D77\u5728\u6A21\u5757\u4E2D\u4F7F\u7528`,
      `An export assignment cannot be used in a module with other exported elements`
    ]);
    define(1193, "", [
      "\u6A21\u5757(%1)\u6CA1\u6709\u5177\u540D\u5BFC\u51FA,\u662F\u5426\u6253\u7B97\u4F7F\u7528`import * as %2 from '%1'`\u6765\u66FF\u6362",
      "Module '%s' has no named exported. Did you mean to use `import * as %2 from '%1'` instead?"
    ]);
    define(1194, "", [
      "\u4E0D\u80FD\u5728\u63CF\u8FF0\u6587\u6863\u7684\u5168\u5C40\u5305\u4E2D\u4F7F\u7528\u5BFC\u51FA",
      "The export cannot is used in the global package of the descriptor documents"
    ]);
    define(1195, "", [
      "\u5BFC\u51FA\u63CF\u8FF0\u7B26(%s)\u5DF2\u7ECF\u5B58\u5728(%s)\u5305\u4E2D",
      "Export the '%s' descriptors is alreay exists. in the '%s' package"
    ]);
    define(1196, "", [
      "\u5F15\u7528(%s)\u5FC5\u987B\u662F\u4E00\u4E2A\u58F0\u660E\u7684\u51FD\u6570\u53C2\u6570",
      "References '%s' must is declared function params"
    ]);
    define(1197, "", [
      "\u6307\u5B9A\u7684\u5168\u547D\u540D\u7A7A\u95F4\u53EA\u80FD\u58F0\u660E\u5728\u6A21\u5757\u7684\u9876\u7EA7\u57DF\u4E2D",
      "The specified full-namespace can only is declare in module top-level scoped"
    ]);
    define(1198, "", [
      "\u8868\u8FBE\u5F0F\u662F\u4E00\u4E2A\u65E0\u503C(void)\u7C7B\u578B\uFF0C\u6240\u4EE5\u6B64\u5904\u7684\u8D4B\u503C\u6CA1\u6709\u610F\u4E49",
      "The expression is of type void, so the assignment here is meaningless."
    ]);
    define(1199, "", [
      "\u5F15\u7528\u540D(%s)\u4E0E\u5BFC\u5165\u6A21\u5757\u51B2\u7A81",
      "Reference name '%s' conflicts with the '%s'"
    ]);
    define(1200, "", [
      "\u9759\u6001\u65B9\u6CD5\u6CA1\u6709\u7EE7\u627F\u7236\u7C7B\u5C5E\u6027\u6216\u8005\u65B9\u6CD5\uFF0C\u6240\u4EE5\u4E0D\u9700\u8981\u4F7F\u7528(Override)\u6CE8\u89E3\u7B26",
      "Static methods no was inherit this parent class attributes or methods, so not need to use the 'Override' annotations"
    ]);
    define(1201, "", [
      "\u58F0\u660E\u7684\u679A\u4E3E\u8868\u8FBE\u5F0F\u53EA\u5BF9key-value\u7684\u6620\u5C04\u652F\u6301\uFF0C\u4E0D\u652F\u6301\u65B9\u6CD5\u6216\u8005\u5C5E\u6027\u7684\u5B9A\u4E49\u3002\u4F46\u5B83\u53EF\u4EE5\u4F7F\u7528\u679A\u4E3E\u6A21\u5757\u6765\u652F\u6301",
      "Declared enum expression support only key-value mappings, not method or attribute definitions. but it can using the enum module to supported"
    ]);
    define(1202, "", [
      "\u58F0\u660E\u7684\u679A\u4E3E\u8868\u8FBE\u5F0F\u4E0D\u652F\u6301\u7EE7\u627F\u548C\u63A5\u53E3\u3002\u4F46\u5B83\u53EF\u4EE5\u4F7F\u7528\u679A\u4E3E\u6A21\u5757\u6765\u652F\u6301",
      "Declared enum expression do not support extends and implements. but it can using the enum module to supported"
    ]);
    define(1203, "", [
      "\u679A\u4E3E\u6A21\u5757\u53EA\u80FD\u7EE7\u627F\u679A\u4E3E\u7C7B\u578B",
      "Enum module can only extends enum types"
    ]);
    define(1204, "", [
      "\u5BB9\u5668\u6307\u4EE4\u7F3A\u5C11\u5F15\u7528\u8868\u8FBE\u5F0F(%s)",
      "Directives container misssing references expression the '%s'"
    ]);
    define(1205, "", [
      "\u6839\u5143\u7D20\u4E0A\u53EA\u80FD\u5B9A\u4E49\u547D\u540D\u7A7A\u95F4\u5C5E\u6027",
      "Root element can only define namespace-attributes"
    ]);
    define(1206, "", [
      "\u6307\u5B9A\u7684\u53C2\u6570(%s)\u6CA1\u6709\u88AB\u58F0\u660E\uFF0C\u5E94\u8BE5\u5728\u7C7B\u578B\u5B9A\u4E49\u65F6\u5148\u58F0\u660E\u6216\u8005\u5220\u9664\u6B64\u53C2\u6570",
      "Arguments the '%s' is not declared and should is declare at type definition or removed this arguments"
    ]);
    define(1207, "", [
      "\u6CE8\u89E3\u7B26(%s)\u4E0D\u662F\u4E00\u4E2A\u88C5\u9970\u5668\u63A5\u53E3\u3002\u5B83\u5E94\u8BE5\u662F\u4E00\u4E2A\u7C7B\u5E76\u5B9E\u73B0\u4E00\u4E2A\u7531'@interface'\u5B9A\u4E49\u7684\u63A5\u53E3\u6216\u8005\u662F\u4E00\u4E2A\u51FD\u6570\u58F0\u660E",
      "The annotation '%s' is not decorator interface. It should is a class and implements an interface defined by '@interface' or a function declaration"
    ]);
    define(1208, "", [
      "\u65B9\u6CD5(%s)\u663E\u793A\u6307\u5B9A\u4E86this\u7C7B\u578B\uFF0C\u6240\u4EE5\u53EA\u80FD\u5728\u6307\u5B9A\u7C7B\u578B\u7684\u5BF9\u8C61\u94FE\u4E2D\u8C03\u7528",
      "The method (%s) specifies this type, so it can only be called in the object chain of the specified type."
    ]);
    module.exports = Diagnostic;
  }
});

// lib/core/Range.js
var require_Range = __commonJS({
  "lib/core/Range.js"(exports, module) {
    var Range = class {
      static is(value2) {
        return value2 ? value2 instanceof Range : false;
      }
      constructor(start, end) {
        this.start = start;
        this.end = end;
      }
    };
    module.exports = Range;
  }
});

// lib/types/LiteralObjectType.js
var require_LiteralObjectType = __commonJS({
  "lib/types/LiteralObjectType.js"(exports, module) {
    var Utils = require_Utils();
    var Namespace = require_Namespace();
    var Type = require_Type();
    var privateKey = Symbol("privateKey");
    function sorting(dataset) {
      const priority = (item2) => {
        const type2 = item2.type();
        if (!type2 || type2.isGenericType)
          return 1;
        if (type2.isLiteralType && type2.isLiteralValueType) {
          return 6;
        } else if (type2.isIntersectionType) {
          return 5;
        } else if (type2.isClassGenericType) {
          const wrap = type2.inherit.type();
          if (wrap && wrap.target && wrap.target.isDeclaratorTypeAlias && wrap.target.genericity) {
            return 4;
          }
        } else if (type2.isUnionType) {
          return 2;
        }
        return 3;
      };
      dataset.sort((a, b) => {
        if (a.params.length < b.params.length) {
          return -1;
        } else if (a.params.length > b.params.length) {
          return 1;
        }
        const a1 = a.params.reduce((acc, item2) => {
          if (item2.question)
            acc--;
          return acc + priority(item2);
        }, 0);
        const b1 = b.params.reduce((acc, item2) => {
          if (item2.question)
            acc--;
          return acc + priority(item2);
        }, 0);
        if (a1 === b1)
          return 0;
        return a1 > b1 ? -1 : 1;
      });
      return dataset;
    }
    var LiteralObjectType = class extends Type {
      constructor(inherit, target, properties = null, dynamicProperties = null, questionProperties = null) {
        super("$LiteralObjectType", inherit);
        this.target = target;
        this.isLiteralObjectType = true;
        this.properties = properties || (target ? target.attributes : null);
        this.dynamicProperties = dynamicProperties || (target ? target.dynamicProperties : null);
        this.questionProperties = questionProperties;
        this._hasGenericType = void 0;
      }
      get hasGenericType() {
        if (this._hasGenericType !== void 0) {
          return this._hasGenericType;
        }
        this._hasGenericType = false;
        if (this.properties && Array.from(this.properties.values()).some((item2) => item2.type()?.hasGenericType)) {
          this._hasGenericType = true;
        }
        if (this.dynamicProperties && Array.from(this.dynamicProperties.values()).some((item2) => item2.type()?.hasGenericType)) {
          this._hasGenericType = true;
        }
        return this._hasGenericType;
      }
      getDescriptor(name, filter, { isNew, isCall } = {}, result = null) {
        if (this.target && this.target.isTypeObjectDefinition) {
          const descriptors = this.target.callDefinitions;
          if (!descriptors)
            return null;
          const dataset = descriptors.get(name);
          if (dataset) {
            if (!filter) {
              return dataset[0] || result;
            } else {
              if (!dataset[privateKey]) {
                dataset[privateKey] = true;
                sorting(dataset);
              }
              for (let i = 0; i < dataset.length; i++) {
                const desc = dataset[i];
                const value2 = filter(desc, result, i, dataset);
                if (value2) {
                  if (value2 === true) {
                    return desc;
                  } else {
                    result = value2;
                  }
                }
              }
            }
          }
        }
        return result;
      }
      clone(inference, flag = false) {
        if (!flag && (!inference || !this.hasGenericType)) {
          return this;
        }
        const properties = /* @__PURE__ */ new Map();
        let dynamicProperties = null;
        this.properties.forEach((item2, key) => {
          if (inference) {
            properties.set(key, item2.type().clone(inference));
          } else {
            properties.set(key, item2);
          }
        });
        const dynamics = this.dynamicProperties || this.target && this.target.dynamicProperties;
        if (dynamics) {
          dynamicProperties = /* @__PURE__ */ new Map();
          dynamics.forEach((item2, key) => {
            dynamicProperties.set(key, item2.type().clone(inference));
          });
        }
        return Utils.setMergedType(new LiteralObjectType(this.inherit, this.target, properties, dynamicProperties));
      }
      attribute(property) {
        return this.properties.get(property);
      }
      dynamicAttribute(propertyType, context = null) {
        const properties = this.dynamicProperties || this.target && this.target.dynamicProperties;
        if (properties) {
          for (let [key, value2] of properties) {
            if (key.check(propertyType, context)) {
              return value2;
            }
          }
        }
        return null;
      }
      get attributes() {
        return this.properties;
      }
      check(stack, context, options = {}) {
        return this.constraint(stack.type(), context, options);
      }
      constraint(type2, context = {}, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isLiteralArrayType || type2.isTupleType) {
          return false;
        }
        if (type2.isAliasType) {
          return this.constraint(type2.inherit.type(), context, options);
        }
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.constraint(item2.type(), context, options));
        }
        const errorHandler = context?.errorHandler || ((result2) => result2);
        const qp = this.questionProperties || {};
        const isInterface = Utils.isInterface(type2);
        if (!isInterface && !this.isBaseObject(type2, context, options)) {
          type2 = Utils.getOriginType(type2);
          return type2.isModule && type2.id === "Object";
        }
        if (!(type2.isLiteralObjectType || type2.isIntersectionType || type2.isGenericType || isInterface))
          return false;
        if (type2.isLiteralObjectType && type2.properties.size === 0) {
          return true;
        }
        if (this.properties.size === 0 && this.dynamicProperties && this.dynamicProperties.size === 0) {
          return true;
        }
        let result = false;
        if (this.properties.size > 0) {
          const properties = Array.from(this.properties);
          result = properties.every((item2) => {
            const [name, base] = item2;
            const acceptType = base.type();
            let right = null;
            if (isInterface) {
              const result2 = type2.getDescriptor(name, (desc) => {
                return acceptType.check(desc, context, options);
              });
              if (result2) {
                return true;
              }
            } else {
              right = type2.attribute(name);
            }
            if (item2 === right)
              return true;
            if (!right) {
              const origin = this.target && this.target.attribute(name);
              const question = origin && origin.question || qp[name];
              return errorHandler(!!question, acceptType, right);
            }
            return errorHandler(acceptType.check(right, context, options), acceptType, right);
          });
        }
        if (!result && type2) {
          result = this.checkDynamicProperties(type2, context, options, errorHandler, !isInterface && this.properties.size == 0);
        }
        return result;
      }
      isBaseObject(type2, context, options) {
        if (type2.isGenericType && type2.hasConstraint)
          type2 = type2.inherit.type();
        type2 = type2.isLiteralObjectType ? type2.inherit : type2;
        if (!type2)
          return false;
        if (type2.isIntersectionType) {
          return this.isBaseObject(type2.left.type(), context, options) || this.isBaseObject(type2.right.type(), context, options);
        }
        return this.inherit.is(type2, context, options);
      }
      checkDynamicProperties(type2, context, options = {}, errorHandler = null, defaultResult = true) {
        const properties = this.dynamicProperties;
        const attributes = type2 && type2.attributes;
        if (properties && properties.size > 0 && attributes instanceof Map) {
          let numberType = Namespace.globals.get("number");
          const regexp = /^\d+$/;
          const entries = attributes.entries();
          let checkResult = true;
          for (let [key, value2] of properties) {
            const matchType = key.type();
            if (!matchType)
              continue;
            const acceptType = value2.init.type();
            let hasMatched = false;
            for (const [name, property] of entries) {
              if (matchType.is(numberType) && !regexp.test(name)) {
                continue;
              }
              hasMatched = true;
              const val = acceptType.check(property, context, options);
              const result = errorHandler ? errorHandler(val, acceptType, property) : val;
              if (!result)
                checkResult = false;
            }
            if (!hasMatched && !value2.question) {
              return false;
            }
          }
          return checkResult;
        }
        return defaultResult;
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isFunctionType || Utils.isScalar(type2))
          return false;
        if (type2.isLiteralArrayType || type2.isTupleType) {
          return false;
        }
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        } else if (type2.isClassGenericType) {
          const inherit = type2.inherit.type();
          if (inherit.isAliasType) {
            return this.is(inherit, context, options);
          }
        } else if (type2.isIntersectionType) {
          return this.is(type2.left.type(), context, options) || this.is(type2.right.type(), context, options);
        }
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        type2 = type2.isLiteralObjectType ? type2.inherit : type2;
        return this.inherit.is(type2, context, options);
      }
      toString(context = {}, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        let depth = 1;
        if (!options.depth) {
          options.depth = 1;
        } else {
          options.depth++;
          depth = options.depth;
        }
        if (options.inbuild) {
          options.rawcode = false;
          options.onlyTypeName = true;
        }
        const properties = Array.from(this.properties).map((item2) => {
          const [name, base] = item2;
          const type2 = base.type();
          const ctx = type2.isClassGenericType || Utils.isModule(type2) ? null : context;
          const origin = this.target && this.target.attribute(name);
          if (origin && origin.computed) {
            return `[${name}]: ` + type2.toString(ctx, options);
          }
          let question = origin && origin.question ? "?" : "";
          if (this.questionProperties && this.questionProperties[name]) {
            question = "?";
          }
          return `${name}${question}: ` + type2.toString(ctx, options);
        });
        if (this.target && this.target.isTypeObjectDefinition) {
          const descriptors = this.target.callDefinitions;
          if (descriptors) {
            descriptors.forEach((items, key) => {
              const kind = key === "#new#" ? "new" : "";
              items.forEach((item2) => {
                properties.unshift(kind + item2.type().toString(context, options));
              });
            });
          }
        }
        if (this.dynamicProperties) {
          this.dynamicProperties.forEach((item2, key) => {
            const kn = item2.key ? item2.key.value() : "key";
            properties.push(`[${kn}:${key.type().toString()}]: ` + item2.type().toString(context, options));
          });
        }
        if (!properties.length) {
          return `{}`;
        }
        const newLine = `\r
`;
        const indent = `	`.repeat(depth);
        const end = depth > 1 ? `	`.repeat(depth - 1) : "";
        return `{${newLine}${indent}${properties.join(`,${newLine}${indent}`)}${newLine}${end}}`;
      }
    };
    module.exports = LiteralObjectType;
  }
});

// lib/types/TupleType.js
var require_TupleType = __commonJS({
  "lib/types/TupleType.js"(exports, module) {
    var Utils = require_Utils();
    var Namespace = require_Namespace();
    var Type = require_Type();
    var TupleType = class extends Type {
      constructor(inherit, elements, target, rest = false, isTupleUnion = false, prefix = false) {
        super("$TupleType", inherit);
        this.elements = [].concat(elements);
        const len = this.elements.length;
        this.rest = rest;
        this.requireCount = rest && len > 1 ? len - 1 : len;
        this.isTupleType = true;
        this.prefix = prefix ? true : !!(target && target.prefix);
        this.isTupleUnion = isTupleUnion ? true : !!(target && target.isTypeTupleUnionDefinition);
        this.target = target;
      }
      get hasGenericType() {
        return this.elements.some((type2) => {
          type2 = type2.type();
          return type2 && type2.hasGenericType;
        });
      }
      getInferResult(context, records) {
        let change = false;
        const elements = this.elements.map((el) => {
          const res = el.type().getInferResult(context, records);
          if (res)
            change = true;
          return res || el;
        });
        if (change) {
          return new TupleType(this.inherit, elements, this.target, this.rest, this.isTupleUnion);
        }
        return null;
      }
      attribute(index) {
        const elements = this.target && this.target.isArrayExpression ? this.target.elements : this.elements;
        if (!this.prefix) {
          index = Number(index);
          if (!isNaN(index)) {
            return elements[index] || null;
          }
        }
        return null;
      }
      dynamicAttribute(type2, context = null) {
        const arrClass = Namespace.globals.get("Array");
        return arrClass && arrClass.dynamicProperties.get(Utils.getOriginType(type2));
      }
      clone(inference, flag = false) {
        if (!flag && (!inference || !this.hasGenericType)) {
          return this;
        }
        const elements = inference ? this.elements.map((item2) => {
          return item2.type().clone(inference);
        }) : this.elements.slice(0);
        return new TupleType(this.inherit, elements, this.target, this.rest, this.isTupleUnion);
      }
      checkItems(items, errorItems = [], context = {}, options = {}, typepPefix = false, originType = null) {
        const errorHandler = context?.errorHandler || ((result) => result);
        const checkItem = (base, item2, flag = true) => {
          let baseType = base.type();
          if (!baseType)
            return false;
          let type2 = this.getWrapAssignType(item2.type());
          if (baseType === type2 || this === type2)
            return true;
          if ((baseType.isThisType || baseType.target && baseType.target.isThisType) && !type2.isInstanceofType) {
            errorItems.push([baseType, item2]);
            if (options.forceResult)
              return true;
            return flag ? errorHandler(false, baseType, item2) : false;
          }
          if (baseType && !baseType.is(type2, context, options)) {
            errorItems.push([baseType, item2]);
            if (options.forceResult)
              return true;
            return flag ? errorHandler(false, baseType, item2) : false;
          }
          return true;
        };
        if (this.prefix || this.rest || this.isTupleUnion) {
          return items.every((item2) => {
            return errorHandler(this.elements.some((base) => {
              return checkItem(base, item2, false);
            }), this.elements, item2);
          });
        }
        const elements = this.target && this.target.isArrayExpression ? this.target.elements : this.elements;
        const len = elements.length;
        const rest = len > 0 ? elements[len - 1] : null;
        const hasRest = rest && rest.type().rest;
        const requireCount = hasRest ? this.requireCount - 1 : this.requireCount;
        if (hasRest && items.length < requireCount) {
          return false;
        } else if (!hasRest && items.length !== requireCount && !typepPefix) {
          let result = this.prefix;
          items.slice(requireCount).forEach((item2) => {
            result = errorHandler(false, null, item2);
          });
          return result;
        }
        return items.every((item2, index) => {
          let base = elements[index];
          if (base && !(hasRest && base === rest)) {
            return checkItem(base, item2);
          } else {
            if (hasRest && rest) {
              return checkItem(rest, item2);
            } else {
              return errorHandler(elements.some((base2) => {
                return checkItem(base2, item2, false);
              }), elements, item2);
            }
          }
        });
      }
      is(type2, context = {}, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isLiteralObjectType)
          return false;
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        } else if (type2.isIntersectionType) {
          return [type2.left, type2.right].some((item2) => this.is(item2.type(), context, options));
        }
        if (this.isTupleUnion && !this.inherit.is(type2.inherit, context, options)) {
          return false;
        }
        let items = null;
        if (type2.isClassGenericType && !type2.isClassType) {
          if (this.inherit.type().is(type2.inherit.type(), context, options)) {
            items = type2.elements;
          } else {
            return false;
          }
        } else if (type2.isTupleType || type2.isLiteralArrayType) {
          if (type2.isTupleType && type2.target && type2.target.isArrayExpression) {
            items = type2.target.elements;
            if (!items.length)
              return true;
          } else {
            items = type2.elements;
          }
        } else if (this.rest) {
          items = [type2];
        } else {
          return false;
        }
        if (type2.isLiteralArrayType && !items.length) {
          return true;
        }
        if (!this.elements.length) {
          return true;
        }
        return this.checkItems(items, [], context, options, type2.isTupleType && type2.prefix, type2);
      }
      needBrackets() {
        if (this.elements.length === 1) {
          let first = this.elements[0] && this.elements[0].type();
          if (first) {
            first = first.isComputeType && !first.object.isThisType ? first.getComputeType() : first;
            if ((first.isUnionType || first.isKeyofType) && first.elements.length > 1) {
              return true;
            } else if (first.isFunctionType) {
              return true;
            }
          }
        }
        return this.elements.length > 1;
      }
      toString(context = {}, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        let isTupleUnion = this.isTupleUnion;
        let needBrackets = false;
        let hasAnyType = false;
        let elements = this.elements.map((item2) => {
          let type2 = item2 && item2.type();
          if (!type2 || type2 === this) {
            hasAnyType = true;
            return "any";
          }
          if (!needBrackets) {
            if (type2.isGenericType && typeof context.inference === "function") {
              const result2 = context.inference(type2);
              if (result2 && result2.type().isUnionType) {
                needBrackets = result2.type().elements.length > 1;
              }
            }
          }
          return type2.toString(context, options);
        });
        if ((hasAnyType || options.hasAnyType) && this.prefix) {
          elements = ["any"];
        }
        const tupleRest = this.rest && this.target && this.target.isTypeTupleRestDefinition;
        const make = () => {
          if (isTupleUnion) {
            if (needBrackets || this.needBrackets()) {
              return `(${elements.join(" | ")})[]`;
            } else {
              return `${elements.join(" | ")}[]`;
            }
          }
          let rest = tupleRest ? "..." : "";
          let squares = rest ? "" : "[]";
          if (elements.length === 1 && (this.prefix || this.rest)) {
            if (needBrackets || this.needBrackets()) {
              return `${rest}(${elements[0]})${squares}`;
            } else {
              return `${rest}${elements[0]}${squares}`;
            }
          }
          return `${rest}[${elements.join(",")}]`;
        };
        let result = make();
        if (options.showRestSymbol) {
          if (this.rest && !result.startsWith("...")) {
            result = "..." + result;
            if (!result.endsWith("]")) {
              result += "[]";
            }
          }
        }
        return result;
      }
    };
    module.exports = TupleType;
  }
});

// lib/types/UnionType.js
var require_UnionType = __commonJS({
  "lib/types/UnionType.js"(exports, module) {
    var Type = require_Type();
    var UnionType = class extends Type {
      constructor(elements, target) {
        super("$UnionType");
        this.isUnionType = true;
        this.target = target;
        this.elements = elements;
        this.hasGenericType = elements.some((type2) => {
          const _type = type2.type();
          return _type ? _type.hasGenericType : false;
        });
      }
      clone(inference) {
        if (!inference || !this.hasGenericType) {
          return this;
        }
        const elements = this.elements.map((item2) => item2.type().clone(inference));
        return new UnionType(elements, this.target);
      }
      checkItems(items, context = {}, options = {}) {
        return items.every((item2) => {
          return this.elements.some((base) => base.type().check(item2, context, options));
        });
      }
      checkType(acceptType, assignment, context, options) {
        if (!acceptType)
          return true;
        if (acceptType.isLiteralObjectType) {
          return acceptType.constraint(assignment, context, options);
        }
        return acceptType.is(assignment, context, options);
      }
      is(type2, context = {}, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        if (type2.isUnionType) {
          return type2.elements.some((item2) => {
            return this.elements.some((base) => this.checkType(base.type(), item2.type(), context, options));
          });
        }
        return this.elements.some((base) => this.checkType(base.type(), type2, context, options));
      }
      toString(context, options = {}) {
        context = this.pushToStringChain(context, options);
        let need = this.elements.length > 1;
        let str = this.elements.map((item2) => {
          const type2 = item2.type();
          if (type2.isFunctionType && need) {
            return `(${type2.toString(context, Object.create(options))})`;
          }
          return type2.toString(context, options);
        }).join(" | ");
        if (options.hasAnyType) {
          return "any";
        }
        return str;
      }
    };
    module.exports = UnionType;
  }
});

// lib/types/LiteralType.js
var require_LiteralType = __commonJS({
  "lib/types/LiteralType.js"(exports, module) {
    var Type = require_Type();
    var LiteralType = class extends Type {
      constructor(inherit, target, value2, compareLiteralValue = false) {
        super("$LiteralType", inherit);
        this.isLiteralType = true;
        this.target = target;
        this.value = value2;
        this.compareLiteralValue = compareLiteralValue;
        this._showValue = false;
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        if (this.isLiteralValueType || options.toLiteralValue) {
          return this.inherit.is(type2, context) && type2.isLiteralType && this.value === type2.value;
        }
        return this.inherit.is(type2, context);
      }
      get isLiteralValueType() {
        return this.target && (this.target.isTypeDefinition || this.target.isTypeKeyofDefinition) || this.compareLiteralValue;
      }
      setValueToShow() {
        this._showValue = true;
      }
      isValueToShow() {
        return this._showValue || this.isLiteralValueType;
      }
      toString(context, options = {}) {
        if (this.isValueToShow() || options.toLiteralValue) {
          if (typeof this.value === "string") {
            const str = this.value.replace(/[\'\"]/g, "");
            return `"${str}"`;
          } else if (this.value !== void 0) {
            return this.value;
          }
        }
        return this.inherit && this.inherit.toString(context, options);
      }
    };
    module.exports = LiteralType;
  }
});

// lib/core/MergeType.js
var require_MergeType = __commonJS({
  "lib/core/MergeType.js"(exports, module) {
    var LiteralObjectType = require_LiteralObjectType();
    var TupleType = require_TupleType();
    var UnionType = require_UnionType();
    var Namespace = require_Namespace();
    var Utils = require_Utils();
    var LiteralType = require_LiteralType();
    var MergeType = class {
      static is(type2) {
        return Utils.isMergedType(type2);
      }
      #isLiteralArrayType = false;
      constructor(originType) {
        this.originType = originType;
        this.dynamicProperties = null;
        this.types = /* @__PURE__ */ new Map();
        this.question = {};
        this.target = null;
        this.dataGroup = null;
        this.hasTuplePrefix = false;
        this.isTupleType = false;
        this.isTupleUnion = true;
        this.keepOriginRefs = false;
        this.keepLiteralArrayType = false;
        this.classGenericOriginType = null;
        this.isClassGenericType = false;
      }
      createGroup(stack) {
        const type2 = stack.type();
        const dataGroup = this.dataGroup || (this.dataGroup = /* @__PURE__ */ new Map());
        const originType = Utils.getOriginType(type2);
        let dataset = dataGroup.get(originType);
        if (!dataset) {
          dataGroup.set(originType, dataset = new MergeType(originType));
          dataset.keepOriginRefs = this.keepOriginRefs;
          dataset.target = type2.target;
          dataset.keepLiteralArrayType = this.keepLiteralArrayType;
        }
        if (type2.isLiteralObjectType) {
          dataset.#isLiteralArrayType = false;
          dataset.dynamicProperties = type2.dynamicProperties;
          let has = dataset.types.size > 0;
          if (has) {
            dataset.types.forEach((value2, prop) => {
              if (!type2.properties.has(prop)) {
                dataset.question[prop] = true;
              }
            });
          }
          type2.properties.forEach((value2, prop) => {
            let items = dataset.types.get(prop);
            if (!items) {
              dataset.types.set(prop, items = new MergeType());
              items.keepOriginRefs = this.keepOriginRefs;
              if (has) {
                dataset.question[prop] = true;
              }
            }
            if (type2.questionProperties && type2.questionProperties[prop]) {
              dataset.question[prop] = true;
            }
            items.add(value2);
          });
        } else if (type2.isLiteralArrayType || type2.isTupleType) {
          dataset.#isLiteralArrayType = !!type2.isLiteralArrayType;
          dataset.hasTuplePrefix = !!type2.prefix;
          dataset.isTupleType = !!type2.isTupleType;
          dataset.isTupleUnion = this.forceNotTupleUnion ? false : MergeType.isTupleUnion(type2);
          type2.elements.forEach((item2, index) => {
            dataset.add(item2);
          });
        } else {
          dataset.#isLiteralArrayType = false;
        }
        return dataset;
      }
      add(stack, toLiteralValue = false, eliminateNullable = false) {
        let type2 = stack && stack.type();
        if (type2) {
          if (eliminateNullable && (type2.isNullableType || type2.isUndefinedType)) {
            return;
          }
          if (type2.isLiteralValueType) {
            this.types.set(type2.value, type2);
          } else if (toLiteralValue && type2.isLiteralType) {
            if (!type2.isLiteralValueType) {
              type2 = new LiteralType(type2.inherit, type2.target, type2.value, type2.compareLiteralValue);
              type2.setValueToShow();
            }
            this.types.set(type2.toString(), type2);
          } else if (type2.isLiteralArrayType || type2.isTupleType) {
            const originType = Utils.getOriginType(type2);
            this.types.set(originType, this.createGroup(stack));
          } else if (type2.isLiteralObjectType) {
            if (!this.keepOriginRefs) {
              const originType = Utils.getOriginType(type2);
              this.types.set(originType, this.createGroup(stack));
            } else {
              this.types.set(type2.toString({}, { toUniKeyValue: true }), stack);
            }
          } else if (type2.isUnionType) {
            type2.elements.forEach((item2) => {
              const type3 = item2.type();
              if (eliminateNullable && type3 && (type3.isNullableType || type3.isUndefinedType)) {
                return;
              }
              const key = type3.toString();
              if (!this.types.has(key)) {
                if (!this.keepOriginRefs) {
                  this.types.set(key, type3);
                } else {
                  this.types.set(key, item2);
                }
              }
            });
          } else if (type2.isClassGenericType) {
            const key = type2.inherit.type();
            let group = this.types.get(key);
            if (!group) {
              group = new MergeType();
              group.classGenericOriginType = type2;
              group.isClassGenericType = type2.isClassType;
              group.target = type2.target;
              this.types.set(key, group);
            }
            type2.types.forEach((item2, index) => {
              index = String(index);
              let merge = group.types.get(index);
              if (!merge) {
                merge = new MergeType();
                group.types.set(index, merge);
              }
              merge.add(item2);
            });
          } else if (type2.isModule && type2.isType) {
            this.types.set(type2, type2);
          } else if (type2.isInstanceofType) {
            this.types.set(type2.inherit, type2);
          } else if (type2.isGenericType) {
            this.types.set(type2, stack);
          } else {
            let key = type2.toString();
            if (!this.types.has(key)) {
              if (!this.keepOriginRefs) {
                this.types.set(key, type2);
              } else {
                this.types.set(key, stack);
              }
            }
          }
        }
      }
      type() {
        const origArrayType = Namespace.globals.get("Array");
        const origObjectType = Namespace.globals.get("Object");
        if (this.originType === origArrayType) {
          const elements = [];
          this.types.forEach((type2) => {
            if (type2 instanceof MergeType) {
              elements.push(type2.type());
            } else {
              elements.push(type2);
            }
          });
          if (this.#isLiteralArrayType && this.keepLiteralArrayType) {
            return Utils.setMergedType(new TupleType(origArrayType, elements));
          }
          if (!elements.length) {
            elements.push(Namespace.globals.get("any"));
          }
          return Utils.setMergedType(new TupleType(origArrayType, elements, this.target, false, this.isTupleUnion, !!this.hasTuplePrefix));
        } else if (this.originType === origObjectType) {
          const properties = /* @__PURE__ */ new Map();
          this.types.forEach((property, propName) => {
            if (property instanceof MergeType) {
              properties.set(propName, property.type());
            } else {
              properties.set(propName, property);
            }
          });
          return Utils.setMergedType(new LiteralObjectType(origObjectType, this.target, properties, this.dynamicProperties, this.question));
        }
        let items = Array.from(this.types.values()).map((item2) => item2.type());
        if (this.classGenericOriginType) {
          const classGenericeType = this.classGenericOriginType;
          const newObj = classGenericeType.newInstance(items, classGenericeType.inherit.type(), this.isClassGenericType, this.target);
          return Utils.setMergedType(newObj);
        }
        if (!(items.length > 0) || items.some((type2) => {
          type2 = type2.type();
          return type2.isAnyType && !type2.isUnknownType && !type2.isComputeType;
        })) {
          return Namespace.globals.get("any");
        }
        if (items.length > 1) {
          let i = 0;
          let first = null;
          while (i < items.length && items.length > 1) {
            const item2 = items[i];
            if (item2.isLiteralObjectType) {
              if (first === null) {
                first = !this.keepOriginRefs ? item2.clone(null, true) : item2;
                i++;
              } else {
                const dynamics = item2.dynamicProperties;
                if (dynamics) {
                  if (!first.dynamicProperties) {
                    first.dynamicProperties = dynamics;
                  } else {
                    dynamics.forEach((item3, key) => {
                      if (!first.dynamicProperties.has(key)) {
                        first.dynamicProperties.set(key, item3);
                      }
                    });
                  }
                }
                if (!(item2.properties.size > 0)) {
                  items.splice(i, 1);
                } else {
                  i++;
                }
              }
            } else {
              i++;
            }
          }
        }
        if (items.length > 1) {
          const dataset = /* @__PURE__ */ new Map();
          const numberTypes = ["int", "uint", "float", "double", "number"];
          items.forEach((item2) => {
            if (Utils.isGlobalShortenType(item2)) {
              let name = item2.toString();
              if (numberTypes.includes(name)) {
                if (name === "number") {
                  numberTypes.forEach((key) => {
                    dataset.delete(key);
                  });
                  dataset.set(name, item2);
                } else if (!dataset.has("number")) {
                  if (name === "unit") {
                    if (!dataset.has("int")) {
                      dataset.set(name, item2);
                    }
                  } else if (name === "double") {
                    if (!dataset.has("float")) {
                      dataset.set(name, item2);
                    }
                  } else {
                    dataset.set(name, item2);
                    if (name === "float") {
                      dataset.delete("double");
                    } else if (name === "int") {
                      dataset.delete("unit");
                    }
                  }
                }
              } else {
                dataset.set(name, item2);
              }
            } else {
              dataset.set(item2, item2);
            }
          });
          items = Array.from(dataset.values());
        }
        if (items.length > 1) {
          return Utils.setMergedType(new UnionType(items, this.target));
        }
        return items[0];
      }
      static forOfItem(type2, keepOriginRefs = true) {
        if (!type2)
          return type2;
        const origin = type2;
        while (type2 && type2.isAliasType) {
          type2 = type2.inherit.type();
        }
        if (!type2)
          return origin;
        if (type2.isLiteralArrayType || type2.isTupleType || type2.isLiteralObjectType || type2.isClassGenericType) {
          var mergeType = new MergeType();
          mergeType.keepOriginRefs = keepOriginRefs;
          if (type2.isClassGenericType) {
            type2.types.forEach((item2) => {
              mergeType.types.set(item2.type(), item2.type());
            });
          } else if (type2.isLiteralArrayType || type2.isTupleType) {
            type2.elements.forEach((item2) => {
              mergeType.add(item2.type());
            });
          } else {
            type2.properties.forEach((item2) => {
              mergeType.add(item2.type());
            });
          }
          return mergeType.type();
        }
        return origin;
      }
      static isTupleUnion(type2) {
        if (type2 && type2.isTupleType && type2.target && type2.target.isTypeTupleDefinition && !type2.prefix && !type2.isTupleUnion) {
          return false;
        }
        return true;
      }
      static isNeedMergeType(type2) {
        if (type2 && type2.isTupleType && type2.target && type2.target.isTypeTupleDefinition && !type2.prefix && !type2.isTupleUnion) {
          return false;
        }
        return true;
      }
      static to(stack, arrayToUnion = false, keepOriginRefs = false, toLiteralValue = false) {
        const type2 = stack && stack.type();
        if (type2) {
          if (type2.isLiteralArrayType || type2.isTupleType) {
            const origArrayType = Namespace.globals.get("Array");
            var mergeType = new MergeType(arrayToUnion ? null : origArrayType);
            mergeType.keepOriginRefs = keepOriginRefs;
            mergeType.hasTuplePrefix = !!type2.prefix;
            mergeType.isTupleType = !!type2.isTupleType;
            mergeType.isTupleUnion = MergeType.isTupleUnion(type2);
            mergeType.target = type2.target;
            type2.elements.forEach((item2) => {
              mergeType.add(item2, toLiteralValue);
            });
            return mergeType.type();
          } else if (type2.isLiteralObjectType) {
            if (keepOriginRefs) {
              return stack;
            }
            const origObjectType = Namespace.globals.get("Object");
            var mergeType = new MergeType(arrayToUnion ? null : origObjectType);
            mergeType.keepOriginRefs = keepOriginRefs;
            mergeType.dynamicProperties = type2.dynamicProperties;
            mergeType.target = type2.target;
            type2.properties.forEach((value2, prop) => {
              mergeType.types.set(prop, MergeType.to(value2, false, keepOriginRefs));
            });
            return mergeType.type();
          } else if (type2.isUnionType) {
            var mergeType = new MergeType();
            mergeType.keepOriginRefs = keepOriginRefs;
            mergeType.target = type2.target;
            type2.elements.forEach((item2) => {
              mergeType.add(item2);
            });
            return mergeType.type();
          } else {
            if (keepOriginRefs) {
              return stack;
            } else {
              return type2;
            }
          }
        }
        return Namespace.globals.get("any");
      }
      static arrayToTuple(items, isTupleUnion = true, prefix = true, target = null) {
        const mergeType = new MergeType(Namespace.globals.get("Array"));
        mergeType.hasTuplePrefix = prefix;
        mergeType.isTupleType = true;
        mergeType.isTupleUnion = isTupleUnion;
        mergeType.target = target;
        items.forEach((item2) => {
          mergeType.add(item2);
        });
        return mergeType.type();
      }
      static arrayToUnion(items, target = null, toLiteralValue = false) {
        const mergeType = new MergeType();
        mergeType.target = target;
        items.forEach((item2) => {
          mergeType.add(item2, toLiteralValue);
        });
        return mergeType.type();
      }
      static mergeTupleElement(type2) {
        if (!type2 || !type2.isTupleType) {
          return type2;
        }
        if (type2.elements.length > 1) {
          const base = type2.elements.find((el) => {
            const type3 = el.type();
            return type3.isTupleType && type3.isTupleUnion && type3.elements.length > 1;
          });
          if (base) {
            const baseType = base.type();
            const origArrayType = Namespace.globals.get("Array");
            const mergeType = new MergeType(origArrayType);
            mergeType.hasTuplePrefix = baseType.prefix;
            mergeType.isTupleType = true;
            mergeType.isTupleUnion = baseType.isTupleUnion;
            mergeType.target = baseType.target;
            baseType.elements.forEach((item2) => {
              mergeType.add(item2);
            });
            type2.elements.forEach((item2) => {
              if (item2 !== base) {
                mergeType.add(item2);
              }
            });
            return Utils.setMergedType(new TupleType(origArrayType, [mergeType.type()], type2.target, false, type2.isTupleUnion, type2.prefix));
          }
        }
        return type2;
      }
    };
    module.exports = MergeType;
  }
});

// lib/core/Cache.js
var require_Cache = __commonJS({
  "lib/core/Cache.js"(exports, module) {
    var groups = /* @__PURE__ */ new Map();
    var Cache = class {
      static clearAll() {
        groups.forEach((cache) => {
          cache.clear();
        });
      }
      static group(name) {
        let cache = groups.get(name);
        if (!cache) {
          cache = new Cache(name);
        }
        return cache;
      }
      static global() {
        return this.group("global");
      }
      static each(finder) {
        groups.forEach((cache) => {
          cache.keys().forEach((key) => finder(key, cache));
        });
      }
      static keys(finder) {
        const dataset = /* @__PURE__ */ new Map();
        groups.forEach((cache) => {
          if (finder) {
            dataset.set(cache, cache.keys().filter((key) => {
              return finder(key, cache);
            }));
          } else {
            dataset.set(cache, cache.keys());
          }
        });
        return dataset;
      }
      static all() {
        return Array.from(groups.values());
      }
      constructor(name) {
        this.name = name;
        this.dataset = /* @__PURE__ */ new Map();
        groups.set(name, this);
      }
      get size() {
        return this.dataset.size;
      }
      get(name) {
        if (this.has(name)) {
          return this.dataset.get(name);
        }
        return void 0;
      }
      set(name, value2) {
        this.dataset.set(name, value2);
        return this;
      }
      has(name) {
        return this.dataset.has(name);
      }
      records(name, initValue = true, flag = true) {
        if (!name)
          return flag;
        if (!this.has(name)) {
          this.set(name, initValue);
          return false;
        } else {
          return true;
        }
      }
      clear(name) {
        if (name) {
          delete this.dataset.delete(name);
        } else {
          this.dataset.clear();
        }
      }
      values() {
        return Array.from(this.dataset.values());
      }
      keys() {
        return Array.from(this.dataset.keys());
      }
    };
    module.exports = Cache;
  }
});

// lib/core/JSModule.js
var require_JSModule = __commonJS({
  "lib/core/JSModule.js"(exports, module) {
    var LiteralObjectType = require_LiteralObjectType();
    var Cache = require_Cache();
    var AutoImporter = require_AutoImporter();
    var Module = require_Module();
    var Namespace = require_Namespace();
    var Utils = require_Utils();
    var moduleKey = Symbol("JSModule");
    var privateKey = Symbol("privateKey");
    var JSModuleNamespace = Symbol("JSModuleNamespace");
    var records = Cache.group("JSModule.records");
    var recordFiles = Cache.group("JSModule.recordFiles");
    var caches = Cache.group("JSModule.cache");
    var resolves = Cache.group("JSModule.resolves");
    var namespaces = Cache.group("JSModule.namespaces");
    var moduleNamespace = new Namespace("");
    moduleNamespace[JSModuleNamespace] = true;
    namespaces.set("#global#", moduleNamespace);
    var JSModule = class {
      static is(module2) {
        return module2 && module2[moduleKey] === true;
      }
      static isJSModuleNamespace(ns) {
        return ns && ns[JSModuleNamespace] === true;
      }
      static getGlobalNs() {
        return moduleNamespace;
      }
      static getModule(sourceId, resolvePath) {
        let result = records.get(sourceId);
        if (result)
          return result;
        if (resolves.size > 0) {
          const source = resolvePath || sourceId;
          const key = resolvePath ? resolvePath + ":" + sourceId : sourceId;
          result = caches.get(key);
          if (result) {
            return result;
          }
          for (let [value2, regexp] of resolves.dataset) {
            if (regexp.test(source)) {
              caches.set(key, value2);
              return value2;
            }
          }
        }
        return null;
      }
      static getNamespace(id = "", parent = null) {
        if (!id) {
          return JSModule.getGlobalNs();
        }
        if (id === "global") {
          return Namespace.top;
        }
        const items = id.split(".");
        let key = null;
        let base = null;
        if (items[0] === "global") {
          items.shift();
          base = Namespace.top;
        } else {
          base = parent || JSModule.getGlobalNs();
        }
        while (key = items.shift()) {
          if (base.children.has(key)) {
            base = base.children.get(key);
          } else {
            const ns = new Namespace(key);
            if (base[JSModuleNamespace]) {
              ns[JSModuleNamespace] = true;
            }
            ns.parent = base;
            base.children.set(key, ns);
            base = ns;
          }
        }
        return base;
      }
      static getType(id, onlyType = false, isMember = false) {
        if (!id || id === "global") {
          return null;
        }
        const at = id.lastIndexOf(".");
        if (at < 1) {
          return null;
        }
        let key = id.substring(0, at);
        let name = id.slice(at + 1);
        let ns = JSModule.getNamespace(key);
        if (!ns)
          return null;
        let module2 = ns.modules.get(ns.id);
        if (module2) {
          if (isMember) {
            return module2.namespaces.get(name) || module2.getType(name);
          }
          return module2.getType(name) || (!onlyType ? module2.namespaces.get(name) : null);
        }
        return null;
      }
      static createModuleFromNamespace(id, module2, compilation) {
        let ns = id.includes(".") ? JSModule.getNamespace(id) : JSModule.getNamespace(id, module2 ? module2.namespace : null);
        let key = ns.id;
        if (!key) {
          return ns;
        }
        let nsModule = ns.modules.get(key);
        if (!nsModule && key) {
          nsModule = new JSModule(compilation, key);
          nsModule.#isNamespaceModule = true;
          nsModule.#namespace = ns;
          if (module2) {
            module2.namespaces.set(key, nsModule);
          }
          ns.modules.set(key, nsModule);
        } else {
          if (module2 && !module2.namespaces.has(key)) {
            module2.namespaces.set(key, nsModule);
          }
        }
        return nsModule;
      }
      static createModule(id, compilation) {
        let module2 = JSModule.get(id);
        if (!module2) {
          module2 = new JSModule(compilation, id);
          module2.#namespace = JSModule.getNamespace();
          JSModule.set(id, module2);
          if (compilation.file) {
            if (!recordFiles.has(compilation.file)) {
              recordFiles.set(compilation.file, module2);
            }
          }
        }
        return module2;
      }
      static getModuleFromNamespace(id) {
        if (!id || id === "global") {
          return null;
        }
        const items = id.split(".");
        if (items[0] === "global") {
          return null;
        }
        let key = null;
        let base = JSModule.getGlobalNs();
        let module2 = null;
        while (key = items.shift()) {
          if (base.children.has(key)) {
            base = base.children.get(key);
            module2 = base.modules.get(key);
          } else {
            return null;
          }
        }
        return module2;
      }
      static getByFile(file) {
        return recordFiles.get(file);
      }
      static get(id) {
        return records.get(id);
      }
      static set(id, module2) {
        if (id.includes("*")) {
          resolves.set(module2, new RegExp("^" + id.replace(/\//g, "\\/").replace(/\./g, "\\.").replace(/\*/g, ".*") + "$"));
        }
        return records.set(id, module2);
      }
      #stacks = [];
      #exports = /* @__PURE__ */ new Map();
      #children = /* @__PURE__ */ new Map();
      #descriptors = /* @__PURE__ */ new Map();
      #types = /* @__PURE__ */ new Map();
      #id = "";
      #isJSModule = true;
      #namespace = null;
      #file = "";
      #isNamespaceModule = false;
      #compilation = null;
      #references = null;
      constructor(compilation, id) {
        this.#id = id;
        this.#compilation = compilation;
        this.#file = compilation.file;
        this[moduleKey] = true;
        compilation.on("onClear", () => this.clear());
      }
      addJSModuleRefs(jsModule) {
        if (jsModule) {
          const refs = this.#references || (this.#references = /* @__PURE__ */ new Set());
          refs.add(jsModule);
        }
      }
      get compilation() {
        return this.#compilation;
      }
      get isNamespaceModule() {
        return this.#isNamespaceModule;
      }
      get file() {
        return this.#file;
      }
      get namespace() {
        return this.#namespace;
      }
      get isJSModule() {
        return this.#isJSModule;
      }
      get types() {
        return this.#types;
      }
      get descriptors() {
        return this.#descriptors;
      }
      get namespaces() {
        return this.#children;
      }
      get exports() {
        return this.#exports;
      }
      get id() {
        return this.#id;
      }
      description() {
        return this;
      }
      descriptor() {
        return this;
      }
      toString() {
        return this.id;
      }
      getExportCount() {
        return this.exports.size;
      }
      clear(compilation) {
        compilation = compilation || this.compilation;
        this.exports.forEach((desc, key) => {
          if (desc.compilation === compilation) {
            this.exports.delete(key);
          }
        });
        this.namespaces.forEach((module2, key) => {
          module2.clear(compilation);
          if (module2.compilation === compilation) {
            this.namespaces.delete(key);
          }
        });
        this.descriptors.forEach((items) => {
          items.forEach((item2) => {
            if (item2.compilation === compilation) {
              let index = items.indexOf(item2);
              items.splice(index, 1);
            }
          });
        });
        this.types.forEach((desc, key) => {
          const type2 = desc.type();
          if (Module.is(type2)) {
            type2.clear(compilation);
          }
          if (desc.compilation === compilation) {
            this.types.delete(key);
          }
        });
        let stacks = this.getStacks();
        stacks.forEach((stack) => {
          if (stack.compilation === compilation) {
            let index = stacks.indexOf(stack);
            stacks.splice(index, 1);
          }
        });
        if (this.namespace) {
          this.namespace.clear(compilation);
        }
        const refs = this.#references;
        if (refs) {
          refs.forEach((jsModule) => jsModule.clear(compilation));
        }
        recordFiles.clear(compilation.file);
      }
      addStack(value2) {
        if (!this.#stacks.length || this.compilation !== value2.compilation) {
          this.#stacks.push(value2);
        }
      }
      getStack() {
        return this.#stacks[0];
      }
      getStacks() {
        return this.#stacks;
      }
      definition(ctx) {
        const desc = this.exports.get("*");
        if (desc && desc.isExportAssignmentDeclaration && desc.expression.isIdentifier) {
          let key = desc.expression.value();
          let items = this.descriptors.get(key);
          if (!items && this.types.has(key)) {
            items = [this.types.get(key)];
          }
          if (items) {
            return items.concat(this.#stacks).map((stack) => stack.definition(ctx));
          }
        }
        return this.#stacks.map((stack) => stack.definition(ctx));
      }
      hover(ctx) {
        const desc = this.exports.get("*");
        let stack = this.#stacks[0];
        let members = null;
        if (desc && desc.isExportAssignmentDeclaration && desc.expression.isIdentifier) {
          let key = desc.expression.value();
          let items = this.descriptors.get(key);
          if (!items && this.types.has(key)) {
            items = [this.types.get(key)];
          }
          if (items) {
            members = items.map((item2) => item2.hover(ctx));
          }
        }
        let def = stack.hover(ctx);
        let overview = this.#stacks.filter((item2) => item2 !== stack).map((stack2) => stack2.definition(ctx));
        if (members) {
          overview = overview.concat(members);
        }
        return stack.formatHover(def, overview);
      }
      type() {
        return this.getExportObjectType();
      }
      getDefaultExported() {
        if (this.exports.size === 0) {
          return null;
        }
        let value2 = this.exports.get("default");
        if (value2) {
          return value2;
        }
        const fetch = (type2) => {
          if (!type2)
            return null;
          if (type2.isLiteralObjectType) {
            return type2.attributes.get("default");
          } else if (type2.isIntersectionType) {
            return fetch(type2.left.type()) || fetch(type2.right.type());
          }
          return null;
        };
        for (let [key, desc] of this.exports) {
          if (desc) {
            let result = fetch(desc.type());
            if (result)
              return result;
          }
        }
        return null;
      }
      getExport(name, flag = false) {
        let desc = this.exports.get(name);
        if (desc) {
          if (flag)
            return desc;
          return desc.description();
        }
        if (this.exports.has(this.id)) {
          let nsModule = this.namespaces.get(this.id);
          if (nsModule) {
            let desc2 = nsModule.getDescriptor(name);
            if (desc2) {
              return desc2;
            }
          }
        }
        let items = [];
        let starDesc = this.exports.get("*");
        if (starDesc)
          items.push(starDesc);
        items.push(...Array.from(this.exports.values()).filter((stack) => stack.isExportAllDeclaration && stack !== desc));
        if (!items.length) {
          return null;
        }
        for (let i = 0; i < items.length; i++) {
          let res = this.findExportItem(items[i], name, flag);
          if (res)
            return res;
        }
        return null;
      }
      findExportItem(desc, name, flag) {
        if (desc.isExportAssignmentDeclaration) {
          if (name !== "default") {
            const isRefs = desc.expression.isIdentifier;
            if (isRefs) {
              let nsModule = this.namespaces.get(desc.expression.value());
              if (nsModule) {
                let desc2 = nsModule.getDescriptor(name) || nsModule.getExport(name, flag);
                if (desc2) {
                  return desc2;
                }
              }
            }
          }
          desc = desc.description();
          if (desc) {
            if (desc.isClassDeclaration || desc.isDeclaratorDeclaration || desc.isEnumDeclaration || desc.isInterfaceDeclaration || desc.isTypeStatement || desc.isDeclaratorFunction || desc.isDeclaratorVariable || desc.isDeclaratorTypeAlias || desc.isStructTableDeclaration) {
              if (name === "default") {
                return desc;
              }
            }
            if (desc.isObjectExpression) {
              return desc.attribute(name);
            } else if (desc.isNamespaceDeclaration) {
              if (desc.module) {
                return desc.module.getExport(name, flag);
              }
            } else {
              return this.getExportFromType(desc.type(), name, desc);
            }
          }
        } else if (desc.isExportAllDeclaration) {
          if (name === "default")
            return null;
          if (desc.source) {
            const jsModule = desc.getResolveJSModule();
            if (jsModule) {
              return jsModule.getExport(name, flag);
            } else {
              return desc.getAllExportDescriptors().get(name);
            }
          } else if (JSModule.is(desc.module)) {
            return desc.module.getDescriptor(name);
          }
        }
      }
      getExportFromType(type2, name, stack) {
        if (!type2)
          return null;
        if (type2.isLiteralObjectType) {
          return type2.attributes.get(name);
        } else if (type2.isIntersectionType) {
          return this.getExportFromType(type2.left.type(), name) || this.getExportFromType(type2.right.type(), name);
        } else if (type2.isUnionType) {
          for (let i = 0; i < type2.elements.length; i++) {
            const result = this.getExportFromType(type2.elements[i].type(), name, stack);
            if (result) {
              return result;
            }
          }
        } else if (stack && stack.isStack && stack.getObjectDescriptor) {
          return stack.getObjectDescriptor(type2, name);
        }
        return null;
      }
      getExportObjectType() {
        const obj = this._exportAllObject;
        if (obj)
          return obj;
        const object = new LiteralObjectType(Namespace.globals.get("object"), null, this.getAllExportDescriptors());
        object.isJSModuleType = true;
        this._exportAllObject = object;
        return object;
      }
      getAllExportDescriptors() {
        let exists = this._allExportDescriptors;
        if (exists)
          return exists;
        if (this.exports.size === 0) {
          return this.getAllDescriptors();
        }
        const properties = this._allExportDescriptors = /* @__PURE__ */ new Map();
        let exportAllDecls = [];
        this.exports.forEach((value2, key) => {
          if (value2.isExportAllDeclaration || value2.isExportAssignmentDeclaration) {
            exportAllDecls.push(value2);
            return;
          }
          properties.set(key, value2);
        });
        if (this.exports.has(this.id)) {
          let nsModule = this.namespaces.get(this.id);
          if (nsModule) {
            nsModule.getAllDescriptors().forEach((value2, key) => {
              properties.set(key, value2);
            });
          }
        }
        if (!exportAllDecls.length) {
          return properties;
        }
        exportAllDecls.forEach((desc) => {
          if (desc.isExportAssignmentDeclaration) {
            const isRefs = desc.expression.isIdentifier;
            let nsModule = null;
            let key = null;
            if (isRefs) {
              key = desc.expression.value();
              nsModule = this.namespaces.get(key);
              if (nsModule) {
                nsModule.getAllDescriptors().forEach((value2, key2) => {
                  properties.set(key2, value2);
                });
              }
            }
            desc = desc.description();
            if (desc) {
              if (desc.isClassDeclaration || desc.isDeclaratorDeclaration || desc.isEnumDeclaration || desc.isInterfaceDeclaration || desc.isDeclaratorVariable || desc.isDeclaratorFunction || desc.isDeclaratorTypeAlias || desc.isStructTableDeclaration) {
                properties.set(desc.value(), desc);
              } else if (desc.isObjectExpression) {
                desc.properties.forEach((value2, key2) => {
                  properties.set(key2, value2);
                });
              } else if (desc.isNamespaceDeclaration && desc.module && nsModule !== desc.module) {
                if (desc.module.exports.size > 0) {
                  desc.module.getAllExportDescriptors().forEach((value2, key2) => {
                    properties.set(key2, value2);
                  });
                } else {
                  desc.module.getAllDescriptors().forEach((value2, key2) => {
                    properties.set(key2, value2);
                  });
                }
              } else if (key) {
                const _desc = desc.descriptor();
                if (JSModule.is(_desc)) {
                  _desc.getAllExportDescriptors().forEach((value2, key2) => {
                    properties.set(key2, value2);
                  });
                } else {
                  properties.set(key, _desc);
                }
              }
            }
          } else if (desc.isExportAllDeclaration) {
            let object = null;
            if (desc.source) {
              const jsModule = desc.getResolveJSModule();
              if (jsModule) {
                object = jsModule.getAllExportDescriptors();
              } else {
                object = desc.getAllExportDescriptors();
              }
            } else if (JSModule.is(desc.module)) {
              object = desc.module.getAllDescriptors();
            }
            if (object) {
              object.forEach((value2, key) => {
                properties.set(key, value2);
              });
            }
          }
        });
        return properties;
      }
      getExportDefaultNamespace() {
        let exported = this.exports.get("default");
        if (exported) {
          let desc = exported.description();
          if (desc && desc.isNamespaceDeclaration) {
            return desc.module;
          }
        }
        for (let [key, exported2] of this.exports) {
          if (!exported2)
            continue;
          let result = null;
          if (exported2.isExportAssignmentDeclaration) {
            const key2 = exported2.expression.isIdentifier ? exported2.expression.value() : null;
            result = this.namespaces.get(key2);
          } else if (exported2.isExportAllDeclaration) {
            if (exported2.source) {
              const jsModule = exported2.getResolveJSModule();
              if (jsModule) {
                result = jsModule.getExportDefaultNamespace();
              }
            }
          }
          if (result) {
            return result;
          }
        }
        return null;
      }
      getModuleDefaultDesriptor(property = null) {
        const get = (desc, id) => {
          if (desc) {
            if (desc.isDeclaratorVariable) {
              if (property) {
                if (desc.getObjectDescriptor(desc.type(), property)) {
                  return desc;
                }
              } else {
                return desc;
              }
            }
            if (desc.isClassDeclaration || desc.isDeclaratorDeclaration || desc.isEnumDeclaration || desc.isInterfaceDeclaration || desc.isDeclaratorTypeAlias || desc.isStructTableDeclaration) {
              return desc.type();
            } else if (desc.isObjectExpression) {
              return desc.properties.get("default");
            } else if (desc.isNamespaceDeclaration && desc.module) {
              return property && desc.module.hasDescriptor(property) ? desc.module : null;
            } else if (Utils.isStack(desc)) {
              desc = desc.descriptor();
              if (JSModule.is(desc)) {
                return desc.getModuleDefaultDesriptor();
              }
            }
          }
          if (property && id) {
            let nsModule = this.namespaces.get(id);
            if (nsModule && nsModule.hasDescriptor(property)) {
              return nsModule;
            }
          }
          return desc;
        };
        let exported = this.exports.get("default");
        if (exported) {
          let desc = exported.description();
          if (desc) {
            return get(desc);
          }
        }
        for (let [key, exported2] of this.exports) {
          if (!exported2)
            continue;
          let result = null;
          if (exported2.isExportAssignmentDeclaration) {
            result = get(exported2.description(), property && exported2.expression.isIdentifier ? exported2.expression.value() : null);
          } else if (exported2.isExportAllDeclaration) {
            if (exported2.source) {
              const jsModule = exported2.getResolveJSModule();
              if (jsModule) {
                result = jsModule.getModuleDefaultDesriptor(property);
              }
            }
          }
          if (result) {
            return result;
          }
        }
        return null;
      }
      createImportDescriptors(source) {
        source = source || this.id;
        const records2 = this.__createImportDescriptors || (this.__createImportDescriptors = /* @__PURE__ */ Object.create(null));
        if (records2[source]) {
          return records2[source];
        }
        const properties = records2[source] = /* @__PURE__ */ new Map();
        const createItem = (source2, local2, imported, extract, origin, desc = null, owner = null, isDefault = false) => {
          const item2 = AutoImporter.create(source2, local2, imported, extract, isDefault, origin);
          item2.owner = owner;
          item2.description = desc;
          return item2;
        };
        const cache = /* @__PURE__ */ new WeakSet();
        const createAll = (object, source2, extract = true) => {
          if (cache.has(object))
            return;
          cache.add(object);
          object.types.forEach((value2, key) => {
            const type2 = value2.type();
            if (Module.is(type2) && type2.isClass) {
              properties.set(key, createItem(source2, key, key, extract, value2, type2, object));
            }
          });
          object.descriptors.forEach((value2, key) => {
            const items = value2.filter((item2) => item2.isDeclaratorFunction || item2.isDeclaratorVariable);
            if (items[0]) {
              properties.set(key, createItem(source2, key, key, extract, items[0], items[0], object));
            }
          });
          return properties;
        };
        if (this.exports.size === 0) {
          return createAll(this, source);
        }
        this.exports.forEach((value2, key) => {
          if (value2.isExportDefaultDeclaration) {
            const desc = value2.description();
            const key2 = this.id;
            properties.set(key2, createItem(source, key2, key2, false, value2, desc, this, true));
          } else if (value2.isExportSpecifier) {
            let exported = value2.exported.value();
            let local2 = value2.local.value();
            let desc = value2.description();
            if (desc.isDeclaratorVariable || desc.isDeclaratorFunction) {
              properties.set(key, createItem(source, exported, local2, true, value2, desc, this));
            } else if (desc.isClassDeclaration || desc.isDeclaratorDeclaration) {
              const type2 = desc.type();
              if (Module.is(type2) && type2.isClass) {
                properties.set(type2.id, createItem(source, type2.id, type2.id, false, value2, desc, this));
              }
            }
          } else if (value2.isExportNamedDeclaration) {
            const decl2 = value2.declaration;
            if (decl2) {
              if (decl2.isVariableDeclaration || decl2.isDeclaratorVariable) {
                decl2.declarations.forEach((decl3) => {
                  let key2 = decl3.id.value();
                  properties.set(key2, createItem(source, key2, key2, true, decl3, decl3.description(), this));
                });
              } else if (decl2.isNamespaceDeclaration) {
                if (decl2.module) {
                  createAll(decl2.module, source);
                }
              } else if (decl2.isDeclaratorDeclaration || decl2.isClassDeclaration) {
                let key2 = decl2.value();
                let type2 = decl2.type();
                if (Module.is(type2) && type2.isClass) {
                  properties.set(key2, createItem(source, key2, key2, true, decl2, type2, this));
                }
              } else if (decl2.isDeclaratorFunction) {
                key = decl2.value();
                properties.set(key, createItem(source, key, key, true, decl2, decl2, this));
              }
            }
          } else if (value2.isExportAssignmentDeclaration) {
            const isRefs = value2.expression.isIdentifier;
            let nsModule = null;
            if (isRefs) {
              nsModule = this.namespaces.get(value2.expression.value());
              if (nsModule) {
                createAll(nsModule, source);
              }
            }
            const origin = value2;
            let desc = desc.description();
            if (desc) {
              if (desc.isDeclaratorVariable || desc.isDeclaratorFunction) {
                const key2 = desc.value();
                properties.set(key2, createItem(source, key2, key2, false, origin, desc, this));
              } else if (desc.isClassDeclaration || desc.isDeclaratorDeclaration) {
                const key2 = desc.value();
                const type2 = desc.type();
                if (Module.is(type2) && type2.isClass) {
                  properties.set(key2, createItem(source, key2, key2, false, origin, type2, this));
                }
              } else if (desc.isObjectExpression) {
                desc.properties.forEach((value3, key2) => {
                  if (key2 === "default") {
                    properties.set(key2, createItem(source, key2, key2, false, origin, value3, this, true));
                  } else {
                    properties.set(key2, createItem(source, key2, key2, true, origin, value3, this));
                  }
                });
              } else if (desc.isNamespaceDeclaration && desc.module && nsModule !== desc.module) {
                createAll(desc.module, source);
              }
            }
          } else if (value2.isExportAllDeclaration) {
            if (value2.source) {
              const jsModule = value2.getResolveJSModule();
              if (jsModule) {
                if (value2.exported) {
                  let key2 = value2.exported.value();
                  properties.set(key2, createItem(source, key2, "*", true, value2, jsModule, jsModule));
                } else {
                  jsModule.createImportDescriptors(source).forEach((value3, key2) => {
                    properties.set(key2, value3);
                  });
                }
              } else {
                value2.getAllExportDescriptors().forEach((value3, key2) => {
                  properties.set(key2, value3);
                });
              }
            } else if (JSModule.is(value2.module)) {
              createAll(value2.module, source);
            }
          }
        });
        if (this.exports.has(source)) {
          let nsModule = this.namespaces.get(source);
          if (nsModule) {
            createAll(nsModule, source);
          }
        }
        return properties;
      }
      getAllDescriptors() {
        const exists = this._allDescriptors;
        if (exists)
          return exists;
        const properties = /* @__PURE__ */ new Map();
        this._allDescriptors = properties;
        this.descriptors.forEach((value2, key) => {
          if (value2[0] && !value2[0].isTypeStatement)
            properties.set(key, value2[0]);
        });
        return properties;
      }
      get(name = "default", ns = null) {
        if (name === "default") {
          return this.getDefaultExported();
        }
        let object = this.exports.get(name);
        if (object)
          return object;
        if (!ns)
          ns = this.id;
        if (ns) {
          let module2 = this.namespaces.get(ns);
          if (module2) {
            return module2.getType(name) || module2.getDescriptor(name);
          }
        }
        return null;
      }
      has(name) {
        return this.exports.has(name);
      }
      set(name, desc) {
        if (name === "default" || !this.exports.has(name)) {
          this.exports.set(name, desc);
        }
      }
      del(name) {
        this.exports.delete(name);
      }
      sorting(dataset) {
        const priority = (item2) => {
          const type2 = item2.type();
          if (!type2 || type2.isGenericType)
            return 1;
          if (type2.isLiteralType && type2.isLiteralValueType) {
            return 6;
          } else if (type2.isIntersectionType) {
            return 5;
          } else if (type2.isClassGenericType) {
            const wrap = type2.inherit.type();
            if (wrap && wrap.target && wrap.target.isDeclaratorTypeAlias && wrap.target.genericity) {
              return 4;
            }
          } else if (type2.isUnionType) {
            return 2;
          }
          return 3;
        };
        dataset.sort((a, b) => {
          if (!a.isDeclaratorFunction) {
            if (!b.isDeclaratorFunction)
              return 0;
            return 1;
          }
          if (!b.isDeclaratorFunction) {
            if (!a.isDeclaratorFunction)
              return 0;
            return -1;
          }
          if (a.params.length < b.params.length) {
            return -1;
          } else if (a.params.length > b.params.length) {
            return 1;
          }
          const a1 = a.params.reduce((acc, item2) => {
            if (item2.question)
              acc--;
            return acc + priority(item2);
          }, 0);
          const b1 = b.params.reduce((acc, item2) => {
            if (item2.question)
              acc--;
            return acc + priority(item2);
          }, 0);
          if (a1 === b1)
            return 0;
          return a1 > b1 ? -1 : 1;
        });
        return dataset;
      }
      hasDescriptor(name) {
        return this.descriptors.has(name) || this.exports.has(name);
      }
      getDescriptor(name, filter, { isNew, isCall, isMember } = {}, result = null) {
        let dataset = this.descriptors.get(name);
        if (!dataset) {
          let exported = this.exports.get(name);
          if (exported) {
            let desc = exported.descriptor();
            if (desc) {
              if (desc.isModuleDeclaration) {
                if (desc.module) {
                  return desc.module;
                }
                return null;
              } else if (JSModule.is(desc)) {
                return desc;
              } else if (JSModule.is(desc.module) && desc.module !== this) {
                return desc.module.getDescriptor(desc.value(), filter, { isNew, isCall, isMember }, result);
              }
            }
            return desc;
          } else {
            const find = (desc) => {
              if (!desc)
                return null;
              if (desc.isExportAllDeclaration) {
                if (desc.source) {
                  const jsModule = desc.getResolveJSModule();
                  if (jsModule) {
                    return jsModule.getDescriptor(name, filter, { isNew, isCall, isMember }, result);
                  } else {
                    let result2 = desc.getAllExportDescriptors().get(name);
                    if (result2) {
                      dataset = [result2];
                    }
                  }
                }
              } else if (desc.isExportAssignmentDeclaration) {
                if (desc.expression.isIdentifier) {
                  const key = desc.expression.value();
                  let _desc = desc.expression.description();
                  if (_desc && (_desc.isImportNamespaceSpecifier || _desc.isImportDefaultSpecifier || _desc.isImportSpecifier)) {
                    let descriptor = _desc.descriptor();
                    if (JSModule.is(descriptor)) {
                      return descriptor.getDescriptor(name, filter, { isNew, isCall, isMember }, result);
                    }
                  }
                  if (this.id === key && _desc) {
                    if (isMember) {
                      if (_desc.isDeclaratorVariable || _desc.isDeclaratorFunction) {
                        let descriptor = desc.expression.getObjectDescriptor(_desc.type(), name);
                        if (descriptor)
                          return descriptor;
                      }
                    }
                  }
                  const nsModule = this.namespaces.get(key);
                  if (nsModule) {
                    return nsModule.getDescriptor(name, filter, { isNew, isCall, isMember }, result);
                  } else {
                    dataset = this.descriptors.get(key);
                  }
                }
              }
            };
            for (let [key, desc] of this.exports) {
              const result2 = find(desc);
              if (result2) {
                return result2;
              }
              if (dataset) {
                break;
              }
            }
          }
        }
        if (dataset) {
          if (!filter) {
            return dataset[0] || result;
          } else {
            if (!dataset[privateKey]) {
              dataset[privateKey] = true;
              this.sorting(dataset);
            }
            for (let i = 0; i < dataset.length; i++) {
              const desc = dataset[i];
              const value2 = filter(desc, result, i, dataset);
              if (value2) {
                if (value2 === true) {
                  return desc;
                } else {
                  result = value2;
                }
              }
            }
          }
        }
        return result;
      }
      addDescriptor(name, descriptor) {
        let dataset = this.descriptors.get(name);
        if (!dataset) {
          dataset = [];
          this.descriptors.set(name, dataset);
        }
        if (descriptor.isDeclaratorVariable || descriptor.isDeclaratorFunction) {
          dataset.unshift(descriptor);
        } else {
          dataset.push(descriptor);
        }
      }
      setType(name, stack) {
        this.types.set(name, stack);
        this.addDescriptor(name, stack);
      }
      getType(id) {
        const desc = this.__getType(id);
        if (desc) {
          return desc.type();
        }
        return null;
      }
      __getType(id) {
        if (!id)
          return null;
        if (id.includes(".")) {
          const items = id.split(".");
          const name = items.pop();
          let module2 = this;
          while (items.length > 0 && module2) {
            const key = items.shift();
            module2 = module2.namespaces.get(key);
          }
          if (module2) {
            return module2.types.get(name);
          }
          return null;
        }
        return this.types.get(id);
      }
    };
    module.exports = JSModule;
  }
});

// lib/core/Predicate.js
var require_Predicate = __commonJS({
  "lib/core/Predicate.js"(exports, module) {
    var Predicate = class {
      static create(type2, desc = null, origin = null, cacheId = null) {
        return new Predicate(origin, type2, desc, cacheId);
      }
      static attribute(key, value2, origin = null) {
        const pred = new Predicate(origin);
        pred.setAttribute(key, value2);
        return pred;
      }
      #origin = null;
      #type = null;
      #desc = null;
      #attributes = null;
      #scope = null;
      #cacheId = null;
      constructor(origin = null, type2 = null, desc = null, cacheId = null) {
        this.#origin = origin;
        this.#type = type2;
        this.#desc = desc;
        this.#cacheId = cacheId;
      }
      get cacheId() {
        return this.#cacheId;
      }
      get scope() {
        return this.#scope;
      }
      set scope(value2) {
        this.#scope = value2;
      }
      get type() {
        return this.#type;
      }
      set type(value2) {
        this.#type = value2;
      }
      get origin() {
        return this.#origin;
      }
      get desc() {
        return this.#desc;
      }
      set desc(value2) {
        this.#desc = value2;
      }
      get attributes() {
        return this.#attributes || (this.#attributes = /* @__PURE__ */ Object.create(null));
      }
      getAttribute(key, defaultValue = null) {
        return this.attributes[key] || defaultValue;
      }
      setAttribute(key, value2) {
        this.attributes[key] = value2;
      }
    };
    module.exports = Predicate;
  }
});

// lib/core/Inference.js
var require_Inference = __commonJS({
  "lib/core/Inference.js"(exports, module) {
    var Namespace = require_Namespace();
    var MergeType = require_MergeType();
    var Utils = require_Utils();
    var LiteralType = require_LiteralType();
    function getComputeValue(object, property) {
      const getProperty2 = (object2, propName, propertyType) => {
        let result = null;
        if (object2.isInstanceofType) {
          if (propName) {
            result = object2.inherit.getDescriptor(propName, (desc, prev) => {
              if ((desc.isPropertyDefinition || desc.isMethodGetterDefinition) && Utils.isModifierPublic(desc)) {
                return true;
              }
              return prev || desc;
            });
          }
          if (!result) {
            result = object2.inherit.dynamicAttribute(propertyType);
          }
          if (result && result.isStack && !Utils.isModifierPublic(result)) {
            return null;
          }
        } else if (object2.isLiteralObjectType) {
          result = propName && object2.attribute(propName) || object2.dynamicAttribute(propertyType);
        } else if (object2.isLiteralArrayType || object2.isTupleType) {
          const propIndex = propName === null ? -1 : parseInt(propName);
          if (propIndex >= 0 && propIndex < object2.elements.length) {
            result = object2.elements[propName];
          }
          if (!result) {
            result = object2.dynamicAttribute(propertyType);
          }
        } else {
          object2 = Utils.getOriginType(object2);
          if (object2.isInterface && object2.isModule) {
            if (propName) {
              result = object2.getDescriptor(propName, (desc, prev) => {
                if ((desc.isPropertyDefinition || desc.isMethodGetterDefinition) && Utils.isModifierPublic(desc)) {
                  return true;
                }
                return prev || desc;
              });
            }
            if (!result) {
              result = object2.dynamicAttribute(propertyType);
            }
          }
        }
        return result ? result.type() : null;
      };
      const getProperties = (object2, property2) => {
        if (property2.isUnionType || property2.isTupleType || property2.isLiteralArrayType) {
          const reduce = (accumulator, item2) => item2.isUnionType || item2.isTupleType ? item2.elements.reduce(reduce, accumulator) : accumulator.concat(item2.type());
          const keys = property2.elements.reduce(reduce, []).filter((item2) => item2.isLiteralType);
          const values = keys.map((item2) => {
            return getProperty2(object2, item2.value, item2);
          }).filter((item2) => !!item2);
          if (values.length) {
            if (values.length === 1)
              return values[0];
            return MergeType.arrayToUnion(values, this.target, true);
          }
        } else {
          return getProperty2(object2, property2.isLiteralType ? property2.value : null, property2);
        }
        return null;
      };
      const defaultType = Namespace.globals.get("any");
      const getDesc = (name, type2) => {
        if (object.isLiteralArrayType || object.isLiteralObjectType || object.isGenericType && object.hasConstraint || object.isTupleType || object.isEnumType || object.isIntersectionType || object.isInstanceofType) {
          const desc = name ? object.attribute(name) : null;
          if (desc) {
            return desc.type();
          } else if (object.isLiteralObjectType || object.isLiteralArrayType || object.isTupleType) {
            return getProperties(object, type2) || defaultType;
          } else if (object.isInstanceofType) {
            return getProperties(object, type2) || defaultType;
          }
        } else if (name) {
          return getProperty2(object, name, type2) || defaultType;
        } else {
          return getProperties(object, type2) || defaultType;
        }
      };
      return property.isLiteralType ? getDesc(property.value, property) : getDesc(null, property);
    }
    function extractWrapGenericValue(type2) {
      let records = null;
      let fetchOriginAssignValue = (origin, declareGeneric) => {
        if (!Utils.isModule(origin))
          return null;
        let ret = origin.getAssignGenerics(declareGeneric);
        if (ret && ret.isGenericType) {
          ret = origin.getAssignGenerics(ret) || ret;
        }
        return ret;
      };
      getClassGenericsFromType(type2).forEach((type3) => {
        let origin = Utils.getOriginType(type3);
        let declareGenerics = getTypeDeclareGenerics(type3);
        declareGenerics.forEach((decl2, index) => {
          let assign = type3.types[index] || fetchOriginAssignValue(origin, decl2) || decl2.assignType;
          if (!assign && decl2.hasConstraint) {
            assign = decl2.inherit;
          }
          if (assign) {
            records = records || (records = /* @__PURE__ */ new Map());
            records.set(decl2, assign);
          }
        });
      });
      return records;
    }
    function extractGenericsFromType(type2) {
      if (!type2)
        return [];
      if (type2.isGenericType)
        return [type2];
      if (type2.isAliasType) {
        return extractGenericsFromType(type2.inherit.type());
      }
      let elements = null;
      if (type2.isLiteralObjectType) {
        elements = Array.from(type2.properties.values());
      } else if (type2.isLiteralArrayType || type2.isTupleType || type2.isUnionType) {
        elements = type2.elements;
      } else if (type2.isClassGenericType) {
        let inherit = type2.inherit.type();
        if (Array.isArray(type2.types)) {
          elements = [...type2.types];
        } else {
          elements = [];
        }
        elements.push(...getTypeDeclareGenerics(inherit));
      } else if (type2.isIntersectionType) {
        elements = [type2.left, type2.right];
      } else if (type2.isInstanceofType && Array.isArray(type2.generics)) {
        elements = type2.generics;
      } else if (type2.isComputeType) {
        elements = [type2.object, type2.property];
      } else if (type2.isKeyofType) {
        elements = [type2.referenceType];
      } else if (type2.isTypeofType) {
        elements = [type2.origin];
      } else if (type2.isPredicateType) {
        elements = [type2.value];
      }
      if (elements) {
        return elements.map((item2) => {
          let _type = item2.type();
          if (_type.hasGenericType) {
            return extractGenericsFromType(_type);
          }
          return [];
        }).flat();
      }
      return [];
    }
    function getTypeDeclareGenerics(type2, origin = null) {
      if (type2.isAliasType && type2.target && type2.target.isDeclaratorTypeAlias && type2.target.genericity) {
        return type2.target.genericity.elements.map((item2) => item2.type());
      } else if (type2.isClassGenericType && type2.target && type2.target.isTypeGenericDefinition) {
        return type2.target.getDeclareGenerics()[1].map((item2) => item2.type());
      } else if (type2.isInstanceofType) {
        type2 = type2.inherit.type();
        if (type2.isAliasType) {
          return getTypeDeclareGenerics(type2, origin);
        }
      }
      origin = origin || Utils.getOriginType(type2);
      if (origin && Utils.isModule(origin)) {
        return origin.getModuleDeclareGenerics();
      }
      return [];
    }
    function needToLiteralValue(type2) {
      if (!type2)
        return false;
      if (type2.isGenericType && type2.hasConstraint) {
        type2 = type2.inherit.type();
      }
      return type2 ? type2.isKeyofType : false;
    }
    function getObjectProperty(object, key) {
      if (object.isEnumType) {
        return object.attribute(key);
      } else if (object.isLiteralObjectType) {
        return object.properties.get(key);
      } else if (object.isIntersectionType) {
        return getProperty(object.left, key) || getProperty(object.right, key);
      } else if (object.isInstanceofType || Utils.isInterface(object)) {
        let origin = object.isInstanceofType ? Utils.getOriginType(object) : object;
        let descriptors = origin.descriptors.get(key);
        if (descriptors) {
          let properties = descriptors.filter((item2) => item2.isPropertyDefinition || item2.isMethodGetterDefinition).map((item2) => item2.type());
          return properties.length > 1 ? MergeType.arrayToUnion(properties) : properties[0];
        }
      }
      return null;
    }
    function getAssigmentBoundType(generic, declared, assigment) {
      let assigmentType = assigment.type();
      if (assigmentType.isTypeofType) {
        assigmentType = assigmentType.origin.type();
      }
      if (declared.isGenericType) {
        if (generic.getUniKey() === declared.getUniKey()) {
          if (assigmentType.isLiteralArrayType) {
            return MergeType.to(assigmentType, false, false, needToLiteralValue(generic));
          }
          if (assigmentType.isLiteralType && needToLiteralValue(generic)) {
            return new LiteralType(assigmentType.inherit, assigmentType.target, assigmentType.value, true);
          }
          return assigmentType;
        }
      }
      if (Utils.isInterface(declared)) {
        let keys = declared.descriptors.keys();
        let isInterface = Utils.isInterface(assigmentType);
        if (isInterface && !declared.is(assigmentType)) {
          return null;
        }
        for (let key of keys) {
          let properties = declared.descriptors.get(key);
          for (let i = 0; i < properties.length; i++) {
            let property = properties[i];
            if (property.isPropertyDefinition || property.isMethodGetterDefinition) {
              let _declared = property.type();
              if ((assigmentType.isLiteralObjectType || isInterface) && _declared.hasGenericType) {
                let assigmentPropertry = getObjectProperty(assigmentType, key);
                if (assigmentPropertry) {
                  let res = getAssigmentBoundType(generic, _declared, assigmentPropertry);
                  if (res) {
                    return res;
                  }
                }
              }
            }
          }
        }
      } else if (declared.isLiteralObjectType) {
        let isObject = assigmentType.isLiteralObjectType || assigmentType.isEnumType || assigmentType.isInstanceofType || assigmentType.isIntersectionType;
        let isInterface = isObject ? false : Utils.isInterface(assigmentType);
        if (isObject || isInterface) {
          let keys = declared.properties.keys();
          for (let key of keys) {
            let property = declared.properties.get(key);
            let assigmentProperty = getObjectProperty(assigmentType, key);
            if (assigmentProperty) {
              let propertyType = property.type();
              if (propertyType.hasGenericType) {
                let res = getAssigmentBoundType(generic, propertyType, assigmentProperty);
                if (res) {
                  return res;
                }
              }
            }
          }
        }
      } else if (declared.isTupleType) {
        let elements = declared.elements;
        if (declared.prefix && assigmentType.isTupleType && assigmentType.prefix) {
          return getAssigmentBoundType(generic, elements[0].type(), assigmentType.elements[0].type());
        } else if (declared.prefix && (assigmentType.isLiteralArrayType || assigmentType.isTupleType && !assigmentType.prefix)) {
          let results = assigmentType.elements;
          if (results.length > 0) {
            let constraint = elements[0].type();
            if (constraint.isGenericType) {
              if (generic.getUniKey() === constraint.getUniKey()) {
                return results.length > 1 ? MergeType.arrayToUnion(results, null, needToLiteralValue(generic)) : results[0].type();
              }
            }
            declared = elements[0].type();
            for (let i = 0; i < results.length; i++) {
              let res = getAssigmentBoundType(generic, declared, results[i]);
              if (res) {
                return res;
              }
            }
          } else {
            return getAssigmentBoundType(generic, declared, Namespace.globals.get("any"));
          }
        } else if (assigmentType.isLiteralArrayType || assigmentType.isTupleType) {
          let results = assigmentType.elements;
          if (results.length === 0) {
            return getAssigmentBoundType(generic, declared, Namespace.globals.get("any"));
          }
          for (let i = 0; i < elements.length; i++) {
            let el = elements[i];
            let assign = results[i];
            if (!assign && assigmentType.isTupleType && assigmentType.prefix) {
              assign = results[0];
            }
            if (assign) {
              declared = el.type();
              if (declared.hasGenericType) {
                let res = getAssigmentBoundType(generic, declared, assign);
                if (res) {
                  return res;
                }
              }
            } else {
              break;
            }
          }
        } else if (declared.prefix) {
          return getAssigmentBoundType(generic, elements[0].type(), assigmentType);
        } else {
          for (let i = 0; i < elements.length; i++) {
            let el = elements[i];
            let res = getAssigmentBoundType(generic, el.type(), assigmentType);
            if (res) {
              return res;
            }
          }
        }
      } else if (declared.isUnionType) {
        let elements = declared.elements;
        let last = null;
        for (let i = 0; i < elements.length; i++) {
          let el = elements[i];
          let res = getAssigmentBoundType(generic, el.type(), assigmentType);
          if (res) {
            last = res;
            if (assigmentType.isFunctionType && !el.type().isFunctionType) {
              continue;
            }
            return res;
          }
        }
        if (last) {
          return last;
        }
      } else if (declared.isFunctionType) {
        if (assigmentType.isFunctionType) {
          const index = declared.params.findIndex((param) => param.isGenericType && generic.getUniKey() === param.getUniKey());
          if (index >= 0) {
            const _assigment = assigmentType.params[index];
            if (_assigment) {
              return _assigment.type();
            }
          } else {
            const rType = declared.getReturnedType();
            if (rType && rType.isGenericType && generic.getUniKey() === rType.getUniKey()) {
              return assigmentType.getInferReturnType();
            }
          }
        }
      } else if (declared.isIntersectionType) {
        return getAssigmentBoundType(generic, declared.left.type(), assigmentType) || getAssigmentBoundType(generic, declared.right.type(), assigmentType);
      } else if (declared.isClassGenericType) {
        if (assigmentType.isClassGenericType) {
          if (declared.inherit.type() === assigmentType.inherit.type()) {
            let declareGenerics = getTypeDeclareGenerics(declared.inherit.type());
            let index = declareGenerics.findIndex((decl2) => decl2.getUniKey() === generic.getUniKey());
            if (index >= 0 && assigmentType.types[index]) {
              return assigmentType.types[index].type();
            }
          } else if (assigmentType.types.length > 0) {
            if (assigmentType.types.length > 1) {
              return MergeType.arrayToTuple(assigmentType.types, false, false);
            }
            return assigmentType.types[0].type();
          }
        } else if ((assigmentType.isTupleType || assigmentType.isLiteralArrayType) && declared.inherit.type().is(assigmentType.inherit.type())) {
          let declareGenerics = getTypeDeclareGenerics(declared.inherit.type());
          let index = declareGenerics.findIndex((decl2) => decl2.getUniKey() === generic.getUniKey());
          if (index >= 0) {
            if (assigmentType.prefix && assigmentType.elements.length > 0) {
              if (assigmentType.elements.length > 1) {
                const newType = MergeType.mergeTupleElement(assigmentType);
                return newType.elements[0].type();
              }
              return assigmentType.elements[0].type();
            } else {
              return MergeType.arrayToUnion(assigmentType.elements);
            }
          }
        } else {
          const inherit = declared.inherit.type();
          if (inherit.isAliasType) {
            return getAssigmentBoundType(generic, inherit, assigmentType);
          } else {
            let types = declared.types;
            for (let i = 0; i < types.length; i++) {
              let el = types[i].type();
              if (el.hasGenericType) {
                let res = getAssigmentBoundType(generic, el, assigmentType);
                if (res) {
                  return res;
                }
              }
            }
            return getAssigmentBoundType(generic, inherit, assigmentType);
          }
        }
      } else if (declared.isAliasType) {
        return getAssigmentBoundType(generic, declared.inherit.type(), assigmentType);
      } else if (declared.isKeyofType) {
        return getAssigmentBoundType(generic, declared.referenceType.type(), assigmentType);
      } else if (declared.isPredicateType) {
        return getAssigmentBoundType(generic, declared.value.type(), assigmentType);
      }
      return null;
    }
    function findGenericIndex(genericItems, generic) {
      return genericItems.findIndex((decl2) => generic.getUniKey() === decl2.type().getUniKey());
    }
    function extractModuleFromType(type2, result = []) {
      if (!type2)
        return result;
      if (type2.isUnionType) {
        type2.elements.forEach((item2) => {
          extractModuleFromType(item2.type(), result);
        });
      } else if (type2.isIntersectionType) {
        extractModuleFromType(type2.left.type(), result);
        extractModuleFromType(type2.right.type(), result);
      } else if (Utils.isModule(type2)) {
        result.push(type2);
      }
      return result;
    }
    function extractContextGenerics(records, context, origin = null, relateGenerics = [], excludeTuple = false) {
      if (!context)
        return records;
      if (context.isTypeofType) {
        return extractContextGenerics(records, context.origin.type(), null, relateGenerics);
      }
      if (origin) {
        let _origins = extractModuleFromType(origin);
        if (_origins.length > 1) {
          _origins.forEach((origin2) => {
            extractContextGenerics(records, context, origin2, relateGenerics, excludeTuple);
          });
          return;
        } else {
          origin = _origins[0];
        }
      }
      let classDeclareGenerics = getTypeDeclareGenerics(context, origin);
      if (context.isAliasType) {
        extractContextGenerics(records, context.inherit.type(), null, relateGenerics);
        if (classDeclareGenerics.length > 0) {
          classDeclareGenerics.forEach((decl2) => {
            let assign = decl2.assignType;
            if (assign) {
              push(decl2, assign.type(), records);
              let index = findGenericIndex(relateGenerics, decl2);
              if (index >= 0) {
                push(relateGenerics[index], assign, records);
              }
            }
          });
        }
      } else if (context.isTupleType || context.isLiteralArrayType) {
        if (!excludeTuple) {
          let assigmentType = context.elements.length > 0 ? context.isTupleType && context.prefix ? context.elements[0].type() : MergeType.arrayToUnion(context.elements) : Namespace.globals.get("any");
          classDeclareGenerics.forEach((decl2) => {
            let index = findGenericIndex(relateGenerics, decl2);
            push(decl2, assigmentType, records);
            if (index >= 0) {
              push(relateGenerics[index], assigmentType, records);
            }
            extractContextGenerics(records, assigmentType, null, [], true);
          });
        } else {
          context.elements.forEach((item2) => extractContextGenerics(records, item2.type(), null, [], true));
        }
      } else if (context.isInstanceofType) {
        if (context.generics && context.generics.length > 0) {
          classDeclareGenerics.forEach((decl2, pos) => {
            let index = findGenericIndex(relateGenerics, decl2);
            let assign = context.generics[pos];
            push(decl2, assign, records, true);
            if (index >= 0) {
              push(relateGenerics[index], assign, records, true);
            }
            if (assign) {
              extractContextGenerics(records, assign.type(), null, [], true);
            }
          });
        }
      } else if (context.isClassGenericType) {
        if (context.types && context.types.length > 0) {
          classDeclareGenerics.forEach((decl2, pos) => {
            let index = findGenericIndex(relateGenerics, decl2);
            let assign = context.types[pos];
            push(decl2, assign, records, true);
            if (index >= 0) {
              push(relateGenerics[index], assign, records, true);
            }
            if (assign) {
              extractContextGenerics(records, assign.type(), null, [], true);
            }
          });
        }
      } else if (context.isIntersectionType) {
        extractContextGenerics(records, context.left.type(), null, relateGenerics);
        extractContextGenerics(records, context.right.type(), null, relateGenerics);
      } else if (context.isUnionType) {
        context.elements.forEach((item2) => {
          extractContextGenerics(records, item2.type(), null, relateGenerics);
        });
      }
    }
    function push(generic, type2, records, force = false) {
      if (type2)
        type2 = type2.type();
      if (type2 && generic != type2) {
        if (force || !records.has(generic)) {
          records.set(generic, type2);
          return true;
        }
      }
      return false;
    }
    function extractMatchGenerics(records, declareGenerics, declareParams, assigmentArgs, assigmentGenerics, relateGenerics = []) {
      let len = assigmentArgs.length;
      let aLen = assigmentGenerics ? assigmentGenerics.length : 0;
      if (aLen > 0) {
        for (let i = 0; i < declareGenerics.length; i++) {
          let generic = declareGenerics[i].type();
          if (aLen > 0 && i < aLen) {
            let assigment = assigmentGenerics[i];
            push(generic, assigment, records, true);
            if (relateGenerics.length > 0) {
              let index = findGenericIndex(relateGenerics, generic);
              if (index >= 0) {
                push(relateGenerics[index], assigment, records, true);
              }
            }
          }
        }
      }
      let after = [];
      for (let i = 0; i < len; i++) {
        let declParamItem = declareParams.length > i ? declareParams[i] : null;
        let declParamType = null;
        if (declParamItem) {
          declParamType = declParamItem.type();
        }
        if (!declParamType && declareParams.length > 0) {
          declParamItem = declareParams[declareParams.length - 1];
          declParamType = declParamItem.type();
          if (declParamType && declParamType.isTupleType && declParamType.rest && declParamType.prefix) {
          } else {
            declParamType = null;
          }
        }
        if (!declParamType)
          break;
        const paramTypes = declParamType.isUnionType ? declParamType.elements.map((item2) => item2.type()) : [declParamType];
        for (let index = 0; index < paramTypes.length; index++) {
          let declParamType2 = paramTypes[index];
          if (declParamType2.isFunctionType) {
            after.push([declParamItem, declParamType2, assigmentArgs[i], i]);
          } else if (declParamType2.hasGenericType) {
            let declParamGenerics = extractGenericsFromType(declParamType2);
            let assigmentArg = assigmentArgs[i];
            if (declParamType2.isTupleType && declParamType2.rest && declParamType2.prefix) {
              let items = assigmentArgs.slice(i).map((item2) => item2.type());
              assigmentArg = items.length > 1 ? MergeType.arrayToUnion(items) : items[0];
              declParamType2 = declParamType2.elements[0].type();
            }
            if (declParamType2.isClassGenericType) {
              extractContextGenerics(records, declParamType2);
              let pos = declParamGenerics.findIndex((generic) => {
                return findGenericIndex(declareGenerics, generic) < 0;
              });
              if (pos >= 0) {
                let external = declParamGenerics[pos];
                let result = getAssigmentBoundType(external, declParamType2, assigmentArg);
                if (result) {
                  declParamGenerics.forEach((paramGeneric) => {
                    if (paramGeneric === external)
                      return;
                    let index2 = findGenericIndex(declareGenerics, paramGeneric);
                    if (index2 < 0)
                      return;
                    if (assigmentGenerics && assigmentGenerics.length > 0 && assigmentGenerics[index2]) {
                      push(paramGeneric, assigmentGenerics[index2], records, true);
                    } else {
                      push(paramGeneric, result, records);
                    }
                  });
                  break;
                }
              }
            }
            let boundValue = null;
            declParamGenerics.forEach((paramGeneric) => {
              let index2 = findGenericIndex(declareGenerics, paramGeneric);
              if (index2 < 0)
                return;
              let assigmentResult = null;
              if (assigmentGenerics && assigmentGenerics.length > 0 && assigmentGenerics[index2]) {
                assigmentResult = assigmentGenerics[index2];
                push(paramGeneric, assigmentResult, records, true);
              } else {
                assigmentResult = boundValue || getAssigmentBoundType(paramGeneric, declParamType2, assigmentArg);
                push(
                  paramGeneric,
                  boundValue = assigmentResult,
                  records
                );
              }
              if (paramGeneric.hasConstraint) {
                const constraint = paramGeneric.inherit.type();
                const result = constraint.isClassGenericType && constraint.isClassType && Utils.isClassType(assigmentResult);
                if (result || constraint.isClassGenericType && constraint.is(assigmentResult)) {
                  let declareGenerics2 = constraint.types.filter((item2) => item2.type().isInferGenericType);
                  if (declareGenerics2.length > 0) {
                    extractMatchGenerics(records, declareGenerics2, [constraint], [assigmentResult]);
                  }
                }
              }
            });
          }
        }
      }
      after.forEach(([declParamItem, declParamType, assigmentArg]) => {
        let declReturnType = declParamType.getReturnedType();
        if (declReturnType && !declReturnType.isVoidType && declReturnType.hasGenericType) {
          let assigmentType = assigmentArg.type();
          if (assigmentType && assigmentType.isFunctionType) {
            let assigmentReturnType = assigmentType.getInferReturnType();
            if (assigmentReturnType && !assigmentReturnType.isVoidType) {
              let extractReturnGenerics = extractGenericsFromType(declReturnType);
              let boundValue = null;
              extractReturnGenerics.forEach((generic) => {
                let index = findGenericIndex(declareGenerics, generic);
                if (index < 0)
                  return;
                if (assigmentGenerics && assigmentGenerics.length > 0) {
                  push(generic, assigmentGenerics[index], records, true);
                } else {
                  push(
                    generic,
                    boundValue = boundValue || getAssigmentBoundType(generic, declReturnType, assigmentReturnType),
                    records
                  );
                }
              });
            }
          }
        }
      });
      return records;
    }
    function getClassGenericsFromType(type2) {
      if (!type2 || !Utils.isType(type2))
        return [];
      if (type2.isClassGenericType && Array.isArray(type2.types) && type2.types.length > 0) {
        return [type2];
      } else if (type2.isUnionType) {
        return type2.elements.map((el) => getClassGenericsFromType(el.type())).flat();
      } else if (type2.isIntersectionType) {
        return [type2.left, type2.right].map((el) => getClassGenericsFromType(el.type())).flat();
      }
      return [];
    }
    function getCalleeStack(stack) {
      if (stack.isParenthesizedExpression) {
        return getCalleeStack(stack.expression);
      }
      return stack;
    }
    function make(stack) {
      let origin = null;
      let records = null;
      let post = null;
      if (stack.isCallExpression) {
        const description = stack.descriptor();
        const [declareGenerics = []] = description ? stack.getDeclareGenerics(description) : [];
        const declareParams = stack.getFunDeclareParams(description);
        const assigmentGenerics = stack.genericity;
        const args = stack.arguments;
        const type2 = stack.getReturnType();
        const relateGenerics = extractGenericsFromType(type2);
        const callee = getCalleeStack(stack.callee);
        let context = callee.isMemberExpression ? callee.object.type() : null;
        let _thisArg = description ? description.thisArgumentContext : null;
        records = /* @__PURE__ */ new Map();
        if (!context && stack.is(description)) {
          if (Utils.isModule(description.module)) {
            if (description.isCallDefinition) {
              context = stack.callee.type();
              origin = Utils.getOriginType(context);
            } else if (Utils.isModule(stack.module)) {
              context = origin = stack.module;
            }
          }
        } else if (context) {
          origin = Utils.getOriginType(context);
        }
        const pushThisCtx = () => {
          if (_thisArg) {
            const type3 = _thisArg.type();
            if (type3 && type3.isGenericType && (!type3.hasConstraint || type3.is(context))) {
              push(type3, context, records, true);
            }
          }
        };
        extractContextGenerics(records, context, origin, relateGenerics);
        if (declareGenerics.length > 0) {
          post = () => {
            extractMatchGenerics(
              records,
              declareGenerics.map((item2) => item2.type()),
              declareParams,
              args,
              assigmentGenerics,
              relateGenerics
            );
            extractContextGenerics(records, type2, null, relateGenerics);
            pushThisCtx();
          };
        } else {
          pushThisCtx();
        }
      } else if (stack.isNewExpression) {
        const [classModule, methodConstructor, _assigmentGenerics = []] = stack.getConstructMethod() || [];
        let callee = getCalleeStack(stack.callee);
        let context = callee.isMemberExpression ? callee.object.type() : null;
        records = /* @__PURE__ */ new Map();
        if (context) {
          extractContextGenerics(records, context);
        }
        if (classModule) {
          const [, declareGenerics = []] = stack.getDeclareGenerics(classModule, methodConstructor);
          const declareParams = methodConstructor ? methodConstructor.params : [];
          const assigmentGenerics = stack.genericity || _assigmentGenerics;
          origin = Utils.getOriginType(classModule);
          if (assigmentGenerics.length > 0) {
            declareGenerics.forEach((decl2, index) => {
              push(decl2.type(), assigmentGenerics[index], records, true);
            });
          }
          if (declareGenerics.length > 0) {
            post = () => {
              extractMatchGenerics(
                records,
                declareGenerics.map((item2) => item2.type()),
                declareParams,
                stack.arguments,
                assigmentGenerics
              );
            };
          }
        }
      } else if (stack.isMemberExpression) {
        const type2 = stack.object.type();
        const relateGenerics = extractGenericsFromType(type2);
        origin = Utils.getOriginType(type2);
        records = /* @__PURE__ */ new Map();
        extractContextGenerics(
          records,
          type2,
          origin,
          relateGenerics
        );
      } else if (stack.isVariableDeclarator || stack.isParamDeclarator || stack.isPropertyDefinition || stack.isFunctionExpression && stack.parentStack.isMethodDefinition) {
        let type2 = stack.type();
        if ((stack.isPropertyDefinition || stack.isFunctionExpression || stack.isParamDeclarator && stack.parentStack.parentStack.isMethodDefinition) && stack.module) {
          origin = stack.module;
        } else {
          origin = Utils.getOriginType(type2);
        }
        records = /* @__PURE__ */ new Map();
        extractContextGenerics(
          records,
          type2,
          origin
        );
      }
      return { records, origin, post };
    }
    var currentStack = null;
    function create(stack, parent = null) {
      currentStack = stack;
      if (parent && !isInfer(parent)) {
        throw new Error("Invalid parent");
      }
      return new Inference(stack, parent);
    }
    function getInferenceFromType(type2, parent = null) {
      if (parent && !isInfer(parent)) {
        throw new Error("Invalid parent");
      }
      let obj = new Inference(null, parent);
      obj.make(type2);
      return obj;
    }
    function isInfer(obj) {
      return obj ? obj instanceof Inference : false;
    }
    var unknown = null;
    var Inference = class {
      [Utils.IS_CONTEXT] = true;
      #stack = null;
      #records = null;
      #origin = null;
      #parent = null;
      #group = null;
      #inited = false;
      #making = false;
      #hoverStack = null;
      constructor(stack, parent = null) {
        this.#stack = stack;
        this.#parent = parent;
      }
      get stack() {
        return this.#stack;
      }
      get records() {
        return this.#records;
      }
      get origin() {
        return this.#origin;
      }
      get parent() {
        return this.#parent;
      }
      get hoverStack() {
        return this.#hoverStack || this.stack;
      }
      setHoverStack(stack) {
        this.#hoverStack = stack;
      }
      init() {
        if (this.#inited === false) {
          this.#inited = true;
          this.#making = true;
          let result = make(this.stack);
          this.#records = result.records;
          this.#origin = result.origin;
          let post = result.post;
          if (post) {
            post();
          }
          this.#making = false;
        }
      }
      make(type2) {
        if (!Utils.isType(type2)) {
          throw new Error("Invalid type in the make inference context ");
        }
        this.#inited = true;
        let origin = Utils.getOriginType(type2);
        if (!Utils.isModule(origin)) {
          origin = null;
        }
        this.#records = /* @__PURE__ */ new Map();
        this.#origin = origin;
        extractContextGenerics(this.#records, type2);
      }
      fetchOriginAssign(generic, origin) {
        if (origin) {
          if (Utils.isModule(origin)) {
            const result = origin.getAssignGenerics(generic);
            if (result && result !== generic) {
              return result;
            }
          }
          if (origin.isUnionType) {
            const items = origin.elements;
            for (let i = 0; i < items.length; i++) {
              let item2 = items[i].type();
              const result = this.fetchOriginAssign(generic, item2);
              if (result) {
                return result;
              }
            }
          } else if (origin.isIntersectionType) {
            const result = this.fetchOriginAssign(generic, origin.left.type()) || this.fetchOriginAssign(generic, origin.right.type());
            if (result) {
              return result;
            }
          }
        }
        return null;
      }
      fetch(generic, flag = false) {
        if (!generic) {
          throw new Error("Generic cannot is null");
        }
        let recursion = 0;
        const getValue = (generic2, flag2 = false) => {
          if (generic2.isGenericType) {
            if (recursion >= 100) {
              return flag2 ? generic2 : null;
            }
            let records = this.#records;
            if (records && records.has(generic2)) {
              const value2 = records.get(generic2);
              if (value2 !== generic2) {
                recursion++;
                return getValue(value2, true);
              }
            }
            let assign = this.fetchOriginAssign(generic2, this.#origin);
            if (assign && assign !== generic2) {
              recursion++;
              return getValue(assign, true);
            }
            let parent = this.#parent;
            if (parent) {
              const result2 = parent.fetch(generic2);
              if (result2) {
                return result2;
              }
            }
            return flag2 ? generic2 : null;
          }
          return generic2;
        };
        const result = getValue(generic);
        if (result)
          return result;
        return flag ? generic : null;
      }
      infer(generic, flag = false) {
        if (!generic) {
          throw new Error("Generic cannot is null");
        }
        let result = this.fetch(generic);
        if (!result) {
          if (generic.assignType) {
            result = generic.assignType.type();
          } else if (generic.hasConstraint) {
            result = generic.inherit.type();
          }
          if (result) {
            if (result.isGenericType) {
              return this.infer(result, true);
            }
            return result;
          }
          if (flag) {
            return generic;
          }
          return unknown || (unknown = Namespace.globals.get("unknown"));
        } else if (result.isGenericType) {
          if (result.assignType) {
            result = result.assignType.type();
          } else if (result.hasConstraint) {
            result = result.inherit.type();
          }
        }
        return result;
      }
      get inference() {
        return (generic) => this.infer(generic);
      }
      apply(type2) {
        if (!Utils.isType(type2)) {
          throw new Error("Type object is invalid");
        }
        const result = type2.getInferResult(this);
        if (result) {
          type2 = result;
        }
        if (type2.hasGenericType) {
          return type2.clone(this.inference);
        }
        return type2;
      }
      create(stack, type2 = null) {
        if (!type2 && (Utils.isStack(stack) || Utils.isType(stack))) {
          type2 = stack.type();
        }
        if (!type2) {
          throw new Error("Type cannot is null of the create child context");
        }
        let group = this.#group || (this.#group = /* @__PURE__ */ new Map());
        if (stack && group.has(stack)) {
          return group.get(stack);
        }
        let items = getClassGenericsFromType(type2);
        if (items.length > 0) {
          let records = /* @__PURE__ */ new Map();
          items.forEach((type3) => {
            let classDeclareGenerics = getTypeDeclareGenerics(type3);
            classDeclareGenerics.forEach((decl2, index) => {
              push(decl2, type3.types[index], records, true);
            });
          });
          let child = new Inference(stack, this);
          child.#records = records;
          child.#inited = true;
          if (stack) {
            group.set(stack, child);
          }
          return child;
        }
        return this;
      }
      createChild(stack) {
        let child = new Inference(stack, this);
        child.#records = null;
        child.#inited = true;
        return child;
      }
      debug() {
        let records = this.#records;
        let stack = this.stack;
        let file = null;
        let line = null;
        if (Utils.isStack(stack)) {
          file = stack.file;
          let loc = stack.getLocation();
          line = loc ? loc.start.line : null;
        }
        let items = [file, line].filter(Boolean);
        let info = items.length > 0 ? items.join(":") : "unknown";
        let making = this.#making ? "making" : "done";
        if (!records) {
          console.log(`[debug inference] [records is null] [${making}] file:${info}`);
        } else {
          console.log(`[debug inference] [total:${records.size}] [${making}] file:${info}`);
          records.forEach((value2, key) => {
            if (value2.isGenericType) {
              console.log(key.getUniKey(), `${value2.getUniKey()}(${value2.toString()})`);
            } else {
              console.log(key.getUniKey(), value2.toString());
            }
          });
          let origin = this.#origin;
          if (origin && Utils.isModule(origin)) {
            console.log(`[debug inference] [origin]`);
            origin.getAllAssignGenerics().forEach((value2, key) => {
              if (value2.isGenericType) {
                console.log(key, `${value2.getUniKey()}(${value2.toString()})`);
              } else {
                console.log(key, value2.toString());
              }
            });
          }
        }
        let parent = this.#parent;
        if (parent) {
          parent.debug();
        }
      }
      append(type2) {
        if (Utils.isType(type2)) {
          this.#records = this.#records || (this.#records = /* @__PURE__ */ new Map());
          extractContextGenerics(this.#records, type2);
        }
      }
      inCallChain() {
        let stack = this.#stack;
        if (stack.isCallExpression || stack.isNewExpression) {
          return true;
        }
        let parent = this.#parent;
        return parent ? parent.inCallChain() : false;
      }
    };
    module.exports = {
      create,
      getInferenceFromType,
      isInfer,
      getCalleeStack,
      extractWrapGenericValue,
      getTypeDeclareGenerics,
      extractContextGenerics,
      extractMatchGenerics,
      extractGenericsFromType,
      getComputeValue
    };
  }
});

// lib/core/Stack.js
var require_Stack = __commonJS({
  "lib/core/Stack.js"(exports, module) {
    var Utils = require_Utils();
    var EventDispatcher = require_EventDispatcher();
    var MergeType = require_MergeType();
    var Module = require_Module();
    var Type = require_Type();
    var Namespace = require_Namespace();
    var JSModule = require_JSModule();
    var Predicate = require_Predicate();
    var AutoImporter = require_AutoImporter();
    var Inference = require_Inference();
    var keySymbol = Symbol("key");
    var mergeArrayKey = Symbol("key");
    var emptyOnlyreadArray = [];
    var NOT_ASSING_GENERICS = 1;
    var MISSING_ASSING_GENERICS = 1 << 1;
    var FAILED_ASSING_GENERICS = 1 << 2;
    var DESCRIPTOR_TYPE_UNMATCH = 1 << 3;
    var FUN_TYPE_PARAMS_UNMATCH = 1 << 4;
    var Stack = class extends EventDispatcher {
      [Utils.IS_STACK] = true;
      #inference = null;
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super();
        this.compilation = compilation;
        this.mtime = compilation.mtime;
        this.compiler = compilation.compiler;
        this.isStack = true;
        this.node = node2;
        this.scope = scope;
        this.parentNode = parentNode;
        this.parentStack = parentStack;
        this.childrenStack = [];
        this.namespace = compilation.namespace;
        this.module = null;
        this.isFragment = false;
        this.file = compilation.file;
        this.childIndexAt = 0;
        this[keySymbol] = {
          context: null,
          comments: null,
          attributes: /* @__PURE__ */ Object.create(null),
          specifier: null,
          lastCacheId: null
        };
        this._useRefItems = null;
        if (parentStack) {
          this.childIndexAt = parentStack.childrenStack.length;
          parentStack.childrenStack.push(this);
          this.isFragment = parentStack.isFragment;
          this.namespace = parentStack.namespace;
          this.module = parentStack.module;
        }
        if (node2) {
          if (compilation.compiler.options.enableStackMap) {
            if (!(parentStack && parentStack.isFragment)) {
              this.compilation.addStack(this);
            }
          }
        }
      }
      is(value2) {
        return value2 ? value2 instanceof Stack : false;
      }
      get comments() {
        if (!this.compiler.options.enableComments)
          return [];
        const comments = this[keySymbol].comments;
        if (comments)
          return comments;
        const type2 = this.node.type;
        switch (type2) {
          case "DeclaratorTypeAlias":
          case "DeclaratorFunction":
          case "DeclaratorVariable":
          case "PackageDeclaration":
          case "ClassDeclaration":
          case "DeclaratorDeclaration":
          case "InterfaceDeclaration":
          case "EnumDeclaration":
          case "StructTableDeclaration":
          case "StructTableColumnDefinition":
          case "EnumProperty":
          case "MethodDefinition":
          case "PropertyDefinition":
          case "JSXAttribute":
            return this[keySymbol].comments = this.findComments() || [];
        }
        return [];
      }
      findComments(latter = false) {
        let stack = this;
        let prev = stack;
        let parent = stack.parentStack;
        let index = -1;
        if (parent) {
          const testSkipAnnotation = (index2) => {
            if (latter) {
              if (index2 < parent.childrenStack.length) {
                const node2 = parent.childrenStack[index2 + 1];
                if (node2.isAnnotationDeclaration) {
                  return testSkipAnnotation(index2 + 1);
                }
              }
            } else {
              if (index2 > 0) {
                const node2 = parent.childrenStack[index2 - 1];
                if (node2.isAnnotationDeclaration) {
                  return testSkipAnnotation(index2 - 1);
                }
              }
            }
            return index2;
          };
          let restrict = latter ? parent.node.end : parent.node.start;
          index = parent.childrenStack.indexOf(prev);
          if (index >= 0) {
            index = testSkipAnnotation(index);
            if (latter) {
              if (index < parent.childrenStack.length) {
                restrict = parent.childrenStack[index + 1].node.start;
              }
            } else if (index > 0) {
              restrict = parent.childrenStack[index - 1].node.end;
            }
            return this.compilation.emitComments.filter((comment) => {
              if (latter) {
                return stack.node.end < comment.start && comment.end < restrict;
              } else {
                return restrict < comment.start && comment.end < stack.node.start;
              }
            });
          }
        }
        return null;
      }
      parseComments(type2 = "Block") {
        let comments = this.comments;
        if (comments.length > 0) {
          const data = /* @__PURE__ */ Object.create(null);
          data.meta = null;
          data.params = [];
          data.comments = [];
          comments = comments.filter((item2) => item2.type === type2);
          comments.forEach((comment) => {
            let text = comment.value.trim();
            if (comment.type === "Block") {
              let lines = text.split(/[\r\n]+/);
              lines = lines.map((line) => line.trim());
              while (lines[0] === "*") {
                lines.shift();
              }
              if (lines.length > 0) {
                while (lines[lines.length - 1] === "*") {
                  lines.pop();
                }
              }
              data.comments.push(lines.join("\n"));
              if (text.includes("@")) {
                lines.forEach((line) => {
                  if (!line || line.length < 4)
                    return;
                  let index = 0;
                  let code = 0;
                  while ((code = line.charCodeAt(index)) && (code === 42 || code === 32))
                    index++;
                  line = line.substring(index);
                  if (code === 64) {
                    let [key, ...args] = line.split(/\s+/g);
                    let value2 = args.join(" ");
                    if (value2) {
                      value2 = value2.trim();
                      key = key.trim();
                      if (value2) {
                        if (!data.meta) {
                          data.meta = /* @__PURE__ */ Object.create(null);
                        }
                        if (value2 === "false")
                          value2 = false;
                        else if (value2 === "true")
                          value2 = true;
                        else {
                          let val = Number(value2);
                          if (!isNaN(val)) {
                            value2 = val;
                          }
                        }
                        let prop = key.substring(1);
                        let existed = data.meta[prop];
                        if (value2 && (prop === "params" || prop === "param") && typeof value2 === "string") {
                          let [_name, _comment] = value2.split(/\s+/, 2);
                          data.params.push({
                            label: _name,
                            comment: _comment
                          });
                        }
                        if (Object.prototype.hasOwnProperty.call(data.meta, prop)) {
                          if (Array.isArray(existed)) {
                            existed.push(value2);
                          } else {
                            data.meta[prop] = [existed, value2];
                          }
                        } else {
                          data.meta[prop] = value2;
                        }
                      }
                    }
                  }
                });
              }
            } else {
              data.comments.push(text);
            }
          });
          return data;
        }
        return null;
      }
      addUseRef(stack) {
        if (this.is(stack)) {
          if (stack.compilation) {
            stack.compilation.addReferenceStack(this);
          }
          this.useRefItems.add(stack);
        }
      }
      get useRefItems() {
        if (!this._useRefItems) {
          return this._useRefItems = /* @__PURE__ */ new Set();
        }
        return this._useRefItems;
      }
      isSameSource(stack) {
        return stack && stack.compilation === this.compilation && stack.mtime === this.mtime;
      }
      getLastCacheId() {
        return this[keySymbol].lastCacheId || this.compilation.cacheId;
      }
      getCacheId() {
        return this.compilation.cacheId;
      }
      getCache(name, always = false) {
        let id = this.compilation.cacheId;
        if (always) {
          id = this.toString();
        }
        let data = this[keySymbol][id];
        if (!data) {
          let lastId = this[keySymbol].lastCacheId;
          if (lastId) {
            delete this[keySymbol][lastId];
          }
          this[keySymbol].lastCacheId = this.compilation.cacheId;
          data = this[keySymbol][id] = /* @__PURE__ */ Object.create(null);
        }
        if (name) {
          return data[name] || (data[name] = /* @__PURE__ */ Object.create(null));
        }
        return data;
      }
      hasAttribute(name, always = false) {
        const data = this.getCache("attributes", always);
        return Object.prototype.hasOwnProperty.call(data, name);
      }
      hasAttributeAlways(name) {
        return this.hasAttribute(name, true);
      }
      removeAttribute(name, always = false) {
        const data = this.getCache("attributes", always);
        return delete data[name];
      }
      removeAttributeAlways(name) {
        return this.removeAttribute(name, true);
      }
      getAttribute(name, initCallback = null, key = null, always = false) {
        const data = this.getCache("attributes", always);
        if (key) {
          data[name] = data[name] || (data[name] = /* @__PURE__ */ new Map());
        }
        if (initCallback) {
          const has = key ? data[name].has(key) : Object.prototype.hasOwnProperty.call(data, name);
          const countKey = name + "###count###";
          if (!has) {
            if (data[countKey] == null) {
              data[countKey] = 0;
            } else {
              if (data[countKey] > 5) {
                return null;
              }
              data[countKey]++;
            }
          }
          const value2 = !has ? initCallback() : key ? data[name].get(key) : data[name];
          delete data[countKey];
          if (!has && value2 !== void 0) {
            if (key) {
              data[name].set(key, value2);
            } else {
              data[name] = value2;
            }
          }
          return value2;
        }
        if (key) {
          return data[name].get(key);
        }
        return data[name];
      }
      getAttributeAlways(name, initCallback = null, key = null) {
        return this.getAttribute(name, initCallback, key, true);
      }
      setAttribute(name, value2, always = false) {
        const data = this.getCache("attributes", always);
        return data[name] = value2;
      }
      setAttributeAlways(name, value2) {
        return this.setAttribute(name, value2, true);
      }
      createTokenStack(compilation, node2, scope, parentNode, parentStack) {
        return Stack.create(compilation, node2, scope, parentNode, parentStack);
      }
      async createCompleted() {
      }
      getGlobalTypeById(id) {
        const value2 = Namespace.globals.get(id);
        if (!value2) {
          this.error(1083, id);
        }
        return value2;
      }
      getTypeById(id, context) {
        context = context || this.module || this.namespace;
        return this.compilation.getModuleById(id, context);
      }
      getModuleById(id, context) {
        if (this.compilation.hasDeclareJSModule) {
          let pp = this.getParentStack((stack) => stack.isModuleDeclaration && stack.module);
          if (pp.isModuleDeclaration && pp.module) {
            const type3 = pp.module.getType(id);
            if (type3) {
              return type3;
            }
          }
        }
        let type2 = this.scope.define(id);
        if (type2) {
          if (type2.isImportDeclaration)
            type2 = type2.description();
          if (Utils.isTypeModule(type2))
            return type2;
        }
        context = context || this.module || this.namespace;
        return this.compilation.getModuleById(id, context);
      }
      hasModuleById(id, context) {
        if (this.compilation.hasDeclareJSModule) {
          let pp = this.getParentStack((stack) => stack.isModuleDeclaration && stack.module);
          if (pp.isModuleDeclaration && pp.module) {
            if (pp.module.types.has(id)) {
              return false;
            }
          }
        }
        let type2 = this.scope.define(id);
        if (type2) {
          return true;
        }
        context = context || this.module || this.namespace;
        return this.compilation.hasModuleById(id, context);
      }
      checkNeedToLoadTypeById(id, context, flag = false) {
        if (!flag && this.compilation.hasDeclareJSModule) {
          let pp = this.getParentStack((stack) => stack.isModuleDeclaration && stack.module);
          if (pp.isModuleDeclaration && pp.module) {
            if (pp.module.types.has(id)) {
              return false;
            }
          }
        }
        let type2 = this.scope.define(id);
        if (type2) {
          return false;
        }
        context = context || this.module || this.namespace;
        return this.compilation.checkNeedToLoadTypeById(id, context);
      }
      async loadTypeAsync(id, context, checkScope = true) {
        context = context || this.module || this.namespace;
        return await this.compilation.loadTypeAsync(id, context, !!this.isImportDeclaration, checkScope);
      }
      getLocation() {
        return this.node.loc || this.compilation.getRangeByNode(this.node);
      }
      getContext() {
        return this.getContextOfInference();
      }
      getContextOfInference() {
        let infer = this.#inference;
        if (infer)
          return infer;
        let parent = null;
        if (this.isIdentifier) {
          let pp = this.parentStack;
          if ((pp.isFunctionExpression || pp.isMethodDefinition) && this === pp.key) {
            return pp.getContextOfInference();
          } else if (pp.isVariableDeclarator && pp.id === this) {
            return pp.getContextOfInference();
          } else if (pp.isProperty && pp.key === this) {
            return pp.getContextOfInference();
          }
        }
        if (this.isCallExpression || this.isNewExpression) {
          let callee = Inference.getCalleeStack(this.callee);
          const desc = callee.description();
          if (this.is(desc) && desc.isDeclarator) {
            let pp = desc.parentStack;
            if (pp.isFunctionExpression) {
              pp = pp.parentStack;
            }
            while (pp && (pp.isProperty || pp.isObjectExpression || pp.isArrayExpression)) {
              pp = pp.parentStack;
            }
            if (pp.isNewExpression || pp.isCallExpression) {
              parent = pp.getContextOfInference();
            }
          } else if (callee.isMemberExpression) {
            parent = callee.object.getContextOfInference();
          }
        } else if (this.isFunctionExpression && !this.parentStack.isMethodDefinition || this.isArrayExpression || this.isObjectExpression) {
          let pp = this.parentStack;
          while (pp && (pp.isProperty || pp.isObjectExpression || pp.isArrayExpression)) {
            pp = pp.parentStack;
          }
          if (pp.isCallExpression || pp.isNewExpression || pp.isVariableDeclarator && pp.acceptType || pp.isAssignmentExpression) {
            parent = pp.getContextOfInference();
          }
        } else if (this.isDeclarator) {
          if (this.isParamDeclarator) {
            let pp = this.parentStack.parentStack;
            while (pp && (pp.isProperty || pp.isObjectExpression || pp.isArrayExpression)) {
              pp = pp.parentStack;
            }
            if (pp.isCallExpression || pp.isNewExpression) {
              parent = pp.getContextOfInference();
              this.#inference = parent.create(this);
              return this.#inference;
            }
          } else if (this.isImportSpecifier || this.isImportDefaultSpecifier || this.isImportNamespaceSpecifier) {
            let desc = this.descriptor();
            if (desc && desc !== this && this.is(desc)) {
              parent = desc.getContextOfInference();
            }
          } else if (this.isVariableDeclarator && this.init && !this.init.isFunctionExpression && !this.acceptType) {
            parent = this.init.getContextOfInference();
          }
        } else if (this.isIdentifier || this.isAssignmentExpression) {
          let pp = this.parentStack;
          if (pp.isAssignmentPattern) {
            pp = pp.parentStack;
          }
          if (!pp.isAnnotationExpression) {
            let desc = this.description();
            if (desc && desc !== this && this.is(desc)) {
              return desc.getContextOfInference();
            }
          }
        } else if (this.isMemberExpression) {
          if (this.parentStack.isImportDeclaration) {
            return this.parentStack.getContextOfInference();
          }
          parent = this.object.getContextOfInference();
        }
        this.#inference = Inference.create(this, parent);
        this.#inference.init();
        return this.#inference;
      }
      debug(match, row = null, callback = null) {
        let line = this.node.loc.start.line;
        let file = this.file;
        if (typeof row === "function") {
          callback = row;
          row = null;
        }
        if (match) {
          if (!file || !file.includes(match)) {
            return;
          }
        }
        if (row && line !== row) {
          return;
        }
        if (callback) {
          callback(line);
          return;
        }
        console.log(`[debug] ${file}:${line}`);
      }
      newContext() {
        return Inference.create(this);
      }
      getParentStack(callback, flag = false) {
        let parent = flag ? this : this.parentStack;
        while (parent && !callback(parent) && parent.parentStack) {
          parent = parent.parentStack;
        }
        return parent || this;
      }
      definition(context) {
        if (this.parentStack) {
          return this.parentStack.definition(context);
        }
        return null;
      }
      hover(context) {
        let result = this.definition(context);
        if (result) {
          if (Array.isArray(result)) {
            result = result[0];
          }
        }
        ;
        if (result && result.text == null) {
          result.text = result.expre;
        }
        return result;
      }
      signature() {
        return this.definition();
      }
      formatHover(def, items) {
        if (!Array.isArray(items)) {
          if (!items) {
            return def;
          } else {
            items = [items, def];
          }
        } else {
          if (!items.length) {
            return def;
          }
          items = items.filter(Boolean);
          items.push(def);
        }
        let message = "";
        const comments = [];
        const cache = {};
        items.forEach((item2) => {
          let text = String(item2.text || item2.expre).trim();
          let prefix = item2 === def || text.charCodeAt(0) === 40 ? "" : "(alias) ";
          if (!cache[text]) {
            message += prefix + text + "\n";
            cache[text] = true;
          }
          if (item2.comments && Array.isArray(item2.comments)) {
            comments.push(...item2.comments);
          }
        });
        def.text = message.trim();
        def.comments = comments;
        return def;
      }
      definitionMergeToArray(defs, append = null) {
        if (!Array.isArray(defs)) {
          if (!defs) {
            if (append)
              return [append];
            return [];
          } else {
            defs = [defs];
          }
        } else {
          defs = defs.filter(Boolean);
        }
        let expre = "";
        let comments = [];
        const cache = {};
        const make = (item2) => {
          let text = String(item2.text || item2.expre).trim();
          let prefix = item2 === append || text.charCodeAt(0) === 40 ? "" : "(alias) ";
          if (item2[mergeArrayKey]) {
            expre = prefix + text + "\n";
            comments = item2.comments;
            return;
          }
          if (!cache[text]) {
            expre += prefix + text + "\n";
            cache[text] = true;
          }
          if (item2.comments) {
            if (Array.isArray(item2.comments)) {
              comments.push(...item2.comments);
            }
          }
        };
        defs.forEach((item2) => make(item2));
        if (append) {
          make(append);
          defs.unshift(append);
        }
        expre = expre.trim();
        return defs.map((item2) => {
          return {
            text: expre,
            comments,
            selection: item2.selection,
            location: item2.location,
            file: item2.file,
            kind: item2.kind,
            [mergeArrayKey]: true
          };
        });
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [];
      }
      description() {
        return this;
      }
      descriptor(desc = null) {
        desc = desc || this.description();
        if (desc && desc !== this && this.is(desc)) {
          return desc.descriptor();
        }
        return desc;
      }
      getDescriptorOwner(desc) {
        if (!desc)
          return null;
        let object = desc.module || desc.namespace;
        if (object && (Module.is(object) || Namespace.is(object))) {
          return object;
        }
        if (desc.isType && desc.target) {
          return this.getDescriptorOwner(desc.target);
        }
        return null;
      }
      type() {
        return null;
      }
      getReferenceType() {
        if (this.isIdentifier) {
          let isMemberExpression = false;
          if (this.parentStack.isMemberExpression) {
            isMemberExpression = true;
            if (this.parentStack.object !== this) {
              return null;
            }
          }
          let id = this.value();
          let desc = this.scope.define(id);
          if (desc) {
            this._hasLocalDefined = true;
            if (desc.isDeclaratorVariable && this.parentStack === desc.acceptType) {
              desc = this.scope.parent.define(id);
            }
          }
          if (desc && desc.isDeclaratorVariable) {
            if (JSModule.is(desc.module)) {
              desc = desc.module.getType(id);
            } else {
              desc = desc.namespace.modules.get(id);
            }
          }
          if (desc && isMemberExpression) {
            if (!(desc.isImportNamespaceSpecifier || desc.isImportSpecifier || desc.isImportDefaultSpecifier)) {
              desc = null;
            }
          }
          if (desc) {
            if (isMemberExpression) {
              let _desc = this.getImportedType(desc, true);
              if (_desc)
                return _desc;
              _desc = this.getTypeFromJSModule(desc.module, id, isMemberExpression, true);
              if (_desc)
                return _desc;
            } else {
              if (desc.isGenericTypeDeclaration || desc.isGenericTypeAssignmentDeclaration || desc.isTypeInferDefinition || desc.isTypeStatement || desc.isDeclaratorTypeAlias || desc.isEnumDeclaration && desc.isExpressionDeclare) {
                if (this.parentStack.isTypeDefinition || this.parentStack.isTypeGenericDefinition) {
                  return desc;
                }
                return desc.type();
              }
              if (Type.is(desc))
                return desc;
              desc = this.getImportedType(desc);
              if (desc)
                return desc;
            }
            return null;
          } else {
            if (this.compilation.hasDeclareJSModule) {
              let pp = this.getParentStack((stack) => stack.isModuleDeclaration && stack.module);
              if (pp.isModuleDeclaration && pp.module) {
                if (isMemberExpression) {
                  const ns = pp.module.namespaces.get(id) || JSModule.getModuleFromNamespace(id);
                  if (ns) {
                    return ns;
                  }
                }
                const type2 = this.getTypeFromJSModule(pp.module, id, isMemberExpression, true);
                if (type2) {
                  return type2;
                }
              }
            }
            if (isMemberExpression) {
              return Namespace.fetch(id, null, true);
            } else {
              return this.compilation.getModuleById(id, this.module || this.namespace);
            }
          }
        } else if (this.isMemberExpression) {
          if (!this.parentStack.isMemberExpression) {
            const type2 = JSModule.getType(this.value());
            if (type2) {
              return type2;
            }
          }
          let description = this.object.getReferenceType();
          if (!description)
            return null;
          let property = this.property.value();
          if (Namespace.is(description)) {
            if (this.parentStack.isMemberExpression) {
              return description.children.get(property);
            }
            return description.modules.get(property);
          } else {
            return this.getTypeFromJSModule(description.isNamespaceDeclaration ? description.module : description, property, !!this.parentStack.isMemberExpression);
          }
        }
        return null;
      }
      getTypeFromJSModule(object, property, isNs, isRefs = false) {
        if (!JSModule.is(object))
          return null;
        if (isNs) {
          let nsModule = object.namespaces.get(property);
          if (nsModule)
            return nsModule;
          let desc = object.getExport(property);
          if (!desc)
            return null;
          if (desc && desc.isNamespaceDeclaration)
            return desc.module;
          if (desc.isImportDefaultSpecifier || desc.isImportNamespaceSpecifier || desc.isImportSpecifier) {
            desc = desc.description();
          }
          if (JSModule.is(desc))
            return desc;
        } else {
          let desc = object.getType(property) || object.getExport(property);
          if (desc) {
            if (this.is(desc))
              desc = desc.type();
            if (Type.is(desc))
              return desc;
          }
        }
        return null;
      }
      getImportedType(object, allowNs = false) {
        if (!object)
          return null;
        if (!allowNs && object.isImportDeclaration) {
          return object.description();
        }
        if (object.isImportNamespaceSpecifier || object.isImportSpecifier || object.isImportDefaultSpecifier) {
          let desc = object.descriptor();
          if (desc) {
            if (allowNs) {
              if (desc.isNamespaceDeclaration) {
                return desc;
              } else if (desc.isExportAssignmentDeclaration) {
                const object2 = desc.getExportNamespace();
                if (object2) {
                  return object2;
                }
              } else if (JSModule.is(desc)) {
                return desc;
              }
            } else {
              const _type = desc.type();
              if (Type.is(_type)) {
                return _type;
              }
            }
          }
        }
        return null;
      }
      getReferenceModuleType() {
        const type2 = this.getReferenceType();
        if (type2 && Module.is(type2)) {
          return type2;
        }
        return null;
      }
      hasLocalReferenceType(id) {
        return this.getAttribute("hasLocalReferenceType:" + id, () => {
          if (this.compilation.hasDeclareJSModule) {
            let pp = this.getParentStack((stack) => stack.isModuleDeclaration);
            if (pp.isModuleDeclaration) {
              const type3 = pp.module.getType(id);
              if (type3) {
                return true;
              }
            }
          }
          let type2 = this.scope.define(id);
          if (type2 && !(type2 instanceof Type)) {
            if (type2.isGenericTypeDeclaration || type2.isGenericTypeAssignmentDeclaration || type2.isTypeStatement || type2.isEnumDeclaration && type2.isExpressionDeclare) {
              return true;
            }
            type2 = null;
          }
          if (!type2) {
            type2 = this.hasModuleById(id);
          }
          return !!type2;
        });
      }
      getTypeDisplayName(type2, ctx, options = {}) {
        if (!type2)
          return "unknown";
        ctx = ctx || this.getContext();
        if (Utils.isContext(ctx)) {
          if (type2.isConditionalExpressionType || type2.isInferGenericType) {
            type2 = type2.getResult(ctx);
          }
        }
        if (Array.isArray(type2)) {
          if (type2.length > 1) {
            return type2.map((item2) => item2.type().toString(ctx, options)).join(" | ");
          } else {
            type2 = type2[0].type();
          }
        }
        return MergeType.to(Utils.inferTypeValue(type2, ctx.inference)).toString(ctx, options);
      }
      getTypeLiteralValueString(type2, ctx) {
        if (!type2)
          return "unknown";
        ctx = ctx || this.getContext();
        type2 = ctx.fetch(type2, true);
        if (type2.isLiteralType) {
          return type2.toString(ctx, { toLiteralValue: true });
        }
        return type2.toString(ctx);
      }
      isLiteralValueConstraint(type2, ctx) {
        ctx = ctx || this.getContext();
        const check = (type3, flag) => {
          if (type3) {
            type3 = ctx.fetch(type3, true);
            if (type3.isLiteralType && (flag || type3.isLiteralValueType)) {
              return true;
            } else if (type3.isKeyofType) {
              return true;
            } else if (type3.isUnionType) {
              return type3.elements.every((item2) => {
                return check(item2.type(), true);
              });
            }
          }
          return false;
        };
        return check(type2);
      }
      checkGenericConstraint(genericType, argumentStack, context) {
        var checkResult = true;
        if (genericType.isGenericType && genericType.hasConstraint) {
          const acceptType = genericType.inherit;
          const assignType = context.fetch(genericType);
          if (assignType && !assignType.isGenericType && !acceptType.check(assignType, context)) {
            checkResult = false;
            argumentStack.error(
              1003,
              this.getTypeDisplayName(assignType, context, { toLiteralValue: acceptType.isKeyofType }),
              this.getTypeDisplayName(acceptType, context)
            );
          }
        }
        return checkResult;
      }
      checkExpressionType(acceptType, expression, curStack = null, ctx = null) {
        let checkResult = true;
        if (acceptType && expression) {
          acceptType = acceptType.type();
          if (!ctx) {
            ctx = expression.isStack && expression.node && expression.compilation ? expression.getContext() : this.getContext();
          }
          if (expression.isArrayExpression || expression.isObjectExpression || expression.isSpreadElement && expression.argument.isArrayExpression) {
            ctx.errorHandler = (result, acceptType2, assignmentStack, assignmentType) => {
              if (!result && assignmentStack && assignmentStack.isStack) {
                if (assignmentStack.isProperty && assignmentStack.init) {
                  assignmentStack = assignmentStack.init;
                } else if (assignmentStack.isTypeAssertExpression) {
                  assignmentStack = assignmentStack.left;
                }
                assignmentType = assignmentType || assignmentStack.type();
                assignmentStack.error(1009, this.getTypeDisplayName(assignmentType, ctx), this.getTypeDisplayName(acceptType2, ctx));
                checkResult = false;
                return true;
              }
              return result;
            };
          }
          if (acceptType && !acceptType.check(expression, ctx)) {
            let target = curStack || expression;
            if (target) {
              target = target.isTypeAssertExpression ? target.left : target;
            }
            if (!(target && target.isStack))
              target = this;
            target.error(1009, this.getTypeDisplayName(expression.type(), ctx), this.getTypeDisplayName(acceptType, ctx));
            checkResult = false;
          }
          ctx.errorHandler = null;
        }
        return checkResult;
      }
      checkArgumentItemType(argumentStack, declareParam, acceptType, context, whenErrorStack) {
        var checkResult = true;
        if (declareParam.isObjectPattern) {
          const argumentType = argumentStack.type();
          let isModule = argumentType.isEnum && argumentType.isModule || argumentType.isInterface && argumentType.isModule;
          if (argumentType.isLiteralObjectType || argumentType.isInstanceofType || argumentType.isEnumType || isModule) {
            declareParam.properties.forEach((property) => {
              let propertyStack = isModule ? argumentType.getMember(property.key.value(), "get") : argumentType.attribute(property.key.value(), "get");
              let throwErrorStack = argumentStack.isObjectExpression && propertyStack && propertyStack.isStack && propertyStack.init ? propertyStack.init : argumentStack;
              if (propertyStack && propertyStack.isStack) {
                checkResult = this.checkArgumentItemType(propertyStack, property, property.type(), context, throwErrorStack);
              } else if (argumentStack.isObjectExpression) {
                checkResult = false;
                (whenErrorStack || argumentStack).error(1152, property.key.value());
              }
            });
          } else if (!argumentType.isAnyType && acceptType) {
            if (!acceptType.is(argumentType, context)) {
              checkResult = false;
              (whenErrorStack || argumentStack).error(1002, this.getTypeDisplayName(argumentType, context), this.getTypeDisplayName(acceptType, context));
            }
          }
        } else if (declareParam.isArrayPattern) {
          const argumentType = argumentStack.type();
          if (argumentType.isLiteralArrayType) {
            declareParam.elements.forEach((property, index) => {
              let propertyStack = argumentType.attribute(index);
              let throwErrorStack = argumentStack.isArrayExpression && propertyStack && propertyStack.isStack ? propertyStack : argumentStack;
              if (propertyStack) {
                return this.checkArgumentItemType(propertyStack, property, property.type(), context, throwErrorStack);
              } else if (argumentStack.isArrayExpression) {
                checkResult = false;
                (whenErrorStack || argumentStack).error(1152, `index-property-${index}`);
              }
            });
          } else {
            const iteratorType = this.getGlobalTypeById("Iterator");
            if (!argumentType.is(iteratorType, context)) {
              checkResult = false;
              (whenErrorStack || argumentStack).error(1002, this.getTypeDisplayName(argumentType, context), this.getTypeDisplayName(iteratorType, context), context);
            }
          }
        } else if (acceptType) {
          const orgType = acceptType;
          const checkConstraint = (acceptType2, argumentStack2, context2) => {
            if (!this.checkGenericConstraint(acceptType2, argumentStack2, context2)) {
              checkResult = false;
            }
          };
          if (acceptType.isGenericType) {
            checkConstraint(acceptType, argumentStack, context);
          } else if (acceptType.hasGenericType) {
            if (acceptType.isTupleType || acceptType.isUnionType || acceptType.isLiteralArrayType) {
              acceptType.elements.forEach((elem) => checkConstraint(elem.type(), argumentStack, context));
            } else if (acceptType.isLiteralObjectType) {
              acceptType.properties.forEach((elem) => checkConstraint(elem.type(), argumentStack, context));
              acceptType.dynamicProperties && acceptType.dynamicProperties.forEach((elem) => checkConstraint(elem.type(), argumentStack, context));
            }
          }
          if (acceptType) {
            if (argumentStack.isArrayExpression || argumentStack.isObjectExpression || argumentStack.isFunctionExpression || argumentStack.isSpreadElement && argumentStack.argument.isArrayExpression) {
              context.errorHandler = (result, acceptType2, checkStack, isFunParam = false) => {
                if (!result && this.is(checkStack)) {
                  if (checkStack.isProperty && checkStack.init) {
                    checkStack = checkStack.init;
                  } else if (checkStack.parentStack.isProperty) {
                    checkStack = checkStack.parentStack;
                  }
                  if (acceptType2) {
                    checkStack.error(1002, this.getTypeDisplayName(checkStack.type(), context), this.getTypeDisplayName(acceptType2, context));
                  } else {
                    if (isFunParam) {
                      checkStack.warn(1206, checkStack.value());
                    } else {
                      checkStack.error(1009, this.getTypeDisplayName(checkStack.type(), context), "unknown");
                    }
                  }
                  return true;
                }
                return result;
              };
            }
            if (!acceptType.type().check(argumentStack, context)) {
              checkResult = false;
              if (orgType.hasConstraint) {
                (whenErrorStack || argumentStack).error(1003, this.getTypeDisplayName(argumentStack.type(), context), this.getTypeDisplayName(orgType.inherit, context));
              } else {
                (whenErrorStack || argumentStack).error(1002, this.getTypeDisplayName(argumentStack.type(), context), this.getTypeDisplayName(acceptType, context));
              }
            }
            context.errorHandler = null;
            return checkResult;
          }
        }
        return checkResult;
      }
      checkMatchType(argumentStack, declareParam, acceptType, context) {
        if (!acceptType)
          return true;
        const argumentType = argumentStack.type();
        if (!argumentType) {
          return false;
        }
        if (argumentType.isGenericType) {
          return true;
        }
        if (argumentStack.isSpreadElement && (argumentType.isTupleType || argumentType.isLiteralArrayType)) {
          return argumentType.elements.some((el) => acceptType.is(el.type(), context));
        }
        if (declareParam && declareParam.isObjectPattern) {
          if (argumentType.isLiteralObjectType || argumentType.isInstanceofType || argumentType.isEnumType || argumentType.isEnum && argumentType.isModule) {
            return true;
          } else {
            const objectType = Namespace.globals.get("object");
            return objectType.is(argumentType, context);
          }
        } else if (declareParam && declareParam.isArrayPattern) {
          const arrayType = Namespace.globals.get("array");
          return arrayType.is(argumentType);
        } else if (acceptType) {
          if (acceptType.isGenericType) {
            if (acceptType.hasConstraint && acceptType.inherit) {
              const constraint = acceptType.inherit.type();
              if (constraint !== acceptType) {
                let _ctx = this.is(declareParam) ? declareParam.getContext().create(argumentStack) : null;
                return this.checkMatchType(argumentStack, declareParam, constraint, _ctx);
              }
            }
            return true;
          } else if (acceptType.isFunctionType) {
            if (!argumentType.isFunctionType)
              return false;
            let last = acceptType.params[acceptType.params.length - 1];
            let hasRest = last && last.isRestElement ? true : false;
            if (argumentType.params.length > acceptType.params.length && !hasRest)
              return false;
            return acceptType.params.every((decl2, index) => {
              const assign = argumentType.params[index];
              if (assign)
                return true;
              return !!(decl2.isAssignmentPattern || decl2.question || decl2.isRestElement);
            });
          } else if (acceptType.isLiteralObjectType) {
            return acceptType.constraint(argumentType, context);
          } else if (acceptType.isLiteralArrayType) {
            const arrayType = Namespace.globals.get("array");
            return arrayType.is(argumentType);
          }
          if (!acceptType.is(argumentType, context)) {
            return false;
          }
        }
        return true;
      }
      getMatchDescriptor(property, classModule, isStatic = false, onlyAccessProperty = false) {
        if (!property || !classModule || !(classModule.isModule || classModule.isNamespace || JSModule.is(classModule) || classModule.isUnionType && property === "#match-union-type" || classModule.isLiteralObjectType && (property === "#new#" || property === "#call#")))
          return null;
        if (classModule.isClassGenericType && classModule.isClassType) {
          return this.getMatchDescriptor(property, type.types[0], true);
        }
        let args = null;
        let assigments = null;
        let pStack = this;
        let isCall = !!this.isCallExpression;
        let isNew = this.isNewExpression;
        let isSet = this.isAssignmentExpression || this.parentStack.isAssignmentExpression && this.parentStack.left === this;
        if (!isCall && (this.parentStack.isCallExpression || this.parentStack.isNewExpression) && this.parentStack.callee === this) {
          isCall = true;
          pStack = this.parentStack;
          if (!isNew && this.parentStack.isNewExpression) {
            isNew = true;
          }
        }
        if (onlyAccessProperty) {
          isCall = false;
          isNew = false;
          isSet = false;
        }
        if (isCall || isNew) {
          isCall = true;
          args = pStack.arguments || emptyOnlyreadArray;
          assigments = pStack.genericity || emptyOnlyreadArray;
        }
        let incompleteFlag = 0;
        let matchResult = false;
        const checkMatchFun = (params, declareGenerics, desc) => {
          incompleteFlag = 0;
          matchResult = false;
          if (params.length === args.length && args.length === 0) {
            return matchResult = true;
          } else if (params.length >= args.length) {
            if (assigments.length > 0) {
              if (declareGenerics.length < assigments.length)
                incompleteFlag = FAILED_ASSING_GENERICS;
              if (declareGenerics.length > assigments.length)
                incompleteFlag = MISSING_ASSING_GENERICS;
            } else if (declareGenerics.length > 0) {
              const required = declareGenerics.some((item2) => {
                if (item2.isGenericTypeDeclaration && !item2.extends) {
                  return true;
                }
                return false;
              });
              if (required) {
                incompleteFlag = NOT_ASSING_GENERICS;
              }
            }
            if (!isNew && desc.isConstructor) {
              incompleteFlag |= DESCRIPTOR_TYPE_UNMATCH;
            }
            matchResult = params.every((declare, index) => {
              const argument = args[index];
              const optional = !!(declare.question || declare.isAssignmentPattern);
              if (argument) {
                if (argument.isSpreadElement && declare.isRestElement) {
                  return true;
                } else if (declare.isRestElement) {
                  let acceptType2 = declare.type();
                  if (acceptType2.isTupleType) {
                    return args.slice(index).every((arg) => {
                      return acceptType2.elements.some((el) => this.checkMatchType(arg, el, el.type()));
                    });
                  } else {
                    return false;
                  }
                }
                let acceptType = declare.type();
                if (declareGenerics && assigments && acceptType && acceptType.isGenericType) {
                  for (let i = 0; i < declareGenerics.length; i++) {
                    if (acceptType === declareGenerics[i].type()) {
                      if (assigments[i]) {
                        acceptType = assigments[i].type();
                      }
                      break;
                    }
                  }
                }
                let ctx = {};
                if (acceptType && acceptType.isClassGenericType) {
                  ctx = Inference.getInferenceFromType(acceptType);
                }
                if (this.checkMatchType(argument, declare, acceptType, ctx)) {
                  return true;
                } else {
                  if (acceptType && acceptType.isFunctionType && argument.type().isFunctionType) {
                    incompleteFlag |= FUN_TYPE_PARAMS_UNMATCH;
                  }
                  return false;
                }
              }
              return optional;
            });
            return matchResult && incompleteFlag === 0;
          }
          return false;
        };
        let target = null;
        const records = [];
        const update = (desc, params, generics) => {
          records[0] = desc;
          records[1] = params;
          records[2] = generics;
          records[3] = matchResult;
          records[4] = incompleteFlag;
          return records;
        };
        const calcScore = (result2, params, generics, incompleteFlag2, desc) => {
          let score = result2 ? 500 : 0;
          if (incompleteFlag2 === -1) {
            return -1;
          }
          if (assigments && assigments.length > 0) {
            score += generics.length;
          }
          if ((NOT_ASSING_GENERICS & incompleteFlag2) === NOT_ASSING_GENERICS) {
            score -= generics.length;
            for (let i = 0; i < generics.length; i++) {
              const decl2 = generics[i].type();
              if (decl2.assignType) {
                score += generics.length - i;
                break;
              }
            }
          }
          if ((FUN_TYPE_PARAMS_UNMATCH & incompleteFlag2) === FUN_TYPE_PARAMS_UNMATCH) {
            score += 1;
          }
          if ((MISSING_ASSING_GENERICS & incompleteFlag2) === MISSING_ASSING_GENERICS) {
            score -= generics.length - assigments.length;
          }
          if ((FAILED_ASSING_GENERICS & incompleteFlag2) === FAILED_ASSING_GENERICS) {
            score -= 500;
            score -= assigments.length - generics.length;
          }
          if ((DESCRIPTOR_TYPE_UNMATCH & incompleteFlag2) === DESCRIPTOR_TYPE_UNMATCH) {
            score -= 1;
          }
          if (args.length > params.length) {
            score -= args.length - params.length;
          } else if (args.length < params.length) {
            score -= params.length - args.length;
          }
          return score;
        };
        const choose = (prev, desc, params, generics) => {
          if (!prev) {
            records.push(desc, params, generics, matchResult, incompleteFlag);
            return records;
          }
          let pScore = calcScore(prev[3], prev[1], prev[2], prev[4], prev[0]);
          let cScore = calcScore(matchResult, params, generics, incompleteFlag, desc);
          let pResult = (FAILED_ASSING_GENERICS & prev[4]) !== FAILED_ASSING_GENERICS && prev[3];
          let cResult = (FAILED_ASSING_GENERICS & incompleteFlag) !== FAILED_ASSING_GENERICS && matchResult;
          if (pResult && cResult && pScore === cScore && desc.toString() === prev.toString()) {
            if (desc.isDeclaratorFunction || desc.isDeclaratorVariable) {
              const cAnnots = desc.annotations.length + desc.imports.length;
              const pAnnots = prev.annotations.length + prev.imports.length;
              if (cAnnots > pAnnots) {
                return update(desc, params, generics);
              } else if (cAnnots < pAnnots) {
                return prev;
              }
            }
          }
          if (cResult) {
            if (pResult && pScore > cScore)
              return prev;
            return update(desc, params, generics);
          }
          if (!pResult && cScore >= pScore) {
            return update(desc, params, generics);
          } else {
            return prev;
          }
        };
        const filter = (desc, prev, index, descriptors, extendsContext) => {
          const isStaticDesc = desc.callableStatic || Utils.isStaticDescriptor(desc);
          if (isStatic) {
            if (!isStaticDesc && !desc.isReadonly) {
              if (!extendsContext || !extendsContext.callableStatic)
                return false;
            }
          } else if (isStaticDesc) {
            return false;
          }
          incompleteFlag = -1;
          if (isCall) {
            if (desc.isEnumProperty || desc.isMethodSetterDefinition || desc.isModuleDeclaration)
              return false;
            let params = emptyOnlyreadArray;
            let generics = emptyOnlyreadArray;
            if (desc.isMethodDefinition && !desc.isMethodGetterDefinition || desc.isDeclaratorFunction || desc.isTypeFunctionDefinition || isNew && desc.isNewDefinition || !isNew && desc.isCallDefinition) {
              generics = desc.genericity ? desc.genericity.elements : emptyOnlyreadArray;
              params = desc.params || emptyOnlyreadArray;
              if (isNew) {
                if (!(desc.isConstructor || desc.isNewDefinition || desc.isTypeFunctionDefinition))
                  return false;
                if (generics === emptyOnlyreadArray && !desc.isNewDefinition && !(desc.isDeclaratorFunction || desc.isTypeFunctionDefinition) && Module.is(desc.module)) {
                  generics = desc.module.getModuleDeclareGenerics(false, true);
                }
              }
              if (checkMatchFun(params, generics, desc)) {
                return true;
              }
            } else if (desc.isPropertyDefinition || desc.isMethodGetterDefinition || desc.isDeclaratorVariable || desc.isDeclaratorDeclaration || desc.isInterfaceDeclaration) {
              if (desc.isDeclaratorVariable && descriptors && descriptors.length === 1) {
                return true;
              }
              let type2 = desc.type();
              if (type2) {
                if (isNew) {
                  if (type2.isClassGenericType && type2.isClassType) {
                    return true;
                  }
                  if (desc.isDeclaratorDeclaration && type2.isClass) {
                    return true;
                  }
                }
                if (type2.isFunctionType) {
                  generics = type2.generics;
                  params = type2.params || emptyOnlyreadArray;
                  if (checkMatchFun(params, generics, desc)) {
                    return true;
                  }
                } else {
                  let _result = this.findImplementedCallableDescriptorByType(type2, isNew);
                  if (_result) {
                    return true;
                  }
                }
              }
            }
            return choose(prev, desc, params, generics);
          } else if (isSet) {
            if (desc.isEnumProperty || desc.isModuleDeclaration)
              return false;
            if (desc.isMethodSetterDefinition) {
              return true;
            } else if (desc.isPropertyDefinition) {
              if (!desc.isReadonly) {
                return true;
              }
            }
          } else {
            if (desc.isMethodGetterDefinition || desc.isPropertyDefinition || desc.isEnumProperty || desc.isDeclaratorVariable || desc.isDeclaratorFunction || desc.isModuleDeclaration || desc.isTypeFunctionDefinition) {
              return true;
            }
          }
          return prev || desc;
        };
        if (classModule.isUnionType) {
          if (!isCall || isNew)
            return null;
          let resules = [];
          let matchedResules = [];
          let prev = null;
          classModule.elements.forEach((item2) => {
            const type2 = item2.type();
            if (type2.isFunctionType) {
              const generics = type2.generics || emptyOnlyreadArray;
              const params = type2.params || emptyOnlyreadArray;
              if (checkMatchFun(params, generics, type2)) {
                matchedResules.push(type2);
              } else {
                const value2 = choose(prev, type2, params, generics);
                const res = value2 === records ? value2[0] : value2;
                prev = value2;
                if (!resules.includes(res)) {
                  resules.push(res);
                }
              }
            }
          });
          if (matchedResules.length > 0) {
            return matchedResules;
          }
          return resules;
        }
        const result = classModule.getDescriptor(property, filter, { isNew, isCall });
        return result === records ? result[0] : target || result;
      }
      findImplementedCallableDescriptorByType(type2, isNew = false) {
        if (!type2)
          return false;
        const Fun = isNew ? null : Namespace.globals.get("Function");
        const fetch = (type3, exclude = null) => {
          if (type3 === exclude)
            return null;
          if (!type3 || type3.isNullableType || type3.isNeverType || type3.isVoidType || type3.isUndefinedType || type3.isAnyType)
            return null;
          if (type3.isComputeType) {
            type3 = type3.getResult();
          }
          if (type3.isLiteralObjectType) {
            if (isNew) {
              type3 = this.getMatchDescriptor(`#new#`, type3);
            } else {
              type3 = this.getMatchDescriptor(`#call#`, type3);
            }
          }
          if (!type3 || type3.isAnyType)
            return null;
          if (!isNew) {
            if (type3 === Fun || type3.isFunctionType || type3.isTypeFunctionDefinition)
              return type3;
          }
          if (type3.isTypeofType) {
            return fetch(type3.origin.type(), type3);
          } else if (type3.isIntersectionType) {
            return fetch(type3.left.type(), type3) || fetch(type3.right.type(), type3);
          } else if (type3.isUnionType) {
            const els = type3.elements;
            for (let index = 0; index < els.length; index++) {
              let res = fetch(els[index].type(), type3);
              if (res)
                return res;
            }
            return null;
          } else if (type3.isAliasType) {
            if (Utils.isGlobalShortenType(type3))
              return null;
            return fetch(type3.inherit.type(), type3);
          }
          if (Utils.isTypeModule(type3)) {
            if (isNew) {
              return this.getMatchDescriptor(`constructor`, type3);
            } else {
              return this.getMatchDescriptor(`#${type3.id}`, type3);
            }
          } else {
            return fetch(Utils.getOriginType(type3), type3);
          }
        };
        return fetch(type2);
      }
      getObjectDescriptor(object, property, isStatic = false, prevObject = null, context = null) {
        if (!object)
          return null;
        if (!(object instanceof Type)) {
          return null;
        }
        const ctx = context || this.getContext();
        object = ctx.infer(object.type());
        if (object === prevObject) {
          return Namespace.globals.get("any");
        }
        if (object.isTypeofType) {
          object = object.origin;
        }
        if (object.isComputeType) {
          object = object.getResult();
        }
        if (object.isAnyType)
          return Namespace.globals.get("any");
        if (object.isAliasType) {
          return this.getObjectDescriptor(object.inherit.type(), property, isStatic, object, context);
        }
        if (object.isClassGenericType) {
          if (object.isClassType) {
            return this.getObjectDescriptor(object.types[0].type(), property, true, object, context);
          } else {
            const wrap = object.inherit.type();
            if (wrap.target && wrap.target.isDeclaratorTypeAlias && wrap.target.genericity) {
              const declareGenerics = wrap.target.genericity.elements;
              if (object.elements.length === 1 && declareGenerics.length === 1) {
                const has = declareGenerics[0].type() === wrap.inherit.type();
                if (has) {
                  return this.getObjectDescriptor(object.elements[0].type(), property, false, object, context);
                }
              }
              const ctx2 = Inference.getInferenceFromType(object);
              return this.getObjectDescriptor(wrap.inherit.type(), property, false, object, ctx2);
            }
          }
        } else if (object.isInstanceofType) {
          const wrap = object.inherit.type();
          if (wrap.target && wrap.target.isDeclaratorTypeAlias && wrap.target.genericity) {
            const declareGenerics = wrap.target.genericity.elements;
            if (object.generics.length === 1 && declareGenerics.length === 1) {
              const has = declareGenerics[0].type() === wrap.inherit.type();
              if (has) {
                return this.getObjectDescriptor(object.generics[0].type(), property, false, object, context);
              }
            }
            const ctx2 = Inference.getInferenceFromType(object);
            return this.getObjectDescriptor(wrap.inherit.type(), property, false, object, ctx2);
          }
        }
        if (object.isIntersectionType) {
          const anyType = Namespace.globals.get("any");
          const lType = this.getObjectDescriptor(object.left.type(), property, isStatic, object, context);
          if (lType && lType !== anyType)
            return lType;
          const rType = this.getObjectDescriptor(object.right.type(), property, isStatic, object, context);
          if (rType && rType !== anyType)
            return rType;
          return lType || rType;
        }
        let dynamicAttribute = false;
        let result = null;
        if (object.isUnionType) {
          const properties = [];
          const elems = object.elements;
          const checkCall = (stack) => {
            if (!stack)
              return false;
            return (stack.isCallExpression || stack.isNewExpression) && stack.callee === this;
          };
          const isCall = checkCall(this) || checkCall(this.parentStack);
          const isTypeDefinition = (stack) => {
            return stack.isTypeObjectPropertyDefinition || stack.isPropertyDefinition || stack.isMethodGetterDefinition;
          };
          let matchResult = null;
          let isFullMatch = true;
          let anyType = null;
          let hasNull = false;
          for (let i = 0; i < elems.length; i++) {
            const item2 = elems[i];
            const objectType = item2.type();
            const isNull = Utils.isNullType(objectType);
            if (!objectType || objectType.isAnyType || isNull) {
              if (isNull) {
                hasNull = true;
              }
              if (objectType.isAnyType) {
                anyType = objectType;
              }
              continue;
            }
            const result2 = this.getObjectDescriptor(objectType, property, isStatic, object, context);
            if (result2) {
              if (isCall) {
                if (!matchResult) {
                  if (result2.isMethodDefinition && !result2.isAccessor || result2.isFunctionExpression || result2.isFunctionType) {
                    matchResult = result2;
                  } else if (result2.isPropertyDefinition || result2.isMethodGetterDefinition || result2.isTypeObjectPropertyDefinition || result2.isProperty && result2 instanceof Stack) {
                    const type2 = result2.type();
                    if (type2.isFunctionType) {
                      matchResult = result2;
                    }
                  }
                }
              } else if (!matchResult) {
                if (isTypeDefinition(result2)) {
                  matchResult = result2;
                  properties.length = 0;
                } else {
                  properties.push(result2);
                }
              }
            } else {
              isFullMatch = false;
            }
          }
          const references = this.compiler.options.checker.references;
          if (!isFullMatch && references.exactly) {
            (this.object || this).warn(1188, property);
          }
          if (hasNull && this.isMemberExpression && !this.optional && references.noNullable) {
            let state = null;
            let scope = this.scope;
            if (scope && scope.allowInsertionPredicate()) {
              state = scope.getValidateState(this.object.description());
            }
            if (!state || !state.value) {
              let hasCheck = false;
              if (state && state.stack) {
                if (state.isAlternate) {
                  hasCheck = !!(state.stack.alternate.hasReturnStatement || state.stack.alternate.hasThrowStatement);
                } else {
                  hasCheck = !!(state.stack.consequent.hasReturnStatement || state.stack.consequent.hasThrowStatement);
                }
              }
              if (!hasCheck) {
                let pp = this.getParentStack((p) => !(p.isMemberExpression || p.isCallExpression || p.isNewExpression || p.isParenthesizedExpression || p.isBinaryExpression));
                if (pp && pp.isLogicalExpression && pp.isAndOperator) {
                  let refs = null;
                  const items = this.getConditions(pp, true);
                  const current = items.find((item2) => {
                    refs = item2;
                    if (item2.isCallExpression || item2.isNewExpression) {
                      refs = item2.callee;
                    }
                    if (refs === this)
                      return true;
                    return refs.isMemberExpression ? refs.object === this.object : false;
                  });
                  if (current && refs) {
                    refs = refs.isMemberExpression ? refs.object : refs;
                    const refsDesc = refs.description();
                    let matched = items.find((item2) => {
                      if (item2 === current)
                        return false;
                      return item2.description() === refsDesc;
                    });
                    if (matched) {
                      if (matched.parentStack.isBinaryExpression) {
                        matched = matched.parentStack;
                      }
                      if (matched.parentStack.isLogicalExpression) {
                        if (matched.parentStack === current.parentStack) {
                          hasCheck = true;
                        } else {
                          hasCheck = matched.parentStack.isAndOperator;
                        }
                      }
                    }
                  }
                }
              }
              if (!hasCheck) {
                this.object.warn(1190, property);
              }
            }
          }
          if (properties.length > 0) {
            if (properties.length === 1) {
              matchResult = properties[0];
            } else {
              const mergeType = new MergeType();
              properties.forEach((item2) => {
                mergeType.add(item2);
              });
              matchResult = mergeType.type();
            }
          }
          return matchResult || anyType;
        } else if (this.isLiteralObject(object)) {
          dynamicAttribute = true;
          let desc = object.target && (object.target.isObjectExpression || object.target.isTypeObjectDefinition) ? object.target.attribute(property) : object.attribute(property);
          if (desc) {
            return desc;
          }
        }
        const origin = Utils.getOriginType(object);
        if (origin.isAnyType) {
          return Namespace.globals.get("any");
        }
        result = this.getMatchDescriptor(property, origin, isStatic);
        if (!result) {
          let literalType = typeof property === "number" ? "number" : "string";
          if (object.isLiteralArrayType || object.isTupleType) {
            if (literalType === "string") {
              literalType = null;
              if (!isNaN(parseInt(property))) {
                literalType = "number";
              }
            } else {
              literalType = "number";
            }
          }
          if (literalType) {
            result = this.getObjectDynamicDescriptor(dynamicAttribute ? object : origin, Namespace.globals.get(literalType), ctx, property);
          }
        }
        if (!result && object.isLiteralObjectType && object.target && object.target.isObjectExpression) {
          if (!this.compiler.options.literalObjectStrict) {
            result = Namespace.globals.get("any");
          }
        }
        return result || null;
      }
      getObjectDescriptorForAuxiliary(object, property, isStatic = false, prevObject = null, context = null) {
        if (!object)
          return null;
        if (!(object instanceof Type)) {
          throw new Error("Argument object is not type");
        }
        const ctx = context || this.getContext();
        object = ctx.fetch(object.type(), true) || object.type();
        if (object === prevObject) {
          return null;
        }
        if (object.isComputeType) {
          object = object.getResult();
        }
        if (object.isAnyType)
          return null;
        if (object.isAliasType) {
          return this.getObjectDescriptorForAuxiliary(object.inherit.type(), property, isStatic, object, ctx);
        }
        if (object.isClassGenericType) {
          if (object.isClassType) {
            return this.getObjectDescriptorForAuxiliary(object.types[0].type(), property, true, object, ctx);
          } else {
            const wrap = object.inherit.type();
            if (wrap.target && wrap.target.isDeclaratorTypeAlias && wrap.target.genericity) {
              const declareGenerics = wrap.target.genericity.elements;
              if (object.elements.length === 1 && declareGenerics.length === 1) {
                const has = declareGenerics[0].type() === wrap.inherit.type();
                if (has) {
                  return this.getObjectDescriptorForAuxiliary(object.elements[0].type(), property, false, object, ctx);
                }
              }
              return this.getObjectDescriptorForAuxiliary(wrap.inherit.type(), property, false, object, ctx);
            }
          }
        }
        if (object.isIntersectionType) {
          return this.getObjectDescriptorForAuxiliary(object.left.type(), property, isStatic, object, ctx) || this.getObjectDescriptorForAuxiliary(object.right.type(), property, isStatic, object, ctx);
        }
        let dynamicAttribute = false;
        let result = null;
        if (object.isUnionType) {
          const elems = object.elements;
          for (let i = 0; i < elems.length; i++) {
            const item2 = elems[i];
            const result2 = this.getObjectDescriptorForAuxiliary(item2.type(), property, isStatic, object, ctx);
            if (result2) {
              return result2;
            }
          }
          return null;
        } else if (this.isLiteralObject(object)) {
          dynamicAttribute = true;
          let desc = object.attribute(property);
          if (desc) {
            return desc;
          }
        }
        const origin = Utils.getOriginType(object);
        if (origin.isModule) {
          if (isStatic) {
            result = origin.getMethod(property);
          } else {
            result = origin.getMember(property);
          }
        }
        if (!result) {
          result = this.getObjectDynamicDescriptor(
            dynamicAttribute ? object : origin,
            Namespace.globals.get(object.isLiteralArrayType || object.isTupleType ? "number" : "string"),
            ctx
          );
        }
        return result;
      }
      isLiteralObject(object) {
        if (!object)
          return false;
        if (object.isTypeofType && object.origin) {
          return this.isLiteralObject(object.origin.type());
        }
        if (object.isLiteralArrayType || object.isTupleType || object.isLiteralObjectType || object.isGenericType && object.hasConstraint || object.isEnumType) {
          return true;
        }
        return false;
      }
      getObjectDynamicDescriptor(object, propertyType, ctx = null, property = null) {
        if (object && propertyType && Type.is(propertyType)) {
          if (object.isGenericType) {
            if (Inference.isInfer(ctx)) {
              object = ctx.fetch(object) || object;
            }
          }
          if (object.isGenericType && object.hasConstraint) {
            object = object.inherit.type();
          }
          if (this.isLiteralObject(object) || Utils.isTypeModule(object)) {
            return object.dynamicAttribute(propertyType, ctx, property);
          }
        }
        return null;
      }
      isTypeInContextType(type2, contextType) {
        if (!contextType || !type2)
          return false;
        if (type2 === contextType) {
          return true;
        } else if (contextType.isClassGenericType) {
          return contextType.types.some((item2) => this.isTypeInContextType(type2, item2.type()));
        } else if (contextType.isFunctionType) {
          const declReturnType = contextType.returnType;
          if (declReturnType && this.isTypeInContextType(type2, declReturnType.type()))
            return true;
          if (contextType.params.some((item2) => this.isTypeInContextType(type2, item2.type())))
            return true;
        } else if (contextType.isTupleType || contextType.isLiteralArrayType || contextType.isUnionType) {
          return contextType.elements.some((item2) => this.isTypeInContextType(type2, item2.type()));
        } else if (contextType.isLiteralObjectType) {
          if (contextType.properties.some((item2) => this.isTypeInContextType(type2, item2.type())))
            return true;
          if (type2.dynamicProperties) {
            const properties = Array.from(type2.dynamicProperties.values());
            if (properties.some((item2) => this.isTypeInContextType(type2, item2.type())))
              return true;
          }
        } else if (type2.isIntersectionType) {
          if (this.isTypeInContextType(type2, type2.left.type()))
            return true;
          if (this.isTypeInContextType(type2, type2.right.type()))
            return true;
        } else if (type2.isAliasType) {
          if (this.isTypeInContextType(type2, type2.inherit.type()))
            return true;
        }
        return false;
      }
      isTypeDefinitionStack(stack) {
        if (!stack)
          return false;
        return stack.isTypeDefinition || stack.isTypeTupleRestDefinition || stack.isTypeTupleDefinition || stack.isTypeGenericDefinition || stack.isTypeObjectDefinition || stack.isTypeObjectPropertyDefinition || stack.isTypeFunctionDefinition || stack.isTypeComputeDefinition || stack.isTypeIntersectionDefinition || stack.isTypeKeyofDefinition || stack.isTypeTypeofDefinition || stack.isTypeUniqueDefinition || stack.isTypePredicateDefinition || stack.isTypeConditionDefinition || stack.isTypeInferDefinition || stack.isTypeConditionalExpression || stack.isTypeUnionDefinition;
      }
      isModuleForWebComponent(module2) {
        if (!(module2 && module2.isModule && module2.isClass)) {
          return false;
        }
        return module2.isWebComponent();
      }
      isModuleForSkinComponent(module2) {
        if (!(module2 && module2.isModule && module2.isClass)) {
          return false;
        }
        return module2.isSkinComponent();
      }
      isJSXForContext(stack) {
        stack = stack || this.parentStack;
        if (stack.isSequenceExpression)
          stack = stack.parentStack;
        if (stack.isParenthesizedExpression)
          stack = stack.parentStack;
        if (stack.isLiteral || stack.isJSXExpressionContainer)
          stack = stack.parentStack;
        if (stack.isJSXAttribute)
          stack = stack.jsxElement;
        if (stack.isMemberExpression)
          return this.isJSXForContext(stack.parentStack);
        return !!(stack.jsxElement && stack.scope.isForContext);
      }
      isJSXForRef(stack) {
        stack = stack || this.parentStack;
        if (stack.isLiteral || stack.isJSXExpressionContainer)
          stack = stack.parentStack;
        if (stack.isJSXAttribute)
          stack = stack.jsxElement;
        if (stack.isMemberExpression)
          return this.isJSXForRef(stack.parentStack);
        return !!(stack.jsxElement && stack.scope.isForContext);
      }
      getAnnotationArgumentItem(name, args, indexes = null) {
        name = String(name).toLowerCase();
        let index = args.findIndex((item2) => {
          const key = String(item2.key).toLowerCase();
          return key === name;
        });
        if (index < 0 && indexes && Array.isArray(indexes)) {
          index = indexes.indexOf(name);
          if (index >= 0) {
            const arg = args[index];
            return arg && !arg.assigned ? arg : null;
          }
        }
        return args[index];
      }
      findAnnotation(stack, filter, inheritFlag = true) {
        if (arguments.length === 1) {
          filter = stack;
          stack = this;
        } else if (arguments.length === 2 && typeof filter === "boolean") {
          inheritFlag = filter;
          filter = stack;
          stack = this;
        }
        if (stack && stack.isModule && stack instanceof Module) {
          const items = stack.getStacks();
          for (let i = 0; i < items.length; i++) {
            const result2 = this.findAnnotation(items[i], filter);
            if (result2) {
              return result2;
            }
          }
          return null;
        }
        if (!stack || !stack.isStack) {
          return null;
        }
        const each = (list, invoke) => {
          if (!list)
            return null;
          let len = list.length;
          let i = 0;
          for (; i < len; i++) {
            const result2 = invoke(list[i]);
            if (result2) {
              return result2;
            }
          }
          return null;
        };
        let result = each(stack.annotations, (annotation) => {
          if (annotation && annotation.isAnnotationDeclaration) {
            let result2 = filter(annotation, stack);
            if (result2) {
              if (result2 === true) {
                result2 = annotation;
              }
              return [result2, stack];
            }
          }
        });
        if (result) {
          return result;
        }
        if (inheritFlag === false) {
          return null;
        }
        if (stack.isClassDeclaration || stack.isDeclaratorDeclaration || stack.isInterfaceDeclaration || stack.isEnumDeclaration) {
          const module2 = stack.module;
          const impls = module2.extends.concat(module2.implements || []);
          return each(impls, (module3) => {
            const result2 = this.findAnnotation(module3, filter, inheritFlag);
            if (result2) {
              return result2;
            }
          });
        } else if (stack.isMethodDefinition || stack.isPropertyDefinition) {
          const module2 = stack.module;
          const name = stack.value();
          const impls = module2.extends.concat(module2.implements || []);
          const token = stack.toString();
          const isStatic = !!stack.static;
          return each(impls, (module3) => {
            const descriptors = module3.descriptors.get(name);
            if (descriptors) {
              for (let i = 0; i < descriptors.length; i++) {
                const stack2 = descriptors[i];
                if (stack2 && token === stack2.toString() && isStatic === !!stack2.static) {
                  const result2 = this.findAnnotation(stack2, filter, inheritFlag);
                  if (result2) {
                    return result2;
                  }
                }
              }
            }
          });
        }
        return null;
      }
      getFunType() {
        return null;
      }
      value() {
        return this.node.name || this.node.value;
      }
      raw() {
        if (this.compilation && this.compilation.source) {
          return this.compilation.source.substr(this.node.start, this.node.end - this.node.start);
        }
        return this.node.raw || this.node.name;
      }
      checker() {
        const cache = this.getCache();
        if (cache.__checked)
          return false;
        return cache.__checked = true;
      }
      parser() {
        const cache = this.getCache();
        if (cache.__parsered)
          return false;
        return cache.__parsered = true;
      }
      parserDescriptor(desc) {
        if (!desc)
          return;
        if (desc.isStack && desc.module === this.module) {
          if (desc.isMethodDefinition || desc.isPropertyDefinition || desc.isFunctionExpression) {
            desc.parser();
          }
        }
      }
      isModuleStack(stack) {
        if (!stack || !stack.isStack)
          return false;
        return stack.isDeclaratorDeclaration || stack.isClassDeclaration || stack.isInterfaceDeclaration || stack.isStructTableDeclaration || stack.isEnumDeclaration && !stack.isExpressionDeclare;
      }
      setRefBeUsed(description) {
        let desc = description || this.description();
        if (!desc)
          return;
        let target = this;
        if (target.isMemberExpression) {
          target = target.property;
        }
        if (desc !== this && this.is(desc)) {
          desc.addUseRef(target);
        } else if (desc && Utils.isTypeModule(desc)) {
          desc.getStacks().forEach((stack) => {
            if (stack !== target) {
              stack.addUseRef(target);
            }
          });
          if (!(this.parentStack.isTypeDefinition || this.parentStack.isTypeGenericDefinition || this.parentStack.isVariableDeclarator)) {
            this.compilation.addDependency(desc, this.module);
          }
        }
      }
      interceptAnnotation(stack) {
        if (!(stack && stack.isAnnotationDeclaration)) {
          return stack;
        }
        const aName = stack.getLowerCaseName();
        if (aName === "hostcomponent" && this.isJSXScript) {
          this.hostComponentAnnotation = stack;
          return null;
        } else if (aName === "require") {
          return null;
        } else if (aName === "reference") {
          if (!(stack.parentStack && (stack.parentStack.isProgram || stack.parentStack.isPackageDeclaration))) {
            stack.error(1105, this.name);
          }
          return null;
        }
        return stack;
      }
      freeze(target) {
        Object.freeze(target || this);
      }
      error(code, ...args) {
        this.compilation.error(this.node, code, ...args);
      }
      warn(code, ...args) {
        this.compilation.warn(this.node, code, ...args);
      }
      deprecated(code, ...args) {
        this.compilation.deprecated(this.node, code, ...args);
      }
      unnecessary(code, ...args) {
        this.compilation.unnecessary(this.node, code, ...args);
      }
      toString() {
        return "Stack";
      }
      async allSettled(items, asyncMethod, fetchResult = false) {
        if (!items)
          return;
        if (!Array.isArray(items)) {
          console.error("Stack.allSettled items invalid.");
          return false;
        }
        try {
          const results = await Promise.allSettled(items.map((item2, index) => asyncMethod(item2, index, items)));
          if (fetchResult) {
            return results.map((promise) => {
              if (promise.status === "rejected") {
                console.error(promise.reason);
              }
              return promise.status === "fulfilled" ? promise.value : null;
            });
          }
        } catch (e) {
          return false;
        }
      }
      async callParser(callback, nowInvokeFlag = false) {
        const cache = this.getCache();
        if (cache.__parsered && !nowInvokeFlag)
          return false;
        try {
          cache.__parsered = true;
          await callback();
        } catch (e) {
          console.error(e);
        }
        return true;
      }
      getConditions(stack, deep = false) {
        if (stack.isLogicalExpression) {
          return [this.getConditions(stack.left, deep), this.getConditions(stack.right, deep)].flat();
        } else if (stack.isParenthesizedExpression) {
          return this.getConditions(stack.expression, deep);
        } else if (deep && stack.isBinaryExpression) {
          if (stack.isIsOperatorFlag) {
            return [stack.left];
          } else {
            return [this.getConditions(stack.left, deep), this.getConditions(stack.right, deep)].flat();
          }
        }
        return [stack];
      }
      parseConditionState(stack) {
        if (!stack)
          return;
        const pp = stack.parentStack;
        const scope = pp.isWhileStatement ? pp.body.scope : pp.consequent.scope;
        if (!scope.allowInsertionPredicate())
          return;
        this.getConditions(stack).forEach((stack2) => {
          let value2 = true;
          if (stack2.isUnaryExpression) {
            if (stack2.isLogicalFlag) {
              value2 = stack2.isLogicalTrueFlag;
            }
            stack2 = stack2.argument;
            if (stack2.isParenthesizedExpression) {
              stack2 = stack2.expression;
            }
          }
          if (!(stack2.isIdentifier || stack2.isMemberExpression))
            return;
          stack2.parser();
          const desc = stack2.description();
          if (desc && (!stack2.parentStack.isLogicalExpression || stack2.parentStack.isAndOperator)) {
            const pScore = scope.parent || scope;
            const old = pScore.getValidateState(desc, true);
            if (old && old.value !== value2 && old.stack === pp) {
              stack2.warn(1191);
              old.expr.warn(1191);
            } else {
              pScore.setValidateState(desc, this, value2, stack2, pp);
              if ((pp.isIfStatement || pp.isConditionalExpression) && pp.alternate) {
                pp.alternate.scope.setValidateState(desc, this, value2, stack2, pp, true);
              }
            }
          }
          const type2 = stack2.type();
          if (type2 && type2.isPredicateType) {
            let dataset = pp.scope.define("#predicate-type#");
            if (dataset) {
              const value3 = dataset.get(desc);
              if (value3) {
                const [descriptor, assignType, rDesc, origin] = value3;
                scope.setPredicate(descriptor, Predicate.create(assignType, rDesc, origin));
              }
            }
          }
        });
      }
      addImportSpecifierDependency(importSpecifier, desc = null, nameId = null) {
        if (!importSpecifier)
          return;
        if (importSpecifier.parentStack && importSpecifier.parentStack.isImportDeclaration) {
          let source = importSpecifier.parentStack.source.value();
          let name = importSpecifier.value();
          let owner = this.isImportDeclaration ? this.additional : this;
          let context = owner.module || this.compilation;
          let added = null;
          if (importSpecifier.isImportDefaultSpecifier) {
            added = context.addRequire(name, name, source, source, false, importSpecifier);
          } else if (importSpecifier.isImportNamespaceSpecifier) {
            added = context.addRequire("*", name, source, source, false, importSpecifier);
          } else if (importSpecifier.isImportSpecifier) {
            added = context.addRequire(name, importSpecifier.imported.value(), source, source, true, importSpecifier, true);
          }
          if (added) {
            if (nameId && name !== nameId) {
              added.name = nameId;
            }
            this.compilation.setDescriptorReferenceName(desc, added.name);
          }
        } else if (AutoImporter.is(importSpecifier)) {
          let owner = this.isImportDeclaration ? this.additional : this;
          let context = owner.module || this.compilation;
          let name = importSpecifier.local;
          let source = importSpecifier.source;
          let imported = importSpecifier.imported;
          let extract = importSpecifier.extract;
          let added = context.addRequire(imported, name, source, source, extract, null, true);
          if (added) {
            if (nameId && name !== nameId) {
              added.name = nameId;
            }
            this.compilation.setDescriptorReferenceName(desc, added.name);
          }
        }
      }
      getMemberMatchDescriptor(object, property, name) {
        if (!object || !object.isNamespace)
          return null;
        const result = object.getDescriptor(property, (desc, prev) => {
          if (desc.isModuleDeclaration && desc.module) {
            return true;
          }
          if (desc.isDeclaratorVariable) {
            const result2 = this.getObjectDescriptor(desc.type(), name);
            if (result2)
              return true;
          }
          if (prev) {
            if (this.isModuleDefinitionStack(prev)) {
              const module2 = prev.type();
              if (module2 && module2.isModule) {
                if (module2.getMethod(name)) {
                  return prev;
                }
              }
            } else {
              if (this.getObjectDescriptor(prev.type(), name)) {
                return prev;
              }
            }
          }
          return desc;
        });
        if (result) {
          if (result.isModuleDeclaration) {
            return result.module.getModuleDefaultDesriptor(name) || result.module;
          }
          return result;
        }
        return null;
      }
      isModuleDefinitionStack(desc) {
        if (arguments.length === 0)
          desc = this;
        if (!desc)
          return false;
        return !!(desc.isClassDeclaration || desc.isDeclaratorDeclaration || desc.isInterfaceDeclaration || desc.isEnumDeclaration && !desc.isExpressionDeclare || desc.isStructTableDeclaration);
      }
      hasLocalDefined() {
        if (this.isMemberExpression) {
          return this.object.hasLocalDefined();
        }
        return false;
      }
      getAnnotationAlias() {
        return null;
      }
      hasNestedReferenceExpression(expression, node2) {
        if (!expression)
          return false;
        if (expression === node2)
          return true;
        if (expression.isCallExpression || expression.isNewExpression) {
          return this.hasNestedReferenceExpression(expression.callee, node2);
        }
        if (expression.isMemberExpression) {
          return this.hasNestedReferenceExpression(expression.getFirstMemberStack(), node2);
        }
        if (expression.isAssignmentExpression || expression.isAssignmentPattern) {
          return this.hasNestedReferenceExpression(expression.right, node2);
        }
        if (expression.isTypeAssertExpression) {
          return this.hasNestedReferenceExpression(expression.left, node2);
        }
        if (expression.isLogicalExpression) {
          return this.hasNestedReferenceExpression(expression.left, node2) || this.hasNestedReferenceExpression(expression.right, node2);
        }
        if (expression.isUnaryExpression) {
          return this.hasNestedReferenceExpression(expression.argument, node2);
        }
        if (expression.isParenthesizedExpression) {
          return this.hasNestedReferenceExpression(expression.expression, node2);
        }
        if (expression.isSequenceExpression) {
          return expression.expressions.some((exp) => this.hasNestedReferenceExpression(exp, node2));
        }
        return false;
      }
      findMethodInheritParamType(module2, key, index, modifier, kind) {
        if (!(module2.extends.length > 0 || module2.implements.length > 0))
          return null;
        const imps = [...module2.extends, ...module2.implements].map((imp) => imp.type());
        for (const impModule of imps) {
          if (modifier === "protected" && Utils.isInterface(impModule))
            continue;
          const descriptors = impModule.descriptors.get(key);
          if (descriptors) {
            for (let desc of descriptors) {
              if (desc.isMethodDefinition && !desc.isMethodGetterDefinition && desc.kind === kind) {
                const param = desc.params[index];
                if (param && param.acceptType) {
                  return param.acceptType;
                }
              }
            }
          }
          const result = this.findMethodInheritParamType(impModule, key, index);
          if (result)
            return result;
        }
        return null;
      }
      findMethodInheritReturnType(module2, key, modifier, kind, isStatic = false) {
        if (!(module2.extends.length > 0 || module2.implements.length > 0))
          return null;
        if (modifier === "private")
          return null;
        const imps = [...module2.extends, ...module2.implements].map((imp) => imp.type());
        for (const impModule of imps) {
          if (modifier === "protected" && Utils.isInterface(impModule))
            continue;
          const descriptors = impModule.descriptors.get(key);
          if (descriptors) {
            for (let desc of descriptors) {
              if (desc.isMethodDefinition && !desc.isMethodSetterDefinition && desc.kind === kind) {
                if (isStatic && !desc.static) {
                  continue;
                } else {
                  const result2 = desc.returnType;
                  if (result2) {
                    return result2;
                  }
                }
              }
            }
          }
          const result = this.findMethodInheritReturnType(impModule, key, modifier, kind, isStatic);
          if (result)
            return result;
        }
        return null;
      }
      getIteratorResultType(type2, ctx) {
        const iterator = Namespace.globals.get("Iterator");
        const origin = Utils.getOriginType(type2);
        if (Utils.isModule(origin) && iterator.is(origin)) {
          const IteratorReturnResult = Namespace.globals.get("IteratorReturnResult");
          let declareGenerics = iterator.getModuleGenerics();
          if (declareGenerics) {
            const res = ctx.fetch(declareGenerics[0]);
            if (res) {
              return res.type();
            }
          }
          const desc = origin.getDescriptor("next", (desc2, prev) => {
            if (desc2.isMethodDefinition) {
              const result = desc2.getReturnedType();
              if (result && IteratorReturnResult.is(result.type(), ctx)) {
                return true;
              }
            }
            return null;
          });
          if (desc) {
            ctx.append(desc.getReturnedType());
            let declareGenerics2 = IteratorReturnResult.getModuleGenerics();
            if (declareGenerics2) {
              const res = ctx.fetch(declareGenerics2[0]);
              if (res) {
                return res.type();
              }
            }
          }
        }
        return null;
      }
      hasNestDescription(stack) {
        let desc = stack.descriptor();
        if (!this.is(desc))
          return false;
        if (desc.isMethodDefinition && !desc.isAccessor && !desc.isConstructor) {
          desc = desc.expression;
        } else if (desc.isVariableDeclarator && desc.init) {
          desc = desc.init;
        }
        if (desc.isFunctionExpression) {
          const parent = this.getParentStack((parent2) => parent2.isFunctionExpression && (parent2 === desc || parent2.isMethodDefinition || parent2.isVariableDeclarator));
          return parent === desc;
        }
        return false;
      }
    };
    module.exports = Stack;
  }
});

// lib/types/InstanceofType.js
var require_InstanceofType = __commonJS({
  "lib/types/InstanceofType.js"(exports, module) {
    var Utils = require_Utils();
    var Type = require_Type();
    var InstanceofType = class extends Type {
      constructor(inherit, target, generics = [], isThis = false, newModuleType = null) {
        super("$InstanceofType", inherit);
        this.target = target;
        this.isInstanceofType = true;
        this.isThisType = !!isThis;
        if (!generics && !isThis && inherit) {
          const baseType = inherit;
          const declares = baseType.isModule && baseType.getModuleGenerics() || [];
          generics = declares.map((item2) => {
            return item2.type();
          });
        }
        this.newModuleType = newModuleType;
        this.generics = generics || [];
        this.hasGenericType = this.inherit.type().hasGenericType || this.generics.some((type2) => !!(type2 && type2.hasGenericType));
      }
      clone(inference) {
        if (!inference || !this.hasGenericType) {
          return this;
        }
        return new InstanceofType(Utils.getOriginType(this.inherit.type().clone(inference)), this.target, this.generics.map((type2) => type2.clone(inference)), this.isThisType);
      }
      getTypeKeys() {
        let inherit = this.inherit.type();
        if (inherit.isClassGenericType && inherit.isClassType && this.target.isNewExpression) {
          inherit = inherit.elements[0].type();
        }
        return inherit.getTypeKeys();
      }
      attribute(property, kind = "get") {
        let inherit = this.inherit.type();
        if (inherit.isClassGenericType && inherit.isClassType && this.target.isNewExpression) {
          inherit = inherit.elements[0].type();
        }
        return inherit.getMember(property, kind);
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        } else if (type2.isIntersectionType) {
          return [type2.left, type2.right].some((item2) => this.is(item2.type(), context, options));
        }
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        if (this.isThisType && type2.isInstanceofType && type2.isThisType) {
          return true;
        }
        if (this.target && this.target.isNewExpression && this.target.genericity) {
          const lGenerics = this.target.genericity;
          const tGenerics = type2.isInstanceofType && type2.target.isNewExpression ? type2.target.genericity : null;
          if (!tGenerics || lGenerics.length != tGenerics.length) {
            return false;
          }
          if (!lGenerics.every((item2, index) => item2.type().is(tGenerics[index].type(), context, options))) {
            return false;
          }
        }
        type2 = type2.isInstanceofType ? type2.inherit : type2;
        if (this.inherit.type().is(type2, context, options)) {
          return true;
        }
        if (this.isThisType && type2) {
          return type2.is(this.inherit, context, options);
        }
        return false;
      }
      toString(context, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        if (this.isThisType) {
          return "this";
        }
        let inherit = this.inherit.type();
        if (inherit.isAliasType && this.generics.length > 0) {
          console.log(this.generics.length);
          return `${inherit.toString(context, { onlyTypeName: true })}<${this.generics.map((type2) => type2.toString(context, options)).join(", ")}>`;
        }
        if (inherit.isModule && this.generics.length > 0) {
          return `${inherit.getName()}<${this.generics.map((type2) => type2.toString(context, options)).join(", ")}>`;
        }
        if (inherit.isClassGenericType && inherit.isClassType && this.target.isNewExpression) {
          return inherit.elements[0].type().toString(context, options);
        }
        return inherit.toString(context, options);
      }
    };
    module.exports = InstanceofType;
  }
});

// lib/stacks/Declarator.js
var require_Declarator = __commonJS({
  "lib/stacks/Declarator.js"(exports, module) {
    var { isInfer } = require_Inference();
    var JSModule = require_JSModule();
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var Utils = require_Utils();
    var Inference = require_Inference();
    var InstanceofType = require_InstanceofType();
    var Declarator = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isDeclarator = true;
        if (!(parentStack && (parentStack.isArrayPattern || parentStack.isProperty && parentStack.parentStack.isObjectPattern))) {
          this._acceptType = this.createTokenStack(compilation, node2.acceptType, scope, node2, this);
        }
        let p = parentStack && parentStack.isProperty && parentStack.parentStack && parentStack.parentStack.isObjectPattern ? parentStack.parentStack : parentStack;
        p = p && (p.isArrayPattern || p.isObjectPattern) && p.parentStack ? p.parentStack : parentStack;
        if (p && (p.isFunctionExpression || p.isTypeFunctionDefinition || p.isTryStatement)) {
          this.question = !!node2.question;
          this.isParamDeclarator = true;
        }
        this.assignValue = null;
        this.assignItems = /* @__PURE__ */ new Set();
        this._kind = "var";
      }
      get acceptType() {
        const parent = this.parentStack;
        let _acceptType = this._acceptType;
        if (!_acceptType && parent) {
          if (parent.isArrayPattern) {
            if (parent.acceptType && parent.acceptType.isTypeTupleDefinition) {
              const index = parent.elements.indexOf(this);
              _acceptType = parent.acceptType.elements[index] || null;
            }
          } else if (parent.isProperty && parent.parentStack.isObjectPattern) {
            _acceptType = parent.acceptType;
          }
        }
        return _acceptType;
      }
      freeze(target) {
        super.freeze(target);
        super.freeze(this.assignItems);
        super.freeze(this.useRefItems);
        this.acceptType && this.acceptType.freeze();
      }
      definition(ctx) {
        if (!isInfer(ctx)) {
          ctx = this.getContext();
        }
        let _type = this.type();
        if (this.is(ctx.stack)) {
          const scope = ctx.stack.scope;
          if (scope.allowInsertionPredicate()) {
            const predicate = scope.getPredicate(this);
            if (predicate && predicate.type) {
              _type = predicate.type;
            }
          }
        }
        const type2 = _type.toString(ctx);
        if (this.isParamDeclarator) {
          const identifier = this.value();
          let relate = this.getAttribute("Declarator.getRelateParamDescriptionParamItem");
          let comments = this.comments;
          let location = this.getLocation();
          let file = this.compilation.file;
          if (ctx.stack === this) {
            if (relate && relate.isStack) {
              comments = relate.comments;
              location = relate.getLocation();
              file = relate.compilation.file;
            }
          }
          return {
            comments,
            expre: `(parameter) ${identifier}:${type2}`,
            location,
            file
          };
        } else if (this.parentStack.isJSXAttribute || this.parentStack.isArrayPattern || this.parentStack.isProperty && this.parentStack.parentStack.isObjectPattern) {
          const identifier = this.value();
          const expre = `(local ${this.kind}) ${identifier}:${type2}`;
          return {
            comments: this.comments,
            expre,
            location: this.getLocation(),
            file: this.compilation.file
          };
        } else if (this.parentStack.isAnnotationDeclaration) {
          const identifier = this.value();
          const name = this.parentStack.name.toLowerCase();
          const expre = `(local ${name}) ${identifier}:any`;
          return {
            comments: this.comments,
            expre,
            location: this.getLocation(),
            file: this.compilation.file
          };
        }
        return null;
      }
      set kind(value2) {
        this._kind = value2;
      }
      get kind() {
        let p = this.parentStack;
        let flag = false;
        if (p && p.isArrayPattern) {
          flag = true;
          p = p.parentStack;
        } else if (p && p.isProperty && p.parentStack.isObjectPattern) {
          flag = true;
          p = p.parentStack.parentStack;
        }
        if (flag && p && p.isVariableDeclarator) {
          return p.kind;
        }
        return this._kind;
      }
      reference(called) {
        if (Utils.isFunction(this.assignValue)) {
          return this.assignValue;
        }
        if (this.assignValue && this.assignValue.isStack) {
          return this.assignValue.reference(called) || this.assignValue;
        }
        return this;
      }
      referenceItems(called) {
        let items = [];
        this.assignItems.forEach((item2) => {
          if (!called && Utils.isFunction(item2)) {
            items.push(item2);
          } else {
            items = items.concat(item2.referenceItems(called) || item2);
          }
        });
        return items.length > 0 ? items : [this];
      }
      description() {
        return this;
      }
      descriptor() {
        if (!this.acceptType) {
          let init = null;
          if (this.isVariableDeclarator) {
            init = this.init;
          } else if (this.isAssignmentPattern) {
            init = this.right;
          }
          if (init && this.is(init)) {
            return init.descriptor();
          }
        }
        return this;
      }
      getRelateParamDescription(stack, argument, index, propertyStack = []) {
        if (!stack)
          return null;
        if (stack.isObjectExpression) {
          return this.getRelateParamDescription(stack.parentStack, stack, index, propertyStack.concat(argument));
        } else if (stack.isProperty) {
          return this.getRelateParamDescription(stack.parentStack, stack, index, propertyStack);
        } else if (stack.isArrayExpression) {
          return this.getRelateParamDescription(stack.parentStack, stack, index, propertyStack.concat(argument));
        } else if (stack.isReturnStatement && stack.parentStack.isBlockStatement && stack.parentStack.parentStack.isFunctionExpression) {
          return this.getRelateParamDescription(stack.parentStack.parentStack, argument, index, propertyStack);
        }
        const fetchObjectType = (object, property) => {
          if (property.isProperty) {
            object = stack.getObjectDescriptorForAuxiliary(object, property.value());
            if (object) {
              return object.type();
            }
          } else if (object.isTupleType && property.parentStack.isArrayExpression) {
            const index2 = property.parentStack.elements.indexOf(property);
            const type2 = object.prefix || object.rest ? object.elements[0] : object.elements[index2];
            if (type2) {
              return type2.type();
            }
          }
          return null;
        };
        const fetchType = (declareParam) => {
          if (!declareParam)
            return null;
          if (argument.isArrayExpression || argument.isObjectExpression) {
            let type2 = declareParam.type();
            if (type2.isTupleType && type2.rest) {
              type2 = type2.elements[0].type();
            }
            while (type2.isAliasType) {
              type2 = type2.inherit.type();
            }
            let desc = type2;
            while (desc && propertyStack.length > 0) {
              desc = fetchObjectType(desc, propertyStack.pop());
            }
            return desc;
          }
          return declareParam;
        };
        const getDescription = (declareParams2, pos) => {
          if (declareParams2 && declareParams2.length > 0) {
            let result = null;
            if (pos >= 0 && pos < declareParams2.length) {
              let declareParam = declareParams2[pos];
              result = fetchType(declareParam);
              if (result && result.isGenericType) {
                let records = Inference.extractWrapGenericValue(declareParam.type());
                if (records && records.has(result)) {
                  result = records.get(result);
                }
              }
            }
            if (!result && declareParams2.length > 0) {
              result = declareParams2[declareParams2.length - 1];
              if (!result.isRestElement) {
                result = null;
              }
            }
            return result;
          }
        };
        if (stack.isFunctionExpression) {
          const returnType = stack.returnType;
          if (returnType) {
            return [
              fetchType(returnType),
              stack
            ];
          }
          return null;
        }
        if (stack.isVariableDeclarator) {
          const acceptType = stack.type();
          if (!acceptType)
            return [];
          return [
            fetchType(acceptType),
            stack
          ];
        }
        if (stack.isAssignmentExpression) {
          return [
            fetchType(stack.left.type()),
            stack
          ];
        }
        if (!(stack.isCallExpression || stack.isNewExpression)) {
          return null;
        }
        let declareParams = stack.getFunDeclareParams();
        let paramIndex = stack.arguments.indexOf(argument);
        return [
          getDescription(declareParams, paramIndex),
          stack,
          paramIndex
        ];
      }
      getRelateParamType() {
        return this.getAttribute("Declarator.getRelateParamType", () => {
          if (!this.parentStack.isFunctionExpression) {
            return null;
          }
          const stack = this.parentStack.parentStack;
          if (stack.isVariableDeclarator && stack.init === this.parentStack) {
            return null;
          }
          const index = this.parentStack.params.indexOf(this);
          if (!(index >= 0))
            return null;
          const [declaredParam, _stack] = this.getRelateParamDescription(stack, this.parentStack, index) || [];
          if (!declaredParam || this === declaredParam)
            return null;
          this.setAttribute("Declarator.getRelateParamDescription", declaredParam);
          const ctx = _stack.getContext();
          const getType = (type2) => {
            const result = Utils.extractFunTypeFromType(type2);
            if (!result)
              return null;
            const [declareFunction, _ctx, _assigmentGenerics, _declareGenerics] = result;
            let value2 = null;
            if (declareFunction.isFunctionType && declareFunction.params && declareFunction.params.length > 0) {
              if (declareFunction.target && declareFunction.target === this.parentStack) {
                return null;
              }
              const param = declareFunction.params[index];
              if (param) {
                this.setAttribute("Declarator.getRelateParamDescriptionParamItem", param);
                if (param.isRestElement) {
                  value2 = param.getItemType();
                } else {
                  value2 = param.type();
                }
              } else {
                const restMaybe = declareFunction.params[declareFunction.params.length - 1];
                if (restMaybe && restMaybe.isRestElement) {
                  this.setAttribute("Declarator.getRelateParamDescriptionParamItem", restMaybe);
                  value2 = restMaybe.getItemType();
                }
              }
            }
            if (value2 && value2.isGenericType) {
              return ctx.fetch(value2) || value2;
            }
            return value2;
          };
          const items = [];
          let paramType = declaredParam.isRestElement ? declaredParam.getItemType() : declaredParam.type();
          if (paramType.isGenericType) {
            paramType = _stack.getContext().fetch(paramType);
            if (!paramType)
              return null;
          }
          if (paramType.isUnionType) {
            items.push(...paramType.elements);
          } else if (paramType.isIntersectionType) {
            items.push(paramType.left);
            items.push(paramType.right);
          } else {
            return getType(paramType);
          }
          for (let item2 of items) {
            const result = getType(item2.type());
            if (result)
              return result;
          }
          return null;
        });
      }
      getAssignType() {
        return this.getAttribute("getAssignType", () => {
          let acceptType = this.acceptType;
          if (acceptType) {
            acceptType = acceptType.type();
          } else if (this.inheritInterfaceAcceptType) {
            acceptType = this.inheritInterfaceAcceptType.type();
          } else if (this.parentStack.isFunctionExpression && this.parentStack.parentStack.isMethodDefinition) {
            const method = this.parentStack.parentStack;
            const index = method.params.indexOf(this);
            if (index >= 0) {
              const module2 = method.module;
              const key = method.value();
              const modifier = Utils.getModifierValue(method);
              if (modifier !== "private") {
                const result = this.findMethodInheritParamType(module2, key, index, modifier, method.kind);
                if (result) {
                  return result.type();
                }
              }
            }
          }
          if (!acceptType && this.value() === "this") {
            const parent = this.parentStack;
            if (parent.parentStack.isMethodDefinition && !parent.parentStack.static && !this.module.static) {
              acceptType = new InstanceofType(this.module, this, null, true);
            } else if (parent.isFunctionExpression && !parent.isArrowFunctionExpression) {
              acceptType = new InstanceofType(Namespace.globals.get("Object"), this, null, true);
            }
          }
          if (!acceptType) {
            acceptType = this.getRelateParamType();
          }
          return acceptType;
        });
      }
      type() {
        if (this.parentStack.isJSXAttribute) {
          if (this.parentStack.value && (this.parentStack.jsxElement.isSlot || this.parentStack.isAttributeSlot)) {
            return this.parentStack.type();
          }
        } else {
          let acceptType = this.getAssignType();
          if (acceptType) {
            return acceptType;
          }
          if (this.parentStack.isProperty && this.parentStack.parentStack.isObjectPattern) {
            return this.parentStack.type();
          }
          if (this.parentStack.isTryStatement) {
            return Namespace.globals.get("Error");
          }
          let init = this.getDefaultInit();
          if (init && !this.checkNullType(init)) {
            const isSelf = init.isStack && init.description() === this;
            if (!isSelf) {
              if (init.isArrayExpression) {
                return init.formatType();
              }
              return init.type();
            }
          }
        }
        if (this.parentStack.isArrayPattern && this.parentStack.parentStack.isVariableDeclarator) {
          const def = this.parentStack.parentStack.init;
          if (def) {
            const index = this.parentStack.elements.indexOf(this);
            if (index >= 0) {
              let value2 = Utils.extractArrayPatternItem(def.type(), index);
              if (value2) {
                return value2.type();
              }
            }
          }
        }
        return Namespace.globals.get("any");
      }
      getDefaultInit(flag) {
        let init = this.getAttribute("Declarator.whenIsNullSetValue");
        if (init)
          return init;
        if (this.isVariableDeclarator) {
          init = this.init;
        } else if (this.isAssignmentPattern) {
          init = this.right;
        } else if (this.dynamic && this.parentStack.isPropertyDefinition && this.init && this.init.isTypeDefinition) {
          init = this.init;
        }
        if (flag)
          return init;
        return init || this.getAttribute("Declarator.assignFirstValue");
      }
      getContext() {
        return this.getAttribute("Declarator.getContext", () => {
          let acceptType = this.acceptType;
          let ctx = null;
          if (acceptType) {
            return super.getContext();
          }
          if (this.parentStack.isFunctionExpression) {
            let stack = this.parentStack.parentStack;
            while (stack && (stack.isProperty || stack.isObjectExpression || stack.isArrayExpression)) {
              stack = stack.parentStack;
            }
            if (stack && (stack.isCallExpression || stack.isNewExpression)) {
              ctx = stack.getContext();
            }
          }
          if (!ctx && !this.isAssignmentPattern) {
            const init = this.getDefaultInit(true);
            if (init !== this && this.is(init)) {
              if (!(init.isFunctionExpression || init.isArrayExpression || init.isObjectExpression)) {
                ctx = init.getContext();
              }
            }
          }
          if (ctx) {
            return ctx.createChild(this);
          }
          return super.getContext();
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.acceptType) {
          this.acceptType.parser();
          const type2 = this.acceptType.type();
          const origin = Utils.getOriginType(type2);
          const module2 = this.module;
          const isGlobal = module2 && module2.compilation.pluginScopes.scope === "global";
          if (origin && origin.isModule && Utils.isTypeModule(origin) && origin.compilation.pluginScopes.scope !== "global" && !isGlobal) {
            this.compilation.addDependency(origin, this.module);
          }
        }
        if (this.module && !this.parentStack.isPropertyDefinition && this.module.id === this.value() && !JSModule.is(this.module)) {
          this.error(1008, this.value());
        }
      }
      checkNullType(type2) {
        if (type2) {
          type2 = type2.type();
          if (type2 && (type2.isNullableType || type2.isUndefinedType)) {
            if (type2.isUndefinedType) {
              this.setAttribute("Declarator.assignFirstValue", null);
            }
            return true;
          }
        }
        return false;
      }
      whenIsNullSetValue(value2) {
        const type2 = this.type();
        if (type2 && value2) {
          if (type2.isNullableType || type2.isUndefinedType || type2.isUnknownType) {
            this.setAttribute("Declarator.whenIsNullSetValue", value2);
          } else if (type2.isUnionType) {
            const hasNull = type2.elements.some((el) => {
              const type3 = el.type();
              return type3.isNullableType || type3.isUndefinedType || type3.isUnknownType;
            });
            if (hasNull) {
              if (type2.elements.some((el) => el.type().is(value2.type()))) {
                this.setAttribute("Declarator.whenIsNullSetValue", value2);
              }
            }
          }
        }
      }
      assignment(value2, stack = null, ctx = null) {
        if (this.assignValue !== value2 && value2 && value2 !== this) {
          if (this.checkNullType(value2))
            return;
          let assignDesc = null;
          if (this.is(value2)) {
            if (value2.description() === this) {
              return null;
            }
            assignDesc = value2.descriptor();
          }
          if (assignDesc) {
            if (assignDesc === this || this.is(assignDesc) && assignDesc.description() === this) {
              return;
            }
          }
          let acceptType = this.acceptType || this.inheritInterfaceAcceptType;
          let isNullable = false;
          if (!acceptType) {
            let init = this.getDefaultInit();
            if (init) {
              isNullable = this.checkNullType(init);
              if (!isNullable) {
                acceptType = init.type();
              }
            }
          }
          if (acceptType) {
            const errorStack = this.is(stack) ? stack : null;
            if (isInfer(ctx)) {
              acceptType = ctx.infer(acceptType.type());
            }
            if (this.checkExpressionType(acceptType, value2, errorStack)) {
              this.assignItems.add(value2);
              this.assignValue = value2;
            }
          }
          if (!this.getAttribute("Declarator.assignFirstValue") && !this.checkNullType(value2)) {
            this.setAttribute("Declarator.assignFirstValue", value2);
          }
        }
      }
    };
    module.exports = Declarator;
  }
});

// lib/stacks/AnnotationDeclaration.js
var require_AnnotationDeclaration = __commonJS({
  "lib/stacks/AnnotationDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var Utils = require_Utils();
    var path = __require("path");
    var Constant = require_Constant();
    var Declarator = require_Declarator();
    var Namespace = require_Namespace();
    var AnnotationDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isAnnotationDeclaration = true;
        this.id = this.createTokenStack(compilation, node2.id, scope, node2, this);
        this.body = (node2.body || []).map((item2) => {
          const stack = this.createTokenStack(compilation, item2, scope, node2, this);
          if (item2.acceptType) {
            stack.acceptType = this.createTokenStack(compilation, item2.acceptType, scope, node2, this);
          }
          return stack;
        });
        this._isCallee = !!node2.isCallee;
        this._isPresetAnnotation = true;
        this._additional = null;
        this._lowerName = String(this.id ? this.id.value() : this.node.name).toLowerCase();
        const allowed = this.compiler.options.annotations;
        if (!(allowed.includes(this.name) || allowed.includes(Utils.firstToUpper(this.name)))) {
          this._isPresetAnnotation = false;
          this.addHook();
        }
      }
      isCallee() {
        return this._isCallee;
      }
      get isPresetAnnotation() {
        return this._isPresetAnnotation;
      }
      addHook() {
        const id = this.id.value();
        if (!Namespace.globals.has(id)) {
          if (this.checkNeedToLoadTypeById(id)) {
            this.compilation.hookAsync("compilation.create.after", async () => {
              const desc = await this.loadTypeAsync(id);
              if (desc && desc.isModule) {
                this.compilation.addDependency(desc, this.module);
              }
            });
          } else {
            const desc = this.scope.define(id);
            if (desc && desc.isModule) {
              this.compilation.addDependency(desc, this.module);
            }
          }
        }
      }
      get name() {
        if (this.id) {
          return this.id.value();
        }
        return this.node.name;
      }
      getLowerCaseName() {
        return this._lowerName;
      }
      set additional(stack) {
        this._additional = stack;
        const scope = this.scope;
        const args = this.getArguments();
        const name = this.getLowerCaseName();
        if ((name === "import" || name === "require") && args.length === 2 && args[0].isObjectPattern) {
          const source = args[1].value;
          args[0].extract.forEach((prop) => {
            var desc = Namespace.globals.get(source) || Namespace.fetch(source);
            if (desc) {
              if ((desc.isAliasType || desc.isLiteralObjectType) && !desc.isModule) {
                if (desc.isAliasType)
                  desc = desc.inherit;
                if (desc.isLiteralObjectType) {
                  desc = desc.attribute(prop.key);
                } else {
                  desc = null;
                }
              } else if (desc.isModule) {
                desc = desc.getMethod(prop.key);
              } else if (desc.isNamespace) {
                desc = desc.get(prop.key);
              } else {
                desc = null;
              }
            }
            if (desc) {
              scope.define(prop.key, desc);
            } else {
              const keyNode = prop.stack.init.isAssignmentPattern ? node.init.left.node : node.init.node;
              scope.define(prop.key, new Declarator(this.compilation, keyNode, prop.stack.scope, prop.stack.parentNode, prop.stack.parentStack));
            }
          });
        } else if (name === "import" || name === "require") {
          args.forEach((item2) => {
            if (item2.assigned) {
              if (scope.isDefine(item2.key)) {
              } else {
                var desc = Namespace.globals.get(item2.value);
                if (desc) {
                  scope.define(item2.key, desc);
                } else {
                  scope.define(item2.key, new Declarator(this.compilation, item2.stack.left.node, item2.stack.scope, item2.stack.parentNode, item2.stack.parentStack));
                }
              }
            }
          });
        } else if (name === "embed") {
          if (stack && stack.module && (stack.isClassDeclaration || stack.isInterfaceDeclaration || stack.isEnumDeclaration && !stack.isExpressionDeclare || stack.isDeclaratorDeclaration)) {
            args.forEach((item2) => {
              if (item2.assigned) {
                if (scope.isDefine(item2.key)) {
                } else {
                  scope.define(item2.key, new Declarator(this.compilation, item2.stack.left.node, item2.stack.scope, item2.stack.parentNode, item2.stack.parentStack));
                }
              }
            });
          }
        }
      }
      get additional() {
        return this._additional;
      }
      getReferenceFiles() {
        return this.getAttribute("getReferenceFiles", () => {
          const files = [];
          this.getArguments().forEach((item2) => {
            const deep = (file, context, isRoot = false) => {
              file = this.compiler.resolveManager.resovleDependency(file, context);
              if (!file)
                return;
              if (Utils.existsSync(file)) {
                const stat = Utils.getFileStatSync(file);
                if (stat.isDirectory()) {
                  const list = Utils.readdir(file);
                  if (list) {
                    list.forEach((filename) => deep(filename, file));
                  }
                } else if (stat.isFile() && (isRoot || this.compiler.isDescriptorFile(file))) {
                  files.push(file);
                }
              } else {
                item2.stack.error(1132, file);
              }
            };
            deep(item2.value, this.file, true);
          });
          return files;
        });
      }
      async createCompleted() {
        const aName = this.getLowerCaseName();
        if (aName !== "reference")
          return;
        if (this.compilation.import === "manifest")
          return null;
        const files = this.getReferenceFiles();
        const compilations = files.map((file) => this.compilation.createChildCompilation(file, null, file, true));
        const results = await Promise.allSettled(compilations);
        const items = results.map((result) => result.value).filter((v) => !!v);
        items.forEach((compilation) => {
          if (!compilation.import) {
            compilation.import = "reference";
          }
        });
        this.setAttribute("referenceCompilations", items);
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.body);
        super.freeze(this.scope);
        this.body.forEach((stack) => stack.freeze());
      }
      definition(context) {
        const enterStack = context && context.stack;
        if (!enterStack)
          return false;
        const name = this.getLowerCaseName();
        if (!["import", "embed", "require"].includes(name)) {
          return null;
        }
        if (name === "embed") {
          const item2 = this.getArguments().find((item3) => {
            return item3.stack === enterStack || item3.stack.left === enterStack;
          });
          const file = item2.resolveFile ? this.compiler.normalizePath(item2.resolveFile) : item2.value;
          return {
            expre: `Embed("${file}")`,
            location: item2.stack.getLocation(),
            range: item2.stack.getLocation(),
            file: this.compilation.file
          };
        } else {
          const find = (item3) => {
            if (item3.assigned) {
              return item3.stack.right === enterStack || item3.stack.left === enterStack;
            } else if (item3.isObjectPattern) {
              return item3.extract.find(find);
            } else if (item3.isProperty) {
              if (item3.stack.init.isAssignmentPattern) {
                return item3.stack.init.right === enterStack || item3.stack.init.left === enterStack;
              } else {
                return item3.stack.init === enterStack;
              }
            }
            return false;
          };
          let item2 = this.getArguments().find(find);
          if (item2) {
            if (item2.isObjectPattern) {
              item2 = item2.extract.find(find);
            }
            const scope = this.additional.scope || this.scope;
            const desc = scope.define(item2.key);
            const file = item2.resolveFile ? this.compiler.normalizePath(item2.resolveFile) : item2.value;
            if (desc) {
              return {
                expre: `(refs) ${item2.key}:${desc.type().toString()}`,
                location: desc.isStack ? desc.getLocation() : null,
                file: desc.isStack ? desc.file : null
              };
            }
            if (item2.assigned) {
              return {
                expre: `${Utils.firstToUpper(name)}(${item2.key} = "${file}")`
              };
            } else {
              return {
                expre: this.raw()
              };
            }
          }
        }
      }
      description() {
        if (!this.isPresetAnnotation) {
          return this.id.description();
        }
        return null;
      }
      descriptor() {
        if (!this.isPresetAnnotation) {
          return this.id.descriptor();
        }
        return null;
      }
      getArguments() {
        if (this._args) {
          return this._args;
        }
        const target = this._args = [];
        this.body.map((item2, index) => {
          if (item2.isAssignmentPattern) {
            const key = item2.left.value();
            const value2 = item2.right.value();
            const assigned = true;
            target.push({ key, value: value2, assigned, stack: item2 });
          } else if (item2.isObjectPattern) {
            const properties = item2.properties.map((node2) => {
              const value2 = node2.key.value();
              const key = node2.init.isAssignmentPattern ? node2.init.right.value() : node2.init.value();
              return { key, value: value2, isProperty: true, stack: node2 };
            });
            target.push({ isObjectPattern: true, extract: properties, stack: item2 });
          } else if (item2.isArrayPattern) {
          } else {
            const key = index;
            const value2 = item2.value();
            const assigned = false;
            target.push({ key, value: value2, assigned, stack: item2 });
          }
        });
        return target;
      }
      checkImportParams(args) {
        if (!args.length || args.length > 3 || args[0].isObjectPattern && args.length < 2) {
          this.error(1001, 2, args.length);
        } else if (args[0].isObjectPattern && !(args[1] && (!args[1].assigned || typeof args[1].value !== "string"))) {
          args[1].stack.error(1135, this.name);
        } else if (args[2] && !(args[2].value === false || args[2].value === true)) {
          args[2].stack.error(1135, this.name);
        }
        const fileItem = args[0].isObjectPattern ? args[1] : args[0];
        let resolve = null;
        if (fileItem.value && !(args.length > 1 && args[args.length - 1].value === true)) {
          resolve = this.compiler.resolveManager.resovleAssets(fileItem.value, this.file);
          if (!resolve) {
            resolve = fileItem.value;
          } else {
            resolve = this.compiler.normalizePath(resolve);
          }
        }
        fileItem.resolveFile = resolve;
        if (args[0].isObjectPattern) {
          const extract = args[0].extract;
          return [fileItem, extract];
        } else {
          if (fileItem.assigned) {
            return [fileItem];
          } else {
            fileItem.key = path.basename(fileItem.value, path.extname(fileItem.value));
            return [fileItem];
          }
        }
      }
      createRequireModule(args) {
        let [file, extract] = args;
        if (!extract) {
          extract = [file];
        }
        extract.forEach((item2) => {
          const topScope = this.compilation.scope;
          const name = item2.isProperty ? item2.value : item2.key;
          const module2 = this.compilation.createModule(this.namespace, name);
          if (topScope.define(name) === module2) {
          } else {
            topScope.define(name, module2);
            module2.isClass = true;
            module2.required = true;
            module2.isAnnotationCreated = true;
            this.compilation.addModuleStack(module2, this);
            if (!module2.addRequire(item2.key, name, file.value, file.resolveFile, !!item2.isProperty, item2.stack)) {
            }
          }
        });
      }
      extractDependenceRefs(args) {
        let [file, extract] = args;
        if (!extract) {
          extract = [file];
        }
        const target = this.additional && this.additional.module || this.compilation;
        extract.forEach((item2) => {
          const name = item2.isProperty ? item2.value : item2.key;
          if (!target.addRequire(item2.key, name, file.value, file.resolveFile, !!item2.isProperty, item2.stack)) {
          }
        });
      }
      async parserAsync() {
        const _name = this.getLowerCaseName();
        if (_name === "reference") {
          if (!(this.parentStack.isProgram || this.parentStack.isPackageDeclaration)) {
            this.error(1103, this.name);
          }
          if (this.compilation.import === "manifest")
            return null;
          const compilations = this.getAttribute("referenceCompilations");
          if (Array.isArray(compilations)) {
            await this.allSettled(compilations, async (compilation) => await compilation.parserAsync());
          }
        }
      }
      parser() {
        if (super.parser() === false)
          return false;
        const args = this.getArguments();
        const _name = this.getLowerCaseName();
        const ownerModule = this.additional && this.additional.module;
        if (!this.isPresetAnnotation) {
          const desc = this.descriptor();
          if (!desc) {
            this.error(1140, this.name);
          } else {
            if (Utils.isModule(desc)) {
              desc.getStacks().forEach((stack) => {
                stack.addUseRef(this.id);
              });
              this.compilation.addDependency(desc, ownerModule);
              if (!desc.isDecorator()) {
                this.error(1207, this.name);
              }
            } else if (!desc.type().isFunctionType) {
              this.error(1207, this.name);
            }
          }
        }
        switch (_name) {
          case "dynamic":
            if (!this.additional || !(this.additional.isClassDeclaration || this.additional.isInterfaceDeclaration || this.additional.isDeclaratorDeclaration || this.additional.isEnumDeclaration && !this.additional.isExpressionDeclare)) {
              this.error(1105, this.name);
            }
            break;
          case "require":
            if (!(this.parentStack && (this.parentStack.isProgram || this.parentStack.isPackageDeclaration))) {
              this.error(1105, this.name);
            }
            this.createRequireModule(this.checkImportParams(args));
            break;
          case "import":
            if (!(this.parentStack && (this.parentStack.isProgram || this.parentStack.isPackageDeclaration))) {
              this.error(1105, this.name);
            }
            this.extractDependenceRefs(this.checkImportParams(args));
            break;
          case "deprecated":
            if (!this.additional || !(this.additional.isMethodDefinition || this.additional.isPropertyDefinition || this.additional.isDeclaratorDeclaration || this.additional.isClassDeclaration)) {
              this.error(1104, this.name);
            }
            break;
          case "hostcomponent":
            if (!args.length || args.length > 1) {
              this.error(1001, 1, args.length);
            }
            const classModule = this.getModuleById(args[0].value);
            if (!classModule) {
              this.error(1083, args[0].value);
            }
            break;
          case "post":
          case "get":
          case "del":
          case "put":
          case "option":
          case "router":
            if (!this.additional || !(this.additional.module.isClass || this.additional.isMethodDefinition)) {
              this.error(1105, this.name);
            }
            break;
          case "callable":
          case "override":
            if (!this.additional || !this.additional.isMethodDefinition) {
              this.error(1104, this.name);
            }
            break;
          case "syntax":
            if (!this.additional || !(this.additional.isPackageDeclaration || this.additional.isProgram || this.additional.isInterfaceDeclaration || this.additional.isDeclaratorDeclaration || this.additional.isDeclaratorTypeAlias || this.additional.isDeclaratorFunction || this.additional.isEnumDeclaration && !this.additional.isExpressionDeclare || this.additional.isClassDeclaration)) {
              if (!this.parentStack.isProgram) {
                this.error(1103, this.name);
              }
            }
            break;
          case "runtime":
            if (!this.additional || !(this.additional.isPackageDeclaration || this.additional.isProgram || this.additional.isInterfaceDeclaration || this.additional.isDeclaratorDeclaration || this.additional.isDeclaratorFunction || this.additional.isEnumDeclaration && !this.additional.isExpressionDeclare || this.additional.isClassDeclaration)) {
              if (!this.parentStack.isProgram) {
                this.error(1103, this.name);
              }
            }
            const value2 = (args[0].value || "").toLowerCase();
            if (value2 === "server") {
              this.compilation.setPolicy(Constant.POLICY_SERVER, ownerModule);
            } else if (value2 === "client") {
              this.compilation.setPolicy(Constant.POLICY_CLIENT, ownerModule);
            } else if (value2 === "all") {
              this.compilation.setPolicy(Constant.POLICY_ALL, ownerModule);
            } else {
              item.error(1092);
            }
            break;
          case "embed":
            if (this.additional && this.additional.module && !(this.additional.isClassDeclaration || this.additional.isDeclaratorDeclaration || this.additional.isPropertyDefinition)) {
              this.error(1102);
            }
            if (!args.length) {
              this.error(1101);
            }
            args.forEach((item2) => {
              let file = this.compiler.resolveManager.resovleAssets(item2.value, this.file);
              var assign = item2.assigned ? item2.key : null;
              var additional = this.additional;
              if (additional && additional.isPropertyDefinition) {
                assign = additional.id.value();
              }
              if (!file) {
                file = this.compiler.normalizePath(item2.value);
                item2.resolveFile = file;
              } else {
                item2.resolveFile = this.compiler.normalizePath(file);
              }
              if (file) {
                const target = additional && additional.module || this.compilation;
                if (!target.addAsset(item2.resolveFile, item2.value, null, path.extname(file), assign, null, this)) {
                  if (target.file === this.compilation.file) {
                    this.error(1106, item2.value);
                  }
                }
              }
            });
            break;
          case "main":
            if (this.additional) {
              const modifier = this.additional.modifier ? this.additional.modifier.value() : "public";
              if (!(modifier === "public" && this.additional.static && this.additional.isMethodDefinition)) {
                this.error(1138, this.name);
              }
            }
            break;
        }
      }
    };
    module.exports = AnnotationDeclaration;
  }
});

// lib/types/ClassGenericType.js
var require_ClassGenericType = __commonJS({
  "lib/types/ClassGenericType.js"(exports, module) {
    var Namespace = require_Namespace();
    var { extractWrapGenericValue } = require_Inference();
    var Type = require_Type();
    var ClassGenericType = class extends Type {
      constructor(types, inherit, isClass, target) {
        super("$ClassGenericType", inherit);
        this.isClassGenericType = true;
        this.isClassType = !!isClass;
        this.elements = types;
        this.target = target;
        this.isThisType = !!(target && target.isThisType);
        this._relatedTypes = null;
      }
      newInstance(types, inherit, isClass, target) {
        return new ClassGenericType(types, inherit, isClass, target);
      }
      get types() {
        const t = this._types;
        if (t)
          return t;
        return this._types = this.elements.map((el) => el.type());
      }
      get hasGenericType() {
        return this.types.some((type2) => {
          return type2 && !!(type2.isGenericType || type2.hasGenericType);
        }) || this.inherit.hasGenericType;
      }
      getInferResult(context, records) {
        const target = this.inherit.type();
        if (records) {
          const newRecords = extractWrapGenericValue(this);
          if (newRecords) {
            newRecords.forEach((value2, key) => {
              const res = value2.getInferResult(context, records);
              if (res) {
                value2 = res;
              }
              records.set(key, value2);
            });
          }
        }
        if (target && target.isAliasType) {
          return target.getInferResult(context, records);
        }
        return null;
      }
      clone(inference) {
        if (!inference) {
          return this;
        }
        const types = this.types.map((type2) => {
          return type2.clone(inference);
        });
        const result = new ClassGenericType(types, this.inherit, this.isClassType, this.target);
        result._relatedTypes = this._relatedTypes;
        return result;
      }
      getWrapCheckerType(wrapType) {
        if (this.elements.length === 1) {
          const declareGenerics = wrapType.target.genericity;
          const has = declareGenerics ? declareGenerics.elements.some((item2) => item2.type() === wrapType.inherit.type()) : false;
          if (has) {
            return this.elements[0].type();
          }
        }
        return wrapType.inherit.type();
      }
      getDeclareGenerics() {
        if (this.target && this.target.isTypeGenericDefinition) {
          return this.target.getDeclareGenerics();
        }
        return [];
      }
      check(stack, context, options = {}) {
        if (!stack)
          return false;
        const inherit = this.inherit.type();
        const isWrap = inherit.isAliasType;
        const type2 = this.inferType(stack.type(), context);
        if (!type2.isClassGenericType) {
          if (this.isClassType && type2.isInstanceofType)
            return false;
          if (!this.isClassType && inherit.check(stack, context, options)) {
            return true;
          }
          if (isWrap) {
            return this.getWrapCheckerType(inherit).check(stack, context, options);
          }
          if (this.hasDynamicAttribute(inherit, context)) {
            return Namespace.globals.get("object").is(type2, context, options);
          }
          if (type2.isUnionType || type2.isIntersectionType) {
            return this.is(type2, context, options);
          }
          return this.isClassType ? this.types[0].is(type2, context) : inherit.check(stack, context, options);
        }
        return this.is(type2, context, options);
      }
      hasDynamicAttribute(object, context = null) {
        if (object && object.isModule && (object.isInterface || object.isClass)) {
          return !!object.dynamicAttribute(Namespace.globals.get("string"), context);
        }
        return false;
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        } else if (type2.isIntersectionType) {
          return [type2.left, type2.right].some((item2) => this.is(item2.type(), context, options));
        }
        if (this.isClassType && (type2.isInstanceofType || !(type2.isClassType && type2.isClassGenericType) || type2.isInterface)) {
          return false;
        }
        const inherit = this.inherit.type();
        const isWrap = inherit.isAliasType;
        if (!(type2.isClassGenericType || type2.isTupleType || type2.isLiteralArrayType || type2.isInstanceofType && !type2.isThisType)) {
          if (this.isClassType && type2.isInstanceofType)
            return false;
          if (!this.isClassType && inherit.is(type2, context, options)) {
            return true;
          }
          if (isWrap) {
            return this.getWrapCheckerType(inherit).is(type2, context, options);
          }
          if (this.hasDynamicAttribute(inherit, context)) {
            return Namespace.globals.get("object").is(type2, context, options);
          }
          return this.isClassType ? this.types[0].is(type2, context, options) : inherit.is(type2, context, options);
        }
        if (!this.isClassType) {
          if (type2.isClassType)
            return false;
          let baseType = this.inferType(type2.inherit.type(), context);
          if (type2.isInstanceofType && !type2.isThisType && type2.target && type2.target.isNewExpression) {
            if (baseType.isClassGenericType && baseType.isClassType) {
              baseType = baseType.types[0].type();
              type2 = baseType;
              baseType = type2.inherit.type();
            }
          }
          if (!inherit.is(baseType, context, options))
            return false;
          let accepts = this.types;
          if (type2.isTupleType || type2.isLiteralArrayType) {
            return accepts.every((accept) => {
              accept = accept.type();
              if (accept.isGenericType)
                return true;
              return type2.elements.some((item2) => accept.is(item2.type(), context));
            });
          }
          let assigments = type2.isInstanceofType ? type2.generics : type2.types;
          let [_, declares = []] = this.getDeclareGenerics();
          const result = accepts.every((accept, index) => {
            accept = accept.type();
            if (accept.isGenericType)
              return true;
            const assign = assigments[index];
            const declared = declares[index];
            if (assign) {
              return accept.is(assign.type(), context, options);
            } else if (accept.isNullableType || accept.isVoidType) {
              return true;
            }
            if (declared && declared.isGenericTypeAssignmentDeclaration) {
              return true;
            }
            if (accept.isAnyType)
              return true;
            return false;
          });
          return result;
        } else {
          if (!type2.isClassType)
            return false;
          return this.types.every((base, index) => {
            const assign = type2.types[index];
            const acceptType = base.type();
            if (acceptType.isAnyType || !assign && (acceptType.isNullableType || acceptType.isVoidType))
              return true;
            return assign ? acceptType.is(assign.type(), context, options) : false;
          });
        }
      }
      toString(context = {}, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        const types = this.types.map((type2) => {
          const _options = options.inbuild ? Object.assign({}, options, { rawcode: false, onlyTypeName: true }) : Object.create(options);
          if (type2.isGenericType && type2.hasConstraint && type2.inherit.type() === this) {
            return type2.target ? type2.target.value() : "any";
          }
          return type2.toString(context, _options);
        });
        if (this.target) {
          if (this.isClassType) {
            return `${this.target.value()}<${types.join(", ")}>`;
          }
          if (this.inherit.isModule) {
            return `${this.inherit.getName()}<${types.join(", ")}>`;
          } else {
            return `${this.inherit.toString(context, Object.assign({}, options, { onlyTypeName: true }))}<${types.join(", ")}>`;
          }
        }
        return this.extends[0].toString(context, Object.create(options));
      }
    };
    module.exports = ClassGenericType;
  }
});

// lib/stacks/AnnotationExpression.js
var require_AnnotationExpression = __commonJS({
  "lib/stacks/AnnotationExpression.js"(exports, module) {
    var MergeType = require_MergeType();
    var Stack = require_Stack();
    var Utils = require_Utils();
    var ClassGenericType = require_ClassGenericType();
    var path = __require("path");
    var Namespace = require_Namespace();
    var keyMapIndexes = {
      http: ["classname", "action", "param", "data", "method", "config"],
      router: ["classname", "action", "param"]
    };
    var AnnotationExpression = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isAnnotationExpression = true;
        this.body = (node2.body || []).map((item2) => {
          const stack = this.createTokenStack(compilation, item2, scope, node2, this);
          if (item2.acceptType) {
            stack.acceptType = this.createTokenStack(compilation, item2.acceptType, scope, node2, this);
          }
          return stack;
        });
        const name = String(this.node.name).toLowerCase();
        this._lowerName = name;
        const isServer = ["provider", "http", "router"].includes(name);
        if (isServer) {
          const args = this.getArguments();
          const item2 = this.getAnnotationArgumentItem("classname", args, ["classname"]);
          if (item2) {
            this.compilation.hookAsync("compilation.create.after", async () => {
              const desc = await this.loadTypeAsync(item2.value);
              if (desc && desc.isModule) {
                this.compilation.addDependency(desc, this.module);
              }
            });
          }
          const response = this.getAnnotationArgumentItem("response", args);
          if (response) {
            this.compilation.hookAsync("compilation.create.after", async () => {
              const desc = await this.loadTypeAsync(response.value);
              if (desc && desc.isModule) {
                this.compilation.addDependency(desc, this.module);
              }
            });
          }
        }
      }
      get name() {
        return this.node.name;
      }
      getLowerCaseName() {
        return this._lowerName;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.body);
        super.freeze(this.scope);
        this.body.forEach((stack) => stack.freeze());
      }
      definition(context) {
        if (context) {
          let current = context.stack;
          if (current) {
            if (current.parentStack.isAssignmentPattern) {
              current = current.parentStack;
            }
            const index = this.body.indexOf(current);
            if (index >= 0) {
              const name = this.getLowerCaseName();
              const args = this.getArguments();
              const itemArg = args[index];
              if (name === "http" || name === "router") {
                const key = this.getArgNamed(itemArg);
                if (key === "classname") {
                  const provideModule = args[0] ? this.getModuleById(args[0].value) : null;
                  if (provideModule && provideModule.isModule) {
                    return provideModule.definition(context);
                  }
                } else if (key === "action") {
                  const provideModule = args[0] ? this.getModuleById(args[0].value) : null;
                  if (provideModule && itemArg && this.isModuleForWebComponent(provideModule)) {
                    let stack = itemArg.stack;
                    if (stack.isAssignmentPattern)
                      stack = stack.right;
                    const desc = stack.description();
                    if (desc && desc.isStack) {
                      return desc.definition(context);
                    }
                  } else {
                    const result = this.getProviderDescriptor(args);
                    if (result) {
                      const [desc] = result;
                      if (desc) {
                        return desc.definition(context);
                      }
                    }
                  }
                } else if (key === "method") {
                  return {
                    expre: `(type) "${itemArg.value}"`,
                    location: itemArg.stack.getLocation(),
                    file: this.compilation.file
                  };
                } else if (itemArg) {
                  let stack = itemArg.stack;
                  if (stack.isAssignmentPattern)
                    stack = stack.right;
                  const desc = stack.description();
                  if (desc && desc.isStack) {
                    return desc.definition(context);
                  }
                }
              }
            }
          }
          return null;
        }
        return {
          expre: `(Annotation) ${this.name}`,
          file: this.compilation.file
        };
      }
      description() {
        return this;
      }
      getArguments() {
        if (this._args) {
          return this._args;
        }
        const target = this._args = [];
        this.body.map((item2, index) => {
          if (item2.isAssignmentPattern) {
            const key = item2.left.value();
            const value2 = item2.right.value();
            const assigned = true;
            target.push({ key, value: value2, assigned, stack: item2 });
          } else if (item2.isObjectPattern) {
            item2.error(1176, item2.raw());
          } else if (item2.isArrayPattern) {
            item2.error(1176, item2.raw());
          } else if (item2.isIdentifier || item2.isLiteral || item2.isCallExpression || item2.isNewExpression || item2.isConditionalExpression || item2.isMemberExpression || item2.isArrayExpression || item2.isObjectExpression) {
            const key = index;
            const value2 = item2.isIdentifier || item2.isLiteral || item2.isMemberExpression ? item2.value() : "";
            const assigned = false;
            target.push({ key, value: value2, assigned, stack: item2 });
          } else {
            item2.error(1176, item2.raw());
          }
        });
        return target;
      }
      getProviderDescriptor(args = null) {
        args = args || this.getArguments();
        return this.getAttribute("getProviderDescriptor", () => {
          const classNameArg = args.find((item2) => String(item2.key).toLowerCase() === "classname") || args[0];
          const actionArg = args.find((item2) => String(item2.key).toLowerCase() === "action") || args[1];
          const provideModule = classNameArg ? this.getModuleById(classNameArg.value) : null;
          if (provideModule && provideModule.isModule && actionArg) {
            const flag = provideModule.compilation.parserDoneFlag;
            const desc = provideModule.getMember(actionArg.value);
            if (desc && desc.isMethodDefinition && !desc.isAccessor && Utils.isModifierPublic(desc)) {
              return [desc, flag, provideModule];
            }
          }
          return null;
        });
      }
      getDescriptorByStack(stack) {
        const name = this.getLowerCaseName();
        if (!(name === "http" || name === "router")) {
          return null;
        }
        const args = this.getArguments();
        const arg = args.find((arg2) => arg2.stack === stack);
        if (arg) {
          const [desc, _, classModule] = this.getProviderDescriptor(args) || [];
          const key = this.getArgNamed(arg);
          if (key === "action") {
            return desc;
          } else if (key === "classname") {
            return classModule;
          }
        }
        return null;
      }
      type() {
        switch (this.getLowerCaseName()) {
          case "env": {
            const args2 = this.getArguments();
            if (args2.length > 1) {
              return Namespace.globals.get("boolean");
            } else if (args2.length > 0) {
              return Namespace.globals.get("string");
            }
            return Namespace.globals.get("nullable");
          }
          case "url":
          case "provider":
            return Namespace.globals.get("string");
          case "router":
            return Namespace.globals.get("annotation.IRouter");
          case "http":
            if (this._type)
              return this._type;
            const args = this.getArguments();
            const response = args.find((arg) => String(arg.key).toLowerCase() === "response");
            const HttpResponse = Namespace.globals.get("net.HttpResponse");
            const responseField = this.compiler.options.metadata.http.responseField;
            let typeValue = null;
            let flag = true;
            const ctx = this.getContext();
            const getResponseType = () => {
              const [desc, _flag] = this.getProviderDescriptor(args) || [];
              if (desc) {
                flag = _flag;
                let value2 = desc.inferReturnType();
                if (value2) {
                  let generics = null;
                  let types = [];
                  if (value2.isUnionType) {
                    generics = value2.elements.filter((el) => el.type().isClassGenericType).map((el) => el.type());
                  } else if (value2.isClassGenericType) {
                    generics = [value2];
                  } else {
                    types.push(value2);
                  }
                  if (generics) {
                    generics.forEach((type2) => {
                      types.push(...type2.types.map((el) => el.type()));
                    });
                  }
                  if (value2.isUnionType) {
                    value2.elements.forEach((el) => {
                      const type2 = el.type();
                      if (generics && generics.includes(type2)) {
                        return;
                      } else {
                        types.push(type2);
                      }
                    });
                  }
                  const merge = new MergeType();
                  types.forEach((type2) => merge.add(type2));
                  value2 = ctx.apply(merge.type());
                  if (value2 && !value2.isGenericType) {
                    return value2;
                  }
                }
              }
              return Namespace.globals.get("any");
            };
            if (response || responseField) {
              const type2 = response && (this.scope.define(response.value) || this.getModuleById(response.value));
              if (type2 && (type2.isTypeStatement || type2.isModule)) {
                return this._type = type2.type();
              } else {
                const desc = HttpResponse.getMember(response ? response.value : responseField, "get");
                const declareGenerics = HttpResponse.getModuleGenerics();
                if (desc) {
                  typeValue = desc.type();
                  if (declareGenerics && declareGenerics.length > 0) {
                    const index = declareGenerics.indexOf(typeValue);
                    if (index === 0) {
                      typeValue = getResponseType();
                    }
                  }
                }
                if (!typeValue) {
                  typeValue = Namespace.globals.get("any");
                }
              }
            } else {
              typeValue = new ClassGenericType(
                [getResponseType()],
                HttpResponse,
                false,
                HttpResponse.moduleStack
              );
            }
            const Promise2 = Namespace.globals.get("Promise");
            const _type = new ClassGenericType(
              [typeValue],
              Promise2,
              false,
              Promise2.moduleStack
            );
            if (!flag)
              return _type;
            return this._type = _type;
          default:
            break;
        }
        return Namespace.globals.get("any");
      }
      getArgNamed(arg) {
        const indexes = keyMapIndexes[this.getLowerCaseName()];
        if (!arg.assigned && indexes[arg.key]) {
          return indexes[arg.key];
        }
        return String(arg.key).toLowerCase();
      }
      parser() {
        if (super.parser() === false)
          return false;
        const args = this.getArguments();
        const item2 = this.getAnnotationArgumentItem("classname", args, ["classname"]);
        const name = this.getLowerCaseName();
        const isServer = ["provider", "http", "router"].includes(name);
        if (name === "http" || name === "router") {
          args.forEach((item3) => {
            let stack = item3.stack;
            let key = this.getArgNamed(item3);
            if (key !== "method") {
              if (key === "action") {
                const result = this.getProviderDescriptor(args);
                if (result) {
                  const [desc, _, ownerModule] = result;
                  if (desc && ownerModule) {
                    stack.setRefBeUsed(desc);
                  }
                }
              } else {
                stack.parser();
                if (stack.isAssignmentPattern) {
                  stack = item3.stack.right;
                }
                if (stack.isCallExpression || stack.isNewExpression) {
                  stack = stack.callee;
                }
                stack.setRefBeUsed();
              }
            }
          });
        }
        if (isServer) {
          if (!item2) {
            this.error(1001, 1, 0);
          } else {
            const moduleClass = this.getModuleById(item2.value);
            if (!moduleClass) {
              item2.stack.error(1027, item2.value);
            } else {
              item2.stack.setRefBeUsed(moduleClass);
              if (name === "http") {
                const response = this.getAnnotationArgumentItem("response", args);
                if (response) {
                  const HttpResponse = Namespace.globals.get("net.HttpResponse");
                  let type2 = HttpResponse.getMember(response.value, "get");
                  if (!type2) {
                    type2 = this.scope.define(response.value) || this.getModuleById(response.value);
                    response.stack.setRefBeUsed(type2);
                  }
                  if (!type2 || !(type2.isTypeStatement || type2.isType)) {
                    response.stack.error(1175, response.value);
                  }
                }
              }
            }
          }
        } else if (name === "url") {
          if (args.length != 1) {
            this.error(1001, 1, args.length);
          } else {
            args.forEach((item3) => {
              let flag = item3.value.charCodeAt(0) === 64;
              let file = flag ? item3.value.substr(1) : this.compiler.resolveManager.resovleAssets(item3.value, this.file);
              if (!file) {
                file = this.compiler.normalizePath(item3.value);
                item3.resolveFile = file;
              } else {
                item3.resolveFile = this.compiler.normalizePath(file);
              }
              if (file) {
                const top = this.module ? this.compilation.getStackByModule(this.module) : this.compilation;
                const name2 = path.basename(item3.resolveFile) || file;
                const assign = top.scope.generateVarName(name2.replace(/(\W)+/g, "_"));
                const target = this.module || this.compilation;
                target.addAsset(item3.resolveFile, item3.value, null, path.extname(file), assign, null, this);
              }
            });
          }
        } else if (name === "env") {
        }
      }
    };
    module.exports = AnnotationExpression;
  }
});

// lib/stacks/Expression.js
var require_Expression = __commonJS({
  "lib/stacks/Expression.js"(exports, module) {
    var Stack = require_Stack();
    var Expression = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isExpression = true;
      }
      reference() {
        const description = this.description();
        if (description !== this && description instanceof Stack) {
          return description.reference();
        }
        return description;
      }
      referenceItems() {
        const description = this.description();
        if (description !== this && description instanceof Stack) {
          return description.referenceItems();
        }
        return [description];
      }
    };
    module.exports = Expression;
  }
});

// lib/types/LiteralArrayType.js
var require_LiteralArrayType = __commonJS({
  "lib/types/LiteralArrayType.js"(exports, module) {
    var Type = require_Type();
    var Utils = require_Utils();
    var LiteralArrayType = class extends Type {
      constructor(inherit, target, elements = null) {
        super("$LiteralArrayType", inherit);
        this.isLiteralArrayType = true;
        this.target = target;
        this.elements = elements || target.elements;
        this._hasGenericType = void 0;
      }
      get hasGenericType() {
        if (this._hasGenericType === void 0) {
          this._hasGenericType = this.elements.some((type2) => type2.type().isGenericType);
        }
        return this._hasGenericType;
      }
      attribute(index) {
        if (this.target && !this.target.isTypeTupleDefinition) {
          return this.target.attribute(index);
        }
        index = Number(index);
        if (!isNaN(index)) {
          return this.elements[index] || null;
        }
        return null;
      }
      dynamicAttribute(type2, context = null) {
        if (this.target && !this.target.isTypeTupleDefinition) {
          return this.target && this.target.isArrayExpression ? this.target.dynamicAttribute(type2, context) : null;
        }
        return this.inherit.type().dynamicAttribute(type2, context);
      }
      clone(inference, flag = false) {
        if (!flag && (!inference || !this.hasGenericType)) {
          return this;
        }
        const elements = inference ? this.elements.map((item2) => item2.type().clone(inference)) : this.elements.slice(0);
        return Utils.setMergedType(new LiteralArrayType(this.inherit, this.target, elements));
      }
      getElementTypes() {
        if (this._elementTypes) {
          return this._elementTypes;
        }
        const items = /* @__PURE__ */ new Set();
        this.elements.forEach((item2) => {
          items.add(item2.type());
        });
        return this._elementTypes = Array.from(items.values());
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isFunctionType || Utils.isScalar(type2) || type2.isLiteralObjectType)
          return false;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        } else if (type2.isIntersectionType) {
          return [type2.left, type2.right].some((item2) => this.is(item2.type(), context, options));
        }
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        if (type2.isLiteralArrayType || type2.isTupleType) {
          const errorHandler = context && context.errorHandler || ((result) => result);
          let bases = this.getElementTypes().map((item2) => item2.type());
          if (bases.length === 0)
            return true;
          return type2.elements.every((el) => {
            const elType = el.type();
            return errorHandler(bases.some((acceptType) => acceptType.is(elType, context, options)), bases, el);
          });
        }
        return this.inherit.is(type2, context, options);
      }
      toString(context, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        const elements = this.elements.map((item2) => {
          const type2 = item2.type();
          if (type2 === this)
            return "any";
          const ctx = type2.isClassGenericType || Utils.isModule(type2) ? null : context;
          return type2.toString(ctx, options);
        }).join(", ");
        return `[${elements}]`;
      }
    };
    module.exports = LiteralArrayType;
  }
});

// lib/stacks/ArrayExpression.js
var require_ArrayExpression = __commonJS({
  "lib/stacks/ArrayExpression.js"(exports, module) {
    var Expression = require_Expression();
    var LiteralArrayType = require_LiteralArrayType();
    var Namespace = require_Namespace();
    var MergeType = require_MergeType();
    var ArrayExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isArrayExpression = true;
        this.elements = [];
        this.spreadElement = [];
        node2.elements.map((item2) => {
          const stack = this.createTokenStack(compilation, item2, scope, node2, this);
          if (stack) {
            this.elements.push(stack);
          }
        });
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.elements);
        this.elements.forEach((stack) => stack.freeze());
      }
      definition() {
        return null;
      }
      attribute(index) {
        if (typeof index === "number") {
          return this.elements[index] || null;
        }
        return null;
      }
      dynamicAttribute(type2, ctx = null) {
        const arrClass = Namespace.globals.get("Array");
        if (type2 && arrClass) {
          return arrClass.dynamicAttribute(type2, ctx);
        }
        return null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      description() {
        return this;
      }
      type() {
        return this.getAttribute("type", () => {
          return new LiteralArrayType(Namespace.globals.get("array"), this);
        });
      }
      formatType() {
        return this.getAttribute("formatType", () => {
          if (this.elements.length > 1) {
            const mergeType = new MergeType(Namespace.globals.get("Array"));
            mergeType.target = this;
            this.elements.forEach((item2) => {
              mergeType.add(item2);
            });
            return mergeType.type();
          }
          return this.type();
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.elements.forEach((item2) => {
          item2.parser();
          item2.setRefBeUsed();
        });
      }
      value() {
        return `[${this.elements.map((elem) => elem.value()).join(",")}]`;
      }
    };
    module.exports = ArrayExpression;
  }
});

// lib/stacks/ArrayPattern.js
var require_ArrayPattern = __commonJS({
  "lib/stacks/ArrayPattern.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var Utils = require_Utils();
    var TupleType = require_TupleType();
    var Declarator = require_Declarator();
    var ArrayPattern = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isArrayPattern = true;
        this.elements = node2.elements.map((item2) => {
          let stack = null;
          if (item2 && item2.type === "Identifier") {
            if (this.parentStack.isVariableDeclarator || this.parentStack.isFunctionExpression) {
              stack = new Declarator(compilation, item2, scope, node2, this);
              const context = parentStack.parentStack.kind === "var" ? "function" : "block";
              const name = stack.value();
              if (scope.isDefine(name, context)) {
                this.error(1007, name);
              }
              scope.define(name, stack);
            } else {
              stack = this.createTokenStack(compilation, item2, scope, node2, this);
            }
          } else if (item2) {
            stack = this.createTokenStack(compilation, item2, scope, node2, this);
          }
          return stack;
        }).filter(Boolean);
        if (node2.acceptType) {
          this._acceptType = this.createTokenStack(compilation, node2.acceptType, scope, node2, this);
        }
      }
      get acceptType() {
        if (this.parentStack.isVariableDeclarator) {
          return this.parentStack._acceptType;
        }
        return this._acceptType;
      }
      type() {
        let acceptType = this.acceptType;
        if (acceptType) {
          return acceptType.type();
        } else {
          return this.getAttribute("type", () => {
            return new TupleType(Namespace.globals.get("array"), this.elements, this);
          });
        }
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.elements);
        this.elements.forEach((stack) => stack.freeze());
      }
      definition() {
        return null;
      }
      setKind(value2) {
        this.elements.forEach((item2) => {
          item2.kind = value2;
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        const init = this.parentStack.init;
        const is = init && init.isArrayExpression;
        const refs = init && init.type();
        const arrayType = Namespace.globals.get("array");
        const iteratorType = Namespace.globals.get("Iterator");
        if (init)
          init.parser();
        if (init && !(arrayType.check(refs) || iteratorType.check(refs))) {
          init.error(1012, init.raw(), refs.toString());
        }
        this.elements.forEach((item2, index) => {
          item2.parser();
          const desc = item2.description();
          const defaultValue = item2.isAssignmentPattern ? true : false;
          if (desc) {
            if (item2.isRestElement) {
              if (refs) {
                desc.assignment(refs, item2);
              }
              return;
            }
            if (is) {
              const value2 = init.attribute(index);
              if (!defaultValue && !value2) {
                item2.error(1014, init.raw(), index);
              }
              if (value2) {
                desc.assignment(value2, item2);
              } else if (item2.right) {
                desc.assignment(item2.right, item2);
              }
            } else {
              let value2 = Utils.extractArrayPatternItem(refs, index);
              if (value2) {
                desc.assignment(value2, item2);
              } else if (item2.right) {
                desc.assignment(item2.right, item2);
              } else if (refs && (refs.isTupleType && !refs.prefix || refs.isLiteralArrayType)) {
                const elements = refs.isTupleType && refs.target && refs.target.isArrayExpression ? refs.target.elements : refs.elements;
                if (elements.length > 0 && !elements[0].type().isUnionType) {
                  item2.error(1014, init.raw(), index);
                }
              }
            }
          }
        });
      }
      value() {
        return this.elements.map((item2) => {
          return item2.value();
        }).join(",");
      }
    };
    module.exports = ArrayPattern;
  }
});

// lib/scope/FunctionScope.js
var require_FunctionScope = __commonJS({
  "lib/scope/FunctionScope.js"(exports, module) {
    var Scope = require_Scope();
    module.exports = class FunctionScope extends Scope {
      constructor(parentScope) {
        super(parentScope);
        this.arguments = [];
        this.returnType = null;
        this.returnItems = [];
        this.key = null;
        this.isArrow = false;
        this.isExpression = false;
        this.isFunctionScope = true;
      }
      type(name) {
        return name === "function";
      }
    };
  }
});

// lib/types/FunctionType.js
var require_FunctionType = __commonJS({
  "lib/types/FunctionType.js"(exports, module) {
    var Namespace = require_Namespace();
    var Utils = require_Utils();
    var Type = require_Type();
    var FunctionType = class extends Type {
      constructor(inherit, target, params, returnType, generics) {
        super("$FunctionType", [inherit]);
        this.params = params ? params : target.params || [];
        this._returnType = returnType;
        this.isFunctionType = true;
        this.target = target;
        this.generics = generics || target.genericity && target.genericity.elements || [];
        this.hasRestElement = false;
      }
      get returnType() {
        return this.inferReturnType();
      }
      get thisArgumentContext() {
        return this.target.thisArgumentContext;
      }
      get async() {
        return !!(this.target && this.target.async);
      }
      inferReturnType() {
        const r = this._returnType;
        if (!r && this.target && (this.target.isFunctionExpression || this.target.isTypeFunctionDefinition)) {
          return this.target.getReturnedType();
        }
        return r;
      }
      getInferReturnType() {
        const r = this._returnType;
        if (!r && this.target) {
          if (this.target.isFunctionExpression) {
            return this.target.inferReturnType();
          } else {
            return this.target.getReturnedType();
          }
        }
        return r;
      }
      getReturnedType() {
        const r = this._returnType;
        if (!r && this.target) {
          return this.target.getReturnedType();
        }
        return r;
      }
      type(context) {
        if (context && context.called) {
          if (this.target && this.target.isFunctionExpression) {
            if (this._returnType) {
              return context.apply(this._returnType);
            } else {
              return this.target.type(context);
            }
          }
          return context.apply(this.returnType);
        }
        return this;
      }
      get hasGenericType() {
        return false;
      }
      checkHasGeneric() {
        if (this._hasGenericType === void 0) {
          this._hasGenericType = this.params.concat(this.returnType, this.generics).some((item2) => {
            const type2 = item2 && item2.type();
            if (type2) {
              if (type2.isFunctionType) {
                return type2.checkHasGeneric();
              }
              return !!type2.hasGenericType;
            }
          });
        }
        return this._hasGenericType;
      }
      clone(inference) {
        return this;
      }
      is(type2, context = {}, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        if (Namespace.globals.get("Function") === type2) {
          return true;
        }
        if (type2.isModule && type2.id && typeof type2.getDescriptor === "function") {
          let hasMatch = false;
          type2.getDescriptor(`#${type2.id}`, (desc, prev) => {
            if (desc.isCallDefinition) {
              if (this.is(desc.type())) {
                return hasMatch = true;
              }
            }
          });
          return hasMatch;
        }
        if (!type2.isFunctionType)
          return false;
        const errorHandler = context?.errorHandler || ((result) => result);
        const inWrapContext = type2.target && type2.target.parentStack && (type2.target.parentStack.isProperty || type2.target.parentStack.isCallExpression || type2.target.parentStack.isNewExpression);
        const isFun = type2.target && type2.target.isFunctionExpression;
        if (type2.params.length > 0) {
          const params = this.params;
          const last = params[params.length - 1];
          const args = type2.params;
          const result = args.every((item2, index) => {
            if (isFun && item2.acceptType) {
              return true;
            }
            let acceptType = params[index];
            if (!acceptType) {
              if (index >= params.length && last) {
                if (last.isRestElement) {
                  acceptType = last.getItemType();
                }
              }
            } else if (acceptType.isRestElement) {
              acceptType = acceptType.getItemType();
            } else {
              acceptType = acceptType.type();
              if (acceptType && acceptType.isTupleType && acceptType.rest) {
                acceptType = acceptType.elements[0].type();
              }
            }
            if (!acceptType) {
              return errorHandler(false, null, item2, isFun);
            }
            if (inWrapContext && item2.isStack && item2.isDeclarator) {
              if (!item2.acceptType) {
                return true;
              }
            }
            let argType = null;
            if (item2.isRestElement) {
              argType = item2.getItemType();
            } else if (item2.isObjectPattern) {
              argType = Namespace.globals.get("object");
            } else {
              argType = item2.type();
              if (argType.isTupleType && argType.rest) {
                argType = argType.elements[0].type();
              }
            }
            if (!argType)
              return true;
            return errorHandler(acceptType.is(argType, context, options), acceptType, item2, isFun);
          });
          if (!result) {
            return false;
          }
        }
        if (inWrapContext && type2.target.isStack && !type2.target_returnType) {
          return true;
        }
        let res = true;
        if (!(isFun && type2.target.rawReturnType)) {
          let left = this.inferReturnType(context);
          let right = type2.inferReturnType(context);
          if (left) {
            res = right && left.type().is(right.type(), context, options);
          }
        }
        return res;
      }
      definition(context) {
        let location = null;
        let comments = "";
        let file = null;
        let kind = "type ";
        if (this.target && (this.target.isFunctionExpression || this.target.isTypeFunctionDefinition)) {
          location = (this.target.key || this.target).getLocation();
          comments = this.target.comments || "";
          file = this.target.file;
          if (this.target.key) {
            kind = this.target.key.value() + " ";
          } else if (this.target.parentStack.isTypeObjectPropertyDefinition) {
            kind = this.target.parentStack.key.value();
            if (kind === "#new#")
              kind = "new ";
            if (kind === "#call#")
              kind = "";
          }
        }
        let expre = this.toString(context);
        return {
          location,
          comments,
          expre: `${kind}${expre}`,
          file
        };
      }
      signature() {
        if (this.target && (this.target.isFunctionExpression || this.target.isTypeFunctionDefinition)) {
          return this.target.signature();
        }
        return this.definition();
      }
      toString(context = {}, options = {}) {
        const _orgCtx = context;
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        let complete = !!options.complete;
        let rawcode = options.rawcode;
        options.rawcode = false;
        if (options.complete === void 0 && !options.inferTypeValueFlag && !(context.stack && (context.stack.isCallExpression || context.stack.isNewExpression))) {
          complete = true;
        }
        const hasNested = (type2) => {
          return options.chain.some((item2) => {
            let _type = type2.isClassGenericType ? type2.inherit.type() : type2;
            if (item2.isClassGenericType) {
              return item2.inherit.type() === _type;
            } else {
              return item2 === _type;
            }
          });
        };
        const _thisCtx = this.thisArgumentContext;
        const _params = _thisCtx ? [_thisCtx, ...this.target.params] : this.target.params;
        const params = _params.map((item2, index) => {
          if (item2.isObjectPattern) {
            const properties = item2.properties.map((property) => {
              const name = property.key.value();
              const acceptType = property.type();
              const init = property.init;
              const ctx = acceptType.isClassGenericType || Utils.isModule(type) ? null : context;
              if (init && init.isAssignmentPattern) {
                return `${init.left.value()}:${acceptType.toString(ctx, options)} = ${init.right.raw()}`;
              }
              return `${name}:${acceptType.toString(ctx, options)}`;
            });
            return `{${properties.join(",")}}`;
          } else if (item2.isArrayPattern) {
            const properties = item2.elements.map((property) => {
              if (property.isAssignmentPattern) {
                const acceptType2 = property.type();
                const ctx2 = acceptType2.isClassGenericType || Utils.isModule(type) ? null : context;
                return `${property.left.value()}:${acceptType2.toString(ctx2, options)} = ${property.right.raw()}`;
              }
              const name = property.value();
              const acceptType = property.type();
              const ctx = acceptType.isClassGenericType || Utils.isModule(type) ? null : context;
              return `${name}:${acceptType.toString(ctx, options)}`;
            });
            return `[${properties.join(",")}]`;
          } else {
            const type2 = _params[index].type();
            let ctx = type2.isClassGenericType || Utils.isModule(type2) ? null : context;
            if (hasNested(type2)) {
              ctx = {};
            }
            const name = item2.value();
            const rest = item2.isRestElement ? "..." : "";
            const question = item2.question ? "?" : "";
            if (item2.isAssignmentPattern && item2.right) {
              const initial = item2.right.value();
              return `${rest}${name}${question}: ${type2.toString(ctx, options)}=${initial}`;
            }
            return `${rest}${name}${question}: ${type2.toString(ctx, options)}`;
          }
        });
        let returnType = this.inferReturnType();
        const genOptions = Object.create(options);
        if (Utils.isContext(_orgCtx) && _orgCtx.stack && _orgCtx.stack.isCallExpression) {
          returnType = _orgCtx.apply(returnType);
        }
        if (!returnType || returnType === this) {
          returnType = Namespace.globals.get("any");
        }
        genOptions.complete = complete;
        genOptions.rawcode = rawcode;
        if (options.inbuild) {
          genOptions.rawcode = true;
        }
        const genericity = this.generics.length > 0 ? "<" + this.generics.map((item2) => item2.type().toString(context, genOptions)).join(", ") + ">" : "";
        return `${genericity}(${params.join(", ")})=>${returnType.toString(context, { chain: options.chain })}`;
      }
    };
    module.exports = FunctionType;
  }
});

// lib/stacks/FunctionExpression.js
var require_FunctionExpression = __commonJS({
  "lib/stacks/FunctionExpression.js"(exports, module) {
    var Utils = require_Utils();
    var Declarator = require_Declarator();
    var FunctionScope = require_FunctionScope();
    var Expression = require_Expression();
    var FunctionType = require_FunctionType();
    var MergeType = require_MergeType();
    var InstanceofType = require_InstanceofType();
    var keySymbol = Symbol("key");
    var Namespace = require_Namespace();
    var FunctionExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        scope = new FunctionScope(scope);
        super(compilation, node2, scope, parentNode, parentStack);
        let isDeclarator = node2.type === "DeclaratorFunction";
        if (!isDeclarator && parentStack && parentStack.isMethodDefinition) {
          scope.isMethod = true;
          if (parentStack.isConstructor) {
            scope.isConstructor = true;
            this.isConstructor = true;
          }
          isDeclarator = !!parentStack.parentStack.isDeclaratorDeclaration;
        }
        this.isFunctionExpression = true;
        this.genericity = this.createTokenStack(compilation, node2.genericity, scope, node2, this);
        this._returnType = this.createTokenStack(compilation, node2.returnType, scope, node2, this);
        this._recursionType = null;
        this.hasReturnType = !!node2.returnType;
        this.thisArgumentContext = null;
        const first = node2.params[0];
        let assignment = null;
        let hasRest = null;
        if (first && first.type == "Identifier" && first.name === "this") {
          this.thisArgumentContext = new Declarator(compilation, node2.params.shift(), scope, node2, this);
        }
        this._hasRecursionReference = false;
        this._recursionCallStacks = null;
        this.params = node2.params.map((item2) => {
          let annotations = item2.annotations;
          if (annotations && annotations.length > 0) {
            annotations = annotations.map((annotation) => {
              return this.createTokenStack(compilation, annotation, scope, item2, this);
            });
          }
          let stack = null;
          if (item2.type == "Identifier") {
            stack = new Declarator(compilation, item2, scope, node2, this);
            if (assignment && !stack.question) {
              assignment.error(1050, assignment.value());
            }
            scope.define(stack.value(), stack);
          } else {
            stack = this.createTokenStack(compilation, item2, scope, node2, this);
            if (stack.isRestElement) {
              hasRest = stack;
            }
            assignment = stack;
          }
          if (annotations && annotations.length > 0) {
            stack.annotations = annotations;
            annotations.forEach((annotation) => {
              annotation.additional = stack;
            });
          }
          return stack;
        });
        if (hasRest && this.params[this.params.length - 1] !== hasRest) {
          hasRest.error(1051, hasRest.value());
        }
        this.awaitCount = 0;
        this.async = scope.async = !!node2.async;
        if (this.async) {
          scope.asyncParentScopeOf = scope;
        }
        if (!parentStack.isMethod) {
          this.callable = true;
        }
        this.body = this.createTokenStack(compilation, node2.body, scope, node2, this);
        this[keySymbol] = {};
        if (this.body) {
          this.compilation.hookAsync("compilation.create.after", async () => {
            this.scope.define("arguments", Namespace.globals.get("IArguments"));
            if (this.isArrowFunctionExpression) {
              const module2 = this.module;
              if (module2) {
                if (!module2.static) {
                  let pp = this.getParentStack((stack) => stack.isVariableDeclarator || stack.isMethodDefinition);
                  if (pp && pp.isVariableDeclarator && pp.parentStack.isPropertyDefinition) {
                    pp = pp.parentStack;
                  }
                  if (pp.isPropertyDefinition) {
                    if (pp.static) {
                      this.scope.define("this", module2);
                    } else {
                      this.scope.define("this", new InstanceofType(module2, this, null, true));
                    }
                  } else if (pp.isMethodDefinition) {
                    if (pp.static) {
                      this.scope.define("this", module2);
                    }
                  }
                } else {
                  this.scope.define("this", module2);
                }
              } else {
                this.scope.define("this", Namespace.globals.get("Record"));
              }
            } else if (!this.parentStack.isMethodDefinition) {
              this.scope.define("this", Namespace.globals.get("Record"));
            }
          });
        }
      }
      freeze() {
        super.freeze();
        super.freeze(this.params);
        this.genericity && this.genericity.freeze();
        this._returnType && this._returnType.freeze();
        this.body && this.body.freeze();
        this.params.forEach((stack) => stack.freeze());
      }
      definition(ctx) {
        let complete = false;
        if (!ctx || ctx.stack && (ctx.stack === this.key || ctx.stack === this || ctx.stack.isMemberExpression)) {
          complete = true;
          ctx = this.getContext();
          if (!ctx.inCallChain()) {
            ctx = {};
          }
          if (ctx && ctx.stack && (ctx.stack.isCallExpression || ctx.stack.isNewExpression)) {
          } else {
          }
        }
        const token = this.parentStack.isProperty || this.parentStack.isMethodDefinition ? this.parentStack.key : this.key;
        let type2 = this.getReturnedType();
        if (Utils.isContext(ctx) && ctx.stack && ctx.stack.isCallExpression) {
          type2 = ctx.apply(type2);
        }
        const _thisCtx = this.thisArgumentContext;
        const _params = _thisCtx ? [_thisCtx, ...this.params] : this.params;
        const params = _params.map((item2) => {
          if (item2.isObjectPattern) {
            const properties = item2.properties.map((property) => {
              const name = property.key.value();
              const acceptType = property.type().toString(ctx);
              const init = property.init;
              if (init && init.isAssignmentPattern) {
                return `${init.left.value()}:${acceptType} = ${init.right.raw()}`;
              }
              return `${name}:${acceptType}`;
            });
            return `{${properties.join(",")}}`;
          } else if (item2.isArrayPattern) {
            const properties = item2.elements.map((property) => {
              const acceptType = property.type().toString(ctx);
              if (property.isAssignmentPattern) {
                return `${property.left.value()}:${acceptType} = ${property.right.raw()}`;
              }
              const name = property.value();
              return `${name}:${acceptType.toString(ctx)}`;
            });
            return `[${properties.join(",")}]`;
          } else {
            const name = item2.value();
            const type3 = item2.type().toString(ctx);
            const rest = item2.isRestElement ? "..." : "";
            const question = item2.question ? "?" : "";
            if (item2.isAssignmentPattern && item2.right) {
              const initial = item2.right.value();
              return `${rest}${name}${question}: ${type3}=${initial}`;
            }
            return `${rest}${name}${question}: ${type3}`;
          }
        });
        const generics = (this.genericity ? this.genericity.elements : []).map((item2) => {
          return item2.type().toString(ctx, { complete });
        });
        const strGenerics = generics.length > 0 ? `<${generics.join(", ")}>` : "";
        const returnType = type2 ? type2.toString(ctx, { chain: ["function"] }) : "void";
        let kind = "function";
        let key = token ? token.value() : "anonymous";
        let loc = null;
        if (this.isNewDefinition) {
          key = this.module.getName();
          kind = "new";
          loc = this.getLocation();
        } else if (this.isCallDefinition || this.parentStack.isMethodDefinition) {
          kind = "method";
        }
        if (this.isArrowFunctionExpression || this.isCallDefinition) {
          return {
            comments: this.comments,
            kind,
            expre: `${kind} ${strGenerics}(${params.join(", ")})=>${returnType}`,
            location: this.getLocation(),
            file: this.compilation.file
          };
        }
        return {
          comments: this.comments,
          kind,
          expre: `${kind} ${key}${strGenerics}(${params.join(", ")}): ${returnType}`,
          location: loc || (token ? token.getLocation() : null),
          file: this.compilation.file
        };
      }
      signature() {
        const def = this.definition();
        const _params = this.params;
        const comments = this.parseComments();
        const params = _params.map((item2) => {
          if (item2.isObjectPattern) {
            return {
              label: "ObjectPattern"
            };
          } else if (item2.isArrayPattern) {
            return {
              label: "ArrayPattern"
            };
          } else {
            const name = item2.value();
            const meta = comments && comments.params.find((param) => param.label === name);
            return {
              label: name,
              comment: meta && meta.comment ? meta.comment : item2.comments.join("\n")
            };
          }
        });
        def.params = params;
        return def;
      }
      reference(called) {
        if (called) {
          const stack = this.scope.returnItems[this.scope.returnItems.length - 1];
          return stack ? stack.reference() : null;
        }
        return this;
      }
      referenceItems(called) {
        if (called) {
          let items = [];
          this.scope.returnItems.forEach((item2) => {
            items = items.concat(item2.referenceItems(called));
          });
          return items;
        } else {
          return [this];
        }
      }
      description() {
        return this;
      }
      getRelateRuturnType(stack, argument, propertyStack = []) {
        if (stack.isObjectExpression) {
          return this.getRelateRuturnType(stack.parentStack, stack, propertyStack.concat(argument));
        } else if (stack.isProperty) {
          return this.getRelateRuturnType(stack.parentStack, stack, propertyStack);
        } else if (stack.isArrayExpression) {
          return this.getRelateRuturnType(stack.parentStack, stack, propertyStack.concat(argument));
        }
        if (stack.isVariableDeclarator && (stack.init === this || !stack._acceptType)) {
          return null;
        }
        const fetchObjectType = (object, property) => {
          if (property.isProperty) {
            object = stack.getObjectDescriptorForAuxiliary(object, property.value());
            if (object) {
              return object.type();
            }
          } else if (object.isTupleType && property.parentStack.isArrayExpression) {
            const index2 = property.parentStack.elements.indexOf(property);
            const type2 = object.prefix || object.rest ? object.elements[0] : object.elements[index2];
            if (type2) {
              return type2.type();
            }
          }
          return null;
        };
        const fetchType = (declareParam) => {
          if (!declareParam)
            return null;
          let type2 = declareParam.type();
          if (type2 && type2.isTupleType && type2.rest) {
            type2 = type2.elements[0]?.type();
          }
          while (type2 && type2.isAliasType) {
            type2 = type2.inherit.type();
          }
          if (type2 && (argument.isArrayExpression || argument.isObjectExpression)) {
            let desc = type2.type();
            while (desc && propertyStack.length > 0) {
              desc = fetchObjectType(desc, propertyStack.pop());
            }
            return desc;
          }
          return declareParam;
        };
        if (stack.isAssignmentExpression || stack.isVariableDeclarator) {
          let result = fetchType(stack.isVariableDeclarator ? stack.type() : stack.left.type());
          if (result) {
            let type2 = result.type();
            if (type2 && type2.isFunctionType && type2.target && type2.target !== this) {
              type2 = type2.target.isFunctionExpression || type2.target.isTypeFunctionDefinition ? type2.target.returnType : null;
              if (type2) {
                return type2.type();
              }
            }
          }
          return null;
        }
        if (!(stack.isCallExpression || stack.isNewExpression)) {
          return null;
        }
        let index = stack.arguments.indexOf(argument);
        let funType = stack.isCallExpression ? stack.descriptor() : stack.description();
        let declareParams = stack.getFunDeclareParams(funType);
        if (funType && declareParams) {
          const declare = fetchType(declareParams[index]);
          if (declare) {
            const result = Utils.extractFunTypeFromType(declare.type());
            if (result) {
              const [funType2, ctx] = result;
              if (funType2 && funType2.isFunctionType && funType2.target && funType2.target !== this) {
                let returnType = funType2.returnType;
                if (returnType) {
                  returnType = returnType.type();
                  if (ctx) {
                    returnType = ctx.fetch(returnType, true);
                  }
                  if (!returnType.isVoidType) {
                    return returnType;
                  }
                }
              }
            }
          }
        }
        return null;
      }
      get hasRecursionReference() {
        return !!(this._hasRecursionReference || this.recursionCallStacks);
      }
      get recursionCallStacks() {
        return this._recursionCallStacks;
      }
      addRecursionCallStacks(stack) {
        const stacks = this._recursionCallStacks || (this._recursionCallStacks = []);
        stacks.push(stack);
      }
      get rawReturnType() {
        return this._returnType || null;
      }
      get returnType() {
        return this.getAttribute("FunctionExpression.returnType", () => {
          let returnResult = null;
          if (this._returnType) {
            returnResult = this._returnType.type();
          } else {
            if (this.parentStack.isMethodDefinition) {
              const method = this.parentStack;
              if (!method.isMethodSetterDefinition && !method.isConstructor) {
                const key = method.value();
                const module2 = method.module;
                const result = this.findMethodInheritReturnType(module2, key, Utils.getModifierValue(method), method.kind, !!method.static);
                if (result) {
                  returnResult = result.type();
                }
              }
            } else {
              returnResult = this.getRelateRuturnType(this.parentStack, this);
            }
          }
          return returnResult;
        });
      }
      inferReturnType() {
        if (this.isArrowFunctionExpression && this.scope.isExpression) {
          return this.body.type();
        }
        return this.getAttribute("inferReturnType", () => {
          this._inferReturnTyping = true;
          const returnItems = this.scope.returnItems;
          if (!returnItems || !returnItems.length) {
            return Namespace.globals.get("void");
          }
          const mergeType = new MergeType();
          mergeType.keepOriginRefs = false;
          mergeType.keepLiteralArrayType = true;
          let breakContext = null;
          let hasVoid = null;
          let emptyArrayType = null;
          let hasTupleType = false;
          for (let item2 of returnItems) {
            let argument = item2.argument;
            if (argument) {
              if (argument.isIdentifier) {
                const def = argument.description();
                if (def && def.isVariableDeclarator && def.init) {
                  let desc = def.init.description();
                  if (desc && desc.isVariableDeclarator && desc.init === this) {
                    continue;
                  }
                  desc = def.init.descriptor();
                  if (desc === this || this.parentStack === desc) {
                    continue;
                  }
                }
              } else {
                const def = argument.descriptor();
                if (def === this || def === this.parentStack) {
                  continue;
                }
              }
              if (this._hasRecursionReference) {
                const block = argument.getParentStack((parent) => parent.isIfStatement || parent === this);
                if (block && block.isIfStatement) {
                  block.parser();
                }
              }
            } else {
              continue;
            }
            let type3 = item2.type();
            if (!type3 || type3.isRecursionType)
              continue;
            let ips = item2.parentStack;
            if (type3.isLiteralArrayType) {
              hasVoid = false;
              if (type3.elements.length === 0) {
                emptyArrayType = type3;
                continue;
              }
            } else if (type3.isTupleType) {
              hasTupleType = true;
            }
            if (ips.isBlockStatement && ips.parentStack.isIfStatement) {
              hasVoid = true;
              if (ips.parentStack.alternate && ips.parentStack.alternate.hasThrowStatement) {
                hasVoid = false;
              }
              if (ips.parentStack.alternate === ips) {
                if (ips.parentStack.consequent.hasThrowStatement) {
                  hasVoid = false;
                }
                let pp = ips.parentStack.parentStack;
                if (pp && pp.parentStack === this) {
                  breakContext = pp;
                  hasVoid = false;
                } else if (pp && pp.parentStack.isIfStatement) {
                  hasVoid = false;
                }
              }
              mergeType.add(type3);
            } else if (ips.isSwitchCase) {
              mergeType.add(type3);
            } else {
              if (breakContext === ips && ips.parentStack === this) {
                break;
              } else {
                if (ips.isBlockStatement && ips.parentStack === this || ips === this) {
                  hasVoid = false;
                } else if (ips.isBlockStatement && ips.hasThrowStatement) {
                  hasVoid = false;
                }
                mergeType.add(type3);
              }
            }
          }
          if (emptyArrayType && !hasTupleType) {
            mergeType.add(emptyArrayType);
          } else if (hasVoid) {
            mergeType.add(Namespace.globals.get("void"));
          }
          this._inferReturnTyping = false;
          const type2 = mergeType.type();
          if (this._recursionType) {
            this._recursionType.result = type2;
          }
          return type2;
        });
      }
      normalization(type2) {
        if (type2 && type2.isUnionType) {
          if (type2.elements.some((type3) => {
            type3 = type3.type();
            if (type3 && type3.isComputeType)
              return false;
            return type3 && type3.isAnyType;
          })) {
            return Namespace.globals.get("any");
          }
        }
        return type2;
      }
      getReturnedType(caller) {
        let returnType = this.returnType;
        ;
        if (!returnType && caller && caller.parentStack.isVariableDeclarator) {
          const context = caller.parentStack.getParentStack((parent) => parent.isFunctionExpression);
          if (context === this) {
            this._hasRecursionReference = true;
          }
        }
        return this.getAttribute("getReturnedType", () => {
          let type2 = returnType;
          let value2 = null;
          if (type2) {
            value2 = this.normalization(type2.type());
          } else {
            value2 = this.inferReturnType();
          }
          if (this.async) {
            const origin = Utils.getOriginType(value2);
            const promiseType = Namespace.globals.get("Promise");
            if (!promiseType.is(origin)) {
              value2 = new InstanceofType(promiseType, null, [value2]);
            }
          }
          return value2;
        });
      }
      type() {
        return this.getFunType();
      }
      getFunType() {
        return this.getAttribute("getFunType", () => {
          return new FunctionType(Namespace.globals.get("Function"), this);
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.genericity) {
          this.genericity.parser();
        }
        const _thisArg = this.thisArgumentContext;
        if (_thisArg) {
          _thisArg.parser();
        }
        this.params.forEach((item2) => {
          item2.parser();
          if (item2.annotations && item2.annotations.length > 0) {
            item2.annotations.forEach((annotation) => {
              annotation.parser();
            });
          }
        });
        if (this._returnType) {
          this._returnType.parser();
          this._returnType.setRefBeUsed();
        }
        if (this.isNewDefinition || this.isCallDefinition) {
          return;
        }
        if (this.body) {
          this.body.parser();
        }
        if (this.parentStack && this.parentStack.parentStack && this.parentStack.parentStack.isUseExtendStatement) {
          return;
        }
        if (!this.isDeclaratorFunction) {
          const isInterface = this.module && (this.module.isDeclaratorModule || this.module.isInterface);
          if (this.isConstructor && this.module && !isInterface && !this.getMatchDescriptor("#" + this.module.id, this.module)) {
            if (this.scope.returnItems.length > 0) {
              const last = this.scope.returnItems[this.scope.returnItems.length - 1];
              last.error(1052);
            }
            if (this.module.inherit && this.scope.firstSuperIndex != 1) {
              (this.body.childrenStack[0] || this.key).error(1053);
            }
          } else if (!isInterface && this.body) {
            let acceptType = this.returnType;
            if (acceptType) {
              acceptType = acceptType.type();
              const hasVoidType = (type2, prev = null) => {
                if (!type2 || type2 === prev)
                  return false;
                if (type2.isGenericType) {
                  if (type2.assignType) {
                    return hasVoidType(type2.assignType.type(), type2);
                  } else if (type2.hasConstraint) {
                    return hasVoidType(type2.inherit.type(), type2);
                  }
                  return true;
                }
                if (type2.isVoidType || type2.isAnyType)
                  return true;
                return type2.isUnionType ? type2.elements.some((el) => hasVoidType(el.type(), type2)) : false;
              };
              if (!hasVoidType(acceptType)) {
                if (this.async) {
                  const promiseType = Namespace.globals.get("Promise");
                  if (promiseType && !promiseType.is(acceptType.type())) {
                    (this._returnType || this).error(1055, promiseType.toString());
                  }
                } else if (!this.scope.returnItems.length) {
                  if (!(this.scope.isArrow && this.scope.isExpression)) {
                    const target = this.parentStack.isMethodDefinition ? this.parentStack.key : this.key;
                    const body = this.body;
                    const has = (body && body.isBlockStatement && body.body).some((item2) => {
                      return !!(item2 && item2.isThrowStatement);
                    });
                    if (!has) {
                      (target || this).error(1133);
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    module.exports = FunctionExpression;
  }
});

// lib/stacks/ArrowFunctionExpression.js
var require_ArrowFunctionExpression = __commonJS({
  "lib/stacks/ArrowFunctionExpression.js"(exports, module) {
    var FunctionExpression = require_FunctionExpression();
    var ArrowFunctionExpression = class extends FunctionExpression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isArrowFunctionExpression = true;
        this.scope.isArrow = true;
        this.scope.isExpression = !!node2.expression;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.scope.isExpression) {
          let acceptType = this.returnType;
          if (acceptType) {
            acceptType = acceptType.type();
            if (acceptType && !acceptType.isGenericType && !acceptType.check(this.body)) {
              this.body.error(1002, this.body.type().toString(), acceptType.toString());
            }
          }
        }
      }
      reference() {
        if (this.scope.isExpression) {
          return this.body;
        }
        return super.reference();
      }
      referenceItems() {
        if (this.scope.isExpression) {
          return [this.body];
        }
        return super.referenceItems();
      }
    };
    module.exports = ArrowFunctionExpression;
  }
});

// lib/stacks/AssignmentExpression.js
var require_AssignmentExpression = __commonJS({
  "lib/stacks/AssignmentExpression.js"(exports, module) {
    var Expression = require_Expression();
    var Predicate = require_Predicate();
    var Utils = require_Utils();
    var Namespace = require_Namespace();
    var AssignmentExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isAssignmentExpression = true;
        this.left = this.createTokenStack(compilation, node2.left, scope, node2, this);
        this.right = this.createTokenStack(compilation, node2.right, scope, node2, this);
        this.left.accessor = "set";
        this.operator = node2.operator;
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
      }
      definition(context) {
        return this.left.definition(context);
      }
      description() {
        const desc = this.left.description();
        return desc;
      }
      getContext() {
        const desc = this.description();
        if (desc && desc.isStack) {
          return desc.getContext();
        }
        return super.getContext();
      }
      type(ctx) {
        return this.right.type(ctx);
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.left.parser();
        this.right.parser();
        this.left.setRefBeUsed();
        this.right.setRefBeUsed();
        let desc = this.description();
        if (desc && desc.isComputeType) {
          desc = this.left.type();
          this.checkExpressionType(desc, this.right, null, this.left.getContext());
        } else if (desc && !desc.isAnyType) {
          let ident = this.left;
          if (ident.isMemberExpression) {
            ident = ident.property;
          }
          let scope = this.scope;
          if (scope && scope.allowInsertionPredicate()) {
            let lType = this.left.type();
            if (!lType || (lType.isAnyType || lType.isNullableType || lType.isUndefinedType)) {
              if (desc.isProperty && desc.computed && this.left.isMemberExpression) {
                const origin = this.left.getFirstMemberStack().description();
                if (origin && origin.isDeclarator) {
                  const rType = this.right.type();
                  if (rType && !rType.isAnyType) {
                    const existed = scope.getPredicate(origin, true);
                    if (existed) {
                      existed.setAttribute(this.left.value(), this.right);
                    } else {
                      scope.setPredicate(origin, Predicate.attribute(this.left.value(), this.right));
                    }
                  }
                }
              } else if (desc.isDeclarator && !desc.acceptType) {
                const rType = this.right.type();
                if (rType && !rType.isAnyType) {
                  scope.setPredicate(desc, Predicate.create(rType, this.right.description(), desc));
                }
              }
            }
            if (desc && desc.isDeclarator) {
              let state = scope.getValidateState(desc);
              if (state) {
                if (state.value && state.isAlternate || !state.value && !state.isAlternate) {
                  desc.whenIsNullSetValue(this.right);
                }
              }
            }
          }
          if (this.left.isArrayPattern || this.left.isObjectPattern) {
          } else {
            if (desc.isMethodDefinition && !desc.isMethodSetterDefinition) {
              this.error(1015, this.left.value());
            } else if (desc.kind === "const" || !desc.assignment) {
              if (!(desc.isLiteralObjectType || desc.isObjectExpression)) {
                let objectType = this.left.isMemberExpression && this.left.object.type();
                if (objectType && objectType.isAliasType) {
                  objectType = objectType.inherit.type();
                }
                if (!objectType || !objectType.isLiteralObjectType) {
                  this.error(1015, this.left.value());
                }
              }
            } else {
              desc.assignment(this.right, ident, this.left.getContext());
            }
          }
        }
      }
      value() {
        return this.left.value();
      }
    };
    module.exports = AssignmentExpression;
  }
});

// lib/stacks/AssignmentPattern.js
var require_AssignmentPattern = __commonJS({
  "lib/stacks/AssignmentPattern.js"(exports, module) {
    var Namespace = require_Namespace();
    var Declarator = require_Declarator();
    var AssignmentPattern = class extends Declarator {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isAssignmentPattern = true;
        this.left = this.createTokenStack(compilation, node2.left, scope, node2, this);
        this.right = this.createTokenStack(compilation, node2.right, scope, node2, this);
        if (!(parentStack && (parentStack.isArrayPattern || parentStack.isProperty))) {
          this._acceptType = this.createTokenStack(compilation, node2.left.acceptType, scope, node2, this);
        }
        const isAssignment = this.parentStack.isArrayPattern && this.parentStack.parentStack.isAssignmentExpression;
        const isJSXAttribute = this.parentStack.isObjectPattern && this.parentStack.parentStack.isJSXAttribute;
        if (!(isAssignment || isJSXAttribute || this.parentStack.isAnnotationDeclaration || this.parentStack.isAnnotationExpression)) {
          const stack = this.getParentStack((stack2) => !!(stack2.isVariableDeclaration || stack2.isBlockStatement));
          const name = this.left.value();
          let context = void 0;
          if (stack && stack.isVariableDeclaration) {
            context = stack.kind === "var" ? "function" : "block";
          }
          if (scope.isDefine(name, context)) {
            this.error(1007, name);
          }
          scope.define(name, this);
          this.assignValue = this.right;
          this.assignFirstValue = this.right;
          this.assignItems.add(this.right);
        }
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
      }
      type() {
        if (this.parentStack && this.parentStack.isAnnotationDeclaration && this.parentStack.name.toLowerCase() === "embed") {
          const item2 = this.parentStack.getArguments()[0];
          if (item2.assigned && /\.(css|less|scss|sass)$/i.test(item2.value)) {
            return Namespace.globals.get("object");
          }
        }
        if (this.acceptType) {
          return this.acceptType.type();
        }
        if (this.inheritInterfaceAcceptType) {
          return this.inheritInterfaceAcceptType.type();
        }
        if (this.parentStack.isTryStatement) {
          return Namespace.globals.get("Error");
        }
        const desc = this.description();
        if (desc && desc !== this) {
          return this.getContext().apply(desc.type());
        }
        return super.type();
      }
      description() {
        const p = this.parentStack;
        var desc = null;
        if (p.isProperty && p.parentStack.isObjectPattern && p.parentStack.parentStack.isVariableDeclarator) {
          const init = p.parentStack.parentStack.init;
          if (init) {
            const type2 = init.type();
            const isStatic = type2.isClassGenericType && type2.isClassType || p.parentStack.parentStack.init.description() === type2;
            desc = this.getObjectDescriptor(init.type(), this.left.value(), isStatic);
            if (desc && (desc.isAnyType || desc.isGenericType || desc.isNullableType || desc.isNeverType)) {
              desc = null;
            }
          }
        } else if (p.isArrayPattern && p.parentStack.isAssignmentExpression) {
          return this.left.description();
        }
        if (desc) {
          return desc;
        }
        return super.description();
      }
      definition(context) {
        const type2 = this.type().toString();
        const identifier = this.value();
        if (this.parentStack.isFunctionExpression) {
          return super.definition(context);
        }
        if (this.parentStack.isAnnotationDeclaration || this.parentStack.isAnnotationExpression) {
          return this.parentStack.definition(context);
        } else if (this.isParamDeclarator) {
          return super.definition(context);
        } else if (this.parentStack.isProperty) {
          return this.parentStack.definition(context);
        }
        return {
          kind: this.kind,
          identifier,
          expre: `${this.kind} ${identifier}:${type2}`,
          location: this.left.getLocation(),
          file: this.compilation.file,
          context: this
        };
      }
      value() {
        return this.left.value();
      }
      error(code, ...args) {
        this.left.error(code, ...args);
      }
      warn(code, ...args) {
        this.left.warn(code, ...args);
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.acceptType) {
          this.acceptType.parser();
        }
        this.right.parser();
        this.right.setRefBeUsed();
        if (this.module && this.module.id === this.left.value()) {
          this.left.error(1008, this.left.value());
        }
        const isStatement = this.parentStack.isFunctionExpression;
        const isNullable = isStatement && this.right.isLiteral && this.right.value() === null;
        if (!isNullable) {
          this.checkExpressionType(this.acceptType, this.right);
        }
        const lDesc = this.left.description();
        const rDesc = this.right.description();
        if (lDesc === rDesc) {
          this.error(1010, this.right.value());
        }
      }
    };
    module.exports = AssignmentPattern;
  }
});

// lib/stacks/AwaitExpression.js
var require_AwaitExpression = __commonJS({
  "lib/stacks/AwaitExpression.js"(exports, module) {
    var Namespace = require_Namespace();
    var Utils = require_Utils();
    var Expression = require_Expression();
    var AwaitExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        node2.name = "await";
        super(compilation, node2, scope, parentNode, parentStack);
        this.isAwaitExpression = true;
        this.argument = this.createTokenStack(compilation, node2.argument, scope, node2, this);
        if (parentStack) {
          parentStack.isAwaitExpression = true;
        }
        let parent = parentStack;
        while (parent && !parent.isFunctionExpression) {
          parent.scope.hasChildAwait = true;
          parent.hasAwait = true;
          parent = parent.parentStack;
        }
        if (parent.isFunctionExpression) {
          parent.hasAwait = true;
        }
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
      }
      definition() {
        return null;
      }
      description() {
        return this.argument.description();
      }
      getContext() {
        return this.argument.getContext();
      }
      type() {
        const type2 = this.argument.type();
        const origin = Utils.getOriginType(type2);
        const PromiseType = Namespace.globals.get("Promise");
        if (origin && PromiseType.is(origin)) {
          if (type2.isInstanceofType && type2.generics[0]) {
            return type2.generics[0].type();
          } else if (type2.isClassGenericType) {
            return type2.types[0].type();
          }
        }
        return type2;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.argument.parser();
        this.argument.setRefBeUsed();
        const stack = this.getParentStack((stack2) => stack2.isFunctionExpression || this.isModuleStack(stack2));
        if (!stack || !(stack.isFunctionExpression && stack.async || stack.isProgram)) {
          this.error(1017);
        }
      }
    };
    module.exports = AwaitExpression;
  }
});

// lib/stacks/BinaryExpression.js
var require_BinaryExpression = __commonJS({
  "lib/stacks/BinaryExpression.js"(exports, module) {
    var Utils = require_Utils();
    var UnionType = require_UnionType();
    var Expression = require_Expression();
    var Predicate = require_Predicate();
    var Namespace = require_Namespace();
    var shortGlobals = [
      "int",
      "uint",
      "double",
      "number",
      "float",
      "array",
      "string",
      "boolean",
      "regexp",
      "object",
      "class"
    ];
    function getTypeId(type2) {
      if (!type2)
        return null;
      if (type2.isLiteralType) {
        return getTypeId(type2.inherit.type());
      } else if (type2.isAliasType) {
        return type2.id;
      }
      return null;
    }
    var BinaryExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isBinaryExpression = true;
        this.left = this.createTokenStack(compilation, node2.left, scope, node2, this);
        this.right = this.createTokenStack(compilation, node2.right, scope, node2, this);
        this.operator = this.node.operator;
        const operator = this.operator;
        this.isIsOperatorFlag = operator === "instanceof" || operator === "is";
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
      }
      definition() {
        return null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      description() {
        return this;
      }
      type(ctx) {
        const operator = this.operator;
        if (operator === "instanceof" || operator === "is") {
          return Namespace.globals.get("boolean");
        } else {
          const code = operator.charCodeAt(0);
          const isBit = operator.length > 1 && (code === 60 || code === 62) && operator.charCodeAt(1) === code;
          if ((code === 33 || code === 60 || code === 61 || code === 62) && !isBit) {
            return Namespace.globals.get("boolean");
          } else if (code === 43) {
            const stringType = Namespace.globals.get("string");
            if (stringType.check(this.left, ctx) || stringType.check(this.right, ctx)) {
              return stringType;
            }
          }
          const id1 = getTypeId(this.left.type());
          const id2 = getTypeId(this.right.type());
          if (id1 === "NaN" || id2 === "NaN") {
            return Namespace.globals.get("NaN");
          } else if (id1 === "float" || id2 === "float") {
            return Namespace.globals.get("float");
          } else if (id1 === "double" || id2 === "double") {
            return Namespace.globals.get("double");
          } else if (id1 === "uint" && id2 === "uint") {
            return Namespace.globals.get("uint");
          } else if ((id1 === "int" || id2 === "int") && !(id1 === "number" || id2 === "number")) {
            return Namespace.globals.get("int");
          }
          return Namespace.globals.get("number");
        }
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.left.parser();
        this.left.setRefBeUsed();
        this.right.parser();
        this.right.setRefBeUsed();
        const operator = this.node.operator;
        if (operator === "instanceof" || operator === "is") {
          const lDesc = this.left.description();
          const lType = this.left.type();
          if (lType && operator === "instanceof") {
            if (lDesc && Utils.isTypeModule(lDesc) || lType.isLiteralType || lType.isClassType && lType.isClassGenericType) {
              this.left.error(1019, this.left.value());
            }
          }
          let rightType = this.right.type();
          let pp = this.parentStack;
          if (pp.isParenthesizedExpression)
            pp = pp.parentStack;
          if (pp.isLogicalExpression)
            pp = pp.parentStack;
          if (pp.isUnaryExpression && pp.isLogicalFlag && pp.isLogicalTrueFlag) {
            pp = pp.parentStack;
          }
          if (pp.isIfStatement || pp.isConditionalExpression) {
            if (rightType && !rightType.isAnyType && lDesc) {
              const scope = pp.consequent.scope;
              const condition = pp.isIfStatement ? pp.condition : pp.test;
              if (scope && scope.allowInsertionPredicate()) {
                let existed = scope.getPredicate(lDesc, true);
                let cacheId = this.getCacheId();
                if (existed && existed.cacheId === cacheId) {
                  if (condition.isLogicalExpression) {
                    if (condition.operator.charCodeAt(0) === 38) {
                      this.warn(1187);
                    } else {
                      if (existed.type.isUnionType) {
                        existed.type.elements.push(rightType);
                      } else {
                        scope.setPredicate(lDesc, Predicate.create(
                          new UnionType([existed.type, rightType]),
                          this.right.description(),
                          lDesc,
                          cacheId
                        ));
                      }
                    }
                  } else if (rightType.is(existed.type)) {
                    existed.type = rightType;
                    existed.desc = this.right.description();
                    this.warn(1186, this.raw());
                  }
                } else {
                  scope.setPredicate(lDesc, Predicate.create(rightType, this.right.description(), lDesc, cacheId));
                }
              }
            }
          }
          if (rightType && rightType.isAliasType && shortGlobals.includes(rightType.id)) {
            rightType = rightType.inherit.type();
          }
          if (!Utils.isTypeModule(rightType)) {
          } else {
            this.compilation.addDependency(rightType, this.module);
          }
        }
      }
    };
    module.exports = BinaryExpression;
  }
});

// lib/scope/BlockScope.js
var require_BlockScope = __commonJS({
  "lib/scope/BlockScope.js"(exports, module) {
    var Scope = require_Scope();
    module.exports = class BlockScope extends Scope {
      constructor(parentScope) {
        super(parentScope);
        this.isBlockScope = true;
      }
      type(name) {
        return name === "block";
      }
    };
  }
});

// lib/stacks/BlockStatement.js
var require_BlockStatement = __commonJS({
  "lib/stacks/BlockStatement.js"(exports, module) {
    var Stack = require_Stack();
    var BlockScope = require_BlockScope();
    var BlockStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        if (parentStack && !(parentStack.isFunctionDeclaration || parentStack.isFunctionExpression || parentStack.isArrowFunctionExpression || parentStack.isForOfStatement || parentStack.isForInStatement || parentStack.isForStatement || parentStack.isIfStatement || parentStack.isWhileStatement || parentStack.isWhenStatement)) {
          scope = new BlockScope(scope);
        }
        super(compilation, node2, scope, parentNode, parentStack);
        this.isBlockStatement = true;
        this.hasReturnStatement = false;
        this.hasThrowStatement = false;
        this.body = [];
        for (const item2 of node2.body) {
          const stack = this.createTokenStack(compilation, item2, scope, node2, this);
          if (stack) {
            if (stack.isThrowStatement) {
              this.hasThrowStatement = true;
            }
            if (stack.isReturnStatement || stack.hasReturnStatement || stack.isThrowStatement) {
              this.hasReturnStatement = true;
            }
            this.body.push(stack);
          }
        }
        ;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.scope);
        super.freeze(this.body);
        this.body.forEach((stack) => stack.freeze());
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        let fristReturnAt = -1;
        this.body.forEach((item2, index) => {
          item2.parser();
          if (fristReturnAt === -1) {
            if (item2.hasReturnStatement || item2.hasThrowStatement) {
              if (index + 1 < this.body.length) {
                fristReturnAt = index;
              }
            }
          }
        });
        if (fristReturnAt >= 0) {
          const start = this.body[fristReturnAt + 1];
          const end = this.body[this.body.length - 1];
          if (start && end) {
            const startRange = this.compilation.getRangeByNode(start.node);
            const endRange = this.compilation.getRangeByNode(end.node);
            const range = {
              loc: {
                start: startRange.start,
                end: endRange.end
              }
            };
            this.compilation.unnecessary(range, 1184);
          }
        }
      }
    };
    module.exports = BlockStatement;
  }
});

// lib/stacks/BreakStatement.js
var require_BreakStatement = __commonJS({
  "lib/stacks/BreakStatement.js"(exports, module) {
    var Stack = require_Stack();
    var BreakStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isBreakStatement = true;
        this.label = this.createTokenStack(compilation, node2.label, scope, node2, this);
        let parent = parentStack;
        while (parent && !parent.isFunctionExpression) {
          if (parent.isSwitchCase || parent.isSwitchStatement || parent.isWhileStatement || parent.isDoWhileStatement || parent.isBlockStatement) {
            parent.hasBreak = true;
            break;
          }
          parent = parent.parentStack;
        }
      }
      freeze() {
        super.freeze(this);
        this.label.freeze();
      }
      getLabelStackByName(name) {
        let labelStack = this.getParentStack((stack) => !!(stack.isLabeledStatement || stack.isFunctionExpression));
        while (labelStack && labelStack.isLabeledStatement) {
          if (labelStack.label.value() === name) {
            return labelStack;
          }
          labelStack = labelStack.labelParent;
        }
        return null;
      }
      definition(context) {
        if (this.label) {
          const labelStack = this.getLabelStackByName(this.label.value());
          if (labelStack) {
            return labelStack.definition(context);
          }
        }
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.label) {
          const labelStack = this.getLabelStackByName(this.label.value());
          if (!labelStack || !labelStack.isLabeledStatement) {
            this.label.error(1022);
          }
        }
        let parent = this.parentStack;
        while (parent) {
          if (parent.isSwitchCase || parent.isDoWhileStatement || parent.isWhileStatement || parent.isForStatement || parent.isForOfStatement || parent.isForInStatement) {
            return true;
          } else if (parent.isFunctionExpression) {
            break;
          } else {
            parent = parent.parentStack;
          }
        }
        this.error(1023);
      }
    };
    module.exports = BreakStatement;
  }
});

// lib/stacks/CallDefinition.js
var require_CallDefinition = __commonJS({
  "lib/stacks/CallDefinition.js"(exports, module) {
    var FunctionExpression = require_FunctionExpression();
    var CallDefinition = class extends FunctionExpression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isCallDefinition = true;
        this.module.addDescriptor("#" + this.module.id, this);
        this.callable = true;
      }
    };
    module.exports = CallDefinition;
  }
});

// lib/stacks/CallExpression.js
var require_CallExpression = __commonJS({
  "lib/stacks/CallExpression.js"(exports, module) {
    var Utils = require_Utils();
    var Expression = require_Expression();
    var Stack = require_Stack();
    var Namespace = require_Namespace();
    var MergeType = require_MergeType();
    var Predicate = require_Predicate();
    var UnionType = require_UnionType();
    var ClassGenericType = require_ClassGenericType();
    var CallExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isCallExpression = true;
        this.callee = this.createTokenStack(compilation, node2.callee, scope, node2, this);
        this.arguments = node2.arguments.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
        this.genericity = null;
        if (node2.genericity) {
          this.genericity = node2.genericity.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
        }
        this.optional = !!node2.optional;
      }
      freeze() {
        super.freeze(this);
        this.callee.freeze();
        super.freeze(this.genericity);
        (this.genericity || []).forEach((stack) => stack.freeze());
      }
      definition(ctx) {
        const identifier = this.callee.value();
        if (this.parentStack.isWhenStatement) {
          const type2 = "boolean";
          const params = this.arguments.map((item2) => item2.value());
          return {
            text: `(method) ${identifier}(${params.join(",")}):${type2}`
          };
        }
        let description = this.descriptor();
        if (!description) {
          description = this.description();
        }
        if (!description)
          return null;
        if (description.isType && description.isAnyType) {
          return null;
        }
        const context = this.getContext();
        if (ctx) {
          context.setHoverStack(ctx.hoverStack);
        }
        return description.definition(context);
      }
      hover(ctx) {
        const identifier = this.callee.value();
        if (this.parentStack.isWhenStatement) {
          const type2 = "boolean";
          const params = this.arguments.map((item2) => item2.value());
          return {
            text: `(method) ${identifier}(${params.join(",")}):${type2}`
          };
        }
        let description = this.descriptor();
        if (!description) {
          description = this.description();
        } else if (!this.is(description)) {
          const desc = this.description();
          if (this.is(desc)) {
            description = desc;
          }
        }
        if (!description)
          return null;
        if (description && (description.isType && description.isAnyType)) {
          return {
            text: `any`
          };
        }
        const context = this.getContext();
        if (ctx) {
          context.setHoverStack(ctx.hoverStack);
        }
        return description.hover(context);
      }
      signature() {
        if (this.parentStack.isWhenStatement) {
          return null;
        }
        let description = this.descriptor();
        if (!description) {
          description = this.description();
        }
        if (!description)
          return null;
        if (description.isType && description.isAnyType) {
          return null;
        }
        return description.signature();
      }
      reference() {
        let description = this.description();
        if (description) {
          if (description instanceof Stack) {
            return description.reference(true);
          } else if (description.isFunctionType) {
            return description.type();
          }
        }
        return null;
      }
      referenceItems() {
        let description = this.description();
        if (description) {
          if (description instanceof Stack) {
            return description.referenceItems(true);
          } else if (description.isFunctionType) {
            return [].concat(description.type());
          }
        }
        return [];
      }
      description() {
        return this.callee.description();
      }
      descriptor() {
        return this.getAttribute("CallExpression.descriptor", () => {
          if (this.callee.isSuperExpression) {
            return this.getMatchDescriptor("constructor", this.callee.type()) || Namespace.globals.get("any");
          }
          let desc = this.callee.descriptor();
          if (desc) {
            if (desc.isMethodDefinition && !desc.isAccessor || desc.isFunctionExpression || desc.isDeclaratorFunction || desc.isFunctionType || desc.isTypeFunctionDefinition) {
              return desc;
            }
          }
          let ctx = null;
          const Fun = Namespace.globals.get("Function");
          const fetch = (type2, exclude = null, noFindModule = false) => {
            if (type2 && type2.isGenericType) {
              ctx = ctx || this.callee.getContext();
              type2 = ctx.fetch(type2, true);
            }
            if (type2 === exclude)
              return null;
            if (!type2 || type2.isNullableType || type2.isNeverType || type2.isVoidType || type2.isUndefinedType)
              return null;
            if (type2.isTupleType || type2.isLiteralArrayType)
              return null;
            if (type2.isComputeType) {
              ctx = ctx || this.callee.getContext();
              type2 = type2.getComputeResult(null, ctx);
            }
            if (type2.isLiteralObjectType) {
              type2 = this.getMatchDescriptor(`#call#`, type2);
            }
            if (!type2)
              return null;
            if (type2 === Fun || type2.isFunctionType || type2.isAnyType || type2.isTypeFunctionDefinition)
              return type2;
            if (type2.isTypeofType) {
              return fetch(type2.origin.type(), type2);
            } else if (type2.isIntersectionType) {
              return fetch(type2.left.type(), type2, true) || fetch(type2.right.type(), type2, true);
            } else if (type2.isUnionType) {
              const els = type2.elements;
              for (let index = 0; index < els.length; index++) {
                let res = fetch(els[index].type(), type2, true);
                if (res)
                  return res;
              }
              return null;
            } else if (type2.isAliasType) {
              if (Utils.isGlobalShortenType(type2))
                return null;
              return fetch(type2.inherit.type(), type2);
            } else if (type2.isClassGenericType) {
            }
            if (!noFindModule) {
              if (Utils.isTypeModule(type2)) {
                return this.getMatchDescriptor(`#${type2.id}`, type2);
              } else {
                return fetch(Utils.getOriginType(type2), type2);
              }
            }
          };
          return fetch(this.callee.type());
        });
      }
      value() {
        return this.callee.value();
      }
      getFunDeclareParams(description = null) {
        if (!description) {
          description = this.descriptor();
        }
        if (!description)
          return [];
        const declareParams = description.isFunctionType && description.target ? description.target.params : description.params;
        return declareParams || [];
      }
      getDeclareGenerics(description) {
        const genericity = description.isFunctionType && description.target ? description.target.genericity : description.genericity;
        return [genericity ? genericity.elements : [], null];
      }
      getCalleeDeclareGenerics() {
        const description = this.descriptor();
        const genericity = description.isFunctionType && description.target ? description.target.genericity : description.genericity;
        if (genericity) {
          return genericity.elements.map((item2) => item2.type());
        }
        return null;
      }
      getAssigmentGenerics() {
        return this.genericity || null;
      }
      getRawType() {
        const type2 = this.type();
        return this.getAttribute("CallExpression.getRawType") || type2;
      }
      getReturnType() {
        return this.getAttribute("CallExpression.getReturnType", () => {
          let description = this.descriptor();
          if (!description) {
            return Namespace.globals.get("any");
          }
          let type2 = null;
          if (description.isMethodDefinition || description.isFunctionExpression) {
            const result = description.getReturnedType(this);
            if (result) {
              type2 = result.type();
            }
          } else {
            let result = description.type();
            let anyType = null;
            if (result.isUnionType) {
              const elements = result.elements.map((item2) => {
                let type3 = item2.type();
                if (type3.isFunctionType) {
                  type3 = type3.getInferReturnType();
                  if (type3) {
                    if (type3.isAnyType)
                      anyType = type3;
                    if (type3.isVoidType || type3.isUndefinedType)
                      return;
                    if (type3.isUnionType)
                      return type3.elements.map((item3) => item3.type());
                  }
                  return type3;
                }
              }).filter(Boolean).flat();
              if (anyType) {
                type2 = result = anyType;
              } else {
                if (elements.length > 1) {
                  const merge = new MergeType();
                  merge.target = result.target;
                  elements.forEach((type3) => merge.add(type3));
                  type2 = result = merge.type();
                } else {
                  type2 = result = elements[0];
                }
              }
            }
            if (result.isInstanceofType && result.isThisType) {
              const refs = this.callee;
              if (refs && refs.isMemberExpression) {
                result = refs.object.type();
              } else {
                result = refs.type();
              }
            }
            if (result && result.isFunctionType) {
              result = result.returnType;
              if (result) {
                type2 = result.type();
              }
            }
          }
          if (!type2) {
            return Namespace.globals.get("any");
          }
          if (type2.isInstanceofType && type2.isThisType && this.callee.isMemberExpression) {
            const _type = this.callee.object.type();
            if (_type.isUnionType) {
              const els = _type.elements.filter((el) => {
                const t = el.type();
                if (t.isNullableType || t.isUndefinedType || t.isNeverType || t.isVoidType || t.isUnknownType)
                  return false;
                return true;
              });
              if (els.length === 1) {
                return els[0].type();
              }
            }
            return _type;
          }
          return type2;
        });
      }
      type() {
        return this.getAttribute("CallExpression.type", () => {
          let type2 = this.getReturnType();
          if (type2) {
            let final = this.getContextOfInference().apply(type2);
            if (final) {
              return final;
            }
          }
          return Namespace.globals.get("any");
        });
      }
      parserArguments() {
        this.arguments.forEach((item2) => {
          item2.parser();
          item2.setRefBeUsed();
        });
      }
      isCallableDesc(desc) {
        if (!(desc.callable || desc.isAnyType || desc.isFunctionType || this.callee.isSuperExpression)) {
          if (desc.isUnionType && Array.isArray(desc.elements)) {
            return desc.elements.some((item2) => this.isCallableDesc(item2.type()));
          }
          return false;
        }
        return true;
      }
      presetPredicateType(declareParams, args) {
        if (!declareParams || !declareParams.length)
          return;
        let type2 = this.getReturnType();
        if (!type2 || !type2.isPredicateType)
          return;
        let pp = this.parentStack;
        if (pp.isParenthesizedExpression)
          pp = pp.parentStack;
        if (pp.isLogicalExpression)
          pp = pp.parentStack;
        let isLogicalFlag = false;
        let isLogicalTrueFlag = false;
        let hasUnary = false;
        if (pp.isUnaryExpression) {
          hasUnary = true;
          isLogicalFlag = pp.isLogicalFlag;
          isLogicalTrueFlag = pp.isLogicalTrueFlag;
          pp = pp.parentStack;
        }
        if (hasUnary && !isLogicalFlag)
          return;
        let index = declareParams.indexOf(type2.argument.description());
        let argument = args[index];
        if (!argument)
          return;
        let lDesc = argument.description();
        if (pp.isIfStatement || pp.isConditionalExpression) {
          const scope = pp.consequent.scope;
          const condition = pp.isIfStatement ? pp.condition : pp.test;
          if (scope && scope.allowInsertionPredicate()) {
            const ctx = this.getContext();
            let assignType = ctx.apply(type2.inferType());
            let rDesc = type2.value.description();
            let existed = scope.getPredicate(lDesc, true);
            let cacheId = this.getCacheId();
            let constraint = type2.inferType();
            if (constraint.isConditionalExpressionType) {
              constraint = constraint.target.condition.extends.type();
            }
            if (isLogicalFlag && !isLogicalTrueFlag) {
              const argumentType = argument.type();
              if (argumentType.isUnionType) {
                const matched = argumentType.elements.filter((item2) => !constraint.is(item2.type(), ctx));
                if (matched.length > 0) {
                  if (matched.length > 1) {
                    assignType = MergeType.arrayToUnion(matched);
                  } else {
                    assignType = matched[0].type();
                  }
                }
              } else if (!constraint.is(assignType, ctx)) {
                assignType = argumentType;
              } else {
                return;
              }
            } else if (!constraint.is(assignType, ctx)) {
              let anyType = null;
              const inference = (type3) => {
                if (constraint.isClassGenericType) {
                  return anyType || (anyType = Namespace.globals.get("any"));
                }
                return ctx.infer(type3) || anyType || (anyType = Namespace.globals.get("any"));
              };
              assignType = constraint.hasGenericType ? constraint.clone(inference) : constraint;
            }
            if (existed && existed.cacheId === cacheId) {
              if (condition.isLogicalExpression) {
                if (condition.operator.charCodeAt(0) === 38) {
                  condition.warn(1187);
                } else {
                  if (existed.type.isUnionType) {
                    existed.type.elements.push(assignType);
                  } else {
                    scope.setPredicate(lDesc, Predicate.create(
                      new UnionType([existed.type, assignType]),
                      rDesc,
                      this,
                      cacheId
                    ));
                  }
                }
              } else if (assignType.is(existed.type)) {
                existed.type = assignType;
                existed.desc = rDesc;
                condition.warn(1186, condition.raw());
              }
            } else {
              scope.setPredicate(lDesc, Predicate.create(assignType, rDesc, this, cacheId));
            }
          }
        } else if (pp.isVariableDeclarator) {
          let scope = this.scope;
          let assignType = this.getContext().apply(type2.inferType());
          let rDesc = type2.value.description();
          let dataset = scope.define("#predicate-type#");
          if (!dataset) {
            dataset = /* @__PURE__ */ new Map();
            scope.define("#predicate-type#", dataset, true);
          }
          dataset.set(pp, [lDesc, assignType, rDesc, this]);
        }
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.genericity && this.genericity.length > 0) {
          this.genericity.forEach((item2) => {
            item2.parser();
          });
        }
        this.arguments.forEach((item2) => {
          if (!item2.isFunctionExpression) {
            item2.parser();
            item2.setRefBeUsed();
          }
        });
        this.callee.parser();
        this.callee.setRefBeUsed();
        this.parserArguments();
        const whenThrow = this.callee.isMemberExpression ? this.callee.property : this.callee;
        let description = this.descriptor();
        if (!description) {
          whenThrow.error(1006, this.value());
          return true;
        } else if (this.is(description) && (description.isMethodDefinition || description.isFunctionExpression)) {
          description.parser();
          if (description.module === this.module && description.isMethodDefinition) {
            const context2 = this.parentStack.getParentStack((parent) => parent.isMethodDefinition);
            if (context2 === description) {
              context2.addRecursionCallStacks(this);
            }
          } else if (this.callee.isIdentifier) {
            const desc = this.description();
            if (this.is(desc) && desc.isVariableDeclarator && desc.value() === this.callee.value()) {
              const context2 = this.parentStack.getParentStack((parent) => {
                if (parent.isMethodDefinition)
                  return true;
                return parent.isFunctionExpression && parent === description;
              });
              if (context2 === description) {
                context2.addRecursionCallStacks(this);
              }
            }
          }
        } else if (description.isAnyType || description === Namespace.globals.get("Function")) {
          return true;
        }
        if (description.isMethodDefinition || description.isFunctionExpression && !description.isDeclaratorFunction) {
          if (description.isNoop) {
            whenThrow.unnecessary(1185);
          } else {
            let fnStatement = description.isMethodDefinition ? description.expression : description;
            if (fnStatement && fnStatement.body && fnStatement.body.isBlockStatement) {
              if (fnStatement.body.body.length === 0) {
                whenThrow.unnecessary(1185);
              }
            }
          }
        }
        const context = this.getContext();
        const [declareGenerics, classGenerics] = this.getDeclareGenerics(description);
        const declareParams = this.getFunDeclareParams(description);
        const declareTypeParams = declareParams;
        const length = declareParams.length;
        const args = this.arguments;
        const _thisArg = description.thisArgumentContext;
        if (_thisArg && _thisArg.acceptType) {
          let _type = _thisArg.type();
          const ctxType = this.callee.isMemberExpression ? this.callee.object.type() : null;
          if (!ctxType) {
            whenThrow.error(1208, this.callee.value());
          }
          if (_type.isGenericType && _type.hasConstraint) {
            _type = _type.inherit.type();
          }
          if (_type && !_type.isGenericType && !_type.is(context)) {
            whenThrow.error(1208, this.callee.value());
          }
        }
        if (this.genericity) {
          const last = this.genericity[this.genericity.length - 1];
          if (declareGenerics.length < 1) {
            last.error(1004, 0, this.genericity.length);
          } else {
            const requires = declareGenerics.filter((item2) => !item2.isGenericTypeAssignmentDeclaration);
            if (requires.length > this.genericity.length) {
              if (requires.length === declareGenerics.length) {
                last.error(1004, requires.length, this.genericity.length);
              } else {
                last.error(1005, requires.length, declareGenerics.length, this.genericity.length);
              }
            }
            this.genericity.forEach((item2, index) => {
              const declareType = declareGenerics[index] && declareGenerics[index].type();
              if (declareType) {
                if (declareType.hasConstraint) {
                  const constraint = declareType.inherit.type();
                  if (!constraint.check(item2, context)) {
                    item2.error(1003, item2.type().toString(context), constraint.toString(context));
                  }
                }
              }
            });
          }
        }
        const requireParams = declareParams.filter((item2) => !(item2.question || item2.isAssignmentPattern || item2.isRestElement));
        const requireCount = requireParams.length;
        const argsLength = args.length;
        let hasRest = false;
        this.presetPredicateType(declareParams, args);
        if (length > 0) {
          const checkArguments = (index, args2, declareParams2, declareTypes, top = false) => {
            let checkResult = true;
            for (; index < args2.length; index++) {
              const argument = args2[index];
              const argumentType = argument.type();
              const declareParamType = declareTypes[index];
              const declareParamItem = declareParams2[index];
              if (!(declareParamType && declareParamItem))
                continue;
              let acceptType = declareParamType.type();
              let inferCtx = context.create(declareParamItem, acceptType);
              if (acceptType.isGenericType && acceptType.hasConstraint) {
                const constraint = acceptType.inherit.type();
                if (!constraint.check(argument, inferCtx)) {
                  argument.error(1003, acceptType.toString(inferCtx), constraint.toString(inferCtx));
                }
              }
              if (argument.isSpreadElement) {
                if (top)
                  hasRest = true;
                if (!argumentType.isAnyType) {
                  if (!(argumentType.isTupleType || argumentType.isLiteralArrayType || Namespace.globals.get("array").is(argumentType))) {
                    argument.error(1154);
                    return false;
                  } else {
                    if (declareParamItem.isRestElement) {
                      checkResult = this.checkArgumentItemType(argument, declareParamItem, acceptType, inferCtx);
                    } else {
                      return checkArguments(index, argumentType.elements, declareParams2, declareTypes);
                    }
                  }
                }
              } else {
                const isRest = acceptType && acceptType.target && acceptType.target.isTypeTupleRestDefinition;
                if (isRest || declareParamItem.isRestElement) {
                  if (top)
                    hasRest = true;
                  let restParamType = acceptType;
                  let result = true;
                  for (; index < args2.length; index++) {
                    let argument2 = args2[index];
                    const res = restParamType.elements.some((declare) => {
                      const acceptType2 = declare.type();
                      if (acceptType2.isTupleType && argument2.isArrayExpression || argument2.isObjectExpression) {
                        return this.checkArgumentItemType(argument2, declare, acceptType2, inferCtx);
                      } else {
                        return acceptType2.check(argument2, inferCtx);
                      }
                    });
                    if (!res) {
                      argument2.error(1002, argument2.type().toString(inferCtx), restParamType.toString(inferCtx));
                      result = false;
                    }
                  }
                  return result;
                } else {
                  let res = this.checkArgumentItemType(argument, declareParamItem, acceptType, inferCtx);
                  if (!res) {
                    checkResult = false;
                  }
                }
              }
            }
            return checkResult;
          };
          checkArguments(0, args, declareParams, declareTypeParams, true);
        }
        if (!hasRest) {
          if (requireCount > 0 && argsLength < requireCount || length < argsLength) {
            whenThrow.error(1e3, requireCount, argsLength);
          }
        }
      }
      value() {
        return this.callee.value();
      }
      raw() {
        return this.callee.raw();
      }
    };
    module.exports = CallExpression;
  }
});

// lib/stacks/ChainExpression.js
var require_ChainExpression = __commonJS({
  "lib/stacks/ChainExpression.js"(exports, module) {
    var Stack = require_Stack();
    var ChainExpression = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isChainExpression = true;
        this.expression = this.createTokenStack(compilation, node2.expression, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.expression.freeze();
      }
      definition() {
        return this.expression.definition();
      }
      reference() {
        return this.expression.reference();
      }
      referenceItems() {
        return this.expression.referenceItems();
      }
      description() {
        return this.expression.description();
      }
      type() {
        return this.expression.type();
      }
      getContext() {
        return this.expression.getContext();
      }
      parser() {
        return this.expression.parser();
      }
      value() {
        return this.expression.value();
      }
      raw() {
        return this.expression.raw();
      }
    };
    module.exports = ChainExpression;
  }
});

// lib/scope/ClassScope.js
var require_ClassScope = __commonJS({
  "lib/scope/ClassScope.js"(exports, module) {
    var Scope = require_Scope();
    module.exports = class ClassScope extends Scope {
      constructor(parentScope, isStatic) {
        super(parentScope);
        this.isStatic = isStatic;
        this.level = parentScope ? parentScope.level + 1 : 1;
        this.isClassScope = true;
      }
      type(name) {
        return name === "class";
      }
    };
  }
});

// lib/stacks/ClassDeclaration.js
var require_ClassDeclaration = __commonJS({
  "lib/stacks/ClassDeclaration.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var Utils = require_Utils();
    var ClassScope = require_ClassScope();
    var ClassDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        scope = scope && scope.type("class") ? scope : new ClassScope(scope);
        super(compilation, node2, scope, parentNode, parentStack);
        this.isClassDeclaration = true;
        this._metatypes = [];
        this._annotations = [];
        this._imports = [];
        this.usings = [];
        this.body = [];
        this.id = this.createTokenStack(compilation, node2.id, scope, node2, this);
        this.modifier = this.createTokenStack(compilation, node2.modifier, scope, node2, this);
        const module2 = this.module = compilation.createModule(
          this.namespace,
          this.id.value(),
          Utils.isModifierInternal(this),
          false,
          Utils.isModifierPrivate(this)
        );
        this.id.module = module2;
        this.abstract = this.createTokenStack(compilation, node2.abstract, scope, node2, this);
        this.extends = (node2.extends || []).map((item2) => {
          let _extend = this.createTokenStack(compilation, item2, scope, node2, this);
          if (item2.genericity) {
            _extend.assignGenerics = item2.genericity.map((item3) => this.createTokenStack(compilation, item3, scope, node2, this));
          }
          return _extend;
        });
        this.inherit = this.extends[0] || null;
        this.isFinal = module2.isFinal = !!node2.final;
        this.static = this.createTokenStack(compilation, node2.static, scope, node2, this);
        this.implements = (node2.implements || []).map((item2) => {
          const stack = this.createTokenStack(compilation, item2, scope, node2, this);
          if (item2.genericity) {
            stack.assignGenerics = item2.genericity.map((item3) => this.createTokenStack(compilation, item3, scope, node2, this));
          }
          return stack;
        });
        scope.parent.define(module2.id, module2);
        this.genericity = this.createTokenStack(compilation, node2.genericity, scope, node2, this);
        this.dynamic = false;
        module2.abstract = !!this.abstract;
        module2.isValid = true;
        module2.isClass = true;
        module2.dynamic = false;
        module2.static = !!this.static;
        module2.isInterface = false;
        module2.isEnum = false;
        compilation.addModuleStack(module2, this);
      }
      set metatypes(value2) {
        value2.forEach((item2) => {
          item2.additional = this;
        });
        this._metatypes = value2;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value2) {
        value2.forEach((annotation) => {
          annotation.additional = this;
          if (this.module.isClass && annotation.getLowerCaseName() === "abstract") {
            this.module.abstract = true;
          }
        });
        this._annotations = value2;
      }
      get annotations() {
        return this._annotations;
      }
      set imports(items) {
        if (Array.isArray(items)) {
          items.forEach((item2) => {
            if (item2.isImportDeclaration) {
              item2.additional = this;
            }
          });
          this._imports = items;
        }
      }
      get imports() {
        return this._imports;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.id);
        super.freeze(this.scope);
        super.freeze(this.inherit);
        super.freeze(this.abstract);
        super.freeze(this.metatypes);
        super.freeze(this.annotations);
        super.freeze(this.implements);
        super.freeze(this.imports);
        super.freeze(this.modifier);
        super.freeze(this.genericity);
        super.freeze(this.module);
        super.freeze(this.body);
        this.body.forEach((stack) => stack.freeze());
      }
      async createCompleted() {
        if (this._createCompletedFlag)
          return;
        this._createCompletedFlag = true;
        try {
          const metatypes = [];
          const annotations = [];
          const compilation = this.compilation;
          const scope = this.scope;
          const node2 = this.node;
          const self = this.module;
          await this.allSettled(this.imports, async (stack) => await stack.addImport(self, this.parentStack.scope));
          if (this.inherit) {
            let stack = this.inherit;
            let id = stack.value();
            let module2 = stack.getReferenceModuleType();
            let load = false;
            let local2 = stack.isMemberExpression ? stack.getFirstMemberStack().value() : id;
            if (!this.scope.isDefine(local2)) {
              module2 = await this.loadTypeAsync(id);
              load = true;
            }
            let push = (module3, stack2) => {
              if (!module3) {
                stack2.error(1027, id);
              } else {
                if (Utils.checkDepend(self, module3)) {
                  stack2.error(1024, id, self.getName(), module3.getName());
                } else {
                  self.extends = module3;
                  module3.used = true;
                  if (!module3.children.some((child) => Utils.isEqualModule(child, self))) {
                    module3.children.push(self);
                  }
                  this.compilation.addDependency(module3, self);
                }
              }
            };
            if (module2 || !load) {
              push(module2, stack);
            } else if (load) {
              this.compilation.hookAsync("compilation.create.done", () => {
                push(stack.getReferenceModuleType(), stack);
              });
            }
          }
          const impls = self.implements = [];
          const pushImp = (module2, stack) => {
            if (module2 && self !== module2) {
              if (!(module2.isInterface || module2.isStructTable)) {
                stack.error(1028, stack.value());
              } else {
                module2.used = true;
                impls.push(module2);
                this.compilation.addDependency(module2, self);
              }
            } else {
              stack.error(1029, stack.value());
            }
          };
          await this.allSettled(this.implements, async (stack) => {
            let id = stack.value();
            let module2 = stack.getReferenceModuleType();
            let load = false;
            let local2 = stack.isMemberExpression ? stack.getFirstMemberStack().value() : id;
            if (!this.scope.isDefine(local2)) {
              module2 = await this.loadTypeAsync(id);
              load = true;
            }
            if (module2 || !load) {
              pushImp(module2, stack);
            } else if (load) {
              this.compilation.hookAsync("compilation.create.done", () => {
                pushImp(stack.getReferenceModuleType(), stack);
              });
            }
          });
          (node2.body.body || []).forEach((item2) => {
            const stack = this.createTokenStack(compilation, item2, scope, node2, this);
            if (stack.isUseExtendStatement) {
              this.usings.push(stack);
            } else if (stack.isMetatypeDeclaration) {
              metatypes.push(stack);
            } else if (stack.isAnnotationDeclaration) {
              annotations.push(stack);
            } else {
              stack.metatypes = metatypes.splice(0, metatypes.length);
              stack.annotations = annotations.splice(0, annotations.length);
              this.body.push(stack);
            }
          });
          if (this.usings.length > 0) {
            await this.allSettled(this.usings.map((stack) => stack.createCompleted()));
          }
        } catch (e) {
          this.compilation.throwError(e);
        }
      }
      genericsCheck(typeModule, assignGenerics, atStack) {
        if (!typeModule)
          return;
        if (assignGenerics && assignGenerics.length > 0) {
          assignGenerics.forEach((item2) => {
            item2.parser();
          });
        }
        const _compilation = typeModule.compilation;
        if (_compilation && _compilation.stack) {
        }
        const [stackModule, declareGenerics = []] = typeModule.getModuleDeclareGenerics(false, false, true);
        if (stackModule) {
          if (atStack) {
            atStack.setRefBeUsed();
          }
          const requires = declareGenerics.filter((item2) => !item2.isGenericTypeAssignmentDeclaration);
          if (!assignGenerics || !assignGenerics.length) {
            if (declareGenerics.length > 0) {
              atStack.error(1030, typeModule.toString(), declareGenerics.length);
            }
          } else {
            const lastStack = assignGenerics[assignGenerics.length - 1];
            if (requires.length > assignGenerics.length || assignGenerics.length > declareGenerics.length) {
              if (requires.length === declareGenerics.length) {
                lastStack.error(1030, typeModule.toString(), requires.length);
              } else {
                lastStack.error(1031, typeModule.toString(), requires.length, declareGenerics.length);
              }
            }
            if (declareGenerics.length > 0) {
              assignGenerics.forEach((item2, index) => {
                const declareType = declareGenerics[index] && declareGenerics[index].type();
                if (declareType && declareType.hasConstraint && !declareType.check(item2)) {
                  item2.error(1003, item2.type().toString(), declareType.toString(true));
                }
              });
            }
          }
        }
      }
      implementCheck(interfaceModule) {
        if (Utils.isModule(interfaceModule) && !interfaceModule.isEntityModule()) {
          return;
        }
        const check = (left, right) => {
          if (!left)
            return;
          if (Utils.isModifierPrivate(left))
            return;
          if (Utils.isModifierPrivate(right))
            return;
          const type2 = left.isAccessor ? left.kind == "set" ? "setter" : "getter" : left.isPropertyDefinition ? "property" : "method";
          if (!right) {
            if (left.question) {
              return;
            }
            const impStack = this.implements.find((stack) => {
              const impModule = stack.type();
              if (interfaceModule === impModule) {
                return true;
              }
              if (impModule.implements.includes(interfaceModule)) {
                return true;
              }
              if (impModule.inherit === interfaceModule) {
                return true;
              }
              return false;
            });
            return (impStack || this.id).error(1032, left.value(), type2, interfaceModule.getName(), this.module.getName());
          }
          if (left.isMethodDefinition) {
            if (!right.isMethodDefinition) {
              let result2 = !!left.isMethodGetterDefinition;
              if (right.isPropertyDefinition) {
                if (left.isMethodSetterDefinition) {
                  result2 = !right.isReadonly;
                } else if (!right.isReadonly) {
                  result2 = !!left.module.getMember(left.value(), "set", true);
                }
              }
              if (!result2) {
                right.error(1034, left.value(), type2, interfaceModule.getName());
              } else {
                let lType = left.expression._returnType;
                let rType = right.declarations[0].acceptType;
                if (!lType) {
                  lType = Namespace.globals.get("void");
                }
                if (lType && rType && !Utils.checkTypeForBoth(lType.type(), rType.type(), false)) {
                  right.error(1033, right.value(), lType.type().toString({ scopeGenerics: true }));
                }
              }
            } else {
              let lType = left.expression._returnType;
              let rType = right.expression._returnType;
              if (!lType && !rType) {
                lType = Namespace.globals.get("void");
                rType = right.inferReturnType();
              }
              if (lType && rType && !Utils.checkTypeForBoth(lType.type(), rType.type(), false)) {
                right.error(1033, right.value(), lType.type().toString({ scopeGenerics: true }));
              }
            }
            const paramLen = left.params.length;
            if (paramLen && paramLen != right.params.length) {
              const requires = left.params.filter((item2) => !item2.question);
              if (requires.length > right.params.length) {
                right.error(1090, left.value(), interfaceModule.getName());
              }
            } else if (paramLen > 0) {
              const lP = left.params[paramLen - 1];
              const rP = right.params[paramLen - 1];
              if (rP) {
                const lT = !!lP.isRestElement;
                const rT = !!rP.isRestElement;
                if (lT !== rT) {
                  right.error(1090, left.value(), interfaceModule.getName());
                }
              }
            }
            const ctx = this.getContext();
            const result = left.params.every((item2, index) => {
              if (right.params[index] && !right.params[index].acceptType) {
                return true;
              }
              const rType = right.params[index] && right.params[index].type();
              if (!rType && item2.question)
                return true;
              return rType ? Utils.checkTypeForBoth(item2.type(), rType, false, ctx) : false;
            });
            if (!result) {
              right.error(1036, left.value(), type2, interfaceModule.getName());
            }
            const lGens = left.genericity ? left.genericity.elements.length : 0;
            const rGens = right.genericity ? right.genericity.elements.length : 0;
            if (rGens > 0 && lGens !== rGens) {
              right.error(1037, left.value(), type2, interfaceModule.getName());
            }
            if (lGens > 0 && rGens > 0) {
              const result2 = left.genericity.elements.every((leftGeneric, index) => {
                const rightGeneric = right.genericity.elements[index];
                if (rightGeneric) {
                  const left2 = leftGeneric.type();
                  const right2 = rightGeneric.type();
                  if (left2.hasConstraint || right2.hasConstraint) {
                    return left2.check(right2);
                  }
                  return true;
                }
                return false;
              });
              if (!result2) {
                right.error(1038, left.value(), type2, interfaceModule.getName());
              }
            }
          } else {
            if (!right.isPropertyDefinition) {
              let result = !!right.isMethodGetterDefinition;
              if (right.isMethodSetterDefinition) {
                result = !left.isReadonly;
              } else if (!left.isReadonly && right.isMethodGetterDefinition) {
                result = !!right.module.getMember(left.value(), "set", true);
              }
              if (!result) {
                right.error(1034, left.value(), type2, interfaceModule.getName());
              } else {
                const lType = left.declarations[0].acceptType;
                if (lType) {
                  const rType = right.inferReturnType();
                  if (lType && rType && !Utils.checkTypeForBoth(lType.type(), rType.type(), false)) {
                    right.error(1033, right.value(), lType.type().toString({ scopeGenerics: true }));
                  }
                }
              }
            } else {
              const lType = left.declarations[0].acceptType;
              if (lType) {
                const rType = right.declarations[0].acceptType;
                if (rType && !Utils.checkTypeForBoth(lType.type(), rType.type(), false)) {
                  right.error(1033, right.value(), lType.type().toString({ scopeGenerics: true }));
                }
              }
            }
          }
          const modifier = Utils.getModifierValue(right);
          if (modifier !== "public") {
            right.error(1039, right.value(), type2, interfaceModule.getName());
          }
        };
        if (Utils.isInterface(interfaceModule) && !interfaceModule.isStructTable && interfaceModule !== this.module) {
          const members = interfaceModule.members || {};
          for (var name in members) {
            const left = members[name];
            if (left.isAccessor) {
              check(left.get, this.module.getMember(name, "get", true));
              check(left.set, this.module.getMember(name, "set", true));
            } else {
              check(left, this.module.getMember(name, null, true));
            }
          }
          if (interfaceModule.dynamicProperties) {
            interfaceModule.dynamicProperties.forEach((value2, key) => {
              this.module.dynamic = true;
              if (!this.module.dynamicProperties.has(key)) {
                this.module.dynamicProperties.set(key, value2);
              }
            });
          }
        }
        if (Utils.isInterface(interfaceModule)) {
          interfaceModule.extends.forEach((item2) => {
            if (!item2.isStructTable) {
              this.implementCheck(item2.type());
            }
          });
        }
        (interfaceModule && interfaceModule.implements || []).forEach((item2) => {
          if (!item2.isStructTable) {
            this.implementCheck(item2.type());
          }
        });
      }
      definition(context) {
        const module2 = this.module;
        context = context || this.getContext();
        context.scopeGenerics = true;
        let location = (this.id || this).getLocation();
        if (this.compilation.JSX) {
          const program = this.compilation.stack;
          if (program && program.body[0]) {
            location = program.body[0].getLocation();
          }
        }
        return {
          kind: "class",
          comments: this.comments,
          expre: `class ${module2.toString(context)}`,
          location,
          file: this.file
        };
      }
      value() {
        return this.id.value();
      }
      type() {
        return this.module;
      }
      description() {
        return this;
      }
      parser() {
        if (super.parser() === false)
          return false;
        try {
          this.imports.forEach((stack) => {
            stack.parser();
          });
          this.usings.forEach((stack) => {
            stack.parser();
          });
          if (this.genericity) {
            this.genericity.parser();
            this.genericity.setRefBeUsed();
          }
          if (this.inherit) {
            const inheritImport = this.inherit.description();
            if (this.is(inheritImport) && (inheritImport.isImportDeclaration || inheritImport.parentStack.isImportDeclaration)) {
              this.inherit.setRefBeUsed(inheritImport);
            }
            const inherit = this.module.getInheritModule();
            if (inherit) {
              this.inherit.setRefBeUsed(inherit);
              this.genericsCheck(inherit, this.inherit.assignGenerics, this.inherit);
              if (this.inherit.assignGenerics && this.inherit.assignGenerics.length > 0) {
                this.module.setAssignGenerics(inherit.type(), this.inherit.assignGenerics);
              }
              if (inherit.isFinal) {
                this.inherit.error(1147, this.module.getName(), inherit.getName());
              }
            }
          }
          this.metatypes.forEach((stack) => {
            stack.parser();
          });
          this.annotations.forEach((stack) => {
            stack.parser();
          });
          this.implements.forEach((stack) => {
            const impImport = stack.description();
            if (impImport && impImport.isImportDeclaration) {
              stack.setRefBeUsed(impImport);
            }
            const impModule = stack.getReferenceModuleType();
            if (impModule) {
              stack.setRefBeUsed(impModule);
              this.genericsCheck(impModule, stack.assignGenerics, stack);
              if (stack.assignGenerics && stack.assignGenerics.length > 0) {
                this.module.setAssignGenerics(impModule, stack.assignGenerics);
              }
            }
          });
          this.implementCheck(this.module);
          this.module.ckeckAllDescriptors();
          this.body.forEach((stack) => {
            stack.parser();
          });
        } catch (e) {
          this.compilation.throwError(e);
        }
      }
    };
    module.exports = ClassDeclaration;
  }
});

// lib/scope/BlankScope.js
var require_BlankScope = __commonJS({
  "lib/scope/BlankScope.js"(exports, module) {
    var Scope = require_Scope();
    module.exports = class BlankScope extends Scope {
      constructor(parentScope) {
        super(parentScope);
        this.isBlankScope = true;
      }
      type(name) {
        return name === "blank";
      }
    };
  }
});

// lib/stacks/ConditionalExpression.js
var require_ConditionalExpression = __commonJS({
  "lib/stacks/ConditionalExpression.js"(exports, module) {
    var Expression = require_Expression();
    var MergeType = require_MergeType();
    var BlankScope = require_BlankScope();
    var ConditionalExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isConditionalExpression = true;
        const _scope1 = node2.consequent?.type === "BlockStatement" ? scope : new BlankScope(scope);
        const _scope2 = node2.alternate?.type === "BlockStatement" ? scope : new BlankScope(scope);
        this.test = this.createTokenStack(compilation, node2.test, scope, node2, this);
        this.consequent = this.createTokenStack(compilation, node2.consequent, _scope1, node2, this);
        this.alternate = this.createTokenStack(compilation, node2.alternate, _scope2, node2, this);
      }
      freeze() {
        super.freeze();
        this.consequent.freeze();
        this.alternate.freeze();
      }
      definition() {
        return null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return this.consequent.referenceItems().concat(this.alternate.referenceItems());
      }
      description() {
        return this;
      }
      type() {
        return this.getAttribute("ConditionalExpression.type", () => {
          const mergeType = new MergeType();
          if (!this.hasNestDescription(this.consequent)) {
            mergeType.add(this.consequent.type());
          }
          if (!this.hasNestDescription(this.alternate)) {
            mergeType.add(this.alternate.type());
          }
          return mergeType.type();
        });
      }
      // getContext(){
      //     return this.getAttribute('getContext', ()=>{
      //         const type = this.type()
      //         if(type.isInstanceofType && type.isThisType){
      //             const module = type.inherit.type()
      //             if(Utils.isModule(module)){
      //                 const moduleStack = module.getInheritContextStack(this.compilation);
      //                 if(moduleStack){
      //                     const parent = moduleStack.getContext();
      //                     return parent.createChild(this);
      //                 }
      //             }
      //         }
      //         return super.getContext()
      //     });
      // }
      parser() {
        if (super.parser() === false)
          return false;
        this.parseConditionState(this.test);
        this.test.parser();
        this.test.setRefBeUsed();
        this.consequent.parser();
        this.consequent.setRefBeUsed();
        this.alternate.parser();
        this.alternate.setRefBeUsed();
      }
    };
    module.exports = ConditionalExpression;
  }
});

// lib/stacks/ContinueStatement.js
var require_ContinueStatement = __commonJS({
  "lib/stacks/ContinueStatement.js"(exports, module) {
    var Stack = require_Stack();
    var ContinueStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isBreakStatement = true;
        this.label = this.createTokenStack(compilation, node2.label, scope, node2, this);
      }
      freeze() {
        super.freeze(this);
        this.label && this.label.freeze();
      }
      getLabelStackByName(name) {
        let labelStack = this.getParentStack((stack) => !!(stack.isLabeledStatement || stack.isFunctionExpression));
        while (labelStack && labelStack.isLabeledStatement) {
          if (labelStack.label.value() === name) {
            return labelStack;
          }
          labelStack = labelStack.labelParent;
        }
        return null;
      }
      definition(context) {
        if (this.label) {
          const labelStack = this.getLabelStackByName(this.label.value());
          if (labelStack) {
            return labelStack.definition(context);
          }
        }
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.label) {
          const labelStack = this.getLabelStackByName(this.label.value());
          if (!labelStack || !labelStack.isLabeledStatement) {
            this.label.error(1022);
          }
        }
        let parent = this.parentStack;
        while (parent) {
          if (parent.isSwitchCase || parent.isDoWhileStatement || parent.isWhileStatement || parent.isForStatement || parent.isForOfStatement || parent.isForInStatement) {
            return true;
          } else if (parent.isFunctionExpression) {
            break;
          } else {
            parent = parent.parentStack;
          }
        }
        this.error(1022);
      }
    };
    module.exports = ContinueStatement;
  }
});

// lib/stacks/DeclaratorDeclaration.js
var require_DeclaratorDeclaration = __commonJS({
  "lib/stacks/DeclaratorDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var Utils = require_Utils();
    var ClassScope = require_ClassScope();
    var JSModule = require_JSModule();
    var DeclaratorDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        scope = new ClassScope(scope);
        super(compilation, node2, scope, parentNode, parentStack);
        this._metatypes = [];
        this._annotations = [];
        this.usings = [];
        this.body = [];
        this._imports = [];
        this.isDeclaratorDeclaration = true;
        this.id = this.createTokenStack(compilation, node2.id, scope, node2, this);
        this.modifier = this.createTokenStack(compilation, node2.modifier, scope, node2, this);
        this.abstract = this.createTokenStack(compilation, node2.abstract, scope, node2, this);
        let module2 = null;
        let idName = this.id.value();
        if (this.module && JSModule.is(this.module)) {
          module2 = this.module.getType(idName);
          if (!module2) {
            module2 = compilation.createPureModule(idName);
            module2.namespace = this.namespace;
          }
        } else {
          module2 = compilation.createModule(
            this.namespace,
            idName,
            Utils.isModifierInternal(this),
            false,
            Utils.isModifierPrivate(this)
          );
        }
        this.module = module2;
        this.id.module = module2;
        this.isFinal = module2.isFinal = !!node2.final;
        this.static = this.createTokenStack(compilation, node2.static, scope, node2, this);
        this.extends = (node2.extends || []).map((item2) => {
          let _extend = this.createTokenStack(compilation, item2, scope, node2, this);
          if (item2.genericity) {
            _extend.assignGenerics = item2.genericity.map((item3) => this.createTokenStack(compilation, item3, scope, node2, this));
          }
          return _extend;
        });
        this.inherit = this.extends[0] || null;
        this.implements = (node2.implements || []).map((item2) => {
          const stack = this.createTokenStack(compilation, item2, scope, node2, this);
          if (item2.genericity) {
            stack.assignGenerics = item2.genericity.map((item3) => this.createTokenStack(compilation, item3, scope, node2, this));
          }
          return stack;
        });
        if (this.extends.length > 1) {
          this.implements.unshift(...this.extends.slice(1));
        }
        this.genericity = this.createTokenStack(compilation, node2.genericity, scope, node2, this);
        this.dynamic = false;
        module2.dynamic = false;
        module2.isValid = true;
        module2.static = !!this.static;
        module2.isEnum = false;
        switch (node2.kind) {
          case "class":
            module2.abstract = !!this.abstract;
            module2.isClass = true;
            module2.isInterface = false;
            break;
          case "interface":
            this.isInterfaceDecorator = module2.isInterfaceDecorator = !!node2.decorator;
            module2.isInterface = true;
            module2.isClass = false;
            module2.abstract = false;
            break;
          default: {
            module2.abstract = false;
          }
        }
        if (module2.isClass) {
          scope.parent.define(module2.id, module2);
        } else if (!scope.parent.isDefine(module2.id)) {
          scope.parent.define(module2.id, module2);
        }
        module2.addStack(this);
      }
      get kind() {
        return this.node.kind;
      }
      set metatypes(value2) {
        value2.some((item2) => {
          item2.additional = this;
        });
        this._metatypes = value2;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value2) {
        value2.forEach((annotation) => {
          annotation.additional = this;
          if (this.module.isClass && annotation.getLowerCaseName() === "abstract") {
            this.module.abstract = true;
          }
        });
        this._annotations = value2;
      }
      get annotations() {
        return this._annotations;
      }
      set imports(items) {
        if (Array.isArray(items)) {
          items.forEach((item2) => {
            if (item2.isImportDeclaration) {
              item2.additional = this;
            }
          });
          this._imports = items;
        }
      }
      get imports() {
        let items = this.module.getStacks();
        if (items && items.length > 1) {
          return items.map((stack) => stack._imports || []).flat();
        }
        return this._imports;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.id);
        super.freeze(this.inherit);
        super.freeze(this.implements);
        super.freeze(this.imports);
        super.freeze(this.modifier);
        super.freeze(this.genericity);
        super.freeze(this.module);
        super.freeze(this.body);
        (this.body || []).forEach((stack) => stack.freeze());
      }
      definition(context) {
        const module2 = this.module;
        const kind = module2.getModuleKind();
        context = context || this.getContext();
        context.scopeGenerics = true;
        let location = (this.id || this).getLocation();
        if (this.compilation.JSX) {
          const program = this.compilation.stack;
          if (program && program.body[0]) {
            location = program.body[0].getLocation();
          }
        }
        return {
          kind,
          comments: this.comments,
          expre: `${kind} ${module2.toString(context)}`,
          location,
          file: this.file
        };
      }
      async createCompleted() {
        const compilation = this.compilation;
        const metatypes = [];
        const annotations = [];
        const self = this.module;
        await this.allSettled(this.imports, async (stack) => {
          await stack.addImport(this.module, this.parentStack.scope);
        });
        if (this.inherit) {
          let stack = this.inherit;
          let id = stack.value();
          let module2 = stack.getReferenceType();
          let load = false;
          let local2 = stack.isMemberExpression ? stack.getFirstMemberStack().value() : id;
          if (!this.scope.isDefine(local2)) {
            module2 = await this.loadTypeAsync(id);
            load = true;
          }
          let push = (module3, stack2) => {
            if (!module3) {
              stack2.error(1027, id);
            } else {
              if (Utils.checkDepend(self, module3)) {
                stack2.error(1024, id, self.getName(), module3.getName());
              } else {
                self.extends = module3;
                module3.used = true;
                module3.children.push(self);
                this.compilation.addDependency(module3, self);
                if (this.static) {
                  Object.assign(self.methods, module3.methods);
                }
              }
            }
          };
          if (module2 || !load) {
            push(module2, stack);
          } else if (load) {
            this.compilation.hookAsync("compilation.create.done", () => {
              push(stack.getReferenceType(), stack);
            });
          }
        }
        let pushImp = (module2, stack) => {
          if (module2 && self !== module2) {
            self.implements.push(module2);
            if (!(module2.isInterface || module2.isDeclaratorModule)) {
              stack.error(1028, stack.value());
            } else {
              this.compilation.addDependency(module2, self);
            }
            if (this.static) {
              Object.assign(self.methods, module2.methods);
              Object.assign(self.methods, module2.members);
            }
          } else {
            stack.error(1029, stack.value());
          }
        };
        await this.allSettled(this.implements, async (stack) => {
          let id = stack.value();
          let module2 = stack.getReferenceType();
          let load = false;
          let local2 = stack.isMemberExpression ? stack.getFirstMemberStack().value() : id;
          if (!this.scope.isDefine(local2)) {
            module2 = await this.loadTypeAsync(id);
            load = true;
          }
          if (module2 || !load) {
            pushImp(module2, stack);
          } else if (load) {
            this.compilation.hookAsync("compilation.create.done", () => {
              pushImp(stack.getReferenceType(), stack);
            });
          }
        });
        (this.node.body || []).map((item2) => {
          const stack = this.createTokenStack(compilation, item2, this.scope, this.node, this);
          if (stack.isUseExtendStatement) {
            this.usings.push(stack);
          } else if (stack.isMetatypeDeclaration) {
            metatypes.push(stack);
          } else if (stack.isAnnotationDeclaration) {
            annotations.push(stack);
          } else {
            stack.metatypes = metatypes.splice(0, metatypes.length);
            stack.annotations = annotations.splice(0, annotations.length);
            this.body.push(stack);
          }
        });
        if (this.usings.length > 0) {
          await this.allSettled(this.usings.map((stack) => stack.createCompleted()));
        }
      }
      genericsCheck(typeModule, assignGenerics, aStack) {
        if (!typeModule)
          return;
        if (assignGenerics && assignGenerics.length > 0) {
          assignGenerics.forEach((item2) => {
            item2.parser();
          });
        }
        const [stackModule, declareGenerics = []] = typeModule.getModuleDeclareGenerics(false, false, true);
        const _compilation = typeModule.compilation;
        if (_compilation && _compilation.stack) {
        }
        if (stackModule) {
          if (aStack) {
            aStack.setRefBeUsed();
          }
          assignGenerics = assignGenerics || [];
          const requires = declareGenerics.filter((item2) => !item2.isGenericTypeAssignmentDeclaration);
          let lastStack = assignGenerics[assignGenerics.length - 1] || aStack || this.id;
          if (requires.length > assignGenerics.length || assignGenerics.length > declareGenerics.length) {
            if (requires.length === declareGenerics.length) {
              lastStack.error(1030, typeModule.toString(), requires.length);
            } else {
              lastStack.error(1031, typeModule.toString(), requires.length, declareGenerics.length);
            }
          }
          if (declareGenerics.length > 0) {
            assignGenerics.forEach((item2, index) => {
              const declareType = declareGenerics[index] && declareGenerics[index].type();
              if (declareType && declareType.hasConstraint && !declareType.check(item2)) {
                item2.error(1003, item2.type().toString(), declareType.toString());
              }
            });
          }
        }
      }
      value() {
        return this.id.value();
      }
      type() {
        return this.module;
      }
      description() {
        return this;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.imports.forEach((stack) => {
          stack.parser();
        });
        this.usings.forEach((stack) => {
          stack.parser();
        });
        if (this.genericity) {
          this.genericity.parser();
          this.genericity.setRefBeUsed();
        }
        this.metatypes.forEach((stack) => {
          stack.parser();
        });
        this.annotations.forEach((stack) => {
          stack.parser();
        });
        if (this.inherit) {
          let inherit = this.module.getInheritModule();
          if (inherit) {
            this.inherit.setRefBeUsed(inherit);
            this.genericsCheck(inherit, this.inherit.assignGenerics, this.inherit);
            if (this.inherit.assignGenerics && this.inherit.assignGenerics.length > 0) {
              this.module.setAssignGenerics(inherit.type(), this.inherit.assignGenerics);
            }
            if (inherit.isFinal) {
              this.inherit.error(1147, this.module.getName(), inherit.getName());
            }
          }
        }
        this.implements.forEach((stack) => {
          const impModule = stack.getReferenceModuleType();
          if (impModule) {
            stack.setRefBeUsed(impModule);
            this.genericsCheck(impModule, stack.assignGenerics, stack);
            if (stack.assignGenerics && stack.assignGenerics.length > 0) {
              this.module.setAssignGenerics(impModule, stack.assignGenerics);
            }
          }
        });
        this.module.ckeckAllDescriptors();
        this.body.forEach((item2) => item2.parser());
      }
    };
    module.exports = DeclaratorDeclaration;
  }
});

// lib/stacks/DeclaratorFunction.js
var require_DeclaratorFunction = __commonJS({
  "lib/stacks/DeclaratorFunction.js"(exports, module) {
    var FunctionExpression = require_FunctionExpression();
    var JSModule = require_JSModule();
    var DeclaratorFunction = class extends FunctionExpression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isDeclaratorFunction = true;
        this.key = this.createTokenStack(compilation, node2.id, scope, node2, this);
        this.modifier = this.createTokenStack(compilation, node2.modifier, scope, node2, this);
        if (!this.module) {
          this.namespace.set(this.key.value(), this);
        }
        this._annotations = [];
        scope.define(this.key.value(), this);
      }
      set imports(items) {
        if (Array.isArray(items)) {
          items.forEach((item2) => {
            if (item2.isImportDeclaration) {
              item2.additional = this;
            }
          });
          this._imports = items;
        }
      }
      get imports() {
        let items = this.namespace.descriptors.get(this.key.value());
        if (items && items.length > 1) {
          return items.map((stack) => stack._imports || []).flat();
        }
        return this._imports;
      }
      set metatypes(value2) {
        this._metatypes = value2;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value2) {
        this._annotations = value2;
        value2.forEach((annotation) => {
          annotation.additional = this;
        });
      }
      get annotations() {
        return this._annotations;
      }
      freeze() {
        super.freeze();
        this.key.freeze();
      }
      value() {
        return this.key.value();
      }
      parser() {
        if (super.parser() === false)
          return false;
        const name = this.key.value();
        if (this.namespace && !JSModule.is(this.module) && !this.namespace.checkDescriptors(name, this)) {
          this.key.error(1096, name);
        }
      }
    };
    module.exports = DeclaratorFunction;
  }
});

// lib/types/AnyType.js
var require_AnyType = __commonJS({
  "lib/types/AnyType.js"(exports, module) {
    var Type = require_Type();
    var AnyType = class extends Type {
      constructor() {
        super("any");
        this.isAnyType = true;
      }
      check() {
        return true;
      }
      definition() {
        return {
          expre: `(type) any`
        };
      }
      is() {
        return true;
      }
      toString(context, options = {}) {
        options.hasAnyType = true;
        return "any";
      }
    };
    module.exports = AnyType;
  }
});

// lib/types/VoidType.js
var require_VoidType = __commonJS({
  "lib/types/VoidType.js"(exports, module) {
    var Namespace = require_Namespace();
    var Type = require_Type();
    var VoidType = class extends Type {
      constructor() {
        super("void");
        this.isVoidType = true;
      }
      is(type2) {
        if (!type2 || type2 === this)
          return true;
        type2 = this.getWrapAssignType(type2);
        if (type2.isInstanceofType && type2.generics && type2.generics.length === 1) {
          const PromiseModule = Namespace.globals.get("Promise");
          const inheritModule = type2.inherit;
          if (PromiseModule && inheritModule && PromiseModule.is(inheritModule.type())) {
            type2 = type2.generics[0].type();
          }
        }
        return !!type2.isVoidType;
      }
      toString() {
        return "void";
      }
    };
    module.exports = VoidType;
  }
});

// lib/types/AliasType.js
var require_AliasType = __commonJS({
  "lib/types/AliasType.js"(exports, module) {
    var Utils = require_Utils();
    var Type = require_Type();
    var AliasType = class extends Type {
      constructor(inherit, target) {
        if (inherit && inherit.isAliasType) {
          inherit = inherit.inherit;
        }
        super("$AliasType", inherit);
        this.isAliasType = true;
        this.target = target;
        if (typeof target === "string") {
          this.typeName = target;
          this.fullName = target;
        } else if (target && target.isStack) {
          this.typeName = target.value();
          this.fullName = this.typeName;
          if (target.namespace && target.namespace.isNamespace) {
            this.fullName = target.namespace.getChain().concat(this.typeName).join(".");
          }
        }
      }
      get id() {
        return this.toString();
      }
      get hasGenericType() {
        return this.inherit.hasGenericType;
      }
      getInferResult(context, records) {
        const target = this.inherit.type();
        if (target) {
          return target.getInferResult(context, records);
        }
        return null;
      }
      definition(ctx) {
        if (Utils.isGlobalShortenType(this)) {
          return null;
        }
        if (this.target && this.target.isStack) {
          return this.target.definition(ctx);
        }
        return super.definition();
      }
      clone(inference) {
        if (inference) {
          return new AliasType(this.inherit.clone(inference), this.target);
        }
        return this;
      }
      check(stack, context = {}, options = {}) {
        const type2 = stack && stack.type();
        if (!type2)
          return false;
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        } else if (type2.isIntersectionType) {
          return [type2.left, type2.right].some((item2) => this.is(item2.type(), context, options));
        } else if (type2.isEnumType) {
          return this.is(type2.inherit.type(), context, options);
        }
        if (!this.isNeedCheckType(type2))
          return true;
        return this.inherit.type().check(stack, context, options);
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        } else if (type2.isIntersectionType) {
          return [type2.left, type2.right].some((item2) => this.is(item2.type(), context, options));
        } else if (type2.isEnumType) {
          return this.is(type2.inherit.type(), context, options);
        }
        if (this.toString() === "object") {
          return !Utils.isScalar(type2) && this.inherit.type().is(type2, context, options);
        }
        return this.inherit.type().is(type2, context, options);
      }
      toString(context, options = {}) {
        let key = this.typeName || this.target.value();
        if (options.inbuild && this.fullName) {
          key = this.fullName;
        }
        if (options.depth) {
          return key;
        }
        if (!options.onlyTypeName && this.target && this.target.genericity && this.target.genericity.isGenericDeclaration) {
          const declareGgenerics = this.target.genericity;
          if (declareGgenerics && declareGgenerics.elements.length > 0) {
            const types = declareGgenerics.elements.map((item2) => {
              let decltype = item2.type();
              let _options = Object.create(options);
              if (options.fetchDeclareGenericsDefaultValue) {
                if (decltype.assignType) {
                  decltype = decltype.assignType.type();
                } else {
                  return "any";
                }
              }
              return decltype.toString({}, _options);
            });
            return `${key}<${types.join(", ")}>`;
          }
        }
        return key;
      }
    };
    module.exports = AliasType;
  }
});

// lib/types/NullableType.js
var require_NullableType = __commonJS({
  "lib/types/NullableType.js"(exports, module) {
    var Namespace = require_Namespace();
    var Type = require_Type();
    var NullableType = class extends Type {
      constructor() {
        super("null");
        this.isNullableType = true;
      }
      is(type2, context, options) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        if (type2.isInstanceofType && type2.generics && type2.generics.length === 1) {
          const PromiseModule = Namespace.globals.get("Promise");
          const inheritModule = type2.inherit;
          if (PromiseModule && inheritModule && PromiseModule.is(inheritModule.type(), context, options)) {
            return this.is(type2.generics[0].type(), context, options);
          }
        }
        return !!type2.isNullableType;
      }
      toString() {
        return "null";
      }
    };
    module.exports = NullableType;
  }
});

// lib/types/UndefinedType.js
var require_UndefinedType = __commonJS({
  "lib/types/UndefinedType.js"(exports, module) {
    var Type = require_Type();
    var UndefinedType = class extends Type {
      constructor() {
        super("undefined");
        this.isUndefinedType = true;
      }
      definition() {
        return null;
      }
      is(type2, context = {}, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        return type2 === this;
      }
      toString() {
        return "undefined";
      }
    };
    module.exports = UndefinedType;
  }
});

// lib/types/NeverType.js
var require_NeverType = __commonJS({
  "lib/types/NeverType.js"(exports, module) {
    var Type = require_Type();
    var NeverType = class extends Type {
      constructor() {
        super("never");
        this.isNeverType = true;
      }
      definition() {
        return {
          expre: `(type) never`
        };
      }
      is(type2, context = {}, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        return type2 === this;
      }
      toString() {
        return "never";
      }
    };
    module.exports = NeverType;
  }
});

// lib/types/UnknownType.js
var require_UnknownType = __commonJS({
  "lib/types/UnknownType.js"(exports, module) {
    var Type = require_Type();
    var UnknownType = class extends Type {
      constructor() {
        super("unknown");
        this.isAnyType = true;
        this.isUnknownType = true;
      }
      check() {
        return true;
      }
      is() {
        return true;
      }
      toString() {
        return "unknown";
      }
    };
    module.exports = UnknownType;
  }
});

// lib/stacks/DeclaratorTypeAlias.js
var require_DeclaratorTypeAlias = __commonJS({
  "lib/stacks/DeclaratorTypeAlias.js"(exports, module) {
    var Stack = require_Stack();
    var AnyType = require_AnyType();
    var VoidType = require_VoidType();
    var AliasType = require_AliasType();
    var NullableType = require_NullableType();
    var UndefinedType = require_UndefinedType();
    var NeverType = require_NeverType();
    var BlockScope = require_BlockScope();
    var Utils = require_Utils();
    var UnknownType = require_UnknownType();
    var DeclaratorTypeAlias = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        scope = new BlockScope(scope);
        super(compilation, node2, scope, parentNode, parentStack);
        this.isDeclaratorTypeAlias = true;
        this.left = this.createTokenStack(compilation, node2.left, scope, node2, this);
        this.right = this.createTokenStack(compilation, node2.right, scope, node2, this);
        this.genericity = this.createTokenStack(compilation, node2.genericity, scope, node2, this);
        this.modifier = this.createTokenStack(compilation, node2.modifier, scope, node2, this);
        this.kind = node2.kind;
        if (node2.kind === "declare") {
          if (!this.module) {
            this.namespace.set(this.left.value(), this);
          }
        }
        scope.parent.define(this.left.value(), this);
      }
      set imports(items) {
        if (Array.isArray(items)) {
          items.forEach((item2) => {
            if (item2.isImportDeclaration) {
              item2.additional = this;
            }
          });
          this._imports = items;
        }
      }
      get imports() {
        let items = this.namespace.descriptors.get(this.left.value());
        if (items && items.length > 1) {
          return items.map((stack) => stack._imports || []).flat();
        }
        return this._imports;
      }
      freeze() {
        super.freeze(this);
        this.left.freeze();
        this.right.freeze();
      }
      definition(ctx) {
        let complete = ctx ? false : true;
        if (ctx && ctx.stack) {
          if (ctx.stack === this.left) {
            complete = true;
          }
        }
        const declareGenerics = this.genericity ? this.genericity.elements : [];
        const generics = declareGenerics.length > 0 ? "<" + declareGenerics.map((decl2) => decl2.type().toString(ctx, { complete })).join(", ") + ">" : "";
        if (Utils.isGlobalShortenType(this.type())) {
          return {
            comments: this.comments,
            kind: "type",
            expre: `type ${this.left.value()}${generics}`
          };
        }
        return {
          comments: this.comments,
          kind: "type",
          expre: `type ${this.left.value()}${generics}`,
          location: this.left.getLocation(),
          file: this.file
        };
      }
      set metatypes(value2) {
        this._metatypes = value2;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value2) {
        this._annotations = value2;
      }
      get annotations() {
        return this._annotations;
      }
      get id() {
        return this.left.value();
      }
      get key() {
        return this.left;
      }
      reference() {
        return this.right.reference();
      }
      referenceItems() {
        return this.right.referenceItems();
      }
      description() {
        return this;
      }
      type() {
        return this.getAttribute("type", () => {
          const value2 = this.right.value();
          switch (value2) {
            case "any":
              return this._type = new AnyType();
            case "unknown":
              return this._type = new UnknownType();
            case "nullable":
              return this._type = new NullableType();
            case "void":
              return this._type = new VoidType();
            case "never":
              return this._type = new NeverType();
            case "undefined":
              return this._type = new UndefinedType();
          }
          return new AliasType(this.right.type(), this);
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.genericity) {
          this.genericity.parser();
        }
        this.right.parser();
      }
      error(code, ...args) {
        this.left.error(code, ...args);
      }
      warn(code, ...args) {
        this.left.warn(code, ...args);
      }
      value() {
        return this.left.value();
      }
      raw() {
        return this.left.raw();
      }
    };
    module.exports = DeclaratorTypeAlias;
  }
});

// lib/stacks/DeclaratorVariable.js
var require_DeclaratorVariable = __commonJS({
  "lib/stacks/DeclaratorVariable.js"(exports, module) {
    var JSModule = require_JSModule();
    var Stack = require_Stack();
    var DeclaratorVariable = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isDeclaratorVariable = true;
        this.modifier = this.createTokenStack(compilation, node2.modifier, scope, node2, this);
        this.declarations = node2.expression.declarations.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
        if (!this.module) {
          this.declarations.forEach((item2) => {
            this.namespace.set(item2.id.value(), this);
          });
        }
        this._annotations = [];
        scope.define(this.value(), this);
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.declarations.forEach((item2) => {
          item2.parser();
          if (this.namespace && !JSModule.is(this.module) && !this.namespace.checkDescriptors(item2.id.value(), this)) {
            item2.id.error(1097, item2.id.value());
          }
        });
      }
      set imports(items) {
        if (Array.isArray(items)) {
          items.forEach((item2) => {
            if (item2.isImportDeclaration) {
              item2.additional = this;
            }
          });
          this._imports = items;
        }
      }
      get imports() {
        if (!this.module) {
          let key = this.declarations[0].id.value();
          let items = this.namespace.descriptors.get(key);
          if (items && items.length > 1) {
            return items.map((stack) => stack._imports || []).flat();
          }
        }
        return this._imports;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.declarations);
        this.declarations.forEach((stack) => stack.freeze());
      }
      definition(context) {
        const kind = this.declarations[0].kind || "var";
        const type2 = this.declarations[0].type().toString(context);
        const id = this.declarations[0].id;
        const token = id.value();
        return {
          comments: this.comments,
          kind,
          expre: `${kind} ${token}:${type2}`,
          location: id.getLocation(),
          file: id.compilation.file
        };
      }
      set metatypes(value2) {
        this._metatypes = value2;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value2) {
        this._annotations = value2;
        value2.forEach((annotation) => {
          annotation.additional = this;
        });
      }
      get annotations() {
        return this._annotations;
      }
      get kind() {
        return this.declarations[0].kind;
      }
      get init() {
        return this.declarations[0].init;
      }
      get key() {
        return this.declarations[0].id;
      }
      get id() {
        return this.declarations[0].value();
      }
      get acceptType() {
        return this.declarations[0].acceptType;
      }
      get assignItems() {
        return this.declarations[0].assignItems;
      }
      reference() {
        return this.declarations[0].reference();
      }
      referenceItems() {
        return this.declarations[0].referenceItems();
      }
      description() {
        return this;
      }
      type() {
        return this.getAttribute("type", () => {
          return this.declarations[0].type();
        });
      }
      error(code, ...args) {
        this.declarations[0].error(code, ...args);
      }
      warn(code, ...args) {
        this.declarations[0].warn(code, ...args);
      }
      value() {
        return this.declarations[0].value();
      }
      raw() {
        return this.declarations[0].raw();
      }
    };
    module.exports = DeclaratorVariable;
  }
});

// lib/stacks/DoWhileStatement.js
var require_DoWhileStatement = __commonJS({
  "lib/stacks/DoWhileStatement.js"(exports, module) {
    var Stack = require_Stack();
    var DoWhileStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isDoWhileStatement = true;
        this.condition = this.createTokenStack(compilation, node2.test, scope, node2, this);
        this.body = this.createTokenStack(compilation, node2.body, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.condition.freeze();
        this.body.freeze();
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (!this.condition) {
          this.error(1041);
        } else {
          this.condition.parser();
          this.condition.setRefBeUsed();
          this.body.parser();
          const desc = this.condition.description();
          if (desc.isLiteral) {
            const has = this.body.body.some((item2) => item2.isReturnStatement || item2.isBreakStatement);
            if (!has) {
              this.condition.warn(1042);
            }
          }
        }
      }
    };
    module.exports = DoWhileStatement;
  }
});

// lib/stacks/EmptyStatement.js
var require_EmptyStatement = __commonJS({
  "lib/stacks/EmptyStatement.js"(exports, module) {
    var Stack = require_Stack();
    var EmptyStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isEmptyStatement = true;
      }
    };
    module.exports = EmptyStatement;
  }
});

// lib/types/EnumType.js
var require_EnumType = __commonJS({
  "lib/types/EnumType.js"(exports, module) {
    var Type = require_Type();
    var EnumType = class extends Type {
      constructor(inherit, target, owner = null) {
        super("$EnumType", inherit);
        this.target = target;
        this.isEnumType = true;
        this.owner = owner;
        this.acceptProperties = [];
      }
      accept(property) {
        this.acceptProperties.push(property);
      }
      attribute(property) {
        if (this.target && this.target.isEnumDeclaration) {
          return this.target.attribute(property);
        }
        return null;
      }
      get attributes() {
        if (this.target && this.target.isEnumDeclaration) {
          return this.target.attributes;
        }
        return null;
      }
      dynamicAttribute(propertyType, context = null, property = null) {
        if (property && this.target && this.target.isEnumDeclaration) {
          const type2 = typeof property;
          if (type2 === "number" || type2 === "string") {
            return this.target.properties.find((attr) => attr.init.value() === property);
          }
        }
        return null;
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        if (!type2.isEnumType) {
          if (type2.isLiteralType && this.target) {
            if (this.target.isEnumProperty) {
              return type2.value === this.target.init.value();
            } else if (this.target.isEnumDeclaration) {
              return this.target.properties.some((attr) => attr.init.value() === type2.value);
            }
          }
          return false;
        }
        if (type2.owner === this)
          return true;
        return type2.owner === this.owner;
      }
      toString(context, options = {}) {
        if (this.owner) {
          if (this.owner.isEnumType) {
            return `${this.owner.target.key.value()}`;
          } else {
            return `${this.owner.id}.${this.target.value()}`;
          }
        }
        let properties = [];
        const inherit = this.inherit;
        if (inherit && inherit.isModule && inherit.isEnum) {
          properties = Object.keys(inherit.methods);
        } else {
          properties = this.target.properties.map((item2) => item2.value());
        }
        return `enum {${properties.join(",")}}`;
      }
    };
    module.exports = EnumType;
  }
});

// lib/stacks/EnumDeclaration.js
var require_EnumDeclaration = __commonJS({
  "lib/stacks/EnumDeclaration.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var Utils = require_Utils();
    var EnumType = require_EnumType();
    var EnumDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isEnumDeclaration = true;
        this.isDeclarator = true;
        this.key = this.createTokenStack(compilation, node2.key, scope, node2, this);
        this.increment = 0;
        this.mapProperties = /* @__PURE__ */ new Map();
        this.imports = [];
        this.body = [];
        this.properties = [];
        this.implements = [];
        this._metatypes = [];
        this._annotations = [];
        this.isExpressionDeclare = !(parentStack.isPackageDeclaration || parentStack.isProgram);
        if (!this.isExpressionDeclare) {
          this.modifier = this.createTokenStack(compilation, node2.modifier, scope, node2);
          this.extends = (node2.extends || []).map((item2) => {
            let _extend = this.createTokenStack(compilation, item2, scope, node2, this);
            if (item2.genericity) {
              _extend.assignGenerics = item2.genericity.map((item3) => this.createTokenStack(compilation, item3, scope, node2, this));
            }
            return _extend;
          });
          this.inherit = this.extends[0] || null;
          this.implements = (node2.implements || []).map((item2) => {
            const stack = this.createTokenStack(compilation, item2, scope, node2, this);
            if (item2.genericity) {
              stack.assignGenerics = item2.genericity.map((item3) => this.createTokenStack(compilation, item3, scope, node2, this));
            }
            return stack;
          });
          if (this.extends.length > 1) {
            this.implements.unshift(...this.extends.slice(1));
          }
          const module2 = this.module = compilation.createModule(this.namespace, this.key.value());
          this.key.module = module2;
          scope.define(module2.id, module2);
          module2.static = false;
          module2.abstract = false;
          module2.isFinal = false;
          module2.isClass = false;
          module2.isInterface = false;
          module2.isEnum = true;
          module2.increment = this.increment;
          compilation.addModuleStack(module2, this);
        } else {
          let lastStack = null;
          this.properties = node2.properties.map((item2, index) => {
            if (!item2.init && lastStack) {
              this.increment = Utils.incrementCharacter(lastStack.init.value());
            }
            const stack = this.createTokenStack(compilation, item2, scope, this.node, this);
            if (!stack.key.isIdentifier) {
              stack.error(1043, stack.raw());
            }
            if (this.mapProperties.has(stack.value())) {
              stack.error(1045, stack.raw());
            }
            this.mapProperties.set(stack.value(), stack);
            lastStack = stack;
            return stack;
          });
          scope.define(this.value(), this);
        }
      }
      get isExpression() {
        return !(this.parentStack.isPackageDeclaration || this.parentStack.isProgram);
      }
      set metatypes(value2) {
        value2.some((item2) => {
          item2.additional = this;
        });
        this._metatypes = value2;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value2) {
        value2.forEach((annotation) => {
          annotation.additional = this;
        });
        this._annotations = value2;
        this.dynamic = value2.some((annotation) => {
          return annotation.name.toLowerCase() === "dynamic";
        });
        this.module.isFinal = value2.some((annotation) => {
          return annotation.name.toLowerCase() === "final";
        });
      }
      get annotations() {
        return this._annotations;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.properties);
        super.freeze(this.mapProperties);
        if (this.parentStack.isPackageDeclaration) {
          super.freeze(this.id);
          super.freeze(this.module);
          (this.properties || []).forEach((stack) => stack.freeze());
        }
      }
      async createCompleted() {
        if (this.isExpressionDeclare) {
          return;
        }
        try {
          const compilation = this.compilation;
          const self = this.module;
          const Enumeration = Namespace.globals.get("Enumeration");
          await this.allSettled(this.imports, async (stack) => await stack.addImport(self, this.parentStack.scope));
          if (this.inherit) {
            let stack = this.inherit;
            let id = stack.value();
            let module2 = stack.getReferenceModuleType();
            let load = false;
            let local2 = stack.isMemberExpression ? stack.getFirstMemberStack().value() : id;
            if (!this.scope.isDefine(local2)) {
              module2 = await this.loadTypeAsync(id);
              load = true;
            }
            let push = (module3, stack2) => {
              if (!module3) {
                stack2.error(1027, id);
              } else {
                if (Utils.checkDepend(self, module3)) {
                  stack2.error(1024, id, self.getName(), module3.getName());
                } else if (Enumeration.is(module3)) {
                  module3.getStacks().forEach((def) => def.addUseRef(stack2));
                  self.extends = module3;
                  module3.used = true;
                  module3.children.push(self);
                  this.compilation.addDependency(module3, self);
                  this.increment = module3.increment;
                } else {
                  stack2.error(1203);
                }
              }
            };
            if (module2 || !load) {
              push(module2, stack);
            } else if (load) {
              this.compilation.hookAsync("compilation.create.done", () => {
                push(stack.getReferenceModuleType(), stack);
              });
            }
          } else {
            self.extends = Enumeration;
          }
          const impls = self.implements = [];
          const pushImp = (module2, stack) => {
            if (module2 && self !== module2) {
              if (!module2.isInterface) {
                if (stack)
                  stack.error(1028, stack.value());
              } else {
                module2.used = true;
                impls.push(module2);
                this.compilation.addDependency(module2, self);
              }
            } else {
              if (stack)
                stack.error(1029, stack.value());
            }
          };
          await this.allSettled(this.implements, async (stack) => {
            let id = stack.value();
            let module2 = stack.getReferenceModuleType();
            let load = false;
            let local2 = stack.isMemberExpression ? stack.getFirstMemberStack().value() : id;
            if (!this.scope.isDefine(local2)) {
              module2 = await this.loadTypeAsync(id);
              load = true;
            }
            if (module2 || !load) {
              pushImp(module2, stack);
            } else if (load) {
              this.compilation.hookAsync("compilation.create.done", () => {
                pushImp(stack.getReferenceModuleType(), stack);
              });
            }
          });
          let lastStack = null;
          this.node.properties.forEach((item2, index) => {
            if (!item2.init && lastStack) {
              if (lastStack.init && lastStack.init.isLiteral) {
                this.increment = Utils.incrementCharacter(lastStack.init.value());
              }
            }
            const stack = this.createTokenStack(compilation, item2, this.scope, this.node, this);
            if (!stack.key.isIdentifier) {
              stack.error(1043, stack.raw());
            }
            if (this.mapProperties.has(stack.value())) {
              stack.error(1045, stack.raw());
            }
            this.mapProperties.set(stack.value(), stack);
            self.addMember(stack.value(), stack, true);
            this.properties.push(stack);
            lastStack = stack;
            return stack;
          });
          self.increment = this.increment;
          const metatypes = [];
          const annotations = [];
          (this.node.body || []).forEach((item2) => {
            const stack = this.createTokenStack(compilation, item2, this.scope, this.node, this);
            if (!stack)
              return null;
            if (stack.isUseExtendStatement) {
            } else if (stack.isMetatypeDeclaration) {
              metatypes.push(stack);
            } else if (stack.isAnnotationDeclaration) {
              annotations.push(stack);
            } else {
              stack.metatypes = metatypes.splice(0, metatypes.length);
              stack.annotations = annotations.splice(0, annotations.length);
              this.body.push(stack);
            }
          });
        } catch (e) {
          this.compilation.throwError(e);
        }
      }
      assignment(value2, stack = null) {
        (stack || this).error(1015, this.raw());
      }
      definition() {
        const expre = `enum ${this.value()}`;
        return {
          kind: "enum",
          comments: this.comments,
          expre,
          location: this.key.getLocation(),
          file: this.file
        };
      }
      get attributes() {
        return this.mapProperties;
      }
      attribute(name) {
        return this.mapProperties.get(name) || null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      description() {
        return this;
      }
      type() {
        if (this.module && this.module.isEnum) {
          return this.module;
        }
        return this.getAttribute("type", () => {
          return new EnumType(Namespace.globals.get("object"), this);
        });
      }
      genericsCheck(typeModule, assignGenerics, atStack) {
        if (!typeModule)
          return;
        if (assignGenerics && assignGenerics.length > 0) {
          assignGenerics.forEach((item2) => {
            item2.parser();
          });
        }
        const [stackModule, declareGenerics = []] = typeModule.getModuleDeclareGenerics(false, false, true);
        if (stackModule) {
          if (atStack) {
            atStack.setRefBeUsed();
          }
          const requires = declareGenerics.filter((item2) => !item2.isGenericTypeAssignmentDeclaration);
          if (!assignGenerics || !assignGenerics.length) {
            if (declareGenerics.length > 0) {
              atStack.error(1030, typeModule.toString(), declareGenerics.length);
            }
          } else {
            const lastStack = assignGenerics[assignGenerics.length - 1];
            if (requires.length > assignGenerics.length || assignGenerics.length > declareGenerics.length) {
              if (requires.length === declareGenerics.length) {
                lastStack.error(1030, typeModule.toString(), requires.length);
              } else {
                lastStack.error(1031, typeModule.toString(), requires.length, declareGenerics.length);
              }
            }
            if (declareGenerics.length > 0) {
              assignGenerics.forEach((item2, index) => {
                const declareType = declareGenerics[index] && declareGenerics[index].type();
                if (declareType && declareType.hasConstraint && !declareType.check(item2)) {
                  item2.error(1003, item2.type().toString(), declareType.toString(true));
                }
              });
            }
          }
        }
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.properties.forEach((stack) => {
          stack.parser();
        });
        if (this.isExpressionDeclare) {
          if (this.inherit) {
            this.inherit.error(1202);
          }
          if (this.implements.length > 0) {
            this.implements.forEach((stack) => stack.error(1202));
          }
          if (this.body.length > 0) {
            this.body.forEach((stack) => stack.error(1201));
          }
        } else {
          this.imports.forEach((stack) => {
            stack.parser();
          });
          this.metatypes.forEach((stack) => {
            stack.parser();
          });
          this.annotations.forEach((stack) => {
            stack.parser();
          });
          if (this.inherit) {
            const inherit = this.module.getInheritModule();
            if (inherit) {
              this.inherit.setRefBeUsed(inherit);
              this.genericsCheck(inherit, this.inherit.assignGenerics, this.inherit);
              if (this.inherit.assignGenerics && this.inherit.assignGenerics.length > 0) {
                this.module.setAssignGenerics(inherit.type(), this.inherit.assignGenerics);
              }
              if (inherit.isFinal) {
                this.inherit.error(1147, this.module.getName(), inherit.getName());
              }
            }
          }
          this.implements.forEach((stack) => {
            const impModule = stack.getReferenceModuleType();
            if (impModule) {
              stack.setRefBeUsed(impModule);
              this.genericsCheck(impModule, stack.assignGenerics, stack);
              if (stack.assignGenerics && stack.assignGenerics.length > 0) {
                this.module.setAssignGenerics(impModule, stack.assignGenerics);
              }
            }
          });
          this.body.forEach((stack) => stack.parser());
        }
      }
      get id() {
        return this.key;
      }
      value() {
        return this.key.value();
      }
    };
    module.exports = EnumDeclaration;
  }
});

// lib/stacks/EnumProperty.js
var require_EnumProperty = __commonJS({
  "lib/stacks/EnumProperty.js"(exports, module) {
    var Stack = require_Stack();
    var EnumType = require_EnumType();
    var EnumProperty = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isEnumProperty = true;
        this.key = this.createTokenStack(compilation, node2.key, scope, node2, this);
        let init = node2.init;
        this.hasInit = !!init;
        if (!init) {
          init = Object.assign({}, node2);
          init.type = "Literal";
          init.value = parentStack.increment;
          if (typeof init.value === "number") {
            init.raw = `${init.value}`;
          } else {
            init.raw = `"${init.value}"`;
          }
        }
        this.init = this.createTokenStack(compilation, init, scope, node2, this);
        this.callableStatic = true;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.init);
        super.freeze(this.key);
      }
      definition() {
        const expre = `(enum property) ${this.parentStack.value()}.${this.value()} = ${this.init.raw()}`;
        return {
          kind: "enum",
          comments: this.comments,
          expre,
          location: this.getLocation(),
          file: this.compilation.file
        };
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      description() {
        return this;
      }
      type() {
        return this.getAttribute("type", () => {
          return new EnumType(this.init.type(), this, this.parentStack.type());
        });
      }
      raw() {
        return this.key.raw();
      }
      value() {
        return this.key.value();
      }
    };
    module.exports = EnumProperty;
  }
});

// lib/stacks/ExportAllDeclaration.js
var require_ExportAllDeclaration = __commonJS({
  "lib/stacks/ExportAllDeclaration.js"(exports, module) {
    var AutoImporter = require_AutoImporter();
    var JSModule = require_JSModule();
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var LiteralObjectType = require_LiteralObjectType();
    var ExportAllDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isExportAllDeclaration = true;
        this.source = this.createTokenStack(compilation, node2.source, scope, node2, this);
        this.exported = this.createTokenStack(compilation, node2.exported, scope, node2, this);
        if (parentStack && !(parentStack.isProgram || parentStack.isPackageDeclaration || parentStack.isModuleDeclaration)) {
          this.error(1159);
        }
        let _exports = null;
        if (parentStack.isModuleDeclaration && parentStack.module) {
          _exports = parentStack.module.exports;
        } else if (this.compilation.isDescriptorDocument()) {
          _exports = this.namespace.exports;
        }
        if (_exports) {
          const key = this.exported ? this.exported.value() : this.source ? this.source.value() : "*";
          if (_exports.has(key)) {
            (this.exported || this).error(1195, key, this.namespace.toString() || "global");
          } else {
            _exports.set(key, this);
          }
        }
      }
      definition(ctx) {
        if (this.source) {
          let file = this.getResolveFile();
          let source = file || this.source.value();
          let compi = this.getResolveCompilation();
          let location = compi ? compi.stack.getLocation() : null;
          let selection = this.source.getLocation();
          const def = {
            text: `(import) "${source}"`,
            location,
            selection,
            file
          };
          if (ctx && ctx.hoverStack === this.source) {
            let jsModule = this.getResolveJSModule();
            if (jsModule) {
              return jsModule.definition(ctx);
            }
          } else if (ctx && this.exported === ctx.hoverStack) {
            def.selection = this.exported.getLocation();
            def.text = `(exported) ${this.exported.value()}`;
            let jsModule = this.getResolveJSModule();
            if (jsModule) {
              return jsModule.definition(ctx);
            }
          }
          return def;
        }
      }
      hover(ctx) {
        if (this.source) {
          let file = this.getResolveFile();
          let source = file || this.source.value();
          const def = {
            text: `(import) "${source}"`,
            selection: this.source.getLocation()
          };
          if (ctx && ctx.hoverStack === this.source) {
            return def;
          } else if (ctx && this.exported === ctx.hoverStack) {
            def.text = `(exported) ${this.exported.value()}`;
            def.selection = this.exported.getLocation();
            let jsModule = this.getResolveJSModule();
            if (jsModule) {
              return jsModule.hover(ctx);
            }
          }
          return def;
        }
      }
      type() {
        return this.getAttribute("type", () => {
          return new LiteralObjectType(Namespace.globals.get("object"), null, this.getAllDescriptors());
        });
      }
      getResolveFile() {
        return this.getAttribute("getResolveFile", () => {
          if (this.source && this.source.isLiteral) {
            const source = this.source.value();
            let resolve = this.compiler.resolveDescriptorFile(source, this.compilation.file);
            if (!resolve) {
              resolve = this.compiler.resolveManager.resolveFile(source, this.compilation.file);
              if (resolve && resolve === this.file) {
                resolve = null;
              }
            }
            resolve = resolve || source;
            if (!resolve && !JSModule.get(source)) {
              this.source.error(1122, source);
            }
            return resolve;
          }
          return null;
        });
      }
      getResolveCompilation() {
        return this.getAttributeAlways("resolveCompilation");
      }
      getResolveJSModule(resolvedCompilation = null) {
        return this.getAttributeAlways("getResolveJSModule", () => {
          if (this.source && this.source.isLiteral) {
            let source = this.source.value();
            let resolve = this.getResolveFile();
            let module2 = JSModule.getModule(source, resolve);
            if (module2) {
              return module2;
            }
            let raw = source;
            if (resolve && resolve !== source) {
              if (source.includes("/")) {
                source = source.slice(source.lastIndexOf("/") + 1);
              }
            }
            const describeSuffix = this.compiler.options.describeSuffix;
            if (describeSuffix && source.endsWith(describeSuffix)) {
              source = source.substring(0, source.length - describeSuffix.length);
            }
            if (raw !== source) {
              module2 = JSModule.getModule(source, resolve);
            }
            if (!module2 && resolvedCompilation) {
              module2 = JSModule.getByFile(resolvedCompilation.file);
            }
            return module2;
          }
          return null;
        });
      }
      async getResolveCompilationAsync() {
        if (!this.source)
          return null;
        if (this.hasAttributeAlways("resolveCompilation")) {
          return this.getAttributeAlways("resolveCompilation");
        }
        let source = this.source.value();
        if (this.compiler.manifester.hasResource(source)) {
          await this.compilation.loadManifest(source, null, true);
        }
        let hasResolve = this.compiler.checkFileExt(this.getResolveFile());
        let compilation = null;
        if (hasResolve) {
          compilation = await this.compilation.createChildCompilation(this.getResolveFile(), this.compilation.file);
          if (compilation === this.compilation) {
            compilation = null;
          }
        }
        const jsModule = this.getResolveJSModule(compilation);
        if (jsModule) {
          this.isResolveJsModule = true;
          if (!compilation) {
            compilation = jsModule.compilation;
          }
        } else if (compilation) {
          compilation.import = "importSpecifier";
        }
        if (hasResolve && !compilation) {
          this.source.error(1132, source);
        }
        if (compilation && !this.compilation.isDescriptorDocument()) {
          compilation.once("onRemoved", () => {
            this.removeAttributeAlways("resolveCompilation");
            this.removeAttributeAlways("getResolveJSModule");
            this.isResolveJsModule = false;
            this.compiler.printLogInfo(`onRemoved: ${this.toString()}: getResolveCompilationAsync: ${compilation.file}`, "Stack");
          });
        }
        this.setAttributeAlways("resolveCompilation", compilation);
        return compilation;
      }
      async createCompleted() {
        const compilation = await this.getResolveCompilationAsync();
        if (compilation) {
          await compilation.createCompleted();
          if (this.parentStack.isPackageDeclaration) {
            const jsModule = this.getResolveJSModule();
            if (jsModule) {
              const isDefault = (owner, desc) => {
                if (owner) {
                  if (owner.id === desc.value()) {
                    return true;
                  }
                  const assignment = owner.exports.get("*");
                  if (assignment && assignment.isExportAssignmentDeclaration && assignment.expression.isIdentifier) {
                    if (assignment.expression.value() === desc.value()) {
                      return true;
                    }
                  }
                }
                return false;
              };
              const addDesc = (desc, key, isChild = false) => {
                const owner = !isChild && desc.parentStack && desc.parentStack.isModuleDeclaration && desc.parentStack.parentStack.isProgram ? desc.parentStack.module : null;
                if (desc.isClassDeclaration || desc.isDeclaratorDeclaration || desc.isInterfaceDeclaration || desc.isEnumDeclaration || desc.isDeclaratorTypeAlias || desc.isStructTableDeclaration) {
                  if (isDefault(owner, desc)) {
                    return;
                  }
                  this.namespace.addDescriptor(key, desc, true);
                } else if (desc.isNamespaceDeclaration) {
                  if (desc.module) {
                    const ns = owner && desc.module.id === owner.id ? this.namespace : Namespace.create(this.namespace.getChain().concat(desc.module.namespace.getChain()).join("."));
                    desc.module.descriptors.forEach((items, key2) => {
                      items.forEach((item2) => {
                        if (this.isModuleDefinitionStack(item2) || item2.isDeclaratorTypeAlias) {
                          ns.addDescriptor(key2, item2, true);
                        }
                      });
                    });
                  }
                } else {
                  if (desc.isDeclaratorVariable || desc.isDeclaratorFunction) {
                    if (isDefault(owner, desc)) {
                      return;
                    }
                    if (JSModule.is(desc.module)) {
                      const items = desc.module.descriptors.get(key);
                      if (items) {
                        items.forEach((value2) => {
                          if (value2.isNamespaceDeclaration) {
                            addDesc(value2, key, true);
                          } else {
                            this.namespace.addDescriptor(key, value2, true);
                          }
                        });
                        return;
                      }
                    }
                  }
                  this.namespace.addDescriptor(key, desc);
                }
              };
              if (this.exported) {
                let key = this.exported.value();
                jsModule.getStacks().forEach((desc) => {
                  this.namespace.addDescriptor(key, desc, true);
                });
              } else {
                jsModule.getAllExportDescriptors().forEach((value2, key) => {
                  if (value2.isExportNamedDeclaration) {
                    const decl2 = value2.declaration;
                    if (decl2) {
                      addDesc(decl2, key);
                    }
                  } else {
                    const decl2 = value2.description();
                    if (decl2) {
                      addDesc(decl2, key);
                    }
                  }
                });
              }
              if (this.compilation.isDescriptorDocument()) {
                if (this.exported) {
                  let key = this.exported.value();
                  let value2 = AutoImporter.create(this.source.value(), key, "*");
                  value2.origin = this;
                  value2.description = this;
                  value2.owner = jsModule;
                  this.namespace.imports.set(key, value2);
                } else {
                  let isTop = this.namespace === Namespace.top;
                  jsModule.createImportDescriptors(this.source.value()).forEach((value2, key) => {
                    if (isTop && value2.extract) {
                      return;
                    }
                    if (value2 === this)
                      return;
                    if (!this.namespace.imports.has(key)) {
                      value2.origin = this;
                      this.namespace.imports.set(key, value2);
                    }
                  });
                }
              }
            }
          }
        }
      }
      value() {
        return this.exported ? this.exported.value() : "*";
      }
      raw() {
        return this.exported ? this.exported.raw() : "*";
      }
      getAllDescriptors(exclude = null) {
        const exists = this._descriptors;
        if (exists)
          return exists;
        let properties = null;
        const make = (compilation) => {
          let properties2 = /* @__PURE__ */ new Map();
          let exportDefault = null;
          compilation.stack.exports.forEach((stack) => {
            if (stack.isExportDefaultDeclaration) {
              exportDefault = stack.description();
            } else if (stack.isExportNamedDeclaration || stack.isExportAllDeclaration) {
              if (stack !== exclude && stack !== this) {
                const dataset = stack.getAllExportDescriptors(stack);
                dataset.forEach((value2, key) => {
                  if (!properties2.has(key)) {
                    properties2.set(key, value2);
                  }
                });
              }
            }
          });
          if (exportDefault) {
            properties2.set("default", exportDefault);
          }
          return properties2;
        };
        if (this.isResolveJsModule) {
          const jsModule = this.getResolveJSModule();
          properties = jsModule.getAllExportDescriptors();
        } else {
          const compilation = this.getResolveCompilation();
          if (compilation && compilation.stack && compilation.stack.exports.length > 0) {
            properties = make(compilation);
          } else {
            if (JSModule.is(this.module)) {
              properties = this.module.getAllExportDescriptors();
            } else if (this.compilation.stack.exports.length > 0) {
              properties = make(this.compilation);
            }
          }
        }
        return this._descriptors = properties || /* @__PURE__ */ new Map();
      }
      getAllExportDescriptors() {
        const exists = this._exportDescriptors;
        if (exists)
          return exists;
        let properties = null;
        if (this.exported) {
          properties = /* @__PURE__ */ new Map([
            [
              this.exported.value(),
              this
            ]
          ]);
        } else {
          properties = this.getAllDescriptors();
        }
        this._exportDescriptors = properties;
        return properties;
      }
      description() {
        if (this.source) {
          if (this.exported) {
            const jsModule = this.getResolveJSModule();
            if (jsModule) {
              return jsModule;
            }
            return this.type();
          }
        }
        return this;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.source) {
          const jsModule = this.isResolveJsModule ? this.getResolveJSModule() : null;
          let len = 0;
          if (jsModule) {
            len = jsModule.getExportCount();
          } else {
            const compilation = this.getResolveCompilation();
            len = compilation && compilation.stack ? compilation.stack.exports.length : 0;
          }
          if (!(len > 0)) {
            (this.exported || this.source).error(1162, this.source.value());
          }
        }
      }
    };
    module.exports = ExportAllDeclaration;
  }
});

// lib/stacks/ExportAssignmentDeclaration.js
var require_ExportAssignmentDeclaration = __commonJS({
  "lib/stacks/ExportAssignmentDeclaration.js"(exports, module) {
    var AutoImporter = require_AutoImporter();
    var JSModule = require_JSModule();
    var Module = require_Module();
    var Stack = require_Stack();
    var ExportAssignmentDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isExportAssignmentDeclaration = true;
        this.expression = this.createTokenStack(compilation, node2.expression, scope, node2, this);
        if (parentStack && !(parentStack.isProgram || parentStack.isPackageDeclaration || parentStack.isModuleDeclaration)) {
          this.error(1159);
        }
        let _exports = null;
        if (parentStack.isModuleDeclaration && parentStack.module) {
          _exports = parentStack.module.exports;
        } else if (this.compilation.isDescriptorDocument()) {
          _exports = this.namespace.exports;
        }
        if (_exports) {
          const key = "*";
          if (_exports.has(key)) {
            this.expression.error(1195, key, this.namespace.toString() || "global");
          } else {
            _exports.set(key, this);
          }
        }
      }
      freeze() {
        this.expression.freeze();
      }
      reference() {
        return this.expression().reference();
      }
      referenceItems() {
        return this.expression().referenceItems();
      }
      definition(ctx) {
        if (this.expression.isIdentifier) {
          let desc2 = this.descriptor();
          let owner = this.is(desc2) ? desc2.module : null;
          let compi = owner ? owner.compilation : null;
          let items = null;
          if (JSModule.is(owner)) {
            items = owner.descriptors.get(this.expression.value());
          } else if (compi) {
            items = desc2.namespace.descriptors.get(this.expression.value());
          }
          if (items && items.length > 1) {
            return this.definitionMergeToArray(items.map((desc3) => desc3.definition(ctx)).filter(Boolean));
          }
        }
        const desc = this.description();
        if (desc && !desc.isLiteral) {
          return desc.definition();
        }
        return null;
      }
      hover(ctx) {
        if (this.expression.isIdentifier) {
          let desc2 = this.descriptor();
          let owner = this.is(desc2) ? desc2.module : null;
          let compi = owner ? owner.compilation : null;
          let items = null;
          if (JSModule.is(owner)) {
            items = owner.descriptors.get(this.expression.value());
          } else if (compi) {
            items = desc2.namespace.descriptors.get(this.expression.value());
          }
          if (items) {
            items = items.map((desc3) => desc3.hover(ctx)).filter(Boolean);
            if (items.length > 0) {
              let def = items[0];
              return this.formatHover(def, items.slice(1));
            }
          }
        }
        const desc = this.description();
        if (desc && !desc.isLiteral) {
          return desc.hover(ctx);
        }
        return null;
      }
      getExportNamespace() {
        let desc = this.expression.descriptor();
        if (desc && desc.isExportAssignmentDeclaration) {
          return desc.getExportNamespace();
        }
        if (this.expression.isIdentifier && JSModule.is(this.module)) {
          return this.module.namespaces.get(this.expression.value());
        }
        return null;
      }
      getExportType() {
        let desc = this.expression.descriptor();
        if (desc && desc.isExportAssignmentDeclaration) {
          return desc.getExportType();
        }
        if (this.expression.isIdentifier && JSModule.is(this.module)) {
          return this.module.getType(this.expression.value());
        }
        return null;
      }
      description() {
        let desc = this.expression.description();
        if (!desc) {
          if (this.expression.isMemberExpression) {
            desc = this.expression.getReferenceType();
          } else if (this.expression.isIdentifier && this.parentStack.isModuleDeclaration) {
            desc = this.module.namespaces.get(this.expression.value());
          }
        }
        return desc;
      }
      descriptor() {
        const desc = this.description();
        if (desc) {
          if (desc.isNamespaceDeclaration) {
            return desc.module;
          } else if (desc.isClassDeclaration || desc.isDeclaratorDeclaration || desc.isNamespaceDeclaration || desc.isEnumDeclaration || desc.isInterfaceDeclaration || desc.isTypeStatement || desc.isDeclaratorTypeAlias || desc.isStructTableDeclaration) {
            return desc.type();
          }
        }
        if (this.is(desc)) {
          return desc.descriptor();
        }
        return desc;
      }
      getAllReferenceIdentifier() {
        if (this.expression.isIdentifier) {
          return [this.expression];
        }
        return [];
      }
      value() {
        return this.expression.value();
      }
      raw() {
        return this.expression.raw();
      }
      type() {
        return this.expression.type();
      }
      async createCompleted() {
        await this.expression.createCompleted();
        if (this.parentStack.isPackageDeclaration && this.expression.isIdentifier && this.compilation.isDescriptorDocument()) {
          const desc = this.expression.description();
          if (desc) {
            if (desc.isImportDefaultSpecifier || desc.isImportNamespaceSpecifier || desc.isImportSpecifier) {
              const jsModule = desc.parentStack.getResolveJSModule();
              if (jsModule) {
                const value2 = desc.description();
                let key = null;
                if (value2.isDeclaratorVariable || value2.isDeclaratorFunction) {
                  key = value2.value();
                } else {
                  const type2 = value2.type();
                  if (Module.is(type2) && type2.isClass) {
                    key = type2.id;
                  }
                }
                if (key) {
                  const value3 = AutoImporter.create(jsModule.id, key, "*");
                  value3.origin = this;
                  this.namespace.imports.set(key, value3);
                }
              }
            }
          }
        }
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.expression.parser();
        const desc = this.description();
        if (desc) {
          this.expression.setRefBeUsed(desc);
        } else {
          this.expression.error(1013, this.expression.value());
        }
      }
    };
    module.exports = ExportAssignmentDeclaration;
  }
});

// lib/stacks/ExportDefaultDeclaration.js
var require_ExportDefaultDeclaration = __commonJS({
  "lib/stacks/ExportDefaultDeclaration.js"(exports, module) {
    var AutoImporter = require_AutoImporter();
    var Stack = require_Stack();
    var ExportDefaultDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isExportDefaultDeclaration = true;
        this.declaration = this.createTokenStack(compilation, node2.declaration, scope, node2, this);
        if (parentStack && !(parentStack.isProgram || parentStack.isPackageDeclaration || parentStack.isModuleDeclaration)) {
          this.error(1159);
        }
        let _exports = null;
        if (parentStack.isModuleDeclaration && parentStack.module) {
          _exports = parentStack.module.exports;
        } else if (this.compilation.isDescriptorDocument()) {
          _exports = this.namespace.exports;
        }
        if (_exports) {
          const key = "default";
          if (_exports.has(key)) {
            this.declaration.error(1195, key, this.namespace.toString());
          } else {
            _exports.set(key, this);
          }
        }
      }
      freeze() {
        this.declaration.freeze();
      }
      reference() {
        return this.description().reference();
      }
      referenceItems() {
        return this.description().referenceItems();
      }
      definition(ctx) {
        const desc = this.description();
        if (desc && !desc.isLiteral) {
          return desc.definition(ctx);
        }
      }
      hover(ctx) {
        const desc = this.description();
        if (desc && !desc.isLiteral) {
          return desc.hover(ctx);
        }
      }
      description() {
        return this.declaration.description();
      }
      descriptor() {
        let desc = this.description();
        if (!desc)
          return null;
        if (desc.isClassDeclaration || desc.isDeclaratorDeclaration || desc.isEnumDeclaration || desc.isInterfaceDeclaration || desc.isTypeStatement || desc.isDeclaratorTypeAlias || desc.isStructTableDeclaration) {
          return decl.type();
        } else if (desc.isNamespaceDeclaration) {
          return desc.module;
        }
        if (this.is(desc))
          return desc.descriptor();
        return desc;
      }
      value() {
        return this.declaration.value();
      }
      raw() {
        return this.declaration.raw();
      }
      type() {
        return this.description().type();
      }
      async createCompleted() {
        if (this.declaration) {
          await this.declaration.createCompleted();
          if (this.parentStack.isPackageDeclaration && this.declaration.isIdentifier && this.compilation.isDescriptorDocument()) {
            const desc = this.declaration.description();
            if (desc) {
              if (desc.isImportDefaultSpecifier || desc.isImportNamespaceSpecifier || desc.isImportSpecifier) {
                if (desc.parentStack.isImportDeclaration) {
                  const jsModule = desc.parentStack.getResolveJSModule();
                  if (jsModule) {
                    let key = this.declaration.value();
                    let value2 = AutoImporter.create(jsModule.id, key, key);
                    value2.origin = this;
                    this.namespace.imports.set(key, value2);
                  }
                }
              }
            }
          }
        }
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.compilation.stack.exports.length > 0) {
          const result = this.compilation.stack.exports.filter((item2) => item2.isExportDefaultDeclaration);
          if (result.length > 1) {
            this.error(1163);
          }
        }
        if (this.declaration) {
          this.declaration.parser();
          this.declaration.setRefBeUsed();
        }
      }
    };
    module.exports = ExportDefaultDeclaration;
  }
});

// lib/stacks/ExportNamedDeclaration.js
var require_ExportNamedDeclaration = __commonJS({
  "lib/stacks/ExportNamedDeclaration.js"(exports, module) {
    var AutoImporter = require_AutoImporter();
    var JSModule = require_JSModule();
    var Module = require_Module();
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var ExportNamedDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isExportNamedDeclaration = true;
        this.declaration = this.createTokenStack(compilation, node2.declaration, scope, node2, this);
        this.source = this.createTokenStack(compilation, node2.source, scope, node2, this);
        this.specifiers = node2.specifiers ? node2.specifiers.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this)) : [];
        if (parentStack && !(parentStack.isProgram || parentStack.isPackageDeclaration || parentStack.isModuleDeclaration)) {
          this.error(1159);
        }
        let _exprots = null;
        if (this.parentStack.isModuleDeclaration && this.parentStack.module) {
          if (this.declaration) {
            const decl2 = this.declaration;
            const _module = this.parentStack.module;
            if (decl2.isDeclaratorFunction || decl2.isDeclaratorVariable || decl2.isNamespaceDeclaration) {
              _module.addDescriptor(decl2.value(), decl2);
              if (decl2.isNamespaceDeclaration) {
                _module.namespaces.set(decl2.value(), decl2.module);
              }
            } else if (decl2.isDeclaratorDeclaration || decl2.isDeclaratorTypeAlias || decl2.isClassDeclaration || decl2.isInterfaceDeclaration || decl2.isStructTableDeclaration || decl2.isEnumDeclaration || decl2.isTypeStatement) {
              _module.setType(decl2.value(), decl2);
            }
            _exprots = _module.exports;
          }
        } else if (this.compilation.isDescriptorDocument()) {
          _exprots = this.namespace.exports;
        }
        if (this.declaration && _exprots) {
          const decl2 = this.declaration;
          if (decl2.isVariableDeclaration || decl2.isDeclaratorVariable) {
            decl2.declarations.forEach((decl3) => {
              let key2 = decl3.id.value();
              if (_exprots.has(key2)) {
                decl3.id.error(1195, key2, this.namespace.toString());
              } else {
                _exprots.set(key2, this);
              }
            });
            return;
          }
          let key = null;
          if (decl2.isNamespaceDeclaration) {
            key = decl2.id.value();
          } else if (decl2.isDeclaratorDeclaration || decl2.isInterfaceDeclaration || decl2.isClassDeclaration) {
            key = decl2.module.id;
          } else if (decl2.isDeclaratorTypeAlias) {
            key = decl2.left.value();
          } else if (decl2.isDeclaratorFunction || decl2.isFunctionDeclaration) {
            key = decl2.key.value();
          } else if (decl2.isAssignmentExpression) {
            key = decl2.left.value();
          } else if (decl2.isIdentifier || decl2.isLiteral) {
            key = decl2.value();
          }
          if (key) {
            _exprots.set(key, this);
          }
        }
      }
      definition(ctx) {
        if (this.declaration) {
          return this.declaration.definition(ctx);
        }
        if (ctx && ctx.hoverStack === this.source) {
          let file = this.getResolveFile();
          let compi = this.getResolveCompilation();
          let source = file || this.source.value();
          let selection = this.source.getLocation();
          let location = compi ? compi.stack.getLocation() : null;
          return {
            text: `import "${source}"`,
            selection,
            location,
            file
          };
        }
        return null;
      }
      hover(ctx) {
        if (this.declaration) {
          return this.declaration.hover(ctx);
        }
        if (ctx && ctx.hoverStack === this.source) {
          let file = this.getResolveFile();
          let source = file || this.source.value();
          let selection = this.source.getLocation();
          return {
            text: `import "${source}"`,
            selection
          };
        }
        return null;
      }
      freeze() {
        super.freeze();
        this.declaration && this.declaration.freeze();
        this.source && this.source.freeze();
        this.specifiers.forEach((item2) => item2.freeze());
      }
      getKeyName() {
        if (this.declaration) {
          if (this.declaration.isClassDeclaration) {
            return this.declaration.module.id;
          } else if (this.declaration.isFunctionDeclaration) {
            return local === item.declaration.key.value() ? item.declaration : null;
          } else if (this.declaration.isAssignmentExpression) {
            return local === item.declaration.left.value() ? item.declaration : null;
          } else if (this.declaration.isIdentifier) {
            return local === item.declaration.value() ? item.declaration : null;
          } else if (this.declaration.isVariableDeclaration) {
            const result = item.declaration.declarations.find((decl2) => decl2.id.value() === local);
            return result ? result : null;
          }
        }
      }
      getAllExportDescriptors(exclude = null) {
        const exists = this._descriptors;
        if (exists)
          return exists;
        const properties = /* @__PURE__ */ new Map();
        const anyType = Namespace.globals.get("any");
        this._descriptors = properties;
        if (this.declaration) {
          const decl2 = this.declaration;
          if (decl2.isNamespaceDeclaration) {
            properties.set(decl2.id.value(), decl2.module);
          } else if (decl2.isDeclaratorDeclaration || decl2.isInterfaceDeclaration || decl2.isClassDeclaration) {
            properties.set(decl2.module.id, decl2.module);
          } else if (decl2.isDeclaratorTypeAlias) {
            properties.set(decl2.left.value(), decl2.type());
          } else if (decl2.isDeclaratorFunction || decl2.isFunctionDeclaration) {
            properties.set(decl2.key.value(), decl2);
          } else if (decl2.isAssignmentExpression) {
            properties.set(decl2.left.value(), decl2.right.description() || anyType);
          } else if (decl2.isIdentifier || decl2.isLiteral) {
            properties.set(decl2.value(), decl2.description() || anyType);
          } else if (decl2.isVariableDeclaration || decl2.isDeclaratorVariable) {
            decl2.declarations.forEach((decl3) => {
              const desc = decl3.init ? decl3.init.description() : decl3.id.description();
              properties.set(decl3.id.value(), desc || anyType);
            });
          }
        } else if (this.specifiers && this.specifiers.length > 0) {
          this.specifiers.forEach((specifier) => {
            const desc = specifier.description() || anyType;
            if (desc.isExportAllDeclaration) {
              if (desc !== exclude) {
                desc.getAllExportDescriptors(exclude).forEach((value2, key) => {
                  properties.set(key, value2);
                });
              }
            } else {
              properties.set(specifier.exported.value(), desc);
            }
          });
        }
        return properties;
      }
      getDescByName(name) {
        if (this.declaration) {
          const decl2 = this.declaration;
          if (decl2.isClassDeclaration) {
            return decl2.module.id === name ? decl2.module : null;
          } else if (decl2.isFunctionDeclaration) {
            return name === decl2.key.value() ? decl2 : null;
          } else if (decl2.isAssignmentExpression) {
            return name === decl2.left.value() ? decl2.right.description() : null;
          } else if (decl2.isIdentifier) {
            return name === decl2.value() ? decl2.description() : null;
          } else if (decl2.isVariableDeclaration) {
            const result = decl2.declarations.find((de) => de.id.value() === name);
            return result ? result.description() : null;
          }
        } else if (this.specifiers && this.specifiers.length > 0) {
          const result = this.specifiers.find((specifier) => {
            return specifier.exported.value() === name;
          });
          if (result) {
            return result.description();
          }
        }
      }
      getResolveFile() {
        return this.getAttribute("getResolveFile", () => {
          if (this.source && this.source.isLiteral) {
            const source = this.source.value();
            let resolve = this.compiler.resolveDescriptorFile(source, this.compilation.file);
            if (!resolve) {
              resolve = this.compiler.resolveManager.resolveFile(source, this.compilation.file);
              if (resolve && resolve === this.file) {
                resolve = null;
              }
            }
            resolve = resolve || source;
            if (!resolve && !JSModule.get(source)) {
              this.source.error(1122, source);
            }
            return resolve;
          }
          return null;
        });
      }
      getResolveCompilation() {
        return this.getAttributeAlways("resolveCompilation");
      }
      getResolveJSModule(resolvedCompilation = null) {
        return this.getAttributeAlways("getResolveJSModule", () => {
          if (this.source && this.source.isLiteral) {
            let source = this.source.value();
            let resolve = this.getResolveFile();
            let module2 = JSModule.getModule(source, resolve);
            if (module2) {
              return module2;
            }
            let raw = source;
            if (resolve && resolve !== source) {
              if (source.includes("/")) {
                source = source.slice(source.lastIndexOf("/") + 1);
              }
            }
            const describeSuffix = this.compiler.options.describeSuffix;
            if (describeSuffix && source.endsWith(describeSuffix)) {
              source = source.substring(0, source.length - describeSuffix.length);
            }
            if (raw !== source) {
              module2 = JSModule.getModule(source, resolve);
            }
            if (!module2 && resolvedCompilation) {
              module2 = JSModule.getByFile(resolvedCompilation.file);
            }
            return module2;
          }
          return null;
        });
      }
      async getResolveCompilationAsync() {
        if (!this.source)
          return null;
        if (this.hasAttributeAlways("resolveCompilation")) {
          return this.getAttributeAlways("resolveCompilation");
        }
        let source = this.source.value();
        if (this.compiler.manifester.hasResource(source)) {
          await this.compilation.loadManifest(source, null, true);
        }
        let hasResolve = this.compiler.checkFileExt(this.getResolveFile());
        let compilation = null;
        if (hasResolve) {
          compilation = await this.compilation.createChildCompilation(this.getResolveFile(), this.compilation.file);
          if (compilation === this.compilation) {
            compilation = null;
          }
        }
        const jsModule = this.getResolveJSModule(compilation);
        if (jsModule) {
          this.isResolveJsModule = true;
          if (!compilation) {
            compilation = jsModule.compilation;
          }
        } else if (compilation) {
          compilation.import = "importSpecifier";
        }
        if (hasResolve && !compilation) {
          this.source.error(1132, source);
        }
        if (compilation && !this.compilation.isDescriptorDocument()) {
          compilation.once("onRemoved", () => {
            this.removeAttributeAlways("resolveCompilation");
            this.removeAttributeAlways("getResolveJSModule");
            this.isResolveJsModule = false;
            this.compiler.printLogInfo(`onRemoved: ${this.toString()}: getResolveCompilationAsync: ${compilation.file}`, "Stack");
          });
        }
        this.setAttributeAlways("resolveCompilation", compilation);
        return compilation;
      }
      async createCompleted() {
        const compilation = await this.getResolveCompilationAsync();
        if (compilation) {
          await compilation.createCompleted();
          if (this.parentStack.isPackageDeclaration) {
            const isDesc = this.compilation.isDescriptorDocument();
            if (this.specifiers.length > 0) {
              const jsModule = this.getResolveJSModule();
              if (jsModule) {
                const addDesc = (desc, key, exported) => {
                  if (desc.isClassDeclaration || desc.isDeclaratorDeclaration || desc.isInterfaceDeclaration || desc.isEnumDeclaration || desc.isStructTableDeclaration) {
                    if (isDesc) {
                      const type2 = value.type();
                      if (Module.is(type2) && type2.isClass) {
                        let value2 = AutoImporter.create(jsModule.id, exported, key, true);
                        value2.origin = this;
                        value2.description = desc;
                        value2.owner = jsModule;
                        this.namespace.imports.set(exported, value2);
                      }
                    }
                    this.namespace.addDescriptor(exported, desc, true);
                  } else if (desc.isNamespaceDeclaration) {
                    if (desc.module) {
                      const ns = Namespace.create(this.namespace.getChain().concat(desc.value()).join("."));
                      desc.module.types.forEach((desc2, key2) => {
                        ns.addDescriptor(key2, desc2, true);
                      });
                      desc.module.descriptors.forEach((items, key2) => {
                        items.forEach((item2) => ns.addDescriptor(key2, item2, true));
                      });
                    }
                  } else {
                    if (desc.isDeclaratorVariable || desc.isDeclaratorFunction) {
                      if (isDesc) {
                        let value2 = AutoImporter.create(jsModule.id, exported, key, true);
                        value2.origin = this;
                        value2.description = desc;
                        value2.owner = jsModule;
                        this.namespace.imports.set(exported, value2);
                      }
                      if (JSModule.is(desc.module)) {
                        const items = desc.module.descriptors.get(key);
                        if (items) {
                          items.forEach((value2) => {
                            if (value2.isNamespaceDeclaration) {
                              addDesc(value2, key, exported);
                            } else {
                              this.namespace.addDescriptor(exported, value2, true);
                            }
                          });
                          return;
                        }
                      }
                    }
                    this.namespace.addDescriptor(exported, desc, true);
                  }
                };
                this.specifiers.forEach((item2) => {
                  const key = item2.local.value();
                  const exported = item2.exported.value();
                  const value2 = item2.descriptor();
                  addDesc(value2, key, exported);
                });
              } else if (!this.source && isDesc) {
                this.specifiers.forEach((item2) => {
                  const key = item2.local.value();
                  const exported = item2.exported.value();
                  const desc = item2.description();
                  if (desc) {
                    if (desc.isImportDefaultSpecifier || desc.isImportNamespaceSpecifier || desc.isImportSpecifier) {
                      const jsModule2 = desc.parentStack.getResolveJSModule();
                      if (jsModule2) {
                        let value2 = AutoImporter.create(jsModule2.id, exported, key, true);
                        value2.origin = this;
                        this.namespace.imports.set(exported, value2);
                      }
                    }
                  }
                });
              }
            }
          }
        }
        if (this.declaration) {
          await this.declaration.createCompleted();
        }
      }
      getFileExt() {
        const resolve = this.getResolveFile();
        if (resolve) {
          const pos = resolve.lastIndexOf(".");
          if (pos > 0) {
            return resolve.substring(pos);
          }
        }
        return null;
      }
      description() {
        const decl2 = this.declaration;
        if (decl2) {
          if (decl2.isAssignmentExpression) {
            return decl2.right.description();
          } else if (decl2.isVariableDeclaration || decl2.isDeclaratorVariable) {
            if (decl2.declarations.length === 1) {
              const de = decl2.declarations[0];
              return de.init ? de.init.description() : de.id.description();
            }
          }
        }
        return decl2;
      }
      descriptor() {
        const decl2 = this.declaration;
        if (decl2) {
          if (decl2.isNamespaceDeclaration) {
            return decl2.module;
          } else if (decl2.isClassDeclaration || decl2.isNamespaceDeclaration || decl2.isDeclaratorDeclaration || decl2.isInterfaceDeclaration || decl2.isStructTableDeclaration || decl2.isDeclaratorTypeAlias || decl2.isTypeStatement || decl2.isEnumDeclaration) {
            return decl2.type();
          }
        }
        const desc = this.description();
        if (this.is(desc))
          return desc.descriptor();
        return desc;
      }
      type() {
        const decl2 = this.declaration;
        if (decl2) {
          return decl2.type();
        }
        return Namespace.globals.get("any");
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.source) {
          const jsModule = this.isResolveJsModule ? this.getResolveJSModule() : null;
          let len = 0;
          if (jsModule) {
            len = jsModule.getExportCount();
          } else {
            const compilation = this.getResolveCompilation();
            len = compilation && compilation.stack ? compilation.stack.exports.length : 0;
          }
          if (!(len > 0)) {
            this.error(1162, this.source.value());
          }
        }
        if (this.declaration) {
          this.declaration.parser();
          this.declaration.setRefBeUsed();
          const desc = this.description();
          if (desc) {
            const decl2 = this.declaration;
            if (decl2.isAssignmentExpression) {
              decl2.right.setRefBeUsed(desc);
            } else if (decl2.isVariableDeclaration) {
              decl2.declarations.forEach((decl3) => {
                const desc2 = decl3.init ? decl3.init.description() : decl3.id.description();
                if (decl3.init) {
                  decl3.init.setRefBeUsed(desc2);
                } else {
                  decl3.id.setRefBeUsed(desc2);
                }
              });
            }
          }
        }
        this.specifiers.forEach((item2) => item2.parser());
      }
    };
    module.exports = ExportNamedDeclaration;
  }
});

// lib/stacks/ExportSpecifier.js
var require_ExportSpecifier = __commonJS({
  "lib/stacks/ExportSpecifier.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var ExportSpecifier = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isExportSpecifier = true;
        this.local = this.createTokenStack(compilation, node2.local, scope, node2, this);
        this.exported = this.createTokenStack(compilation, node2.exported, scope, node2, this);
        let _exports = null;
        let pp = this.parentStack.parentStack;
        if (pp.isModuleDeclaration && pp.module) {
          const _module = pp.module;
          _exports = _module.exports;
        } else if (this.compilation.isDescriptorDocument()) {
          _exports = this.namespace.exports;
        }
        if (_exports) {
          let key = this.exported.value();
          if (_exports.has(key)) {
            this.exported.error(1195, key, this.namespace.toString());
          } else {
            _exports.set(key, this);
          }
        }
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.exported);
      }
      definition(ctx) {
        let desc = this.description();
        if (desc) {
          return desc.definition(ctx);
        }
      }
      hover(ctx) {
        let def = {
          text: `export ${this.exported.value()}`
        };
        let desc = this.description();
        if (desc) {
          return this.formatHover(def, desc.hover(ctx));
        }
        return def;
      }
      reference() {
        const desc = this.description();
        if (desc && !desc.isExportAllDeclaration) {
          return desc.reference();
        }
        return null;
      }
      referenceItems() {
        const desc = this.description();
        if (desc && !desc.isExportAllDeclaration) {
          return desc.referenceItems();
        }
        return [];
      }
      description() {
        if (this.parentStack.source) {
          const jsModule = this.parentStack.isResolveJsModule ? this.parentStack.getResolveJSModule() : null;
          const local2 = this.local.value();
          if (jsModule) {
            return jsModule.getExport(local2);
          } else {
            const compilation = this.parentStack.getResolveCompilation();
            if (compilation && compilation.stack && compilation.stack.exports.length > 0) {
              const exports2 = compilation.stack.exports;
              for (var i = 0; exports2.length > i; i++) {
                const item2 = exports2[i];
                if (item2.isExportAllDeclaration) {
                  const descriptors = item2.getAllExportDescriptors();
                  const desc = descriptors.get(local2);
                  if (desc)
                    return desc;
                } else if (item2.isExportNamedDeclaration) {
                  const desc = item2.getDescByName(local2);
                  if (desc)
                    return desc;
                }
              }
            }
          }
          return null;
        }
        return this.local.description();
      }
      descriptor() {
        const desc = this.description();
        if (this.is(desc))
          return desc.descriptor();
        return desc;
      }
      type() {
        const desc = this.description();
        if (desc)
          return desc.type();
        return Namespace.globals.get("any");
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (!this.parentStack.source) {
          this.local.parser();
          this.local.setRefBeUsed();
        } else {
          const desc = this.description();
          if (!desc) {
            this.error(1164, this.parentStack.source.value(), this.local.value());
          } else {
            this.local.setRefBeUsed(desc);
          }
        }
      }
    };
    module.exports = ExportSpecifier;
  }
});

// lib/stacks/ExpressionStatement.js
var require_ExpressionStatement = __commonJS({
  "lib/stacks/ExpressionStatement.js"(exports, module) {
    var Stack = require_Stack();
    var ExpressionStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isExpressionStatement = true;
        this.expression = this.createTokenStack(compilation, node2.expression, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.expression.freeze();
      }
      definition() {
        return null;
      }
      error(code, ...args) {
        this.expression.error(code, ...args);
      }
      warn(code, ...args) {
        this.expression.warn(code, ...args);
      }
      reference() {
        return this.expression.reference();
      }
      referenceItems() {
        return this.expression.referenceItems();
      }
      description() {
        return this.expression.description();
      }
      type(ctx) {
        return this.expression.type(ctx);
      }
      parser() {
        this.expression.parser();
      }
      value() {
        return this.expression.value();
      }
      raw() {
        return this.expression.raw();
      }
    };
    module.exports = ExpressionStatement;
  }
});

// lib/stacks/ForInStatement.js
var require_ForInStatement = __commonJS({
  "lib/stacks/ForInStatement.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var BlockScope = require_BlockScope();
    var ForInStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        scope = new BlockScope(scope);
        super(compilation, node2, scope, parentNode, parentStack);
        this.isForInStatement = true;
        this.left = this.createTokenStack(compilation, node2.left, scope, node2, this);
        this.right = this.createTokenStack(compilation, node2.right, scope, node2, this);
        this.body = this.createTokenStack(compilation, node2.body, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
        this.body.freeze();
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.left.parser();
        this.left.setRefBeUsed();
        this.right.parser();
        this.right.setRefBeUsed();
        if (this.body) {
          this.body.parser();
        }
        const desc = this.right.description();
        const type2 = desc.type();
        const iterator = Namespace.globals.get("Iterator");
        const objectType = Namespace.globals.get("Object");
        if (!type2.isAnyType) {
          if (iterator.check(type2) || objectType.check(type2))
            return;
          this.right.error(1046, this.right.raw());
        }
        if (this.left.isVariableDeclaration) {
          if (this.left.declarations.length > 1) {
            this.left.declarations[1].error(1047, "for-in");
          }
          if (this.left.declarations[0].init) {
            this.left.declarations[0].init.error(1048, "for-in");
          }
        }
        const checkItems = /* @__PURE__ */ new Set();
        const getCheckItems = (desc2) => {
          if (!desc2)
            return [];
          let items = [];
          if (desc2.isDeclarator || desc2.isPropertyDefinition) {
            if (desc2.acceptType && !desc2.acceptType.type().isAnyType) {
              checkItems.add(desc2.acceptType.type());
            } else {
              items = Array.from(desc2.assignItems);
            }
          } else if (desc2.isMethodDefinition || desc2.isFunctionDeclaration) {
            if (desc2.returnType && !desc2.returnType.type().isAnyType) {
              checkItems.add(desc2.returnType.type());
            } else {
              items = desc2.scope.returnItems.map((item2) => item2.argument);
              if (desc2.isMethodGetterDefinition) {
                const name = desc2.key.value();
                const setter = this.module.getMember(name, "set");
                if (setter) {
                  items = items.concat(Array.from(setter.assignItems));
                }
              }
            }
          } else {
            items.push(desc2);
          }
          items.forEach((item2) => {
            if (item2.isArrayExpression || item2.isLiteral || item2.isObjectExpression || item2.isModule) {
              if (item2.isModule) {
                checkItems.add(item2);
              } else {
                checkItems.add(item2.type());
              }
            } else if (item2.isStack) {
              const desc3 = item2.description();
              if (item2 !== desc3) {
                getCheckItems(desc3);
              }
            }
          });
        };
        getCheckItems(desc);
        const result = Array.from(checkItems).every((type3) => {
          return type3.is(iterator) || type3.is(objectType);
        });
        if (!result) {
          this.right.warn(1049, this.right.raw());
        }
      }
    };
    module.exports = ForInStatement;
  }
});

// lib/core/Context.js
var require_Context = __commonJS({
  "lib/core/Context.js"(exports, module) {
    var Namespace = require_Namespace();
    var UnknownType = require_UnknownType();
    var Utils = require_Utils();
    var MergeType = require_MergeType();
    var InstanceofType = require_InstanceofType();
    var UKType = new UnknownType();
    var privateKey = Symbol("privateKey");
    var defaultInferType = null;
    var Context = class {
      [Utils.IS_CONTEXT] = true;
      static is(value2) {
        return value2 && value2 instanceof Context;
      }
      static setDefaultInferType(type2) {
        if (type2 && type2.isType) {
          defaultInferType = type2;
        } else {
          defaultInferType = null;
        }
      }
      constructor(stack) {
        this.stack = stack;
        this.children = [];
        this.parent = null;
        this.dataset = /* @__PURE__ */ new Map();
        this._declareGenerics = null;
        this.makeDoneCache = /* @__PURE__ */ new WeakSet();
        this.applyResult = /* @__PURE__ */ new Map();
        this.isContext = true;
        this.onSetValue = null;
        this._applyContext = {};
        throw new Error("Context is deprecated");
      }
      createChild(stack) {
        const old = stack[privateKey];
        if (old)
          return old;
        const ctx = new Context(stack);
        stack[privateKey] = ctx;
        ctx.parent = this;
        this.children.push(ctx);
        return ctx;
      }
      hasDeclareGenerics() {
        if (this.stack.isFunctionExpression || this.stack.isClassDeclaration || this.stack.isDeclaratorDeclaration || this.stack.isInterfaceDeclaration) {
          return !!this.stack.genericity;
        } else if (this.stack.isCallExpression || this.stack.isNewExpression) {
          let desc = this.stack.description();
          if (desc) {
            if (desc.isMethodDefinition) {
              desc = desc.expression;
            }
            if (desc.isFunctionExpression) {
              return !!desc.genericity;
            }
            desc = desc.isDeclarator ? desc.type() : desc;
            if (Utils.isTypeModule(desc)) {
              const stackModule = desc.moduleStack;
              return !!(stackModule && stackModule.genericity);
            }
          }
        }
        return !!this.stack.isTypeGenericDefinition;
      }
      declareGenerics(declare) {
      }
      setValue(type2, value2) {
        if (type2 && value2) {
          if (type2.isGenericType) {
            if (value2.isGenericType) {
              const res = this.getValue(value2, true);
              if (res)
                value2 = res;
            }
            if (value2.isTypeofType) {
              value2 = value2.origin;
            }
            if (Utils.isStack(value2) || Utils.isType(value2)) {
              if (type2 !== value2.type()) {
                this.dataset.set(type2.getUniKey(), value2);
              }
            }
          } else {
            if (this.stack && this.stack.compiler) {
              const options = this.stack.compiler.options;
              if (options.debug || options.throwError) {
                throw new Error(`Assigment type is not generic-type`);
              }
            }
          }
        }
      }
      getValue(type2, flag = false) {
        if (!type2 || !type2.isGenericType)
          return null;
        let result = this.dataset.get(type2.getUniKey()) || null;
        if (type2 === result) {
          result = null;
        }
        if (flag && !result) {
          if (this.parent) {
            return this.parent.getValue(type2, flag);
          }
        }
        return result;
      }
      batch(declares, assignments) {
        if (declares && declares.length > 0 && assignments && assignments.length > 0) {
          declares.forEach((declare, index) => {
            const value2 = assignments[index];
            if (value2) {
              this.setValue(declare, value2);
            }
          });
        }
      }
      merge(context) {
      }
      mergeAll(context) {
        if (!context)
          return null;
        if (context instanceof Context) {
          context.dataset.forEach((value2, key) => {
            if (!this.dataset.has(key) && value2 !== UKType) {
              this.dataset.set(key, value2);
            }
          });
          if (context.parent) {
            this.mergeAll(context.parent);
          }
        } else {
          throw new Error(`Argument context is not Context instanced.`);
        }
      }
      assignment(type2, callback = null, excludes = null) {
        if (!type2)
          return;
        if (excludes && excludes.has(type2)) {
          return;
        }
        if (type2.isTypeofType)
          type2 = type2.origin.type();
        if (type2.isGenericType) {
          let _type = type2.assignType ? type2.assignType.type() : type2.hasConstraint ? type2.inherit.type() : null;
          if (_type !== type2) {
            excludes = excludes || /* @__PURE__ */ new WeakSet();
            excludes.add(type2);
            return this.assignment(_type, callback, excludes);
          } else {
            return;
          }
        }
        if (type2.isAliasType) {
          if (type2.target && type2.target.isDeclaratorTypeAlias) {
            this.merge(type2.target.getContext());
          }
          const inherit = type2.inherit;
          if (inherit && type2 !== inherit) {
            this.assignment(inherit.type(), callback, excludes);
          }
          return;
        }
        const setValue = (assignments) => {
          if (declareGenerics) {
            declareGenerics.forEach((decl2, index) => {
              let value2 = assignments[index];
              if (value2) {
                decl2 = decl2.type();
                if (decl2 === value2.type()) {
                  value2 = decl2.assignType;
                  if (!value2)
                    return;
                }
                if (callback) {
                  callback(decl2, value2);
                } else {
                  this.setValue(decl2, value2);
                }
              }
            });
          }
        };
        let originType = Utils.getOriginType(type2);
        let [stack, declareGenerics] = this.getDeclareGenerics(type2, originType);
        if (originType && originType.isModule) {
          if (stack)
            this.merge(stack.getContext());
          originType.getStacks().forEach((item2) => {
            if (stack !== item2) {
              this.merge(item2.getContext());
            }
          });
        }
        if (type2.isTupleType || type2.isLiteralArrayType) {
          if (type2.isTupleType) {
            type2.elements.forEach((item2) => {
              this.assignment(item2.type(), callback, excludes);
            });
          }
          setValue([MergeType.to(type2, true, true)]);
        } else if (type2.isInstanceofType && type2.generics && type2.generics.length > 0) {
          setValue(type2.generics);
        } else if (type2.isClassGenericType) {
          if (!type2.isClassType) {
            const wrap = type2.inherit.type();
            if (wrap.target && wrap.target.isDeclaratorTypeAlias && wrap.target.genericity) {
              declareGenerics = wrap.target.genericity.elements;
            }
          }
          type2.types.forEach((assign) => {
            this.assignment(assign, callback, excludes);
          });
          setValue(type2.types);
        }
      }
      getDeclareGenerics(type2, originType) {
        if (type2.isInstanceofType) {
          type2 = type2.inherit.type();
        }
        if (type2.isAliasType && type2.target && type2.target.isDeclaratorTypeAlias && type2.target.genericity) {
          return [type2.target, type2.target.genericity.elements];
        } else if (type2.isClassGenericType && type2.target && type2.target.isTypeGenericDefinition) {
          return type2.target.getDeclareGenerics();
        }
        originType = originType || Utils.getOriginType(type2);
        if (originType && originType.isModule) {
          return originType.getModuleDeclareGenerics(true);
        }
        return [];
      }
      make(type2) {
        if (!type2)
          return false;
        if (this.makeDoneCache.has(type2))
          return true;
        this.makeDoneCache.add(type2);
        if (type2.isTypeofType)
          type2 = type2.origin.type();
        if (type2.isIntersectionType) {
          this.make(type2.left.type());
          this.make(type2.right.type());
        } else if (type2.isUnionType) {
          const dataset = /* @__PURE__ */ new Map();
          type2.elements.forEach((item2) => {
            this.assignment(item2.type(), (key, value2) => {
              if (value2.isTypeofType)
                value2 = value2.origin.type();
              let target = dataset.get(key);
              if (!target) {
                dataset.set(key, target = [value2]);
              } else {
                target.push(value2);
              }
            });
          });
          dataset.forEach((items, key) => {
            if (items.length > 1) {
              const mergeType = new MergeType();
              items.forEach((type3) => mergeType.add(type3));
              this.setValue(key, mergeType.type());
            } else {
              this.setValue(key, items[0]);
            }
          });
        } else {
          this.assignment(type2);
        }
        return true;
      }
      __fetch(type2, flag = false, prev = null) {
        if (!type2)
          return null;
        if (!type2.isGenericType)
          return type2;
        let result = this.getValue(type2);
        let value2 = result ? result.type() : null;
        if (value2 && value2.isGenericType) {
          if (value2 !== type2 && value2 !== prev) {
            return this.__fetch(value2, flag, value2);
          }
        } else if ((!result || value2 === UKType) && this.parent) {
          return this.parent.__fetch(type2, flag, prev || value2);
        }
        if (!value2) {
          value2 = type2.assignType;
          if (value2) {
            value2 = value2.type();
            if (value2 && value2.isGenericType && value2 !== type2 && value2 !== prev) {
              return this.__fetch(value2, flag, prev);
            }
          }
        }
        if (!value2 && prev) {
          value2 = prev;
        }
        return flag && !value2 ? type2 : value2;
      }
      fetch(type2, flag = false) {
        let result = this.__fetch(type2, flag);
        if (!result || result === UKType) {
          if (defaultInferType) {
            result = defaultInferType;
          }
        }
        return result;
      }
      inferValue(type2, flag = false) {
        if (!type2 || !type2.isGenericType)
          return type2;
        let result = this.fetch(type2);
        if (!result || result === UKType) {
          result = type2.hasConstraint ? type2.inherit : result;
        }
        if (result) {
          return result.type();
        } else if (flag) {
          return UKType;
        }
        return null;
      }
      get inference() {
        return (type2) => {
          if (!type2 || !type2.isGenericType)
            return type2;
          let result = this.fetch(type2);
          if (!result || result === UKType) {
            this._applyContext.mismatch = true;
            result = type2.hasConstraint ? type2.inherit : result;
          }
          if (result) {
            return result.type();
          }
          return type2;
        };
      }
      apply(type2, context = {}) {
        if (type2 && type2.hasGenericType) {
          this._applyContext = context;
          if (type2.isGenericType) {
            return this.fetch(type2) || (this._applyContext.mismatch = true, type2.hasConstraint ? type2.inherit.type() : UKType);
          }
          if (this.applyResult.has(type2)) {
            return this.applyResult.get(type2);
          }
          let result = type2.clone(this.inference);
          if (type2.isComputeType) {
            result = result.getComputeType();
          }
          this.applyResult.set(type2, result);
          return result;
        }
        return type2;
      }
      isObjectType(type2) {
        if (!type2)
          return false;
        return type2.isLiteralObjectType || type2.isInstanceofType || type2.isEnumType || type2.isEnum && type2.isModule;
      }
      extracts(declareParams, assignments, declareGenerics, parserFlag = false) {
        const cache = /* @__PURE__ */ new Map();
        const onSetValue = (decl2, assignValue, context = []) => {
          const old = cache.get(decl2);
          if (old) {
            if (old[0] === "via") {
              return false;
            }
            if (context.length === 2 && context[0] === "wrap") {
              if (old.length > 2 && old[0] === "wrap") {
                return false;
              }
            }
          }
          cache.set(decl2, context);
          return true;
        };
        let declareParamsLen = declareParams.length;
        for (let index = 0; index < declareParamsLen; index++) {
          let declared = declareParams[index];
          let argument = assignments[index];
          if (!argument)
            return;
          if (parserFlag) {
            if (argument.isFunctionExpression || argument.isObjectExpression || argument.isArrayExpression) {
              argument.parser();
              argument.setRefBeUsed();
            }
          }
          if (argument.isSpreadElement) {
            const type2 = argument.type();
            let elements = [];
            let defaultValue = null;
            if (type2.isTupleType && !type2.prefix || type2.isLiteralArrayType) {
              elements = type2.elements;
            } else if (type2.isTupleType && type2.prefix) {
              defaultValue = type2.elements[0];
            }
            for (let s = 0; s < elements.length && s + index < declareParamsLen; s++) {
              declared = declareParams[s + index];
              let value2 = elements[s] || defaultValue;
              if (declared && value2) {
                this.extract(declared, value2, declareGenerics, onSetValue);
              } else {
                break;
              }
            }
          }
          if (declared.isRestElement) {
            let _items = assignments.slice(index);
            if (parserFlag) {
              _items.forEach((argument2) => {
                if (argument2.isFunctionExpression || argument2.isObjectExpression || argument2.isArrayExpression) {
                  argument2.parser();
                  argument2.setRefBeUsed();
                }
              });
            }
            return this.extract(declared, MergeType.arrayToTuple(_items), declareGenerics, onSetValue);
          }
          this.extract(declared, argument, declareGenerics, onSetValue);
        }
      }
      extract(declared, argument, declareGenerics, onSetValue) {
        if (!declared || !argument)
          return null;
        const isInScope = (declType2) => {
          if (!declareGenerics || !Array.isArray(declareGenerics))
            return true;
          if (declType2 && declType2.target && declType2.target.isGenericTypeDeclaration) {
            if (declType2.target.parentStack.parentStack.isDeclaratorTypeAlias) {
              return true;
            }
          }
          return declareGenerics.some((item2) => item2.type() === declType2);
        };
        if (declared.isObjectPattern) {
          const argumentType = argument.type();
          if (!this.isObjectType(argumentType)) {
            return;
          }
          return declared.properties.forEach((property) => {
            const declType2 = property.type();
            if (!declType2.hasGenericType)
              return;
            const matchResult = this.stack.getObjectDescriptor(argumentType, property.key.value(), false, true);
            if (declType2.isGenericType) {
              this.extractive(declType2, matchResult, isInScope, onSetValue);
            } else {
              this.extract(declType2, matchResult, declareGenerics, onSetValue);
            }
          });
        } else if (declared.isArrayPattern) {
          const argumentType = argument.type();
          if (!(argumentType.isLiteralArrayType || argumentType.isTupleType)) {
            return;
          }
          return declared.elements.forEach((item2, index) => {
            const declType2 = item2.type();
            if (!declType2.hasGenericType)
              return;
            const matchResult = this.stack.getObjectDescriptor(argumentType, index, false, true);
            if (declType2.isGenericType) {
              this.extractive(declType2, matchResult, isInScope, onSetValue);
            } else {
              this.extract(declType2, matchResult, declareGenerics, onSetValue);
            }
          });
        }
        let declType = declared.type();
        if (declType) {
          if (declType.hasGenericType || declType.isFunctionType || declType.isClassGenericType) {
            this.extractive(declType, argument, isInScope, onSetValue);
          }
          if (declType.isGenericType) {
            if (declType.hasConstraint) {
              let constraint = declType.inherit.type();
              if (constraint && !constraint.check(argument, this)) {
                const str1 = this.stack.isLiteralValueConstraint(constraint, this) ? this.stack.getTypeLiteralValueString(declType, this) : this.stack.getTypeDisplayName(declType, this);
                const str2 = this.stack.getTypeDisplayName(constraint, this);
                argument.error(1003, str1, str2);
              }
            }
          }
        }
      }
      extractive(declareType, assignValue, checkScope, onSetValue) {
        if (!declareType || !assignValue)
          return;
        let checkFlag = true;
        const context = [];
        const setValue = (decl2, assignValue2, callback) => {
          if (!checkFlag || !checkScope || checkScope(decl2, this, assignValue2)) {
            if (onSetValue && onSetValue(decl2, assignValue2, context) === false) {
              return false;
            }
            if (callback) {
              return callback(decl2, assignValue2);
            } else {
              if (assignValue2.isLiteralArrayType) {
                assignValue2 = this.arrayToUnionType(decl2, assignValue2, true);
              }
              this.setValue(decl2, assignValue2);
              return true;
            }
          }
          return false;
        };
        const forEach = (items, callback, flag) => {
          for (let i = 0; i < items.length; i++) {
            if (callback(flag ? items[i] : items[i].type(), i)) {
              return true;
            }
          }
          return false;
        };
        const every = (declareType2, assignType, callback) => {
          if (declareType2.isGenericType) {
            if (assignType && assignType.isClassGenericType && !assignType.isClassType) {
              this.make(assignType);
            }
            context.push("via");
            return setValue(declareType2, assignType, callback);
          } else if (declareType2.isTupleType && (assignType.isLiteralArrayType || assignType.isTupleType)) {
            const isRest = !!declareType2.rest;
            context.push("array");
            return forEach(declareType2.elements, (decl2, index) => {
              if (decl2.isGenericType) {
                let assignValue2 = assignType;
                if (!isRest) {
                  if (!declareType2.prefix) {
                    if (assignType.isTupleType) {
                      if (assignType.elements.length === 1) {
                        assignValue2 = assignType.elements[0];
                      } else {
                        assignValue2 = assignType.elements[index] || Namespace.globals.get("any");
                      }
                    } else if (assignType.isLiteralArrayType) {
                      assignValue2 = assignType.elements[index] || Namespace.globals.get("any");
                    }
                  } else {
                    if (assignType.isTupleType && assignType.prefix && assignType.elements.length === 1) {
                      assignValue2 = assignType.elements[0];
                    }
                  }
                } else if (assignValue2.isTupleType) {
                  assignValue2 = this.arrayToUnionType(decl2, assignValue2);
                }
                return setValue(decl2, assignValue2, (decl3, assignType2) => {
                  return this.setValue(decl3, this.arrayToUnionType(decl3, assignType2, isRest));
                });
              } else {
                let assign = null;
                if (decl2.isTupleType) {
                  if (assignType.isLiteralArrayType) {
                    const origin = Namespace.globals.get("Array");
                    const mergeType = new MergeType(origin);
                    mergeType.keepOriginRefs = true;
                    mergeType.hasTuplePrefix = !!decl2.prefix;
                    mergeType.isTupleType = true;
                    mergeType.isTupleUnion = !!decl2.isTupleUnion;
                    mergeType.forceNotTupleUnion = !decl2.prefix;
                    mergeType.target = assignType.target;
                    assignType.elements.forEach((item2) => {
                      mergeType.add(item2);
                    });
                    assign = mergeType.type();
                  } else if (assignType.isTupleType) {
                    assign = assignType;
                  }
                  if (assign.elements[index]) {
                    if (decl2.prefix && !assign.prefix) {
                      assign = MergeType.to(assign.elements[index], true);
                    } else if (assign.prefix === decl2.prefix) {
                      assign = assign.elements[index];
                      if (assign.isTupleType && !decl2.prefix && decl2.elements.length < assign.elements.length) {
                        assign = Namespace.globals.get("any");
                      }
                    }
                  } else {
                    assign = Namespace.globals.get("any");
                  }
                } else {
                  assign = assignType.elements[index];
                }
                if (assign) {
                  return every(decl2, assign, (decl3, assignType2) => {
                    return this.setValue(decl3, assignType2);
                  });
                }
              }
            });
          } else if (declareType2.isUnionType) {
            context.push("union");
            return forEach(declareType2.elements, (decl2) => {
              return every(decl2, assignType, callback);
            });
          } else if (declareType2.isLiteralObjectType) {
            context.push("object");
            return forEach(Array.from(declareType2.properties.values()), (property) => {
              let decl2 = property.type();
              if (decl2.hasGenericType) {
                const value2 = this.stack.getObjectDescriptor(assignType, property.key.value());
                if (value2) {
                  return every(decl2, value2.type(), callback);
                }
              }
            }, true);
          } else if (declareType2.isClassGenericType) {
            context.push("wrap");
            const inherit = declareType2.inherit.type();
            if (assignType.isClassGenericType) {
              if (inherit.is(assignType.inherit.type())) {
                const [, declareGenerics = []] = this.getDeclareGenerics(declareType2);
                forEach(declareType2.types, (value2, index) => {
                  let _decl = declareGenerics[index];
                  if (_decl) {
                    _decl = _decl.type();
                    this.setValue(_decl, value2);
                  }
                  if (assignType.types[index]) {
                    let _old = checkFlag;
                    checkFlag = false;
                    every(value2, assignType.types[index].type());
                    checkFlag = _old;
                  }
                });
                return true;
              }
            } else if (!declareType2.isClassType && inherit.isAliasType) {
              const [, declareGenerics = []] = this.getDeclareGenerics(declareType2);
              forEach(declareType2.types, (value2, index) => {
                let _decl = declareGenerics[index];
                if (_decl) {
                  _decl = _decl.type();
                  this.setValue(_decl, value2);
                }
              });
              return every(inherit.inherit.type(), assignType, (decl2, assignValue2) => {
                let setFlag = false;
                assignValue2 = this.arrayToUnionType(decl2, assignValue2);
                forEach(declareType2.types, (value2, index) => {
                  let _decl = declareGenerics[index];
                  if (_decl) {
                    _decl = _decl.type();
                    this.setValue(_decl, value2);
                    if (!setFlag) {
                      setFlag = every(value2, assignValue2, callback);
                    }
                  }
                });
                return true;
              });
            } else {
              const [, declareGenerics = []] = this.getDeclareGenerics(declareType2);
              let setFlag = false;
              forEach(declareType2.types, (value2, index) => {
                let _decl = declareGenerics[index];
                if (_decl) {
                  _decl = _decl.type();
                  this.setValue(_decl, value2);
                }
                if (!setFlag) {
                  setFlag = every(value2, assignType, callback);
                }
              });
              return true;
            }
          } else if (declareType2.isIntersectionType) {
            context.push("intersect");
            return forEach([declareType2.left.type(), declareType2.right.type()], (decl2) => {
              return every(decl2, assignType, callback);
            });
          } else if (declareType2.isAliasType) {
            return every(declareType2.inherit.type(), assignType, callback);
          } else if (declareType2.isFunctionType && assignType.isFunctionType) {
            context.push("function");
            const voidType = Namespace.globals.get("void");
            let assignValue2 = assignType.getInferReturnType();
            let decl2 = declareType2.returnType;
            if (decl2 && assignValue2) {
              decl2 = decl2.type();
              if (voidType !== decl2) {
                if (assignType.async) {
                  const origin = Utils.getOriginType(assignValue2);
                  const promiseType = Namespace.globals.get("Promise");
                  if (origin !== promiseType) {
                    assignValue2 = new InstanceofType(promiseType, null, [assignValue2]);
                    this.make(assignValue2);
                  }
                }
                return every(decl2, assignValue2, callback);
              }
            }
          }
          return false;
        };
        every(declareType, assignValue.type());
      }
      arrayToUnionType(declareType, assignType, isRest = false) {
        if (!declareType || !assignType || !declareType.isGenericType)
          return assignType;
        const inherit = declareType.inherit;
        const isKeyof = inherit && inherit.isKeyofType;
        if (assignType.isLiteralArrayType || assignType.isTupleType) {
          return MergeType.to(assignType, !isRest, true, isKeyof);
        }
        return assignType;
      }
    };
    module.exports = Context;
  }
});

// lib/stacks/ForOfStatement.js
var require_ForOfStatement = __commonJS({
  "lib/stacks/ForOfStatement.js"(exports, module) {
    var Context = require_Context();
    var MergeType = require_MergeType();
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var Utils = require_Utils();
    var Inference = require_Inference();
    var BlockScope = require_BlockScope();
    var ForOfStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        scope = new BlockScope(scope);
        super(compilation, node2, scope, parentNode, parentStack);
        this.isForOfStatement = true;
        this.left = this.createTokenStack(compilation, node2.left, scope, node2, this);
        this.right = this.createTokenStack(compilation, node2.right, scope, node2, this);
        this.body = this.createTokenStack(compilation, node2.body, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
        this.body.freeze();
      }
      definition() {
        return null;
      }
      forOfType() {
        return this.getAttribute("forOfType", () => {
          let rightType = this.right.type();
          let ctx = Inference.getInferenceFromType(rightType, this.right.getContext());
          let valueType = Namespace.globals.get("any");
          if (rightType && !rightType.isAnyType) {
            if (rightType.isLiteralArrayType || rightType.isUnionType || rightType.isLiteralObjectType) {
              valueType = MergeType.to(rightType, !!(rightType.isLiteralArrayType || rightType.isLiteralObjectType));
            } else if (rightType.isTupleType) {
              if (rightType.elements.length == 1 && rightType.prefix) {
                valueType = rightType.elements[0].type();
              } else {
                valueType = MergeType.to(rightType, true);
              }
            } else if (rightType.isLiteralType) {
              valueType = Namespace.globals.get("string");
            } else {
              const result = this.getIteratorResultType(rightType, ctx);
              if (result) {
                valueType = result;
              }
            }
          }
          return valueType;
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.left.parser();
        this.left.setRefBeUsed();
        this.right.parser();
        this.right.setRefBeUsed();
        if (this.body) {
          this.body.parser();
        }
        const iterator = Namespace.globals.get("Iterator");
        const object = Namespace.globals.get("Object");
        const type2 = Utils.getOriginType(this.right.type());
        if (this.left.isVariableDeclaration) {
          if (this.left.declarations.length > 1) {
            this.left.declarations[1].error(1047, "for-of");
          }
          if (this.left.declarations[0].init) {
            this.left.declarations[0].init.error(1048, "for-of");
          }
        }
        if (type2 && !type2.isAnyType && !(iterator.is(type2) || object.is(type2))) {
          this.right.error(1049, this.right.raw());
        }
      }
    };
    module.exports = ForOfStatement;
  }
});

// lib/stacks/ForStatement.js
var require_ForStatement = __commonJS({
  "lib/stacks/ForStatement.js"(exports, module) {
    var Stack = require_Stack();
    var BlockScope = require_BlockScope();
    var ForStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        scope = new BlockScope(scope);
        super(compilation, node2, scope, parentNode, parentStack);
        this.isForStatement = true;
        this.init = this.createTokenStack(compilation, node2.init, scope, node2, this);
        this.condition = this.createTokenStack(compilation, node2.test, scope, node2, this);
        this.update = this.createTokenStack(compilation, node2.update, scope, node2, this);
        this.body = this.createTokenStack(compilation, node2.body, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.init && this.init.freeze();
        this.condition && this.condition.freeze();
        this.update && this.update.freeze();
        this.body.freeze();
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.init) {
          this.init.parser();
          this.init.setRefBeUsed();
        }
        if (this.condition) {
          this.condition.parser();
          this.condition.setRefBeUsed();
        }
        if (this.update) {
          this.update.parser();
          this.update.setRefBeUsed();
        }
        if (this.body) {
          this.body.parser();
        }
      }
    };
    module.exports = ForStatement;
  }
});

// lib/stacks/FunctionDeclaration.js
var require_FunctionDeclaration = __commonJS({
  "lib/stacks/FunctionDeclaration.js"(exports, module) {
    var FunctionExpression = require_FunctionExpression();
    var FunctionDeclaration = class extends FunctionExpression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isFunctionDeclaration = true;
        this.key = this.createTokenStack(compilation, node2.id, scope, node2, this);
        if (this.key) {
          scope.define(this.key.value(), this);
        }
      }
      freeze() {
        super.freeze();
        this.key && this.key.freeze();
        Object.freeze(this.useRefItems);
      }
    };
    module.exports = FunctionDeclaration;
  }
});

// lib/stacks/GenericDeclaration.js
var require_GenericDeclaration = __commonJS({
  "lib/stacks/GenericDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var GenericDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isGenericDeclaration = true;
        this.elements = node2.elements.map((item2) => {
          const stack = this.createTokenStack(compilation, item2, scope, node2, this);
          const fnScope = scope.getScopeByType("function");
          const name = stack.value();
          const def = scope.define(name);
          if (def && this.is(def) && def.scope.getScopeByType("function") === fnScope) {
            stack.error(1056, name);
          } else {
            scope.define(name, stack);
          }
          return stack;
        });
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.elements);
      }
      description() {
        return this;
      }
      definition() {
        return null;
      }
      type() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        let isAssignLast = false;
        this.elements.forEach((item2) => {
          item2.parser();
          const isAssign = item2.isGenericTypeAssignmentDeclaration;
          if (isAssignLast && !isAssign) {
            item2.error(1058);
          }
          isAssignLast = item2.isGenericTypeAssignmentDeclaration;
        });
      }
      value() {
        const elements = this.elements.map((item2) => {
          return item2.value();
        });
        return `<${elements.join(",")}>`;
      }
      raw() {
        const elements = this.elements.map((item2) => {
          return item2.raw();
        });
        return `<${elements.join(",")}>`;
      }
    };
    module.exports = GenericDeclaration;
  }
});

// lib/types/GenericType.js
var require_GenericType = __commonJS({
  "lib/types/GenericType.js"(exports, module) {
    var Type = require_Type();
    var GenericType = class extends Type {
      constructor(target, inherit = null, assignType = null, isFunGeneric = false) {
        super("$GenericType", inherit);
        this.target = target;
        this.isGenericType = true;
        this.assignType = assignType;
        this.isFunGeneric = isFunGeneric;
        this.hasGenericType = true;
        this.unikey = null;
      }
      getUniKey() {
        const unikey = this.unikey;
        if (unikey)
          return unikey;
        const target = this.target;
        let parent = target.parentStack.parentStack;
        const index = target.parentStack.elements.indexOf(target);
        const namespace = target.namespace.toString();
        let classId = null;
        let methodId = null;
        let hash = `${String(target.parentStack.elements.length)}`;
        if (parent.isCallDefinition || parent.isNewDefinition) {
          parent = parent.parentStack;
        }
        if (parent.isClassDeclaration || parent.isInterfaceDeclaration || parent.isDeclaratorDeclaration) {
          classId = parent.id.value();
        } else if (parent.isFunctionExpression || parent.isTypeFunctionDefinition) {
          if (parent.key) {
            hash += `-${parent.params.length}`;
            if (parent.parentStack.isMethodDefinition) {
              classId = parent.parentStack.module.id;
            } else if (parent.module) {
              classId = parent.module.id;
            }
            if (parent.isDeclaratorFunction) {
              classId = parent.key.value();
            } else {
              methodId = parent.key.value();
            }
          } else if (parent.parentStack.isProperty) {
            const mStack = parent.parentStack.getParentStack((parent2) => {
              if (parent2.isMethodDefinition) {
                return true;
              }
            });
            if (parent.parentStack.module) {
              classId = parent.module.id;
            }
            if (mStack && mStack.isMethodDefinition) {
              methodId = `${mStack.key.value()}:${parent.parentStack.key.value()}`;
            } else {
              methodId = parent.parentStack.key.value();
            }
          }
        } else if (parent.isDeclaratorTypeAlias) {
          classId = parent.id;
        }
        const name = namespace ? `${namespace}.${classId}` : classId;
        const iden = methodId ? `${methodId}:${hash}-${index}` : `${hash}-${index}`;
        return this.unikey = `${name}::${iden}`;
      }
      get _extends() {
        const target = this.target;
        if (target) {
          if (target.extends) {
            return [target.extends.type()];
          }
        }
        return null;
      }
      set _extends(value2) {
      }
      get hasConstraint() {
        const target = this.target;
        if (target) {
          return !!target.extends;
        }
        return false;
      }
      attribute(property) {
        const inherit = this.inherit;
        if (!inherit) {
          return null;
        }
        if (inherit.isLiteralObjectType) {
          return inherit.attribute(property);
        } else if (inherit.isModule) {
          return inherit.getMember(property, "get");
        }
        return null;
      }
      clone(inference) {
        if (inference) {
          const result = inference(this);
          if (result) {
            return result;
          }
        }
        return this;
      }
      check(stack, context = {}, options = {}) {
        if (!stack)
          return false;
        let type2 = stack.type();
        if (!type2)
          return false;
        if (!this.isNeedCheckType(type2))
          return true;
        const inference = context && context.inference;
        if (inference) {
          let target = inference(this);
          if (target !== this) {
            let inherit = this.inherit;
            if (inherit && inherit.type().isKeyofType) {
              options.toLiteralValue = true;
            }
            return target.check(type2, context, options);
          }
        }
        return this.is(type2, context, options);
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        if (!this.isNeedCheckType(type2))
          return true;
        let inherit = this.inherit;
        if (inherit && inherit.type().isKeyofType) {
          options.toLiteralValue = true;
        }
        let target = this.inferType(this, context);
        if (target !== this) {
          if (options.toLiteralValue) {
            if (target.isLiteralArrayType || target.isTupleType) {
              return target.elements.some((base) => {
                return base.type().is(type2, context, options);
              });
            }
          }
          return target.is(type2, context, options);
        }
        if (type2.isInstanceofType) {
          type2 = type2.inherit;
        }
        if (inherit) {
          if (inherit && inherit.isLiteralObjectType) {
            return inherit.constraint(type2, context, options);
          } else {
            if (type2.isGenericType && type2.hasConstraint) {
              type2 = type2.inherit;
            }
            return inherit.type().is(type2, context, options);
          }
        }
        return false;
      }
      toString(context = {}, options = {}) {
        let inherit = this.inherit;
        if (inherit && inherit.type().isKeyofType) {
          options.toLiteralValue = true;
        }
        let complete = options.complete;
        options.complete = false;
        if (!options.rawcode) {
          if (options.onlyTypeName) {
            return this.target.value();
          }
          if (!complete) {
            const type2 = this.inferType(this, context);
            if (type2 !== this) {
              if (!(options.chain && options.chain.includes(type2) && type2.isFunctionType)) {
                return type2.toString(context, options);
              } else if (this.assignType) {
                return this.assignType.type().toString(context, options);
              }
            }
            if (options.toUniKeyValue) {
              return this.getUniKey();
            }
            return this.target.value();
          }
        }
        const parts = [];
        parts.push(this.target.value());
        if (inherit) {
          parts.push(` extends ${inherit.toString(context, options)}`);
        }
        if (this.assignType) {
          parts.push(" = " + this.assignType.toString(context, options));
        }
        return parts.join("");
      }
    };
    module.exports = GenericType;
  }
});

// lib/stacks/GenericTypeAssignmentDeclaration.js
var require_GenericTypeAssignmentDeclaration = __commonJS({
  "lib/stacks/GenericTypeAssignmentDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var GenericType = require_GenericType();
    var GenericTypeAssignmentDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isGenericTypeAssignmentDeclaration = true;
        this.left = this.createTokenStack(compilation, node2.left, scope, node2, this);
        this.extends = this.createTokenStack(compilation, node2.extends, scope, node2, this);
        this.right = this.createTokenStack(compilation, node2.right, scope, node2, this);
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.left);
        super.freeze(this.extends);
        super.freeze(this.right);
      }
      definition() {
        const type2 = this.type();
        if (type2.isModule) {
          return type2.definition();
        }
        const identifier = this.left.value();
        return {
          kind: this.kind,
          comments: this.comments,
          identifier,
          expre: `(Type) ${type2.toString()}`,
          location: this.left.getLocation(),
          file: this.compilation.file,
          context: this
        };
      }
      error(code, ...args) {
        this.left.error(code, ...args);
      }
      warn(code, ...args) {
        this.left.warn(code, ...args);
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type() {
        if (!this._type) {
          const isFunGeneric = !!(this.parentStack && this.parentStack.parentStack && this.parentStack.parentStack.isFunctionExpression);
          this._type = new GenericType(this, null, this.right.type(), isFunGeneric);
        }
        return this._type;
      }
      parser() {
        if (!super.parser())
          return false;
        this.right.parser();
        if (this.extends) {
          if (this.scope.define(this.extends.value()) === this) {
            this.extends.error(1141, this.extends.value());
          } else {
            this.extends.parser();
          }
        }
      }
      value() {
        return this.left.value();
      }
    };
    module.exports = GenericTypeAssignmentDeclaration;
  }
});

// lib/stacks/GenericTypeDeclaration.js
var require_GenericTypeDeclaration = __commonJS({
  "lib/stacks/GenericTypeDeclaration.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var GenericType = require_GenericType();
    var GenericTypeDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isGenericTypeDeclaration = true;
        this.valueType = this.createTokenStack(compilation, node2.value, scope, node2, this);
        this.extends = this.createTokenStack(compilation, node2.extends, scope, node2, this);
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.valueType);
        super.freeze(this.extends);
      }
      definition(context) {
        const type2 = this.type();
        const identifier = this.valueType.value();
        const owner = this.parentStack.parentStack;
        let ns = owner.module ? owner.module.toString(context) : owner.isDeclaratorTypeAlias ? owner.left.value() : "";
        let desc = owner.isFunctionExpression ? owner.type().toString() : ns;
        let name = owner.isFunctionExpression && owner.parentStack && owner.parentStack.key ? ns + "." + owner.parentStack.key.value() : "";
        return {
          kind: this.kind,
          comments: this.comments,
          identifier,
          expre: `(type parameter) ${type2.toString()} in ${name}${desc}`,
          location: this.valueType.getLocation(),
          file: this.compilation.file,
          context: this
        };
      }
      error(code, ...args) {
        this.valueType.error(code, ...args);
      }
      warn(code, ...args) {
        this.valueType.warn(code, ...args);
      }
      description() {
        return this;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type() {
        if (!this._type) {
          if (this.extends && this.scope.define(this.extends.value()) === this) {
            this._type = Namespace.globals.get("never");
          } else {
            const isFunGeneric = !!(this.parentStack && this.parentStack.parentStack && this.parentStack.parentStack.isFunctionExpression);
            this._type = new GenericType(this, null, null, isFunGeneric);
          }
        }
        return this._type;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.extends) {
          if (this.scope.define(this.extends.value()) === this) {
            this.extends.error(1141, this.extends.value());
          } else {
            this.extends.parser();
          }
        }
      }
      value() {
        return this.valueType.value();
      }
      raw() {
        return this.valueType.raw();
      }
    };
    module.exports = GenericTypeDeclaration;
  }
});

// lib/stacks/Identifier.js
var require_Identifier = __commonJS({
  "lib/stacks/Identifier.js"(exports, module) {
    var JSModule = require_JSModule();
    var Module = require_Module();
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var Utils = require_Utils();
    var Type = require_Type();
    var Identifier = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isIdentifier = true;
        this._hasMatchAutoImporter = false;
        this._hasLocalDefined = false;
        this.addHook();
      }
      get hasMatchAutoImporter() {
        return this._hasMatchAutoImporter;
      }
      addHook() {
        if (!this.isJSXForContext()) {
          const id = this.value();
          if (!this.parentStack.isMemberExpression || this.parentStack.node.object === this.node) {
            let desc = this.scope.define(id);
            if (desc)
              return;
          }
          if (this.module && this.module.descriptors.has(id)) {
            return;
          }
          let pp = this.parentStack;
          if ((pp.isCallExpression || pp.isNewExpression) && pp.node.callee !== this.node) {
            const code = id.charCodeAt(0);
            if (!(code >= 65 && code <= 90 || code === 95)) {
              return;
            }
          }
          const maybe = pp.isCallExpression || pp.isNewExpression || pp.isAssignmentPattern && pp.node.right === this.node || pp.isAssignmentExpression && pp.node.right === this.node || pp.isVariableDeclarator && pp.node.init === this.node || pp.isMemberExpression && pp.node.object === this.node || pp.isProperty && pp.node.value === this.node && !(pp.parentStack.isObjectPattern || pp.parentStack.isArrayPattern);
          if (maybe) {
            pp = this.getParentStack((stack) => !stack.isMemberExpression);
            if (pp) {
              if (!(pp.isCallExpression || pp.isNewExpression)) {
                const code = id.charCodeAt(0);
                if (!(code >= 65 && code <= 90 || code === 95)) {
                  return;
                }
              }
              if (pp.isPackageDeclaration || pp.isAnnotationExpression || pp.isAnnotationDeclaration || pp.isImportDeclaration || pp.isTypeDefinition) {
                return;
              }
            }
            if (this.checkNeedToLoadTypeById(id)) {
              this.compilation.hookAsync("compilation.create.after", async () => {
                if (this.module && this.module.descriptors.has(id)) {
                  return;
                }
                const desc = await this.loadTypeAsync(id);
                if (desc && desc.isModule) {
                  this.compilation.addDependency(desc, this.module);
                }
              });
            } else {
              const desc = this.scope.define(id);
              if (desc && desc.isModule) {
                this.compilation.addDependency(desc, this.module);
              }
            }
          }
        }
      }
      resolveDefinitionContext(context) {
        const pStack = this.parentStack;
        if (pStack) {
          if (this.isTypeDefinitionStack(pStack)) {
            return [pStack, context || pStack.getContext()];
          } else if ((pStack.isCallExpression || pStack.isNewExpression) && pStack.callee === this) {
            return [pStack, context || pStack.getContext()];
          }
          if (pStack.isMethodDefinition || pStack.isFunctionDeclaration || pStack.isProperty) {
            if (pStack.key === this) {
              return [pStack, context || pStack.getContext()];
            } else if (pStack.isProperty && pStack.parentStack.isObjectPattern && pStack.init === this) {
              return [pStack, context];
            }
          } else if (pStack.isVariableDeclarator) {
            if (pStack.parentStack.isDeclaratorVariable) {
              return [pStack.parentStack, context || pStack.parentStack.getContext()];
            } else if (pStack.id === this) {
              return [pStack, context || pStack.getContext()];
            }
          } else if (pStack.isClassDeclaration || pStack.isDeclaratorDeclaration || pStack.isInterfaceDeclaration || pStack.isEnumDeclaration && !pStack.isExpressionDeclare) {
            if (!context && !(pStack.inherit === this || pStack.implements.includes(this))) {
              context = pStack.getContext();
            }
          } else if (pStack.isDeclaratorTypeAlias || pStack.isDeclaratorVariable || pStack.isDeclaratorFunction) {
            return [pStack, context || pStack.getContext()];
          } else if (pStack.isAnnotationExpression) {
            const name = pStack.name.toLowerCase();
            if (name === "http" || name === "router") {
              const index = pStack.body.indexOf(this);
              if (index >= 0) {
                const args = pStack.getArguments();
                const itemArg = args[index];
                if (index < 2 || itemArg && String(itemArg.key).toLowerCase() === "action") {
                  return [pStack, context || super.getContext()];
                }
              }
            }
          } else if (pStack.isImportSpecifier || pStack.isImportDefaultSpecifier || pStack.isImportNamespaceSpecifier) {
            return [pStack, context || pStack.getContext()];
          } else if (pStack.isExportAssignmentDeclaration || pStack.isExportDefaultDeclaration || pStack.isExportNamedDeclaration || pStack.isExportSpecifier || pStack.isExportAllDeclaration) {
            return [pStack, context || this.getContext()];
          } else if (pStack.isTypeObjectPropertyDefinition || pStack.isTypeTupleRestDefinition) {
            return [pStack, context || this.getContext()];
          } else if (pStack.isMemberExpression && pStack.property === this) {
            return [pStack, context || pStack.getContext()];
          }
          const pp = this.getParentStack((p) => !p.isMemberExpression);
          if (pp.isImportDeclaration) {
            return [pp, context];
          }
        }
        const desc = this.description();
        context = context || this.getContext();
        if (desc) {
          if (desc === this && desc.isDeclarator) {
            const def = {};
            let token = this.value();
            let type2 = this.type().toString(context);
            let text = `(local ${this.kind}) ${token}:${type2}`;
            def.text = text;
            return [this, context, def, true];
          }
          if (pStack.isMemberExpression && pStack.object === this) {
            if (desc.isNamespace) {
              return [desc, context];
            }
          }
          if (Module.is(desc)) {
            return [desc, context];
          } else if (Type.is(desc)) {
            const def = this.is(desc.target) ? desc.target : desc;
            if (def)
              return [def, context];
          } else if (this.is(desc)) {
            return [desc, context, null, desc.isDeclarator];
          }
        }
        if (this.parentStack) {
          if (this.parentStack.isStructTableDeclaration || this.parentStack.isAssignmentExpression || this.parentStack.isUnaryExpression || this.parentStack.isTypeAssertExpression) {
            return null;
          } else {
            return [this.parentStack, context];
          }
        }
        return null;
      }
      definition(context) {
        if (this.value() === "arguments") {
          return {
            text: `(local const) arguments: ${this.type().toString()}`
          };
        }
        let result = this.resolveDefinitionContext(context);
        if (!result)
          return null;
        let [desc, ctx, def, isDeclarator] = result;
        if (def)
          return def;
        if (!ctx) {
          ctx = this.getContext();
        }
        ctx.setHoverStack(context && context.hoverStack || this);
        if (isDeclarator) {
          const def2 = desc.definition(ctx);
          if (def2) {
            if (desc.isDeclarator) {
              let identifier = desc.value();
              let type2 = this.type().toString(context);
              let isProperty = desc.parentStack.isPropertyDefinition;
              let token = isProperty ? `${desc.module.id}.${identifier}` : identifier;
              let expre = isProperty ? `${desc.kind || ""} ${token}:${type2}` : `(local ${desc.kind}) ${token}:${type2}`;
              def2.expre = expre;
            }
            return def2;
          }
        }
        return desc.definition(ctx);
      }
      hover(context) {
        if (this.value() === "arguments") {
          return {
            text: `(local const) arguments: ${this.type().toString()}`
          };
        }
        let result = this.resolveDefinitionContext(context);
        if (!result)
          return null;
        let [desc, ctx, def, isDeclarator] = result;
        if (def)
          return def;
        if (!ctx) {
          ctx = this.getContext();
        }
        ctx.setHoverStack(context && context.hoverStack || this);
        if (isDeclarator) {
          const def2 = desc.hover(ctx);
          if (def2) {
            if (desc.isDeclarator) {
              let identifier = desc.value();
              let type2 = this.type().toString(context);
              let isProperty = desc.parentStack.isPropertyDefinition;
              let token = isProperty ? `${desc.module.id}.${identifier}` : identifier;
              let text = isProperty ? `${desc.kind || ""} ${token}:${type2}` : `(local ${desc.kind}) ${token}:${type2}`;
              def2.text = text;
            }
            return def2;
          }
        }
        return desc.hover(ctx);
      }
      reference(called) {
        const value2 = this.value();
        const description = this.scope.define(value2);
        if (description && description !== this && description instanceof Stack) {
          return description.reference(called);
        }
        return this;
      }
      referenceItems(called) {
        const value2 = this.value();
        const description = this.scope.define(value2);
        if (description && description !== this && description instanceof Stack) {
          return description.referenceItems(called);
        }
        return [this];
      }
      getContext() {
        const desc = this.description();
        if (this.scope.allowInsertionPredicate()) {
          const predicate = this.scope.getPredicate(desc);
          if (predicate && this.is(predicate.origin) && predicate.origin.isCallExpression) {
            const ctx = predicate.origin.getContext();
            return ctx.create(this);
          }
        }
        return super.getContext();
      }
      hasLocalDefined() {
        return this._hasLocalDefined;
      }
      findDescription() {
        return this.getAttribute("Idenfifier.findDescription.result", () => {
          if (this.parentStack.isMemberExpression && !this.parentStack.computed && this.parentStack.object !== this) {
            return false;
          }
          const value2 = this.value();
          const module2 = this.module;
          let isAnnot = false;
          let p = this.parentStack;
          if (p) {
            if (p.isVariableDeclarator && p.id === this) {
              if (!p.parentStack.parentStack.isExportNamedDeclaration) {
                return false;
              }
            }
            if (p.isAssignmentPattern && p.left === this && !(p.parentStack.isArrayPattern && p.parentStack.parentStack.isAssignmentExpression)) {
              return false;
            }
            if (p.isProperty && p.key === this && !p.computed && p.hasInit) {
              return false;
            }
            isAnnot = p.isAnnotationDeclaration || p.isAnnotationExpression;
            if (!isAnnot) {
              p = p.parentStack;
              isAnnot = p.isAnnotationDeclaration || p.isAnnotationExpression;
            }
          }
          var desc = this.scope.define(value2);
          if (desc && desc.isVariableDeclarator && this.hasNestedReferenceExpression(desc.init, this)) {
            desc = null;
          }
          var global = false;
          if (desc) {
            this._hasLocalDefined = true;
          }
          if (module2 && desc === module2) {
            return { desc, global };
          }
          if (this.compilation.hasDeclareJSModule) {
            if (!desc) {
              if (JSModule.is(module2)) {
                desc = module2.namespaces.get(value2);
                if (!desc && module2.isNamespaceModule && module2.id === value2) {
                  desc = module2;
                }
              }
            } else if (this.parentStack.isMemberExpression && this.parentStack.object === this) {
              if (desc.isDeclaratorFunction || desc.isDeclaratorVariable) {
                if (JSModule.is(desc.module)) {
                  const result = desc.module.namespaces.get(value2);
                  if (result) {
                    desc = result;
                  }
                }
              }
            }
          }
          if (desc) {
            if (desc.isDeclarator)
              return { desc, global };
          } else {
            global = !this.isJSXForContext();
            const pp = this.parentStack;
            const isDecl = (pp.isEnumProperty || pp.isFunctionDeclaration || pp.isMethodDefinition) && pp.key === this || pp.isVariableDeclarator && pp.id === this;
            if (global && !isDecl) {
              if (pp.isBinaryExpression && pp.isIsOperatorFlag && pp.right === this) {
                desc = this.getModuleById(value2);
              } else if (pp.isTypeAssertExpression && pp.right === this) {
                desc = this.getModuleById(value2);
              } else {
                let priorityModule = (pp.isNewExpression || pp.isCallExpression) && pp.callee === this;
                if (priorityModule) {
                  const descriptors = Namespace.dataset.descriptors.get(value2);
                  if (descriptors && descriptors.length > 0) {
                    const result = descriptors.find((d) => d.isDeclaratorVariable);
                    if (result) {
                      desc = result;
                    }
                  }
                  if (!desc) {
                    desc = this.getModuleById(value2);
                  }
                }
                if (!desc) {
                  let isMember = pp.isMemberExpression && pp.object === this;
                  let property = null;
                  if (isMember) {
                    property = pp.property.value();
                    desc = Namespace.dataset.children.get(value2);
                    if (desc) {
                      if (!desc.descriptors.has(property)) {
                        desc = null;
                      }
                    }
                  }
                  if (!desc) {
                    if (Namespace.dataset.descriptors.has(value2)) {
                      desc = Namespace.dataset.descriptors.get(value2).find((desc2) => desc2.isModuleDeclaration || this.isModuleDefinitionStack(desc2));
                      if (desc) {
                        if (desc.isModuleDeclaration) {
                          desc = desc.module.getModuleDefaultDesriptor(property);
                        } else {
                          desc = desc.module;
                        }
                      }
                    }
                    if (!desc) {
                      desc = this.getMatchDescriptor(value2, Namespace.dataset);
                    }
                  }
                  if (!desc && !priorityModule) {
                    desc = this.getModuleById(value2);
                  }
                }
                if (desc && (!pp.isMemberExpression || pp.object === this)) {
                  if (!this.compiler.options.service && this.compilation.isLocalDocument()) {
                    if (Namespace.dataset.imports.has(value2)) {
                      this.addImportSpecifierDependency(Namespace.dataset.imports.get(value2), this);
                      this._hasMatchAutoImporter = true;
                    }
                  }
                }
              }
            }
          }
          const scopeCtx = { removed: false };
          desc = this.checkScope(desc, scopeCtx);
          if (!desc && module2 && !isAnnot && !this.parentStack.parentStack.isPropertyDefinition) {
            const isRef = !this.parentStack.isMemberExpression || this.parentStack.object === this;
            if (isRef && !this.isTypeDefinitionStack(this.parentStack)) {
              const scope = this.scope.getScopeByCallback((scope2) => scope2.isMethod && scope2.type("function") || scope2.type("class"));
              if (scope && (scope.isMethod || scope.jsx)) {
                const isStatic = !!(module2.static || scope.isStatic);
                desc = this.getMatchDescriptor(value2, module2, isStatic);
                if (!desc && scope.isMethod && !isStatic) {
                  desc = this.getMatchDescriptor(value2, module2, true);
                }
                desc = this.checkScope(desc, scopeCtx);
              }
            }
          }
          return { desc, global, scopeCtx };
        });
      }
      descriptor() {
        return this.getAttribute("Idenfifier.descriptor", () => {
          let desc = this.description();
          if (!desc)
            return null;
          let _desc = desc;
          if (desc.isImportDeclaration) {
            if (desc.hasMatchAutoImporter) {
              this._hasMatchAutoImporter = true;
              _desc = desc.description();
            } else {
              return desc.description();
            }
          }
          while (_desc && (_desc.isImportNamespaceSpecifier || _desc.isImportSpecifier || _desc.isImportDefaultSpecifier)) {
            _desc = _desc.description();
          }
          if (!_desc) {
            return Namespace.globals.get("any");
          }
          if (_desc.isVariableDeclarator || _desc.isDeclaratorVariable) {
            const type2 = _desc.type();
            if (type2 && type2.isFunctionType && type2.target && type2.target.isDeclaratorFunction) {
              _desc = type2.target;
            }
          }
          if (!_desc || _desc === desc)
            return desc;
          let rawStack = null;
          if (this.is(_desc)) {
            if (_desc.isDeclaratorTypeAlias || _desc.isTypeStatement || _desc.isClassDeclaration || _desc.isDeclaratorDeclaration || _desc.isInterfaceDeclaration || _desc.isStructTableDeclaration || _desc.isEnumDeclaration) {
              rawStack = _desc;
              _desc = _desc.type();
            }
          }
          if (_desc) {
            if (this.parentStack.isMemberExpression && this.parentStack.object === this) {
              if (JSModule.is(_desc))
                return _desc;
              if (_desc.isModuleDeclaration)
                return _desc.module;
              if (rawStack && JSModule.is(rawStack.parentStack.module)) {
                let object = rawStack.parentStack.module;
                return object.namespaces.get(rawStack.value());
              } else if (_desc.isDeclaratorFunction || _desc.isDeclaratorVariable || _desc.isDeclaratorTypeAlias) {
                if (JSModule.is(_desc.module)) {
                  let object = _desc.module;
                  return object.namespaces.get(_desc.value());
                }
              }
            } else if (this.parentStack.isNewExpression) {
              if (JSModule.is(_desc)) {
                const result = _desc.getModuleDefaultDesriptor();
                if (result) {
                  _desc = result;
                }
              }
              if (_desc.isDeclaratorFunction || _desc.isDeclaratorVariable || _desc.isDeclaratorTypeAlias || _desc.isModuleDeclaration) {
                let object = _desc.module;
                if (JSModule.is(object)) {
                  const result = object.getType(_desc.value());
                  if (result) {
                    return result;
                  }
                }
              }
            } else if (this.parentStack.isCallExpression) {
              let object = null;
              let key = this.value();
              if (JSModule.is(_desc)) {
                object = _desc;
                const result = _desc.getModuleDefaultDesriptor();
                if (result) {
                  _desc = result;
                }
              } else if (rawStack && JSModule.is(rawStack.parentStack.module)) {
                object = rawStack.parentStack.module;
                key = rawStack.value();
              } else if (_desc.isNamespaceDeclaration && JSModule.is(_desc.parentStack.module)) {
                object = _desc.parentStack.module;
                if (_desc.id.Identifier) {
                  key = _desc.id.value();
                }
              }
              if (_desc.isDeclaratorFunction || _desc.isDeclaratorVariable || _desc.isDeclaratorTypeAlias) {
                key = _desc.value();
                if (JSModule.is(_desc.module)) {
                  object = _desc.module;
                } else if (Namespace.is(_desc.namespace)) {
                  object = _desc.namespace;
                }
              }
              if (object) {
                const result = this.parentStack.getMatchDescriptor(key, object);
                if (result) {
                  return result;
                }
              }
            }
            return _desc;
          }
          return desc;
        });
      }
      description() {
        return this.getAttribute("Idenfifier.description", () => {
          const value2 = this.value();
          let isMemberExpression = false;
          let pStack = null;
          if (this.parentStack.isImportDeclaration) {
            return this.parentStack.description();
          } else if (this.parentStack.isMemberExpression && this.parentStack.object === this) {
            isMemberExpression = true;
            pStack = this.getParentStack((stack) => !stack.isMemberExpression);
            if (pStack && pStack.isImportDeclaration) {
              return Namespace.fetch(value2, null, true);
            }
          } else {
            let pp = this.parentStack;
            if (pp.isAssignmentPattern) {
              pp = pp.parentStack;
            }
            if (pp.isAnnotationExpression) {
              const name = pp.getLowerCaseName();
              if (name === "http" || name === "router") {
                const desc2 = pp.getDescriptorByStack(this);
                if (desc2) {
                  return desc2;
                }
              }
            }
          }
          let { desc, scopeCtx } = this.findDescription();
          if (desc === false)
            return null;
          if (!desc && isMemberExpression) {
            if (this.compilation.hasDeclareJSModule) {
              let pp = this.getParentStack((stack) => stack.isModuleDeclaration);
              if (pp && pp.isModuleDeclaration && pp.module) {
                let type2 = pp.module.namespaces.get(value2);
                if (type2)
                  return type2;
                const glob = JSModule.getModuleFromNamespace(value2);
                if (glob) {
                  return glob;
                }
              }
            }
            if (!this.isTypeDefinitionStack(pStack) && Namespace.top.descriptors.has(value2)) {
              return this.getMatchDescriptor(value2, Namespace.top);
            }
            return Namespace.fetch(value2, null, true);
          }
          if (!desc && scopeCtx && scopeCtx.removed) {
            this.error(1178, this.raw());
          }
          if (desc && desc.isDeclaratorVariable && desc.init === this) {
            return null;
          } else if (desc === this) {
            return null;
          }
          return desc;
        });
      }
      checkScope(desc, ctx) {
        if (this.compilation.isDescriptorDocument())
          return desc;
        let pp = this;
        if (this.parentStack.isMemberExpression) {
          if (this.parentStack.object !== this) {
            return desc;
          }
          pp = this.getParentStack((stack) => !stack.isMemberExpression);
        }
        const _desc = this.is(desc) ? desc.descriptor() : desc;
        if (_desc && _desc.compilation !== this.compilation && !this.isTypeDefinitionStack(pp.parentStack)) {
          if (!this.compiler.scopeManager.checkDescriptor(_desc, this.compilation)) {
            ctx.removed = true;
            return null;
          }
        }
        return desc;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.isJSXForContext()) {
          return true;
        }
        const description = this.description();
        if (description) {
          this.setRefBeUsed(description);
        }
        if (description && !description.isNamespace) {
          if (!(description.isMethodDefinition || description.isFunctionExpression)) {
            const type2 = description.type();
            if (type2) {
              if (type2.isModule && !this.isTypeDefinitionStack(this.parentStack)) {
                this.compilation.addDependency(type2, this.module);
              }
              this.parserDescriptor(type2);
            }
          }
        }
        if (!description) {
          this.error(1013, this.value());
        } else if ((description.isAliasType || description.isGenericTypeDeclaration || description.isTypeStatement) && !this.scope.isDirective) {
          const parent = this.parentStack;
          if (!parent.isTypeTransformExpression && !(this.isTypeDefinitionStack(parent) || parent.isGenericTypeDeclaration || parent.isBinaryExpression && parent.isIsOperatorFlag || parent.isGenericDeclaration)) {
            this.error(1059, this.value());
          }
        }
      }
      type() {
        return this.getAttribute("Identifier.type", () => {
          let type2 = null;
          let description = this.description();
          if (description) {
            if (description.isImportDeclaration) {
              description = description.description();
            }
            if (description) {
              let isSelf = this.parentStack.isAssignmentExpression && this.parentStack.left === this || this.parentStack.isVariableDeclarator && this.parentStack.id === this;
              let allow = isSelf ? false : this.scope.allowInsertionPredicate();
              if (allow) {
                const predicate = this.scope.getPredicate(description);
                if (predicate && predicate.type) {
                  return predicate.type;
                }
              }
              if (description.isImportDefaultSpecifier || description.isImportNamespaceSpecifier || description.isImportSpecifier || description.isImportDeclaration) {
                type2 = description.type();
              } else if (Namespace.is(description)) {
                type2 = description;
              } else if (description !== this && this.is(description)) {
                type2 = description.type();
              } else {
                type2 = description.type();
              }
              if (allow && type2) {
                const state = this.scope.getValidateState(description);
                if (state) {
                  if (state.value && !state.isAlternate || !state.value && state.isAlternate) {
                    type2 = Utils.inferNotNullType(type2);
                  }
                }
              }
            }
          }
          return type2 || Namespace.globals.get("any");
        });
      }
      value() {
        return this.node.name;
      }
      raw() {
        return this.node.name;
      }
    };
    module.exports = Identifier;
  }
});

// lib/stacks/IfStatement.js
var require_IfStatement = __commonJS({
  "lib/stacks/IfStatement.js"(exports, module) {
    var Stack = require_Stack();
    var BlockScope = require_BlockScope();
    var IfStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isIfStatement = true;
        this.condition = this.createTokenStack(compilation, node2.test, scope, node2, this);
        this.consequent = this.createTokenStack(compilation, node2.consequent, new BlockScope(scope), node2, this);
        this.alternate = node2.alternate ? this.createTokenStack(compilation, node2.alternate, new BlockScope(scope), node2, this) : null;
        this.hasReturnStatement = false;
        if (this.alternate && this.consequent) {
          let alternate = !!(this.alternate.hasReturnStatement || this.alternate.hasThrowStatement);
          let consequent = !!(this.consequent.hasReturnStatement || this.consequent.hasThrowStatement);
          if (!alternate && this.alternate.isBlockStatement) {
            alternate = this.alternate.body.some((item2) => !!(item2.hasReturnStatement || item2.hasThrowStatement));
          }
          if (alternate && !consequent && this.consequent.isBlockStatement) {
            consequent = this.consequent.body.some((item2) => !!(item2.hasReturnStatement || item2.hasThrowStatement));
          }
          this.hasReturnStatement = alternate && consequent;
        }
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.condition);
        super.freeze(this.consequent);
        super.freeze(this.alternate);
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (!this.condition) {
          this.error(1041);
        } else {
          this.parseConditionState(this.condition);
          this.condition.parser();
          this.condition.setRefBeUsed();
        }
        if (this.consequent) {
          this.consequent.parser();
        }
        if (this.alternate) {
          this.alternate.parser();
        }
      }
    };
    module.exports = IfStatement;
  }
});

// lib/stacks/ImportDeclaration.js
var require_ImportDeclaration = __commonJS({
  "lib/stacks/ImportDeclaration.js"(exports, module) {
    var JSModule = require_JSModule();
    var Module = require_Module();
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var Utils = require_Utils();
    var ImportDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isImportDeclaration = true;
        this.source = this.createTokenStack(compilation, node2.source, scope, node2, this);
        this.specifiers = node2.specifiers.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
        this.alias = this.createTokenStack(compilation, node2.alias, scope, node2, this);
        this.importDescriptor = null;
        this.isResolveJsModule = false;
        this.bindingToNamespace = false;
        this.hasImporterDescriptor = false;
        this._hasMatchAutoImporter = false;
        if (!this.compilation.isDescriptorDocument()) {
          this.compilation.hookAsync("compilation.parser.after", async () => {
            if (this.specifiers.length > 0) {
              this.specifiers.forEach((decl2) => {
                if (!decl2.useRefItems.size) {
                  decl2.unnecessary(1183, decl2.value());
                }
              });
            } else if (this.source && !this.source.isLiteral) {
              if (!this.useRefItems.size) {
                this.unnecessary(1183, this.source.value());
              }
            }
          });
        }
      }
      get hasMatchAutoImporter() {
        return this._hasMatchAutoImporter;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.alias);
        super.freeze(this.source);
        this.specifiers.forEach((item2) => item2.freeze());
      }
      set additional(stack) {
        this._additional = stack;
      }
      get additional() {
        return this._additional;
      }
      addUseRef(stack) {
        super.addUseRef(stack);
        const type2 = this.type();
        if (type2 && type2.isModule) {
          const module2 = (this.additional || this).module;
          this.compilation.addDependency(type2, module2);
        }
      }
      definition(ctx) {
        const compi = this.getResolveCompilation();
        const file = this.getResolveFile();
        const location = compi ? compi.stack.getLocation() : null;
        const source = this.alias || (this.source.isMemberExpression ? this.source.property : this.source);
        const id = source.isLiteral ? `"${file || source.value()}"` : source.value();
        const def = {
          text: `import ${id}`,
          file,
          location
        };
        if (ctx?.hoverStack === this.source) {
          return def;
        }
        let desc = this.description();
        if (desc) {
          return desc.definition(ctx);
        } else {
          return def;
        }
      }
      hover(ctx) {
        const file = this.getResolveFile();
        const source = this.alias || (this.source.isMemberExpression ? this.source.property : this.source);
        const id = source.isLiteral ? `"${file || source.value()}"` : source.value();
        const selection = (ctx?.hoverStack || this.source).getLocation();
        const def = {
          text: `import ${id}`,
          selection,
          file
        };
        if (ctx?.hoverStack === this.source) {
          return def;
        }
        let desc = this.description();
        if (desc) {
          return this.formatHover(def, desc.hover(ctx));
        }
        return def;
      }
      toDefinition(ctx) {
        return this.definition(ctx);
      }
      description() {
        const desc = this.getAttributeAlways("importDescriptor");
        return Module.is(desc) ? desc.type() : desc;
      }
      descriptor() {
        return this.description() || this;
      }
      getImportMatchDescriptor(object, property) {
        if (!object || !object.isNamespace)
          return null;
        const result = object.getDescriptor(property, (desc, prev) => {
          if (desc.isDeclaratorVariable || desc.isDeclaratorFunction) {
            return true;
          }
          if (prev && prev.isModuleDeclaration && prev.module) {
            return prev;
          }
          if (this.isModuleDefinitionStack(prev))
            return prev;
          return desc;
        });
        if (result) {
          if (result.isModuleDeclaration || this.isModuleDefinitionStack(result)) {
            return result.module;
          }
          return result;
        }
        return null;
      }
      async addImport(owner, scope) {
        scope = scope || this.scope;
        const add = (key, module2, stack) => {
          if (owner) {
            owner.addImport(key, module2, module2.id != key, scope);
          }
          this.compilation.importModules.set(key, module2);
          this.compilation.importModuleNameds.set(module2, key);
          module2.getStacks().forEach((def) => {
            def.addUseRef(stack);
          });
        };
        if (this.source.isLiteral) {
          const compilation = await this.getResolveCompilationAsync();
          this.specifiers.forEach((item2) => {
            item2.localBinding();
          });
          if (compilation && compilation.modules.size > 0 && !compilation.isDescriptorDocument()) {
            this.compilation.hookAsync("compilation.create.done", () => {
              this.specifiers.forEach((item2) => {
                if (item2.isImportNamespaceSpecifier) {
                  compilation.modules.forEach((module2) => {
                    add(compilation.mainModule === module2 ? item2.value() : module2.id, module2, item2);
                  });
                } else if (item2.isImportDefaultSpecifier) {
                  const desc = item2.descriptor();
                  if (Module.is(desc)) {
                    add(item2.value(), desc, item2);
                  }
                } else if (item2.isImportSpecifier) {
                  const module2 = compilation.modules.get(item2.imported.value());
                  if (module2) {
                    add(item2.value(), module2, item2);
                  }
                }
              });
            });
          }
        } else {
          const check = (key, stack) => {
            let records = scope.define(key);
            if (records) {
              let _records = records;
              if (this.is(records) && records.parentStack.isImportDeclaration) {
                records = records.parentStack;
              }
              if (records.isImportDeclaration) {
                if (records.additional === this.additional) {
                  let one = stack;
                  if (stack.isImportDeclaration) {
                    one = stack.source.isMemberExpression ? stack.source.property : stack.source;
                  }
                  one.error(1025, key);
                  _records.error(1025, key);
                }
              } else if (!this.compilation.modules.has(key)) {
                stack.error(1025, key);
                if (this.is(records)) {
                  records.error(1199, key, this.raw());
                }
              }
            }
          };
          let sourceId = this.source.value();
          if (this.source.isMemberExpression && sourceId.startsWith("global.")) {
            sourceId = sourceId.substring(7);
          }
          let result = Namespace.globals.get(sourceId);
          if (result) {
            result = this.compilation.getTypeValue(result, true);
          } else {
            result = await this.compilation.loadTypeAsync(sourceId, null, true);
          }
          let property = this.source.isMemberExpression ? this.source.property.value() : this.source.value();
          let ns = this.source.isMemberExpression ? Namespace.fetch(this.source.object.value(), null, true) : Namespace.top;
          let nameId = this.alias ? this.alias.value() : property;
          if (result) {
            this.setAttributeAlways("importDescriptor", result);
          }
          check(nameId, this);
          scope.define(nameId, this);
          this.compilation.hookAsync("compilation.create.done", () => {
            if (!result && ns) {
              result = this.getImportMatchDescriptor(ns, property) || ns.get(property);
              this.setAttributeAlways("importDescriptor", result);
            }
            if (result && Utils.isTypeModule(result)) {
              add(nameId, result, this);
            }
            if (!this.compilation.isDescriptorDocument()) {
              if (ns && ns.imports.has(property)) {
                this.hasImporterDescriptor = true;
                this._hasMatchAutoImporter = true;
                this.addImportSpecifierDependency(ns.imports.get(property), this, nameId);
              }
              if (result) {
                let compilation = result.compilation;
                if (Utils.isCompilation(compilation)) {
                  compilation.once("onRemoved", () => {
                    this.removeAttributeAlways("importDescriptor");
                    this.compiler.printLogInfo(`onRemoved: ${this.toString()}: addImport: ${compilation.file}`, "Stack");
                  });
                }
              }
            }
          });
        }
      }
      getResolveFile() {
        return this.getAttribute("getResolveFile", () => {
          let source = this.source.isLiteral ? this.source.value() : this.source.value().replace(".", "/");
          let resolve = this.compiler.resolveDescriptorFile(source, this.compilation.file);
          if (!resolve) {
            resolve = this.compiler.resolveManager.resolveFile(
              source,
              this.compilation.file
            );
            if (resolve && resolve === this.file) {
              resolve = null;
            }
          }
          if (!resolve && this.source.isLiteral) {
            resolve = this.source.value();
          }
          return resolve;
        });
      }
      getResolveCompilation() {
        return this.getAttributeAlways("resolveCompilation");
      }
      getResolveJSModule(resolvedCompilation = null) {
        return this.getAttributeAlways("getResolveJSModule", () => {
          if (this.source && this.source.isLiteral) {
            let source = this.source.value();
            let resolve = this.getResolveFile();
            let module2 = JSModule.getModule(source, resolve);
            if (module2) {
              return module2;
            }
            let raw = source;
            if (resolve && resolve !== source) {
              if (source.includes("/")) {
                source = source.slice(source.lastIndexOf("/") + 1);
              }
            }
            const describeSuffix = this.compiler.options.describeSuffix;
            if (describeSuffix && source.endsWith(describeSuffix)) {
              source = source.substring(0, source.length - describeSuffix.length);
            }
            if (raw !== source) {
              module2 = JSModule.getModule(source, resolve);
            }
            if (!module2 && resolvedCompilation) {
              module2 = JSModule.getByFile(resolvedCompilation.file);
            }
            return module2;
          }
          return null;
        });
      }
      async getResolveCompilationAsync() {
        if (this.hasAttributeAlways("resolveCompilation")) {
          return this.getAttributeAlways("resolveCompilation");
        }
        let source = this.source.value();
        if (this.compiler.manifester.hasResource(source, true)) {
          await this.compilation.loadManifest(source, null, true);
        }
        let hasResolve = this.compiler.checkFileExt(this.getResolveFile());
        let compilation = null;
        if (hasResolve) {
          compilation = await this.compilation.createChildCompilation(this.getResolveFile(), this.compilation.file);
          if (compilation === this.compilation) {
            compilation = null;
          }
        }
        const jsModule = this.getResolveJSModule(compilation);
        if (jsModule) {
          this.isResolveJsModule = true;
          if (!compilation) {
            compilation = jsModule.compilation;
          }
        } else if (compilation) {
          compilation.import = "importSpecifier";
        }
        if (hasResolve && !compilation) {
          this.source.error(1132, source);
        }
        if (compilation && !this.compilation.isDescriptorDocument()) {
          compilation.once("onRemoved", () => {
            this.isResolveJsModule = false;
            this.removeAttributeAlways("resolveCompilation");
            this.removeAttributeAlways("getResolveJSModule");
            this.compiler.printLogInfo(`onRemoved: ${this.toString()}: getResolveCompilationAsync: ${compilation.file}`, "Stack");
          });
        }
        this.setAttributeAlways("resolveCompilation", compilation);
        return compilation;
      }
      getDescByName(desc, key) {
        if (!desc || desc.isAnyType)
          return null;
        if ((desc.isAliasType || desc.isLiteralObjectType) && !desc.isModule) {
          if (desc.isAliasType)
            desc = desc.inherit;
          if (desc.isLiteralObjectType) {
            return desc.attribute(key);
          }
        } else if (desc.isNamespace) {
          let result = desc.get(key);
          if (!result) {
            result = desc.descriptors.get(key);
            if (result && result[0])
              return result[0];
          }
          return result;
        }
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.source.isLiteral) {
          if (this.specifiers.length > 0) {
            const compilation = this.getResolveCompilation();
            let len = 0;
            if (compilation) {
              const jsModule = this.isResolveJsModule ? this.getResolveJSModule() : null;
              if (jsModule) {
                len = jsModule.getExportCount();
              } else if (compilation.stack) {
                len = compilation.stack.exports.length;
              }
            }
            let noExported = true;
            this.specifiers.forEach((item2) => {
              item2.parser();
              if (noExported && item2.description()) {
                noExported = false;
              }
            });
            if (compilation && noExported && !(len > 0)) {
              this.error(1162, this.source.value());
            }
          }
        } else {
          const desc = this.description();
          if (!desc) {
            this.error(1026, this.source.value());
          } else {
            this.source.setRefBeUsed(desc);
          }
        }
      }
      type() {
        return this.description() || Namespace.globals.get("any");
      }
      value() {
        return this.source.value();
      }
    };
    module.exports = ImportDeclaration;
  }
});

// lib/stacks/ImportDefaultSpecifier.js
var require_ImportDefaultSpecifier = __commonJS({
  "lib/stacks/ImportDefaultSpecifier.js"(exports, module) {
    var Declarator = require_Declarator();
    var Namespace = require_Namespace();
    var Module = require_Module();
    var JSModule = require_JSModule();
    var ImportDefaultSpecifier = class extends Declarator {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2.local, scope, parentNode, parentStack);
        this.isImportDefaultSpecifier = true;
        this._kind = "const";
      }
      freeze() {
        super.freeze(this);
      }
      definition(ctx) {
        let compi = this.parentStack.getResolveCompilation();
        let file = this.parentStack.getResolveFile();
        let location = compi ? compi.stack.getLocation() : null;
        if (!compi) {
          file = this.file;
          location = this.getLocation();
        }
        const def = {
          text: `import ${this.value()}`,
          file,
          location
        };
        const desc = this.descriptor();
        if (desc) {
          if (!desc.isNamespaceDeclaration && !Module.is(desc)) {
            if (JSModule.is(desc.module)) {
              const items = desc.module.descriptors.get(desc.value());
              if (items) {
                return items.map((stack) => stack.definition(ctx));
              }
            } else if (desc.isDeclaratorFunction && Namespace.is(desc.namespace)) {
              const items = desc.namespace.descriptors.get(desc.value());
              if (items) {
                return items.map((stack) => stack.definition(ctx));
              }
            }
          }
          return desc.definition(ctx);
        }
        return def;
      }
      hover(ctx) {
        const selection = (ctx?.hoverStack || this).getLocation();
        const def = {
          text: `import ${this.value()}`,
          selection
        };
        const desc = this.descriptor();
        if (desc) {
          if (!desc.isNamespaceDeclaration && !Module.is(desc)) {
            if (JSModule.is(desc.module)) {
              const items = desc.module.descriptors.get(desc.value());
              if (items) {
                return this.formatHover(def, items.map((stack) => stack.hover(ctx)));
              }
            } else if (desc.isDeclaratorFunction && Namespace.is(desc.namespace)) {
              const items = desc.namespace.descriptors.get(desc.value());
              if (items) {
                return this.formatHover(def, items.map((stack) => stack.hover(ctx)));
              }
            }
          }
          return this.formatHover(def, desc.hover(ctx));
        }
        return def;
      }
      toDefinition(ctx) {
        return this.definition(ctx);
      }
      description() {
        return this.getAttribute("description", () => {
          if (this.parentStack.source.isLiteral) {
            const compilation = this.parentStack.getResolveCompilation();
            if (compilation) {
              const jsModule = this.parentStack.isResolveJsModule ? this.parentStack.getResolveJSModule() : null;
              if (jsModule) {
                return jsModule.getExport("default");
              }
            }
            if (compilation) {
              if (compilation.stack && compilation.stack.exports.length > 0) {
                const result = compilation.stack.exports.find((item2) => item2.isExportDefaultDeclaration);
                if (result) {
                  return result.description();
                }
              }
            }
            const source = this.parentStack.source.value();
            const desc = Namespace.globals.get(source);
            if (desc) {
              if (Module.is(desc)) {
                return desc;
              } else if (desc.isDeclaratorFunction || desc.isDeclaratorVariable) {
                return desc;
              }
            }
          }
          return null;
        });
      }
      descriptor() {
        const desc = this.description();
        if (desc && desc.isImportDefaultSpecifier)
          return desc.descriptor();
        return desc;
      }
      type() {
        const desc = this.description();
        if (desc)
          return desc.type();
        return Namespace.globals.get("any");
      }
      localBinding() {
        const name = this.value();
        const additional = this.parentStack.additional;
        if (additional) {
          const binding = additional.isDeclaratorVariable || additional.isDeclaratorFunction || additional.isDeclaratorDeclaration || additional.isDeclaratorTypeAlias;
          if (binding && additional.value() === name) {
            return true;
          }
        }
        if (this.parentStack.parentStack.isPackageDeclaration) {
          if (this.compilation.isDescriptorDocument()) {
            this.namespace.imports.set(name, this);
            this.parentStack.bindingToNamespace = true;
          }
        }
        if (this.scope.isDefine(name)) {
          const old = this.scope.define(name);
          if (old && old.compilation === this.compilation && !this.compilation.isDescriptorDocument()) {
            this.error(1025, name);
          }
        }
        this.scope.define(name, this);
      }
      parser() {
        if (super.parser() === false)
          return false;
        const desc = this.description();
        if (desc) {
          this.setRefBeUsed(desc);
        } else {
          const compilation = this.parentStack.getResolveCompilation();
          if (compilation) {
            this.error(1193, this.parentStack.source.value(), this.value());
          }
        }
      }
    };
    module.exports = ImportDefaultSpecifier;
  }
});

// lib/stacks/ImportExpression.js
var require_ImportExpression = __commonJS({
  "lib/stacks/ImportExpression.js"(exports, module) {
    var Stack = require_Stack();
    var Utils = require_Utils();
    var ImportExpression = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isImportExpression = true;
        this.source = this.createTokenStack(compilation, node2.source, scope, node2, this);
        this.compilation.hookAsync("compilation.create.after", async () => {
          if (this.source.isLiteral) {
            await this.getResolveCompilationAsync();
          } else {
            const desc = await this.loadTypeAsync(this.source.value());
            if (desc && desc.isModule) {
              this.compilation.addDependency(desc, this.module);
            }
          }
        });
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.source);
      }
      definition(ctx) {
        const desc = this.description();
        if (desc) {
          return desc.definition(ctx);
        }
        let compi = this.parentStack.getResolveCompilation();
        let file = compi ? compi.file : null;
        let location = compi ? compi.stack.getLocation() : null;
        const def = {
          text: `import("${file || this.source.value()}")`,
          file,
          location
        };
        return def;
      }
      hover(ctx) {
        let compi = this.parentStack.getResolveCompilation();
        let file = compi ? compi.file : null;
        let selection = (ctx?.hoverStack || this.source).getLocation();
        const def = {
          text: `import("${file || this.source.value()}")`,
          selection
        };
        const desc = this.description();
        if (desc) {
          return this.formatHover(def, desc.hover(ctx));
        }
        return def;
      }
      description() {
        if (this.source) {
          if (this.source.isLiteral) {
            const compilation = this.getResolveCompilation();
            if (compilation && compilation.modules.size > 0) {
              return compilation.mainModule;
            }
          } else {
            return this.getModuleById(this.source.value());
          }
        }
        return null;
      }
      getResolveFile() {
        return this.getAttribute("getResolveFile", () => {
          const id = this.source.isLiteral ? this.source.value() : this.source.value().replace(".", "/");
          const resolve = this.resolve = this.compiler.resolveManager.resolveFile(
            id,
            id.includes(".") ? id : this.compilation.file
          );
          if (!resolve) {
            this.source.error(1122, this.source.value());
          }
          return resolve;
        });
      }
      getResolveCompilation() {
        return this.getAttributeAlways("resolveCompilation");
      }
      async getResolveCompilationAsync() {
        if (this.hasAttributeAlways("resolveCompilation")) {
          return this.getAttributeAlways("resolveCompilation");
        }
        let compilation = null;
        if (this.compiler.checkFileExt(this.getResolveFile())) {
          compilation = await this.compilation.createChildCompilation(this.getResolveFile(), this.compilation.file);
          if (!compilation) {
            this.source.error(1132, this.source.value());
          } else {
            if (this.compilation.isDescriptorDocument()) {
              compilation.once("onRemoved", () => {
                this.removeAttributeAlways("resolveCompilation");
                this.compiler.printLogInfo(`onRemoved: ${this.toString()}: getResolveCompilationAsync: ${compilation.file}`, "Stack");
              });
            }
            if (compilation.mainModule) {
              this.compilation.addDependency(compilation.mainModule, this.module);
            } else {
              this.compilation.addDependency(compilation);
            }
            compilation.import = "importSpecifier";
          }
        }
        this.setAttributeAlways("resolveCompilation", compilation);
        return compilation;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.source) {
          const module2 = this.description();
          if (!module2) {
            if (this.compiler.checkFileExt(this.getResolveFile())) {
              const file = this.source.value();
              if (file) {
                this.source.error(1026, this.source.value());
              } else {
                this.source.error(1060, this.source.value());
              }
            }
          } else {
            module2.used = true;
            this.compilation.addDependency(module2, this.module);
          }
        } else {
          this.error(1e3, 1, 0);
        }
      }
      type() {
        return this.description() || this.getGlobalTypeById("any");
      }
      value() {
        return this.source.value();
      }
      raw() {
        return this.source.raw();
      }
    };
    module.exports = ImportExpression;
  }
});

// lib/stacks/ImportNamespaceSpecifier.js
var require_ImportNamespaceSpecifier = __commonJS({
  "lib/stacks/ImportNamespaceSpecifier.js"(exports, module) {
    var Declarator = require_Declarator();
    var Namespace = require_Namespace();
    var LiteralObjectType = require_LiteralObjectType();
    var ImportNamespaceSpecifier = class extends Declarator {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2.local, scope, parentNode, parentStack);
        this.isImportNamespaceSpecifier = true;
        this._kind = "const";
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.local);
      }
      definition(ctx) {
        let desc = this.description();
        if (desc) {
          return desc.definition(ctx);
        }
        let compi = this.parentStack.getResolveCompilation();
        let file = this.parentStack.getResolveFile();
        let location = compi ? compi.stack.getLocation() : null;
        if (!compi) {
          file = this.file;
          location = this.getLocation();
        }
        const def = {
          text: `import * as ${this.value()}`,
          location,
          file
        };
        return def;
      }
      hover(ctx) {
        let selection = (ctx?.hoverStack || this).getLocation();
        const def = {
          expre: `import * as ${this.value()}`,
          selection
        };
        let desc = this.description();
        if (desc) {
          return this.formatHover(def, desc.hover(ctx));
        }
        return def;
      }
      toDefinition(ctx) {
        return this.definition(ctx);
      }
      description() {
        return this.getAttribute("description", () => {
          if (this.parentStack.source.isLiteral) {
            const compilation = this.parentStack.getResolveCompilation();
            if (compilation) {
              const jsModule = this.parentStack.isResolveJsModule ? this.parentStack.getResolveJSModule() : null;
              if (jsModule) {
                this.setRefBeUsed(jsModule);
                return jsModule;
              }
            }
            if (compilation && compilation.stack && compilation.stack.exports.length > 0) {
              const properties = /* @__PURE__ */ new Map();
              let exportDefault = null;
              compilation.stack.exports.forEach((stack) => {
                this.setRefBeUsed(stack);
                if (stack.isExportDefaultDeclaration) {
                  exportDefault = stack.description();
                } else if (stack.isExportNamedDeclaration || stack.isExportAllDeclaration) {
                  stack.getAllExportDescriptors(stack).forEach((value2, key) => {
                    properties.set(key, value2);
                  });
                }
              });
              if (exportDefault) {
                properties.set("default", exportDefault);
              }
              return properties.size > 0 ? new LiteralObjectType(Namespace.globals.get("object"), null, properties) : Namespace.globals.get("object");
            }
            const source = this.parentStack.source.value();
            const desc = Namespace.globals.get(source) || Namespace.fetch(source);
            if (desc) {
              if (desc.isStack && (desc.isDeclaratorFunction || desc.isDeclaratorVariable)) {
                this.setRefBeUsed(desc);
                return desc;
              } else if (Namespace.is(desc)) {
                return desc;
              }
            }
          }
          return null;
        });
      }
      descriptor() {
        const desc = this.description();
        if (desc && desc.isImportNamespaceSpecifier)
          return desc.descriptor();
        return desc;
      }
      type() {
        const desc = this.description();
        if (desc) {
          if (desc.isNamespace)
            return desc;
          return desc.type();
        }
        return Namespace.globals.get("any");
      }
      localBinding() {
        if (this.node.type === "Identifier") {
          const name = this.value();
          const additional = this.parentStack.additional;
          if (additional) {
            const binding = additional.isDeclaratorVariable || additional.isDeclaratorFunction || additional.isDeclaratorDeclaration || additional.isDeclaratorTypeAlias;
            if (binding && additional.value() === name) {
              return true;
            }
          }
          if (this.parentStack.parentStack.isPackageDeclaration) {
            if (this.compilation.isDescriptorDocument()) {
              this.namespace.imports.set(name, this);
              this.parentStack.bindingToNamespace = true;
            }
          }
          if (this.scope.isDefine(name)) {
            const old = this.scope.define(name);
            if (old && old.compilation === this.compilation && !this.compilation.isDescriptorDocument()) {
              this.error(1025, name);
            }
          }
          this.scope.define(name, this);
        }
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.description();
      }
    };
    module.exports = ImportNamespaceSpecifier;
  }
});

// lib/stacks/ImportSpecifier.js
var require_ImportSpecifier = __commonJS({
  "lib/stacks/ImportSpecifier.js"(exports, module) {
    var Declarator = require_Declarator();
    var Namespace = require_Namespace();
    var Module = require_Module();
    var JSModule = require_JSModule();
    var ImportSpecifier = class extends Declarator {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2.local, scope, parentNode, parentStack);
        this.isImportSpecifier = true;
        this.imported = this.createTokenStack(compilation, node2.imported, scope, node2, this);
        this._kind = "const";
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.imported);
      }
      // get useRefItems(){
      //    const dataset = this.fetchUseRefItems();
      //    return dataset || super.useRefItems;
      // }
      // fetchUseRefItems(){
      //      if(!this.parentStack.source.isLiteral)return null;
      //      const compilation = this.parentStack.getResolveCompilation();
      //      if(compilation)return null;
      //      const source = this.parentStack.source.value();
      //      const desc = Namespace.fetch(source, null, true);
      //      if(desc && desc.isNamespace && desc.descriptors.has(this.imported.value())){
      //          const dataset = super.useRefItems;
      //          desc.getDescriptor(this.imported.value(), (desc)=>{
      //              if( desc.isStack && desc.useRefItems){
      //                  desc.useRefItems.forEach( (value)=>{
      //                      if(value && value.compilation === this.compilation){
      //                         dataset.add(value);
      //                      }
      //                  });
      //              }
      //          });
      //          return dataset;
      //      }
      //      return null;
      // }
      definition(ctx) {
        let compi = this.parentStack.getResolveCompilation();
        let file = this.parentStack.getResolveFile();
        let location = compi ? compi.stack.getLocation() : null;
        if (!compi) {
          file = this.file;
          location = (this.imported || this).getLocation();
        }
        const def = {
          expre: `import ${this.value()}`,
          file,
          location
        };
        let desc = this.descriptor();
        if (desc) {
          if (!desc.isNamespaceDeclaration && !Module.is(desc)) {
            if (JSModule.is(desc.module)) {
              const items = desc.module.descriptors.get(desc.value());
              if (items) {
                return items.map((stack) => stack.definition(ctx));
              }
            } else if (desc.isDeclaratorFunction && Namespace.is(desc.namespace)) {
              const items = desc.namespace.descriptors.get(desc.value());
              if (items) {
                return items.map((stack) => stack.definition(ctx));
              }
            }
          }
          return desc.definition(ctx);
        }
        return def;
      }
      hover(ctx) {
        let selection = (ctx?.hoverStack || this.imported || this).getLocation();
        const def = {
          expre: `import ${this.value()}`,
          selection
        };
        let desc = this.descriptor();
        if (desc) {
          if (!desc.isNamespaceDeclaration && !Module.is(desc)) {
            if (JSModule.is(desc.module)) {
              const items = desc.module.descriptors.get(desc.value());
              if (items) {
                return this.formatHover(def, items.map((stack) => stack.hover(ctx)));
              }
            } else if (desc.isDeclaratorFunction && Namespace.is(desc.namespace)) {
              const items = desc.namespace.descriptors.get(desc.value());
              if (items) {
                return this.formatHover(def, items.map((stack) => stack.hover(ctx)));
              }
            }
          }
          return this.formatHover(def, desc.hover(ctx));
        }
        return def;
      }
      toDefinition(ctx) {
        return this.definition(ctx);
      }
      description() {
        const desc = this.getDescription();
        if (desc && desc.isExportAssignmentDeclaration) {
          return null;
        }
        return desc;
      }
      descriptor() {
        const desc = this.description();
        if (desc && desc.isImportSpecifier)
          return desc.descriptor();
        return desc;
      }
      getDescription() {
        return this.getAttribute("getDescription", () => {
          if (this.parentStack.source.isLiteral) {
            const compilation = this.parentStack.getResolveCompilation();
            if (compilation) {
              const jsModule = this.parentStack.isResolveJsModule ? this.parentStack.getResolveJSModule() : null;
              if (jsModule) {
                return jsModule.getExport(this.imported.value());
              }
            }
            if (compilation) {
              if (compilation.stack && compilation.stack.exports.length > 0) {
                const imported = this.imported.value();
                const exports2 = compilation.stack.exports;
                for (var i = 0; exports2.length > i; i++) {
                  const item2 = exports2[i];
                  if (item2.isExportAllDeclaration) {
                    const desc2 = item2.getAllExportDescriptors().get(imported);
                    if (desc2)
                      return desc2;
                  } else if (item2.isExportNamedDeclaration) {
                    const desc2 = item2.getDescByName(imported);
                    if (desc2)
                      return desc2;
                  } else if (item2.isExportAssignmentDeclaration) {
                    return item2;
                  }
                }
              }
              const source = this.parentStack.source.value();
              const desc = Namespace.fetch(source, null, true);
              if (desc) {
                const key = this.imported.value();
                const result = desc.descriptors.get(key);
                if (result && result[0])
                  return result[0];
                return desc.get(key);
              }
            } else if (!compilation) {
              const source = this.parentStack.source.value();
              const desc = Namespace.fetch(source);
              if (desc) {
                const imports = desc.imports;
                if (Array.isArray(imports) && imports.some((imp) => imp === this.parentStack)) {
                  return null;
                }
                return this.parentStack.getDescByName(desc, this.imported.value());
              }
            }
          }
          return null;
        });
      }
      type() {
        const desc = this.description();
        if (desc)
          return desc.type();
        return Namespace.globals.get("any");
      }
      localBinding() {
        const name = this.value();
        const additional = this.parentStack.additional;
        if (additional) {
          const binding = additional.isDeclaratorVariable || additional.isDeclaratorFunction || additional.isDeclaratorDeclaration || additional.isDeclaratorTypeAlias;
          if (binding && additional.value() === name) {
            return true;
          }
        }
        if (this.parentStack.parentStack.isPackageDeclaration) {
          if (this.compilation.isDescriptorDocument()) {
            this.namespace.imports.set(name, this);
            this.parentStack.bindingToNamespace = true;
          }
        }
        if (this.scope.isDefine(name)) {
          const old = this.scope.define(name);
          if (old && old.compilation === this.compilation && !this.compilation.isDescriptorDocument()) {
            this.error(1025, name);
          }
        }
        this.scope.define(name, this);
      }
      parser() {
        if (super.parser() === false)
          return false;
        const desc = this.getDescription();
        if (!desc) {
          const compilation = this.parentStack.getResolveCompilation();
          if (compilation) {
            (this.imported || this).error(1164, this.parentStack.source.value(), this.imported.value());
          }
        } else {
          if (desc.isExportAssignmentDeclaration) {
            (this.imported || this).error(1193, this.parentStack.source.value(), this.imported.value());
          } else {
            (this.imported || this).setRefBeUsed(desc);
          }
        }
      }
    };
    module.exports = ImportSpecifier;
  }
});

// lib/stacks/InterfaceDeclaration.js
var require_InterfaceDeclaration = __commonJS({
  "lib/stacks/InterfaceDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var Utils = require_Utils();
    var ClassScope = require_ClassScope();
    var InterfaceDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        scope = new ClassScope(scope);
        super(compilation, node2, scope, parentNode, parentStack);
        this.isInterfaceDeclaration = true;
        this.isInterfaceDecorator = !!node2.decorator;
        this._metatypes = [];
        this._annotations = [];
        this.body = [];
        this.usings = [];
        this._imports = [];
        this.id = this.createTokenStack(compilation, node2.id, scope, node2, this);
        const module2 = this.module = compilation.createModule(this.namespace, this.id.value());
        module2.isInterfaceDecorator = this.isInterfaceDecorator;
        this.id.module = module2;
        this.extends = (node2.extends || []).map((item2) => {
          let _extend = this.createTokenStack(compilation, item2, scope, node2, this);
          if (item2.genericity) {
            _extend.assignGenerics = item2.genericity.map((item3) => this.createTokenStack(compilation, item3, scope, node2, this));
          }
          return _extend;
        });
        this.inherit = this.extends[0] || null;
        this.implements = (node2.implements || []).map((item2) => {
          const stack = this.createTokenStack(compilation, item2, scope, node2, this);
          if (item2.genericity) {
            stack.assignGenerics = item2.genericity.map((item3) => this.createTokenStack(compilation, item3, scope, node2, this));
          }
          return stack;
        });
        if (this.extends.length > 1) {
          this.implements.unshift(...this.extends.slice(1));
        }
        scope.parent.define(module2.id, module2);
        this.modifier = this.createTokenStack(compilation, node2.modifier, scope, node2);
        this.genericity = this.createTokenStack(compilation, node2.genericity, scope, node2, this);
        module2.isInterface = true;
        compilation.addModuleStack(module2, this);
      }
      set metatypes(value2) {
        value2.forEach((item2) => {
          item2.additional = this;
        });
        if (value2.length > 0) {
          this._metatypes = value2;
        }
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value2) {
        value2.forEach((annotation) => {
          annotation.additional = this;
        });
        if (value2.length > 0) {
          this._annotations = value2;
        }
      }
      get annotations() {
        return this._annotations;
      }
      set imports(items) {
        if (Array.isArray(items)) {
          items.forEach((item2) => {
            if (item2.isImportDeclaration) {
              item2.additional = this;
            }
          });
          this._imports = items;
        }
      }
      get imports() {
        return this._imports;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.id);
        super.freeze(this.scope);
        super.freeze(this.inherit);
        super.freeze(this.implements);
        super.freeze(this.imports);
        super.freeze(this.modifier);
        super.freeze(this.genericity);
        super.freeze(this.module);
        super.freeze(this.body);
        (this.body || []).forEach((stack) => stack.freeze());
      }
      definition(context) {
        const module2 = this.module;
        context = context || this.getContext();
        context.scopeGenerics = true;
        let location = (this.id || this).getLocation();
        return {
          kind: "interface",
          comments: this.comments,
          expre: `interface ${module2.toString(context)}`,
          location,
          file: this.file
        };
      }
      async createCompleted() {
        const compilation = this.compilation;
        const self = this.module;
        await this.allSettled(this.imports, async (stack) => {
          const module2 = await stack.addImport(this.module, this.parentStack.scope);
          if (module2 && module2.isType) {
            if (this.checkDepend(this.module, module2)) {
              stack.error(1024, stack.value());
            }
          }
        });
        if (this.inherit) {
          let stack = this.inherit;
          let id = stack.value();
          let module2 = stack.getReferenceModuleType();
          let load = false;
          let local2 = stack.isMemberExpression ? stack.getFirstMemberStack().value() : id;
          if (!this.scope.isDefine(local2)) {
            module2 = await this.loadTypeAsync(id);
            load = true;
          }
          let push = (module3, stack2) => {
            if (!module3) {
              stack2.error(1027, id);
            } else {
              if (Utils.checkDepend(self, module3)) {
                stack2.error(1024, id, self.getName(), module3.getName());
              } else {
                self.extends = module3;
                module3.used = true;
                if (!module3.children.some((child) => Utils.isEqualModule(child, self))) {
                  module3.children.push(self);
                }
                this.compilation.addDependency(module3, self);
              }
            }
          };
          if (module2 || !load) {
            push(module2, stack);
          } else if (load) {
            this.compilation.hookAsync("compilation.create.done", () => {
              push(stack.getReferenceModuleType(), stack);
            });
          }
        }
        const impls = self.implements;
        const pushImp = (module2, stack) => {
          if (module2 && self !== module2) {
            if (!(module2.isInterface || module2.isDeclaratorModule || module2.isStructTable)) {
              stack.error(1028, stack.value());
            } else {
              impls.push(module2);
              this.compilation.addDependency(module2, self);
            }
          } else {
            stack.error(1029, stack.value());
          }
        };
        await this.allSettled(this.implements, async (stack) => {
          let id = stack.value();
          let module2 = stack.getReferenceModuleType();
          let load = false;
          let local2 = stack.isMemberExpression ? stack.getFirstMemberStack().value() : id;
          if (!this.scope.isDefine(local2)) {
            module2 = await this.loadTypeAsync(id);
            load = true;
          }
          if (module2 || !load) {
            pushImp(module2, stack);
          } else if (load) {
            this.compilation.hookAsync("compilation.create.done", () => {
              pushImp(stack.getReferenceModuleType(), stack);
            });
          }
        });
        const metatypes = [];
        const annotations = [];
        (this.node.body || []).map((item2) => {
          const stack = this.createTokenStack(compilation, item2, this.scope, this.node, this);
          if (stack.isUseStatement) {
            this.usings.push(stack);
          } else if (stack.isMetatypeDeclaration) {
            metatypes.push(stack);
          } else if (stack.isAnnotationDeclaration) {
            annotations.push(stack);
          } else {
            stack.metatypes = metatypes.splice(0, metatypes.length);
            stack.annotations = annotations.splice(0, annotations.length);
            this.body.push(stack);
          }
        });
      }
      genericsCheck(typeModule, assignGenerics, aStack) {
        if (!typeModule)
          return;
        if (assignGenerics && assignGenerics.length > 0) {
          assignGenerics.forEach((item2) => {
            item2.parser();
          });
        }
        const [stackModule, declareGenerics = []] = typeModule.getModuleDeclareGenerics(false, false, true);
        const _compilation = typeModule.compilation;
        if (_compilation && _compilation.stack) {
        }
        if (stackModule) {
          if (aStack) {
            aStack.setRefBeUsed();
          }
          assignGenerics = assignGenerics || [];
          const requires = declareGenerics.filter((item2) => !item2.isGenericTypeAssignmentDeclaration);
          const lastStack = assignGenerics[assignGenerics.length - 1] || aStack || this.id;
          if (requires.length > assignGenerics.length || assignGenerics.length > declareGenerics.length) {
            if (requires.length === declareGenerics.length) {
              lastStack.error(1030, typeModule.toString(), requires.length);
            } else {
              lastStack.error(1031, typeModule.toString(), requires.length, declareGenerics.length);
            }
          }
          if (declareGenerics.length > 0) {
            assignGenerics.forEach((item2, index) => {
              const declareType = declareGenerics[index] && declareGenerics[index].type();
              if (declareType && declareType.hasConstraint && !declareType.check(item2)) {
                item2.error(1003, item2.type().toString(), declareType.toString());
              }
            });
          }
        }
      }
      type() {
        return this.module;
      }
      description() {
        return this;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.imports.forEach((item2) => item2.parser());
        this.usings.forEach((item2) => item2.parser());
        if (this.genericity) {
          this.genericity.parser();
          this.genericity.setRefBeUsed();
        }
        this.metatypes.forEach((item2) => item2.parser());
        this.annotations.forEach((item2) => item2.parser());
        if (this.inherit) {
          const inheritImport = this.inherit.description();
          if (this.is(inheritImport) && (inheritImport.isImportDeclaration || inheritImport.parentStack.isImportDeclaration)) {
            this.inherit.setRefBeUsed(inheritImport);
          }
          let inherit = this.module.getInheritModule();
          if (inherit) {
            this.inherit.setRefBeUsed(inherit);
            this.genericsCheck(inherit, this.inherit.assignGenerics, this.inherit);
            if (this.inherit.assignGenerics && this.inherit.assignGenerics.length > 0) {
              this.module.setAssignGenerics(inherit.type(), this.inherit.assignGenerics);
            }
          }
        }
        this.implements.forEach((stack) => {
          const impImport = stack.description();
          if (impImport && impImport.isImportDeclaration) {
            stack.setRefBeUsed(impImport);
          }
          const impModule = stack.getReferenceModuleType();
          if (impModule) {
            stack.setRefBeUsed(impModule);
            this.genericsCheck(impModule, stack.assignGenerics, stack);
            if (stack.assignGenerics && stack.assignGenerics.length > 0) {
              this.module.setAssignGenerics(impModule, stack.assignGenerics);
            }
          }
        });
        this.body.forEach((item2) => item2.parser());
        this.module.ckeckAllDescriptors();
      }
      value() {
        return this.id.value();
      }
      raw() {
        return this.node.name;
      }
    };
    module.exports = InterfaceDeclaration;
  }
});

// lib/stacks/JSXAttribute.js
var require_JSXAttribute = __commonJS({
  "lib/stacks/JSXAttribute.js"(exports, module) {
    var BlockScope = require_BlockScope();
    var Stack = require_Stack();
    var MergeType = require_MergeType();
    var Utils = require_Utils();
    var { Parser } = require_Parser();
    var Declarator = require_Declarator();
    var Namespace = require_Namespace();
    var LiteralObjectType = require_LiteralObjectType();
    var JSXAttribute = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isJSXAttribute = true;
        this.jsxElement = parentStack.jsxElement;
        this.name = this.createTokenStack(compilation, node2.name, this.scope, node2, this);
        this.value = this.createTokenStack(compilation, node2.value, this.scope, node2, this);
        this.hasNamespaced = !!this.name.isJSXNamespacedName;
        this.isAttributeXmlns = this.hasNamespaced ? this.name.namespace.value().toLowerCase() === "xmlns" : false;
        this.isAttributeDirective = false;
        this.isMemberProperty = false;
        if (this.isAttributeXmlns && parentStack && parentStack.parentStack.isJSXElement) {
          parentStack.parentStack.xmlns.push(this);
        }
        if (this.isAttributeXmlns && this.jsxElement.jsxRootElement !== this.jsxElement) {
          this.name.error(1117);
        }
        if (this.hasNamespaced && !this.isAttributeXmlns) {
          const xmlns = this.name.getXmlNamespace();
          const jsxConfig = this.compiler.options.jsx || {};
          let ns = null;
          if (xmlns && xmlns.value) {
            ns = xmlns.value.value();
          } else {
            const nsStack = this.getNamespaceStack();
            ns = jsxConfig.xmlns && jsxConfig.xmlns.default[nsStack.namespace.value().toLowerCase()] || ns;
          }
          if (ns) {
            let custom = "";
            if (ns.includes("::")) {
              const [_ns, _custom] = ns.split("::", 2);
              ns = _ns;
              custom = _custom;
            }
            if (ns === "@directives") {
              const sections = jsxConfig.xmlns && jsxConfig.xmlns.sections;
              const directives = sections[ns];
              if (this.value && this.jsxElement.jsxRootElement === this.jsxElement) {
                this.value.error(1115);
              }
              if (directives) {
                let dName = custom ? custom.toLowerCase() : this.name.value();
                if (!(directives.includes(dName) || directives.includes("*"))) {
                  this.name.error(1125, directives.join(","));
                } else {
                  this.isAttributeDirective = true;
                }
                const newContext = jsxConfig.xmlns.context || [];
                if (newContext.includes(dName)) {
                  this.scope = new BlockScope(this.scope);
                  this.scope.isDirective = true;
                  const dName2 = this.name.value().toLowerCase();
                  const isFor = dName2 === "for" || dName2 === "each";
                  this.scope.isForContext = this.scope.parent.isForContext || isFor;
                  this.scope.forContextScope = (isFor ? this.scope : this.scope.parent.forContextScope) || null;
                  this.parentStack.scope = this.scope;
                  this.parentStack.parentStack.scope = this.scope;
                }
              }
            } else if (ns === "@slots") {
              this.isAttributeSlot = true;
              this.jsxElement.hasAttributeSlot = true;
              if (this.value) {
                this.scope = new BlockScope(this.scope);
                this.scope.isAttributeSlotScope = true;
                this.parentStack.scope = this.scope;
                this.parentStack.parentStack.scope = this.scope;
              }
            } else if (ns === "@events" || ns === "@natives") {
              this.isAttributeEvent = true;
            } else if (ns === "@binding") {
              this.isAttributeBinding = true;
            }
          }
        }
        this.addHook();
      }
      addHook() {
        if (this.isAttributeXmlns) {
          let namespace = this.value && this.value.value();
          if (namespace) {
            if (namespace.includes("::")) {
              const [_ns, defineClass] = namespace.split("::", 2);
              if (_ns === "@events") {
                this.compilation.hookAsync("compilation.create.after", async () => {
                  await this.loadTypeAsync(defineClass);
                });
              }
            }
          }
        }
      }
      freeze() {
        super.freeze();
        this.name.freeze();
        this.value.freeze();
      }
      definition(context) {
        if (this.isAttributeXmlns) {
          const str = [this.name.name.value(), this.value && this.value.value()].filter((value2) => !!value2).join(": ");
          return {
            kind: "namespace",
            comments: null,
            identifier: this.name.name.value(),
            expre: `(xmlns) ${str}`,
            location: this.value ? this.value.getLocation() : this.name.name.getLocation(),
            file: this.compilation.file,
            range: this.name.node.loc
          };
        } else if (this.isAttributeDirective) {
          return null;
        }
        if (this.hasNamespaced) {
          var xmlns = this.getXmlNamespace();
          var namespace = xmlns && xmlns.value ? xmlns.value.value() : null;
          if (namespace && namespace.includes("::")) {
            const [namespace2, defineClass] = namespace2.split("::", 2);
            if (namespace2 === "@events") {
              const defineClassModule = this.getModuleById(defineClass);
              if (defineClassModule) {
                const desc2 = this.getAttributeDescription(defineClassModule, "get");
                if (desc2) {
                  const def = desc2.definition(context);
                  if (def) {
                    def.range = this.name.name.getLocation();
                    return def;
                  }
                }
              }
            }
          }
        }
        if (this.isAttributeSlot && this.value) {
          return {
            expre: `(local var) ${this.value.value()}: ${this.type().toString()}`,
            location: this.value.getLocation(),
            file: this.file
          };
        } else if (this.jsxElement.isSlot) {
          const isLocal = context ? context.stack !== this.name : false;
          if (this.jsxElement.isSlotDeclared) {
            if (this.value) {
              const desc2 = this.value.description();
              return {
                expre: `(refs) ${this.name.value()}: ${this.value.type().toString()}`,
                location: desc2 && desc2.isStack ? desc2.getLocation() : this.value.getLocation(),
                file: desc2 && desc2.isStack ? desc2.file : this.value.file
              };
            } else {
              return {
                expre: `(refs) ${this.name.value()}: any`,
                location: this.name.getLocation(),
                file: this.name.file
              };
            }
          } else {
            const el = this.jsxElement;
            const slotName = el.openingElement.name.value();
            const desc2 = el.getSlotDescription(slotName);
            const key = this.value ? this.value : this.name;
            let type2 = Namespace.globals.get("any");
            let stack = key;
            if (desc2) {
              if (desc2.isJSXElement) {
                const attributes = desc2.openingElement ? desc2.openingElement.attributes : [];
                const _key = this.name.value();
                const attr = attributes.length === 1 ? attributes[0] : attributes.find((attr2) => attr2.name.value() === _key);
                if (attr && attr.isJSXAttribute && attr.value) {
                  stack = attr.name;
                  type2 = attr.value.type();
                }
              } else if (desc2.isAnnotation && desc2.args && desc2.args.length > 0) {
                const _key = this.name.value();
                const argument = desc2.args.length === 1 ? desc2.args[0] : desc2.args.find((arg) => arg.name === _key);
                if (argument) {
                  if (argument.stack)
                    stack = argument.stack;
                  if (argument.type)
                    type2 = argument.type;
                }
              }
            }
            if (isLocal) {
              return {
                expre: `(local var) ${key.value()}: ${type2.toString()}`,
                location: key.getLocation(),
                file: key.file
              };
            } else {
              return {
                expre: `(refs) ${key.value()}: ${type2.toString()}`,
                location: stack.getLocation(),
                file: stack.file
              };
            }
          }
        }
        const desc = this.description();
        if (desc) {
          const def = desc.definition(context);
          return def;
        }
        const elem = this.parentStack.parentStack;
        if (elem && elem.isJSXStyle && elem.absoluteFile) {
          return {
            kind: "attr",
            comments: null,
            identifier: this.name.value(),
            expre: `(attr) ${this.name.value()}: ${elem.absoluteFile.replace(/\\/g, "/")}`,
            location: {
              start: { column: 0, line: 1 },
              end: { column: 0, line: 1 }
            },
            range: (context.stack || this.value).getLocation(),
            file: elem.absoluteFile
          };
        }
        return null;
      }
      reference() {
        if (this.value) {
          return this.value.reference();
        }
        return null;
      }
      referenceItems() {
        if (this.value) {
          return this.value.referenceItems();
        }
        return [];
      }
      getNamespaceStack() {
        if (this.name.isJSXNamespacedName) {
          return this.name;
        } else if (this.name.isJSXMemberExpression && this.name.object.isJSXNamespacedName) {
          return this.name.object;
        }
        return null;
      }
      getXmlNamespace(ns) {
        if (this.parentStack.isJSXOpeningElement) {
          const stack = this.getNamespaceStack();
          return this.parentStack.getXmlNamespace(ns || stack.namespace.value());
        }
        return null;
      }
      getAttributeDescription(desc, kind = "set") {
        if (desc && desc.isModule) {
          const argument = this.value ? this.value : Namespace.globals.get("boolean");
          const name = this.name.isJSXNamespacedName ? this.name.name.value() : this.name.value();
          return desc.getDescriptor(name, (desc2, prev, index) => {
            if (desc2.isMethodSetterDefinition) {
              const params = desc2.params || [];
              if (params[0] && this.checkMatchType(argument, params[0], argument.type())) {
                return true;
              }
              return desc2;
            } else if (desc2.isPropertyDefinition && !desc2.isReadonly) {
              if (this.checkMatchType(argument, desc2, argument.type())) {
                return true;
              }
              return desc2;
            }
            return false;
          });
        }
        return null;
      }
      description() {
        if (this.isAttributeDirective || this.jsxElement.isDirective) {
          return this._directiveDesc;
        } else if (!this.isAttributeXmlns) {
          return this.getAttribute("description", () => {
            const value2 = this.value;
            let desc = null;
            if (this.jsxElement.isSlot) {
              if (this.jsxElement.isSlotDeclared) {
                return value2 ? value2.description() : null;
              } else {
                const el = this.jsxElement;
                const slotName = el.openingElement.name.value();
                desc = el.getSlotDescription(slotName);
              }
            } else if (this.isAttributeSlot) {
              desc = this.getSlotAttrDescription();
            }
            if (desc) {
              if (desc.isJSXElement) {
                const attributes = desc.openingElement ? desc.openingElement.attributes : [];
                if (attributes.length === 1) {
                  return attributes[0].value.description();
                } else {
                  const properties = /* @__PURE__ */ new Map();
                  attributes.forEach((attr) => {
                    if (attr.value) {
                      properties.set(attr.name.value(), attr.value);
                    }
                  });
                  return new LiteralObjectType(Namespace.globals.get("object"), null, properties);
                }
              } else if (desc.isAnnotation && desc.args && desc.args.length > 0) {
                if (desc.args.length === 1) {
                  return desc.args[0].type;
                } else {
                  const properties = /* @__PURE__ */ new Map();
                  desc.args.forEach((attr) => {
                    if (attr.type) {
                      properties.set(attr.name, attr.type);
                    }
                  });
                  return new LiteralObjectType(Namespace.globals.get("object"), null, properties);
                }
              }
            }
            const elem = this.parentStack.parentStack;
            if (elem.isJSXElement && elem.isComponent) {
              return this.getAttributeDescription(elem.descriptor());
            }
          });
        }
        return null;
      }
      type() {
        return this.getAttribute("type", () => {
          let desc = null;
          if (this.jsxElement.isSlot) {
            if (this.jsxElement.isSlotDeclared) {
              if (this.value) {
                return this.value.type();
              }
              return Namespace.globals.get("any");
            } else {
              const el = this.jsxElement;
              const slotName = el.openingElement.name.value();
              desc = el.getSlotDescription(slotName);
            }
          } else if (this.isAttributeSlot && this.value) {
            desc = this.getSlotAttrDescription();
          } else {
            return Namespace.globals.get("void");
          }
          if (desc) {
            if (desc.isJSXElement) {
              const attributes = desc.openingElement ? desc.openingElement.attributes : [];
              const properties = /* @__PURE__ */ new Map();
              attributes.forEach((attr) => {
                if (attr.value) {
                  properties.set(attr.name.value(), attr.value);
                }
              });
              return new LiteralObjectType(Namespace.globals.get("object"), null, properties);
            } else if (desc.isAnnotation && desc.args && desc.args.length > 0) {
              const properties = /* @__PURE__ */ new Map();
              let props = null;
              desc.args.forEach((attr) => {
                if (attr.type && !props) {
                  if ((attr.name === "scope" || attr.name === "props") && attr.type.isLiteralObjectType) {
                    props = attr.type;
                    return;
                  }
                  properties.set(attr.name, attr.type);
                }
              });
              if (props) {
                return props;
              }
              return new LiteralObjectType(Namespace.globals.get("object"), null, properties);
            }
          }
          return Namespace.globals.get("any");
        });
      }
      createType(descStack, name, type2) {
        type2 = type2 || descStack.type();
        if (descStack && type2) {
          let _type = MergeType.forOfItem(type2);
          if (_type !== type2) {
            _type.definition = () => {
              return {
                expre: `(local var) ${name}:${_type.toString()}`,
                location: this.value.getLocation(),
                file: this.compilation.file
              };
            };
          }
          return _type;
        }
        return Namespace.globals.get("any");
      }
      checkConditionStatementDirective() {
        const index = this.jsxElement.parentStack.childrenStack.indexOf(this.jsxElement);
        const prevStack = this.jsxElement.parentStack.childrenStack[index - 1];
        if (prevStack && prevStack.isJSXElement) {
          if (prevStack.isDirective) {
            const directiveName = prevStack.openingElement.name.value().toLowerCase();
            if (directiveName === "if" || directiveName === "elseif") {
              return true;
            }
          }
          return prevStack.openingElement.attributes.some((item2) => {
            if (item2.isAttributeDirective) {
              const directiveName = item2.name.value().toLowerCase();
              return directiveName === "if" || directiveName === "elseif";
            }
            return false;
          });
        }
        return false;
      }
      parserDirective() {
        if (this._directiveDesc !== void 0) {
          return this._directiveDesc;
        }
        this._directiveDesc = null;
        this.valueArgument = { expression: null, declare: {} };
        const name = this.name.value().toLowerCase();
        let desc = null;
        if (name === "if" || name === "elseif") {
          if (name === "elseif") {
            if (!this.checkConditionStatementDirective()) {
              this.name.error(1156);
            }
          }
          if (!this.value || this.value.isLiteral && !this.value.value().trim()) {
            this.error(1144, `condition`);
          } else {
            desc = this.parserAttributeValueStack();
            this.valueArgument.expression = desc;
          }
        } else if (name === "each" || name === "for") {
          this.scope.isForContext = true;
          if (this.value && this.value.isJSXExpressionContainer) {
            this.value.error(1121);
          } else {
            const value2 = this.value.value();
            const divide = value2.match(/\s+(of|in)\s+/i);
            var item2 = null;
            if (divide) {
              const startAt = this.value.node.start + 1;
              item2 = this.parserAttributeValueStack(this.compilation.source.substr(0, startAt + divide.index), startAt, true);
              desc = this.parserAttributeValueStack(this.compilation.source.substr(0, startAt + value2.length), startAt + divide.index + divide[0].length, false, this.jsxElement.parentStack.scope);
            } else {
              if (name === "each") {
                this.value.error(1116);
              } else {
                this.value.error(1121);
              }
            }
            if (desc) {
              desc.parser();
              this.valueArgument.expression = desc;
              const descType = desc.type();
              const originType = Utils.getOriginType(descType);
              if (originType && !originType.isAnyType) {
                if (name === "each" && !Namespace.globals.get("array").is(descType)) {
                  this.value.error(1119, descType.toString());
                } else if (originType.isNullableType || originType.isNeverType || originType.isVoidType || Namespace.globals.get("boolean").is(originType)) {
                  this.value.error(1049, descType.toString());
                }
              }
            }
            if (item2) {
              item2.parser();
              if (item2.isParenthesizedExpression) {
                item2 = item2.expression;
              }
              const segments = item2.isSequenceExpression ? item2.expressions : [item2];
              const refType = desc ? desc.type() : null;
              let makeType = refType;
              if (makeType) {
                makeType = MergeType.forOfItem(makeType);
                if (Utils.isStack(desc)) {
                  const ctx = desc.getContext();
                  if (makeType === refType) {
                    const result = this.getIteratorResultType(makeType, ctx);
                    if (result) {
                      makeType = result;
                    }
                  } else {
                    makeType = ctx.apply(makeType);
                  }
                }
              }
              const mapTypes = [
                makeType ? makeType : Namespace.globals.get("any"),
                Namespace.globals.get("string"),
                Namespace.globals.get("number")
              ];
              if (refType && name === "each" && (refType.isLiteralArrayType || refType.isTupleType)) {
                mapTypes[1] = mapTypes[2];
              }
              const mapNames = ["item", "key", "index"];
              if (!(segments.length >= 1 && segments.length <= 3)) {
                this.value.error(1121);
              } else {
                segments.forEach((stack, index) => {
                  (function(stack2, _type) {
                    stack2.isDeclarator = true;
                    stack2.kind = "let";
                    stack2.type = function type2() {
                      return _type;
                    };
                    stack2.description = function description() {
                      return this;
                    };
                    stack2.definition = function definition(ctx) {
                      return {
                        text: `(local let) ${this.value()}:${this.type().toString(ctx | this.getContext())}`,
                        location: this.getLocation(),
                        file: this.compilation.file
                      };
                    };
                    stack2.hover = function hover(ctx) {
                      return {
                        text: `(local let) ${this.value()}:${this.type().toString(ctx | this.getContext())}`
                      };
                    };
                  })(stack, mapTypes[index]);
                  const name2 = stack.value();
                  this.valueArgument.declare[mapNames[index]] = name2;
                  this.jsxElement.scope.define(name2, stack);
                });
              }
            }
          }
        } else if (name === "else") {
          if (!this.checkConditionStatementDirective()) {
            this.name.error(1156);
          }
        } else if (name === "custom") {
          if (!this.value) {
            this.name.error(1145, 1, 0);
          } else if (this.value.isJSXExpressionContainer) {
            const expression = this.value.type();
            if (expression && expression.isLiteralObjectType) {
              const result = ["name", "value"].every((name2) => {
                return !!expression.attribute(name2);
              });
              if (!result) {
                this.name.error(1171);
              }
            } else {
              this.name.error(1171);
            }
          } else {
            this.name.error(1171);
          }
        } else {
          desc = this.parserAttributeValueStack();
          this.valueArgument.expression = desc;
        }
        return this._directiveDesc = desc;
      }
      parserSlotScopeParamsStack() {
        if (!this.value || this.isAttributeDirective || !(this.jsxElement.isSlot || this.isAttributeSlot))
          return null;
        return this.getAttribute("parserSlotScopeParamsStack", () => {
          if (!this.value.isLiteral) {
            const value2 = this.value.isJSXExpressionContainer ? this.value.expression : this.value;
            if (!value2)
              return null;
            if (value2.isIdentifier) {
              return new Declarator(this.compilation, value2.node, this.scope, this.node, this);
            } else {
              this.value.error(1169);
              return null;
            }
          }
          try {
            const scope = this.scope;
            const startAt = this.value.node.start + 1;
            const len = this.value.value().length;
            const node2 = Parser.parseBindingAtom(this.compilation.source.substr(0, startAt + len), startAt, this.compilation.compiler.options.parser);
            if (node2.type === "Identifier") {
              return new Declarator(this.compilation, node2, scope, this.node, this);
            }
            const stack = this.createTokenStack(
              this.compilation,
              node2,
              scope,
              this.node,
              this
            );
            return stack;
          } catch (e) {
            this.value.error(1085, e.message);
          }
          return null;
        });
      }
      parserAttributeValueStack(content, startAt = 0, isDeclarator = false, scope = null, noParser = false) {
        if (this._attributeValueStack !== void 0 && !content) {
          return this._attributeValueStack;
        }
        const context = this.jsxElement.getSubClassDescription();
        const createStack = (expression, startAt2) => {
          if (!expression || expression.length === startAt2) {
            return null;
          }
          try {
            this.value.module = this.module || context && context.type();
            this.value.isFragment = true;
            let node2 = Parser.parseExpressionAt(expression, startAt2, this.compilation.compiler.options.parser);
            const stack = this.createTokenStack(
              this.compilation,
              node2,
              scope || this.scope,
              this.value.node,
              this.value
            );
            if (stack) {
              if (!noParser)
                stack.parser();
              if (!isDeclarator) {
                const desc = stack.description();
                if (desc) {
                  this.setRefBeUsed(desc);
                } else {
                  stack.error(1013, stack.value());
                }
              }
            }
            return stack;
          } catch (e) {
            this.value.error(1085, e.message);
          }
        };
        if (content) {
          return createStack(content, startAt);
        } else if (this.value) {
          if (this.value.isJSXExpressionContainer) {
            return this.value;
          } else {
            const startAt2 = this.value.node.start + 1;
            const len = this.value.value().length;
            return this._attributeValueStack = createStack(this.compilation.source.substr(0, startAt2 + len), startAt2);
          }
        }
        return null;
      }
      getAttributeName() {
        if (this.hasNamespaced) {
          const nsStack = this.getNamespaceStack();
          if (nsStack) {
            return nsStack.namespace.value().toLowerCase() + ":" + nsStack.name.value();
          }
        }
        return this.name.value();
      }
      getSlotAttrDescription() {
        if (!this.isAttributeSlot)
          return null;
        const slotDesc = this.__slotDesc;
        if (slotDesc !== void 0)
          return slotDesc;
        const el = this.jsxElement;
        if (el && el.parentStack && el.parentStack.isWebComponent) {
          const slotName = this.name.value();
          return this.__slotDesc = el.parentStack.getSlotDescription(slotName, el.parentStack.descriptor()) || null;
        }
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.value) {
          this.value.parser();
        }
        if (this.jsxElement.isDirective) {
          const direName = this.jsxElement.openingElement.name.value().toLowerCase();
          if (direName !== "custom") {
            const name = this.name.value();
            if (["condition", "name", "item", "key", "index"].includes(name)) {
              const scope = name === "name" ? this.jsxElement.parentStack.scope : this.scope;
              const desc = this.parserAttributeValueStack(null, 0, !(name === "name" || name === "condition"), scope);
              this._directiveDesc = desc;
              return true;
            }
          }
        }
        if (this.jsxElement.isSlot) {
          if (this.jsxElement.isSlotDeclared) {
            if (!this.value) {
              this.name.error(1170, this.name.value());
            }
          } else if (!this.isAttributeDirective) {
            if (this.value) {
              let _stack = this.parserSlotScopeParamsStack();
              if (_stack) {
                if (_stack.isObjectPattern) {
                  _stack.properties.forEach((propery) => {
                    if (propery.init.isAssignmentPattern) {
                      this.scope.define(propery.init.left.value(), propery);
                    } else {
                      this.scope.define(propery.init.value(), propery);
                    }
                  });
                } else if (_stack.isDeclarator) {
                  this.jsxElement.scope.define(_stack.value(), _stack);
                }
              }
            } else {
              this.jsxElement.scope.define(this.name.value(), this);
            }
          }
        }
        if (this.isAttributeSlot) {
          const el = this.jsxElement;
          const slotName = this.name.value();
          if (el && el.parentStack && el.parentStack.isWebComponent) {
            const pSlot = this.getSlotAttrDescription();
            if (!pSlot && slotName !== "default") {
              this.name.warn(1126, slotName);
            }
            if (this.value) {
              let _stack = this.parserSlotScopeParamsStack();
              if (_stack) {
                if (_stack.isObjectPattern) {
                  _stack.properties.forEach((propery) => {
                    if (propery.init.isAssignmentPattern) {
                      this.scope.define(propery.init.left.value(), propery);
                    } else {
                      this.scope.define(propery.init.value(), propery);
                    }
                  });
                } else if (_stack.isDeclarator) {
                  this.scope.define(_stack.value(), _stack);
                }
              }
            }
          } else {
            this.name.name.error(1157, slotName);
          }
        }
        if (this.isAttributeDirective) {
          this.parserDirective();
        } else if (this.isAttributeBinding) {
          if (this.value && !this.value.isJSXExpressionContainer) {
            this.parserAttributeValueStack();
          }
        } else {
          const nsStack = this.getNamespaceStack();
          const jsxConfig = this.compiler.options.jsx || { xmlns: {} };
          if (this.isAttributeXmlns) {
            let namespace = this.value && this.value.value();
            if (namespace) {
              if (namespace.includes("::")) {
                const [_ns, defineClass] = namespace.split("::", 2);
                if (_ns === "@events") {
                  const defineClassModule = this.getModuleById(defineClass);
                  namespace = _ns;
                  if (!Utils.isClassType(defineClassModule)) {
                    this.name.error(1027, defineClass);
                  }
                }
              }
            }
          } else if (this.hasNamespaced) {
            const xmlns = this.getXmlNamespace() || jsxConfig.xmlns.default[nsStack.namespace.value().toLowerCase()];
            if (!xmlns) {
              this.error(1098, nsStack.namespace.value());
            } else {
              let namespace = xmlns.value && xmlns.value.value();
              if (namespace && namespace.includes("::")) {
                const [_, defineClass] = namespace.split("::", 2);
                const defineClassModule = this.getModuleById(defineClass);
                const desc = defineClassModule && defineClassModule.getMethod(nsStack.name.value(), "get");
                if (!desc) {
                } else {
                  this.setRefBeUsed(desc);
                  this.compilation.addDependency(defineClassModule, this.module);
                }
              }
            }
          }
        }
      }
    };
    module.exports = JSXAttribute;
  }
});

// lib/stacks/Literal.js
var require_Literal = __commonJS({
  "lib/stacks/Literal.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var LiteralType = require_LiteralType();
    var keySymbol = Symbol("key");
    var Literal = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isLiteral = true;
        this[keySymbol] = {};
      }
      definition(context) {
        if (this.parentStack.isImportDeclaration || this.parentStack.isExportAllDeclaration || this.parentStack.isExportDefaultDeclaration || this.parentStack.isExportNamedDeclaration) {
          return this.parentStack.definition(this.getContext());
        }
        return null;
      }
      hover() {
        if (this.parentStack.isImportDeclaration || this.parentStack.isExportAllDeclaration || this.parentStack.isExportDefaultDeclaration || this.parentStack.isExportNamedDeclaration) {
          return this.parentStack.hover(this.getContext());
        }
      }
      reference() {
        return this;
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      getTypeName() {
        const node2 = this.node;
        let type2 = "string";
        if (node2.regex) {
          type2 = "regexp";
        } else if (node2.value == node2.raw) {
          type2 = "uint";
          if (this.parentStack.isUnaryExpression) {
            type2 = "int";
          } else if (node2.raw.includes(".")) {
            type2 = "float";
          }
        } else if (node2.raw === "false" || node2.raw === "true") {
          type2 = "boolean";
        } else if (node2.raw === "null") {
          type2 = "nullable";
        } else if (node2.raw === "undefined") {
          type2 = "undefined";
        }
        return type2;
      }
      type() {
        return this.getAttribute("type", () => {
          let type2 = this.getTypeName();
          let final = Namespace.globals.get(type2);
          if (!(type2 === "regexp" || type2 === "nullable")) {
            return new LiteralType(final, this.parentStack.isTypeDefinition ? this.parentStack : this, this.node.value);
          }
          return final;
        });
      }
      value() {
        return this.node.value;
      }
      raw() {
        return this.node.raw;
      }
    };
    module.exports = Literal;
  }
});

// lib/stacks/JSXCdata.js
var require_JSXCdata = __commonJS({
  "lib/stacks/JSXCdata.js"(exports, module) {
    var Literal = require_Literal();
    var JSXCdata = class extends Literal {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.jsxElement = parentStack.jsxElement;
        this.isJSXCdata = true;
      }
    };
    module.exports = JSXCdata;
  }
});

// lib/stacks/JSXClosingElement.js
var require_JSXClosingElement = __commonJS({
  "lib/stacks/JSXClosingElement.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var JSXClosingElement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isJSXClosingElement = true;
        this.jsxElement = parentStack.jsxElement;
        this.name = this.createTokenStack(compilation, node2.name, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.name && this.name.freeze();
      }
      definition(context) {
        if (this.jsxElement) {
          return this.jsxElement.definition(context);
        }
        const stack = context && context.stack;
        if (this.parentStack && this.parentStack.hasNamespaced) {
          if (stack) {
            const xmlns = this.parentStack.getXmlNamespace();
            const namespace = xmlns && xmlns.value && xmlns.value.value();
            const space = this.parentStack.isProperty ? Namespace.fetch(namespace, null, true) : Namespace.create(namespace, true);
            const desc = this.name.description(space, stack);
            return desc ? desc.definition(context) : null;
          } else {
            const desc = this.parentStack.description();
            if (desc) {
              return desc.definition(context);
            }
          }
        } else if (this.parentStack.isJSXElement) {
          return this.parentStack.definition(context);
        }
        return null;
      }
      reference() {
        return null;
      }
      referenceItems() {
        return [];
      }
      description() {
        return null;
      }
      type() {
        return this.getGlobalTypeById("void");
      }
      value() {
        return this.name.value();
      }
    };
    module.exports = JSXClosingElement;
  }
});

// lib/stacks/JSXClosingFragment.js
var require_JSXClosingFragment = __commonJS({
  "lib/stacks/JSXClosingFragment.js"(exports, module) {
    var Stack = require_Stack();
    var JSXClosingFragment = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isJSXClosingFragment = true;
        this.jsxElement = parentStack.jsxElement;
      }
      definition() {
        return null;
      }
      reference() {
        return null;
      }
      referenceItems() {
        return [];
      }
      description() {
        return null;
      }
      type() {
        return this.getGlobalTypeById("void");
      }
    };
    module.exports = JSXClosingFragment;
  }
});

// lib/stacks/JSXElement.js
var require_JSXElement = __commonJS({
  "lib/stacks/JSXElement.js"(exports, module) {
    var Stack = require_Stack();
    var Namespace = require_Namespace();
    var InstanceofType = require_InstanceofType();
    var BlockScope = require_BlockScope();
    var MergeType = require_MergeType();
    var Utils = require_Utils();
    var TupleType = require_TupleType();
    var JSXElement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isJSXElement = true;
        this.jsxRootElement = parentStack.jsxRootElement || this;
        this.jsxElement = this;
        this.xmlns = [];
        this.directives = null;
        this.isSlot = false;
        this.isSlotDeclared = false;
        this.isDirective = false;
        this.isWebComponent = false;
        this.isSkinComponent = false;
        this.ownerProperty = null;
        this.newCreatedScope = false;
        this.openingElement = this.createTokenStack(compilation, node2.openingElement, this.scope, node2, this);
        if (this.hasNamespaced) {
          const nsStack = this.getNamespaceStack();
          const jsxConfig = this.compiler.options.jsx || {};
          const xmlns = this.getXmlNamespace();
          let namespace = xmlns && xmlns.value ? xmlns.value.value() : jsxConfig.xmlns.default[nsStack.namespace.value()];
          if (namespace === "@directives") {
            this.scope = new BlockScope(this.scope);
            this.scope.isDirective = true;
            const dName = this.openingElement?.name?.value().toLowerCase();
            const isFor = dName === "for" || dName === "each";
            this.scope.isForContext = this.scope.parent.isForContext || isFor;
            this.scope.forContextScope = (isFor ? this.scope : this.scope.parent.forContextScope) || null;
            this.isDirective = true;
            this.syncOpeningElementScopeOf();
          } else if (namespace === "@slots") {
            this.scope = new BlockScope(this.scope);
            this.scope.isSlotScope = true;
            this.syncOpeningElementScopeOf();
          }
        }
        this.children = node2.children.filter((item2) => {
          return !(item2.type == "JSXText" && !item2.value.trim());
        }).map(
          (item2) => this.createTokenStack(compilation, item2, this.scope, node2, this)
        );
        if (this.jsxRootElement === this) {
          this.children.sort((a, b) => {
            return a.isJSXScript || a.isJSXStyle ? -1 : 0;
          });
          this.compilation.jsxElements.push(this);
        }
        this.closingElement = this.createTokenStack(compilation, node2.closingElement, this.scope, node2, this);
        this.addHook();
      }
      syncOpeningElementScopeOf() {
        this.openingElement.scope = this.scope;
        this.openingElement.attributes.forEach((attr) => {
          attr.scope = this.scope;
          attr.name.scope = this.scope;
          if (attr.value)
            attr.value.scope = this.scope;
        });
      }
      addHook() {
        if (!(this.hasNamespaced || this.openingElement.name.isJSXMemberExpression) || this.isSlot || this.isDirective)
          return;
        const id = this.getFullClassName();
        if (id && !this.hasModuleById(id)) {
          this.compilation.hookAsync("compilation.create.after", async () => {
            await this.loadTypeAsync(id);
          });
        } else if (id && !this.scope.define(id)) {
          const type2 = Namespace.globals.get(id);
          if (Utils.isModule(type2)) {
            this.compilation.addDependency(type2, this.module);
          }
        }
      }
      getFullClassName() {
        return this.getAttribute("getLoadClassName", () => {
          if (this.hasNamespaced) {
            const stack = this.getNamespaceStack();
            const ns = stack.namespace.value();
            const name = this.openingElement.value();
            const xmlns = this.getXmlNamespace(ns);
            if (xmlns) {
              const jsxConfig = this.compiler.options.jsx || {};
              const sections = jsxConfig.xmlns && jsxConfig.xmlns.sections;
              const namespace = xmlns && xmlns.value ? xmlns.value.value() : jsxConfig.xmlns.default[ns];
              if (namespace && sections[namespace]) {
                return null;
              }
              return namespace && namespace !== "@" ? `${namespace}.${name}` : name;
            } else {
              return `${ns}.${name}`;
            }
          } else {
            return this.openingElement.name.value();
          }
        });
      }
      async createCompleted() {
        if (!this.compilation.JSX || !this.module)
          return;
        if (this.parentStack && this.parentStack.isProgram) {
          const id = this.getFullClassName();
          if (id) {
            const desc = await this.loadTypeAsync(id);
            if (desc && desc.isModule && desc.isClass) {
              if (!this.module.inherit && desc) {
                this.module.extends = desc;
              }
            }
          }
          await Promise.all(this.children.filter((stack) => stack.isJSXScript).map((stack) => stack.createCompleted()));
        }
      }
      get hasNamespaced() {
        return !!this.openingElement.hasNamespaced;
      }
      get nodeName() {
        if (this.hasNamespaced) {
          const stack = this.getNamespaceStack();
          const ns = stack.namespace.value();
          const name = this.openingElement.value();
          const xmlns = this.getXmlNamespace(ns);
          if (xmlns) {
            const namespace = xmlns.value && xmlns.value.value();
            return namespace && namespace !== "@" ? `${namespace}.${name}` : name;
          } else {
            return `${ns}.${name}`;
          }
        } else {
          return this.openingElement.name.value();
        }
      }
      get attributes() {
        if (this.isAttrClone) {
          return this._attributes;
        }
        return this.openingElement.attributes.slice(0);
      }
      #_isComponent = void 0;
      get isComponent() {
        const result = this.#_isComponent;
        if (result !== void 0)
          return result;
        const desc = this.descriptor();
        if (this.isWebComponent) {
          return this.#_isComponent = true;
        }
        if (!Utils.isModule(desc))
          return false;
        const VNode = Namespace.globals.get("VNode");
        return this.#_isComponent = VNode !== desc;
      }
      #_isProperty = void 0;
      get isProperty() {
        const _result = this.#_isProperty;
        if (_result !== void 0)
          return _result;
        let result = false;
        if (this.parentStack && this.parentStack.isJSXElement) {
          const xmlns = this.getXmlNamespace();
          if (xmlns) {
            if (this.openingElement.name.isJSXMemberExpression) {
              result = true;
            } else if (this.openingElement.name.isJSXNamespacedName) {
              let ns = xmlns.value && xmlns.value.value();
              if (ns) {
                let componentClass = Namespace.fetch(ns);
                result = this.parentStack.descriptor() === componentClass;
              }
            }
          }
        }
        return this.#_isProperty = result;
      }
      freeze() {
        super.freeze();
        this.children.forEach((item2) => item2.freeze());
      }
      definition(context) {
        if (this.isSlot) {
          if (this.isSlotDeclared) {
            return {
              expre: `(slots) ${this.openingElement.name.value()}`,
              location: this.openingElement.name.getLocation(),
              file: this.file
            };
          } else {
            const declareSlot = this.getSlotDescription(this.openingElement.name.value());
            if (declareSlot) {
              if (declareSlot.isJSXElement) {
                return declareSlot.definition(context);
              } else if (declareSlot.isAnnotation && declareSlot.arguments && declareSlot.arguments.length > 0) {
                const slotStack = declareSlot.arguments[0].stack;
                if (slotStack) {
                  return {
                    expre: `(slots) ${declareSlot.name}`,
                    location: slotStack.getLocation(),
                    file: slotStack.file
                  };
                }
              }
            }
          }
        }
        const desc = this.descriptor();
        if (desc && desc !== Namespace.globals.get("VNode")) {
          return desc.definition(context);
        }
        return null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      isFirstUppercase(name) {
        if (name) {
          const code = name.charCodeAt(0);
          return code >= 65 && code <= 90;
        }
        return false;
      }
      description() {
        return this.getAttribute("description", () => {
          const info = this.getElementInfo();
          let desc = null;
          if (info) {
            if (info.isDirective) {
              this.isDirective = true;
            } else if (info.isSlot) {
              this.isSlot = true;
            } else {
              let vnode = null;
              if (info.base) {
                desc = this.openingElement.name.description(info.base);
              } else if (info.desc) {
                desc = info.desc;
              } else if (info.className) {
                vnode = Namespace.globals.get("VNode");
                desc = this.getModuleById(info.className) || vnode;
              }
              if (!desc && info.base) {
                const className = info.base.isNamespace ? info.base.getChain().concat(this.openingElement.name.value()).join(".") : this.openingElement.name.value();
                if (this.isProperty) {
                  this.openingElement.name.error(1080, className);
                } else {
                  this.openingElement.name.error(1111, className);
                }
              }
              if (desc) {
                if (desc !== vnode) {
                  this.openingElement.name.setRefBeUsed(desc);
                  if (this.closingElement) {
                    this.closingElement.name.setRefBeUsed(desc);
                  }
                }
                let type2 = desc.type();
                if (Utils.isModule(type2)) {
                  if (this.isModuleForWebComponent(type2)) {
                    this.isWebComponent = true;
                  } else if (this.isModuleForSkinComponent(type2)) {
                    this.isSkinComponent = true;
                  }
                  this.compilation.addDependency(type2, this.module);
                } else if (this.is(desc) && desc.isDeclarator) {
                  this.isWebComponent = true;
                } else if (info.className) {
                  const code = String(info.className).charCodeAt(0);
                  if (code >= 65 && code <= 90) {
                    this.isWebComponent = true;
                  }
                }
              }
            }
          }
          return desc || Namespace.globals.get("any");
        });
      }
      descriptor() {
        const desc = this.description();
        if (desc) {
          return desc.type();
        }
        return Namespace.globals.get("any");
      }
      getElementInfo() {
        return this.getAttribute("getElementInfo", () => {
          if (this.hasNamespaced) {
            const xmlns = this.getXmlNamespace();
            const jsxConfig = this.compiler.options.jsx || {};
            let sections = jsxConfig.xmlns && jsxConfig.xmlns.sections;
            const nsStack = this.getNamespaceStack();
            let namespace = xmlns && xmlns.value ? xmlns.value.value() : jsxConfig.xmlns.default[nsStack.namespace.value()];
            let load = true;
            if (namespace && sections[namespace]) {
              const sects = sections[namespace];
              const isAll = sects[0] === "*";
              if (isAll || sects.includes(this.openingElement.name.value())) {
                load = false;
                if (namespace === "@slots") {
                  return { isSlot: true };
                } else if (namespace === "@directives") {
                  return { isDirective: true };
                }
              } else {
                this.openingElement.name.error(1125, sects.join(","));
              }
            }
            if (load) {
              const base = this.isProperty ? this.parentStack.getSubClassDescription() : Namespace.fetch(namespace, null, true);
              return { base };
            } else {
              return false;
            }
          } else {
            const className = this.openingElement.name.value();
            const desc = this.scope.define(className);
            return { desc, className };
          }
        });
      }
      type() {
        return this.getAttribute("type", () => {
          let vnode = Namespace.globals.get("VNode");
          let isArray = false;
          if (this.isDirective) {
            let name = String(this.openingElement.name.value()).toLowerCase();
            isArray = name === "for" || name === "each";
          } else {
            isArray = this.openingElement.attributes.some((attr) => {
              if (attr.isAttributeDirective) {
                let name = String(attr.name.value());
                if (name === "for" || name === "each") {
                  return true;
                }
              }
              return false;
            });
          }
          if (isArray) {
            return new TupleType(Namespace.globals.get("Array"), [vnode], null, false, false, true);
          }
          const desc = this.description();
          return desc ? new InstanceofType(desc.type(), this) : vnode;
        });
      }
      getNamespaceStack() {
        if (this.openingElement.name.isJSXNamespacedName) {
          return this.openingElement.name;
        } else if (this.openingElement.name.isJSXMemberExpression && this.openingElement.name.object.isJSXNamespacedName) {
          return this.openingElement.name.object;
        }
        return null;
      }
      getXmlNamespace(ns) {
        ns = ns || this.hasNamespaced && this.getNamespaceStack().namespace.value();
        if (!ns)
          return null;
        const target = this.__xmlns || (this.__xmlns = {});
        if (target[ns] !== void 0) {
          return target[ns];
        }
        const xmlns = this.xmlns.find((item2) => {
          return item2.name.name.value() === ns;
        });
        const getParent = () => {
          const parent = this.getParentStack((parent2) => !!parent2.isJSXElement);
          if (parent && parent.isJSXElement) {
            return parent.getXmlNamespace(ns);
          }
          return null;
        };
        return target[ns] = xmlns || (this.parentStack.isJSXElement ? this.parentStack.getXmlNamespace(ns) : getParent());
      }
      getSubClassDescription() {
        const module2 = this.module;
        const desc = this.descriptor();
        if (module2) {
          if (module2.getInheritModule() === desc) {
            return module2;
          }
        }
        return desc;
      }
      filterPropertyChildren() {
        const children = this.children.filter((item2) => {
          if (item2.isJSXText) {
            return !!item2.value().trim();
          }
          return !!item2;
        });
        return children;
      }
      getDescriptionAcceptType(desc) {
        if (desc) {
          if (desc.isMethodSetterDefinition || desc.isPropertyDefinition) {
            return desc.params[0] && desc.params[0].type();
          } else if (desc.isPropertyDefinition) {
            return desc.type();
          }
        }
        return null;
      }
      parserPropertyValue() {
        const children = this.children;
        if (children.length !== 1 || !children[0].isJSXExpressionContainer) {
          this.error(1113);
        } else {
          return children[0].descriptor();
        }
      }
      getSlotDescription(slotName, classModule) {
        let parentComponent = classModule || this.parentStack && this.parentStack.descriptor();
        const define = (desc) => {
          var stackModule = this.compilation.getStackByModule(desc);
          if (stackModule) {
            const annotation = stackModule.annotations && stackModule.annotations.find((annotation2) => {
              if (annotation2.getLowerCaseName() === "define") {
                const args = annotation2.getArguments();
                if (args && args.length > 1 && args[0].value && args[0].value.toLowerCase() === "slot") {
                  return args.slice(1).some((item2) => {
                    return item2.assigned && item2.key === "name" && item2.value === slotName || !item2.assigned && item2.value === slotName;
                  });
                }
              }
              return false;
            });
            if (annotation) {
              const args = annotation.getArguments();
              const obj = { "name": slotName, args: [], isAnnotation: true, annotation, arguments: args };
              args.slice(1).forEach((item2, index) => {
                const acceptType = item2.stack.acceptType;
                if (acceptType)
                  acceptType.parser();
                if (item2.assigned) {
                  const key = item2.key.toLowerCase();
                  if (key === "scope" || key === "props") {
                    obj.args.push({
                      name: item2.value,
                      stack: item2.stack,
                      type: acceptType ? acceptType.type() : Namespace.globals.get("any")
                    });
                  }
                } else if (index > 0) {
                  obj.args.push({
                    name: item2.value,
                    stack: item2.stack,
                    type: acceptType ? acceptType.type() : Namespace.globals.get("any")
                  });
                }
              });
              return obj;
            }
          }
        };
        while (parentComponent) {
          parentComponent = parentComponent.type();
          const pSlots = parentComponent.jsxDeclaredSlots;
          if (!(pSlots && pSlots.has(slotName))) {
            const result = define(parentComponent);
            if (result) {
              return result;
            }
            parentComponent = parentComponent.inherit;
          } else {
            return pSlots.get(slotName);
          }
        }
        return null;
      }
      checkConditionStatementDirective() {
        const index = this.parentStack.childrenStack.indexOf(this);
        const prevStack = this.parentStack.childrenStack[index - 1];
        if (prevStack && prevStack.isJSXElement && prevStack.isDirective) {
          const directiveName = prevStack.openingElement.name.value().toLowerCase();
          return directiveName === "if" || directiveName === "elseif";
        } else if (prevStack && prevStack.openingElement.attributes.length > 0) {
          return prevStack.openingElement.attributes.some((attr) => {
            if (attr.isAttributeDirective) {
              const directiveName = attr.name.value().toLowerCase();
              return directiveName === "if" || directiveName === "elseif";
            }
            return false;
          });
        }
        return false;
      }
      checkDirective() {
        const directiveName = this.openingElement.name.value().toLowerCase();
        const attrs = this.openingElement.attributes;
        if (directiveName === "elseif" || directiveName === "else") {
          if (!this.checkConditionStatementDirective()) {
            this.error(1156);
          }
        }
        switch (directiveName) {
          case "if":
          case "show":
          case "elseif":
            if (attrs.length !== 1) {
              this.openingElement.name.error(1145, 1, attrs.length);
            } else if (!attrs.every((attr) => attr.name.value() === "condition")) {
              this.openingElement.name.error(1144, `condition`);
            }
            break;
          case "else":
            if (attrs.length > 0) {
              this.openingElement.name.error(1145, 0, attrs.length);
            }
            break;
          case "each":
          case "for": {
            this.scope.isForContext = true;
            const _attrs = attrs.filter((attr) => ["name", "item", "key", "index"].includes(attr.name.value()));
            if (_attrs.length < 1) {
              this.openingElement.name.error(1145, 4, _attrs.length, ["*name", "item", "key", "index"].join(", "));
            } else {
              const resource = _attrs.find((attr) => attr.name.value() === "name");
              if (!resource) {
                this.openingElement.name.error(1204, "name");
                return;
              }
              const description = resource.description();
              const descType = description && description.type();
              const originType = Utils.getOriginType(descType);
              if (originType && !originType.isAnyType) {
                if (directiveName === "each" && !Namespace.globals.get("array").is(descType)) {
                  resource.value.error(1119, descType.toString());
                } else if (originType.isNullableType || originType.isNeverType || originType.isVoidType || Namespace.globals.get("boolean").is(originType)) {
                  resource.value.error(1049, descType.toString());
                }
              }
              const mapTypes = {
                "item": descType ? MergeType.forOfItem(descType) : Namespace.globals.get("any"),
                "key": Namespace.globals.get("string"),
                "index": Namespace.globals.get("number")
              };
              this.scope.define("item", mapTypes.item);
              _attrs.forEach((attr) => {
                const stack = attr.description();
                if (stack) {
                  const name = stack.value();
                  const key = attr.name.value().toLowerCase();
                  if (name && Object.prototype.hasOwnProperty.call(mapTypes, key)) {
                    (function(stack2, _type) {
                      stack2.isDeclarator = true;
                      stack2.kind = "let";
                      stack2.type = function type2() {
                        return _type;
                      };
                      stack2.description = function description2() {
                        return this;
                      };
                      stack2.definition = function definition(ctx) {
                        return {
                          expre: `(let var) ${this.value()}:${this.type().toString(ctx | this.getContext())}`,
                          location: this.getLocation(),
                          file: this.compilation.file
                        };
                      };
                    })(stack, mapTypes[key]);
                    this.scope.define(name, stack);
                  }
                }
              });
            }
            break;
          }
          case "custom": {
            const pros = {
              "name": Namespace.globals.get("any"),
              "value": Namespace.globals.get("any"),
              "modifier": Namespace.globals.get("object"),
              "props": Namespace.globals.get("object")
            };
            if (attrs.length < 2 || attrs.length > 3) {
              this.openingElement.name.error(1145, 3, attrs.length);
            } else {
              const required = {};
              const check = (attr) => {
                const name = attr.name.value();
                const type2 = pros[name];
                required[name] = true;
                if (type2) {
                  if (attr.value) {
                    return this.checkExpressionType(type2, attr.value, attr.name);
                  } else {
                    attr.name.error(1172);
                  }
                } else {
                }
                return false;
              };
              attrs.forEach(check);
              if (!(required.name && required.value)) {
                this.openingElement.name.error(1173);
              }
            }
            break;
          }
        }
      }
      getInheritModule() {
        const desc = this.descriptor();
        if (this.isComponent && this.jsxRootElement === this) {
          if (this.compilation.JSX && this.parentStack && this.parentStack.isProgram && (this.isModuleForWebComponent(desc) || this.isModuleForSkinComponent(desc))) {
            return desc;
          }
        }
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        const jsxConfig = this.compiler.options.jsx || { xmlns: {} };
        const desc = this.descriptor();
        this.children = this.filterPropertyChildren();
        if (this.parentStack.isJSXElement) {
          this.ownerProperty = this.parentStack.ownerProperty || (this.isProperty ? this : null);
        }
        if (this.hasNamespaced) {
          const xmlns = this.getXmlNamespace() || jsxConfig.xmlns.default[this.getNamespaceStack().namespace.value().toLowerCase()];
          if (!xmlns) {
            this.error(1098, this.getNamespaceStack().namespace.value());
          }
        }
        const isComponent = this.isComponent;
        const subDesc = this.getSubClassDescription();
        if (isComponent && this.jsxRootElement === this) {
          if (this.compilation.JSX && this.parentStack && this.parentStack.isProgram) {
            this.scope.define("this", new InstanceofType(this.module, this));
            if (!(this.isSkinComponent || this.isWebComponent)) {
              this.openingElement.name.error(1179, this.openingElement.name.value());
            }
          } else if (!this.isWebComponent) {
            this.openingElement.name.error(1134, this.openingElement.name.value());
          }
        }
        if (this.isSlot && this.module) {
          const slotName = this.openingElement.name.value();
          const pStack = this.getParentStack((stack) => !!(stack.isComponent || !stack.isJSXElement));
          if (pStack) {
            let isDeclareSlot = !pStack.isComponent || this.compilation.JSX && pStack.jsxRootElement === pStack;
            if (!isDeclareSlot) {
              if (this.parentStack !== pStack) {
                isDeclareSlot = true;
              } else {
                const pSlot = this.getSlotDescription(slotName);
                if (!pSlot && slotName !== "default") {
                  isDeclareSlot = true;
                } else if (pStack.isComponent) {
                  if (this.openingElement.attributes.length > 0) {
                    const attrs = this.openingElement.attributes.filter((attr) => !attr.isAttributeDirective);
                    if (attrs.length > 0) {
                      const isJsx = pSlot && pSlot.isJSXElement && pSlot.openingElement;
                      const hasDeclareScoped = isJsx && pSlot.openingElement.attributes.some((attr) => !attr.isAttributeDirective);
                      if (isJsx && !hasDeclareScoped) {
                        attrs.forEach((attr) => {
                          attr.name.error(1130, attr.name.value());
                        });
                      }
                    }
                  }
                  let cache = pStack.getAttribute("componentsUseSlots");
                  if (!cache) {
                    pStack.setAttribute("componentsUseSlots", cache = {});
                  }
                  if (cache[slotName] === true) {
                    this.openingElement.name.error(1129, slotName);
                  } else {
                    cache[slotName] === true;
                  }
                }
              }
            }
            if (isDeclareSlot) {
              const declaredSlots = this.module.jsxDeclaredSlots || (this.module.jsxDeclaredSlots = /* @__PURE__ */ new Map());
              this.isSlotDeclared = true;
              if (declaredSlots.has(slotName)) {
                this.openingElement.name.error(1129, slotName);
              } else {
                declaredSlots.set(slotName, this);
              }
              this.compilation.once("clear-cache", () => {
                declaredSlots.clear();
              });
            }
          } else {
            this.openingElement.name.error(1127, slotName);
          }
        }
        const attributes = this.openingElement.attributes;
        const cacheAttrs = {};
        const isRoot = !this.isWebComponent && this.jsxRootElement === this && this.isJSXElement && this.openingElement.name.value() === "root";
        attributes.forEach((item2) => {
          item2.parser();
          if (item2.isJSXSpreadAttribute)
            return;
          const name = item2.getAttributeName();
          if (cacheAttrs[name] === true) {
            item2.error(1045, name);
          }
          cacheAttrs[name] = true;
          if (isRoot && !item2.isAttributeXmlns) {
            item2.name.error(1205);
          }
          if (!item2.isAttributeXmlns && !item2.isAttributeDirective && !item2.isAttributeEvent && !item2.isAttributeSlot) {
            if (isComponent) {
              const attrDesc = item2.getAttributeDescription(subDesc);
              if (attrDesc) {
                item2.isMemberProperty = true;
                if (!(attrDesc.isMethodSetterDefinition || attrDesc.isPropertyDefinition)) {
                  item2.name.error(1080, item2.name.value());
                } else if (attrDesc.isPropertyDefinition && attrDesc.isReadonly) {
                  item2.name.error(1142, item2.name.value());
                } else {
                  if (item2.value) {
                    attrDesc.assignment(item2.value, item2.name);
                  }
                }
              }
            } else {
            }
          } else if (item2.isAttributeDirective && this.isDirective) {
            item2.name.error(1143);
          }
        });
        if (this.isProperty) {
          if (desc) {
            desc.assignment(this.parserPropertyValue(this.getDescriptionAcceptType(desc)), this);
          }
        }
        if (!(isComponent || this.isProperty || this.isSlot || this.isDirective) && this.openingElement.name.isJSXMemberExpression) {
          this.warn(1108);
        }
        if (this.isDirective) {
          this.checkDirective();
        } else {
          this.directives = this.openingElement.attributes.filter((attr) => {
            return attr.isAttributeDirective;
          });
        }
        let needCheckSlotDefine = false;
        let pSlots = null;
        let hasDefaultSlot = false;
        if (this.isWebComponent && desc && !desc.isDeclaratorModule && Utils.isModule(desc)) {
          if (!(desc.isSkinComponent || desc.isWebComponent) || this.jsxRootElement !== this) {
            needCheckSlotDefine = true;
            pSlots = desc.jsxDeclaredSlots;
            if (pSlots && pSlots.has("default")) {
              hasDefaultSlot = true;
            } else {
              hasDefaultSlot = !!this.getSlotDescription("default", desc);
            }
          }
        }
        this.children.forEach((item2) => {
          item2.parser();
          if (!item2.isSlot && needCheckSlotDefine && !hasDefaultSlot) {
            this.openingElement.name.warn(1131, this.openingElement.name.value());
          }
        });
      }
      value() {
        return this.openingElement.value();
      }
    };
    module.exports = JSXElement;
  }
});

// lib/stacks/JSXEmptyExpression.js
var require_JSXEmptyExpression = __commonJS({
  "lib/stacks/JSXEmptyExpression.js"(exports, module) {
    var Stack = require_Stack();
    var JSXEmptyExpression = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.jsxElement = parentStack.jsxElement;
        this.isJSXEmptyExpression = true;
      }
      definition() {
        return null;
      }
      description() {
        return null;
      }
    };
    module.exports = JSXEmptyExpression;
  }
});

// lib/stacks/JSXExpressionContainer.js
var require_JSXExpressionContainer = __commonJS({
  "lib/stacks/JSXExpressionContainer.js"(exports, module) {
    var Stack = require_Stack();
    var JSXExpressionContainer = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isJSXExpressionContainer = true;
        this.jsxElement = parentStack.jsxElement;
        this.expression = this.createTokenStack(compilation, node2.expression, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.expression.freeze();
      }
      definition(context) {
        const desc = this.expression.description();
        if (desc) {
          const def = desc.definition(context);
          if (def)
            return def;
        }
        return null;
      }
      reference() {
        return this.expression.reference();
      }
      referenceItems() {
        return this.expression.referenceItems();
      }
      description() {
        return this.expression.descriptor();
      }
      type(ctx) {
        return this.expression.type(ctx);
      }
      parser() {
        this.expression.parser();
        this.expression.setRefBeUsed();
      }
      value() {
        return this.expression.value();
      }
      raw() {
        return this.expression.raw();
      }
    };
    module.exports = JSXExpressionContainer;
  }
});

// lib/stacks/JSXFragment.js
var require_JSXFragment = __commonJS({
  "lib/stacks/JSXFragment.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var JSXFragment = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isJSXFragment = true;
        this.jsxRootElement = parentStack.jsxRootElement || this;
        this.children = node2.children.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
      }
      freeze() {
        super.freeze();
        this.children.forEach((item2) => item2.freeze());
      }
      definition() {
        return null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      description() {
        return null;
      }
      getXmlNamespace(ns) {
        const xmlns = this.xmlns;
        if (xmlns && ns && xmlns.name.value() === ns) {
          return xmlns;
        }
        return this.parentStack.isJSXElement || this.parentStack.isJSXFragment ? this.parentStack.getXmlNamespace(ns) : null;
      }
      type() {
        return Namespace.globals.get("VNode");
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.children.forEach((item2) => item2.parser());
      }
    };
    module.exports = JSXFragment;
  }
});

// lib/stacks/JSXIdentifier.js
var require_JSXIdentifier = __commonJS({
  "lib/stacks/JSXIdentifier.js"(exports, module) {
    var Identifier = require_Identifier();
    var JSXIdentifier = class extends Identifier {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.jsxElement = parentStack.jsxElement;
        this.isJSXIdentifier = true;
      }
      reference() {
        return null;
      }
      referenceItems() {
        return [];
      }
      description() {
        return null;
      }
      type() {
        return this.getGlobalTypeById("void");
      }
      definition(context) {
        return this.parentStack.definition(context || this.getContext());
      }
      getAttributeDescription(desc, kind = "set") {
        if (desc) {
          return this.compilation.getReference(this.value(), desc, false, kind);
        }
        return null;
      }
    };
    module.exports = JSXIdentifier;
  }
});

// lib/stacks/JSXMemberExpression.js
var require_JSXMemberExpression = __commonJS({
  "lib/stacks/JSXMemberExpression.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var Utils = require_Utils();
    var JSXMemberExpression = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isJSXMemberExpression = true;
        this.jsxElement = parentStack.jsxElement;
        this.object = this.createTokenStack(compilation, node2.object, scope, node2, this);
        this.property = this.createTokenStack(compilation, node2.property, scope, node2, this);
        this.hasNamespaced = !!this.object.isJSXNamespacedName;
      }
      reference(called) {
        return null;
      }
      referenceItems(called) {
        return [];
      }
      definition(context) {
        return this.parentStack.definition(context);
      }
      getFirstMemberStack() {
        if (this.object.isJSXMemberExpression) {
          return this.object.getFirstMemberStack();
        } else {
          return this.object;
        }
      }
      getXmlNamespace(ns) {
        if (this.parentStack.isJSXOpeningElement) {
          return this.parentStack.getXmlNamespace(ns);
        }
        return null;
      }
      description(space, endStack) {
        const property = this.property.value();
        let desc = null;
        if (this.object.isJSXMemberExpression) {
          desc = this.object.description(space, endStack);
        } else if (space) {
          if (space.isModule) {
            return space.getDescriptor(property, (desc2) => {
              if (desc2.isPropertyDefinition && Utils.isModifierPublic(desc2) && !desc2.isReadonly) {
                return true;
              } else if (desc2.isMethodSetterDefinition && Utils.isModifierPublic(desc2)) {
                return true;
              } else {
                return false;
              }
            });
          } else if (space.isNamespace) {
            return this.getModuleById(space.fullName + "." + property, Namespace.dataset);
          }
        }
        if (endStack && endStack !== this.property) {
          return desc;
        }
        if (desc) {
          desc = desc.isModule ? desc : Utils.getOriginType(desc.type());
          return desc.getDescriptor(property, (desc2) => {
            if (desc2.isPropertyDefinition && Utils.isModifierPublic(desc2) && !desc2.isReadonly) {
              return true;
            } else if (desc2.isMethodSetterDefinition && Utils.isModifierPublic(desc2)) {
              return true;
            } else {
              return false;
            }
          });
        }
        return null;
      }
      type() {
        return Namespace.globals.get("void");
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.object.parser();
        this.property.parser();
      }
      raw() {
        return `${this.object.raw()}.${this.property.raw()}`;
      }
      value() {
        return `${this.object.value()}.${this.property.value()}`;
      }
    };
    module.exports = JSXMemberExpression;
  }
});

// lib/stacks/JSXNamespacedName.js
var require_JSXNamespacedName = __commonJS({
  "lib/stacks/JSXNamespacedName.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var Utils = require_Utils();
    var JSXNamespacedName = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isJSXNamespacedName = true;
        this.jsxElement = parentStack.jsxElement;
        this.namespace = this.createTokenStack(compilation, node2.namespace, scope, node2, this);
        this.name = this.createTokenStack(compilation, node2.name, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.name && this.name.freeze();
        this.namespace && this.namespace.freeze();
      }
      getXmlNamespace() {
        if (this.parentStack.isJSXOpeningElement || this.parentStack.isJSXAttribute || this.parentStack.isJSXMemberExpression) {
          return this.parentStack.getXmlNamespace(this.namespace.value());
        }
        return null;
      }
      getAttributeDescription(desc, kind = "set") {
        if (desc) {
          return this.compilation.getReference(this.name.value(), desc, false, kind);
        }
        return null;
      }
      definition(context) {
        const stack = context && context.stack;
        if (stack === this.namespace || this.parentStack.isAttributeDirective) {
          const def = this.getXmlNamespace();
          if (def) {
            let ns = def.value.value();
            if (ns.includes("::")) {
              ns = ns.split("::")[0];
            }
            const expr = this.parentStack.isAttributeDirective ? `${ns}::${this.name.value()}` : def.value.value();
            return {
              text: `(refs) ${expr}`,
              location: def.value.getLocation(),
              file: def.compilation.file,
              range: this.getLocation()
            };
          }
          return null;
        }
        return this.parentStack.definition(context);
      }
      reference() {
        return null;
      }
      referenceItems() {
        return [];
      }
      description(space, endStack) {
        const name = this.name.value();
        if (this.name.isJSXMemberExpression) {
          return this.name.description(space, endStack);
        } else if (space) {
          if (space.isModule) {
            return space.getDescriptor(name, (desc) => {
              if (desc.isPropertyDefinition && Utils.isModifierPublic(desc)) {
                return true;
              } else if (desc.isMethodSetterDefinition && Utils.isModifierPublic(desc)) {
                return true;
              } else {
                return false;
              }
            });
          } else if (space.isNamespace) {
            return this.getModuleById(space.fullName + "." + name, Namespace.dataset);
          }
          return null;
        } else {
          return this.getModuleById(name);
        }
      }
      type() {
        return this.getGlobalTypeById("void");
      }
      value() {
        return this.name.value();
      }
    };
    module.exports = JSXNamespacedName;
  }
});

// lib/stacks/JSXOpeningElement.js
var require_JSXOpeningElement = __commonJS({
  "lib/stacks/JSXOpeningElement.js"(exports, module) {
    var Stack = require_Stack();
    var JSXOpeningElement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isJSXOpeningElement = true;
        this.jsxElement = parentStack.jsxElement;
        this.name = this.createTokenStack(compilation, node2.name, this.scope, node2, this);
        this.attributes = node2.attributes.map((item2) => this.createTokenStack(compilation, item2, this.scope, node2, this));
        this.selfClosing = !!node2.selfClosing;
        this.hasNamespaced = !!(this.name.isJSXNamespacedName || this.name.hasNamespaced);
      }
      freeze() {
        super.freeze();
        this.attributes && this.attributes.forEach((item2) => item2.freeze());
        this.name && this.name.freeze();
      }
      getXmlNamespace(ns) {
        if (this.parentStack.isJSXElement) {
          return this.parentStack.getXmlNamespace(ns);
        }
        return null;
      }
      definition(context) {
        if (this.parentStack.isJSXElement) {
          return this.parentStack.definition(context);
        }
        return null;
      }
      reference() {
        return null;
      }
      referenceItems() {
        return [];
      }
      description() {
        return null;
      }
      type() {
        return this.getGlobalTypeById("void");
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.name.parser();
        this.attributes.forEach((item2) => {
          item2.parser();
        });
      }
      raw() {
        return this.name.raw();
      }
      value() {
        return this.name.value();
      }
    };
    module.exports = JSXOpeningElement;
  }
});

// lib/stacks/JSXOpeningFragment.js
var require_JSXOpeningFragment = __commonJS({
  "lib/stacks/JSXOpeningFragment.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var JSXOpeningFragment = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isJSXOpeningFragment = true;
        this.jsxElement = parentStack.jsxElement;
        this.attributes = node2.attributes.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
        this.selfClosing = !!node2.selfClosing;
      }
      freeze() {
        super.freeze();
        this.attributes && this.attributes.forEach((item2) => item2.freeze());
      }
      definition() {
        return null;
      }
      reference() {
        return null;
      }
      referenceItems() {
        return [];
      }
      description() {
        return null;
      }
      type() {
        return Namespace.globals.get("void");
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.attributes.forEach((item2) => {
          item2.parser();
        });
      }
    };
    module.exports = JSXOpeningFragment;
  }
});

// lib/stacks/JSXScript.js
var require_JSXScript = __commonJS({
  "lib/stacks/JSXScript.js"(exports, module) {
    var Stack = require_Stack();
    var Utils = require_Utils();
    var JSXScript = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isJSXScript = true;
        this.jsxElement = this;
        this.body = [];
        this.hasClassDeclared = false;
        this.isScriptProgram = parentStack.isJSXElement && parentStack.jsxRootElement === parentStack && parentStack.parentStack.isProgram;
        if (!this.compilation.JSX) {
          this.error(1109);
        }
        this.openingElement = this.createTokenStack(compilation, node2.openingElement, scope, node2, this);
        this.closingElement = this.createTokenStack(compilation, node2.closingElement, scope, node2, this);
        if (!this.isScriptProgram) {
          node2.children.forEach((item2) => {
            const stack = this.createTokenStack(compilation, item2, this.scope, node2, this);
            this.body.push(stack);
          });
        } else {
          const annotations = [];
          const metatypes = [];
          const imports = [];
          node2.children.forEach((item2) => {
            const stack = this.createTokenStack(compilation, item2, this.scope, node2, this);
            if (stack) {
              if (stack.isMetatypeDeclaration) {
                metatypes.push(stack);
              } else if (stack.isAnnotationDeclaration) {
                const _stack = this.interceptAnnotation(stack);
                if (_stack) {
                  annotations.push(_stack);
                }
              } else if (stack.isImportDeclaration) {
                imports.push(stack);
              } else {
                stack.annotations = annotations.splice(0, annotations.length);
                stack.metatypes = metatypes.splice(0, metatypes.length);
                if (stack.isClassDeclaration) {
                  this.hasClassDeclared = true;
                  this.module = stack.module;
                  stack.imports = imports.splice(0, imports.length);
                }
                this.body.push(stack);
              }
            }
          });
          this.imports = imports;
          if (annotations.length > 0) {
            annotations.forEach((item2) => {
              item2.error(1093);
            });
          }
          if (metatypes.length > 0) {
            metatypes.forEach((item2) => {
              item2.error(1093);
            });
          }
          if (!this.hasClassDeclared) {
            this.compilation.addModuleStack(this.module, this);
          }
        }
      }
      async createCompleted() {
        if (this._createCompletedFlag)
          return;
        this._createCompletedFlag = true;
        if (!this.isScriptProgram)
          return;
        await this.allSettled(this.imports, async (stack) => await stack.addImport(this.module, this.parentStack.scope));
        await this.allSettled(this.body.filter((stack) => stack.isClassDeclaration).map((stack) => stack.createCompleted()));
        const host = this.hostComponentAnnotation;
        if (host) {
          const args = host.getArguments();
          if (args[0]) {
            this.hostComponentModule = await this.loadTypeAsync(args[0].value);
          }
        }
      }
      freeze() {
        super.freeze();
        super.freeze(this.scope);
        super.freeze(this.body);
        this.body.forEach((stack) => stack.freeze());
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.isScriptProgram) {
          this.imports.forEach((stack) => {
            stack.parser();
          });
          this.compilation.stack.scripts.push(this);
          if (this.hostComponentAnnotation) {
            const pDesc = this.parentStack.description();
            const declare = pDesc && pDesc.getModuleGenerics();
            const args = this.hostComponentAnnotation.getArguments();
            if (declare && args[0]) {
              const refsModule = this.hostComponentModule || this.getModuleById(args[0].value);
              if (refsModule) {
                if (declare[0].hasConstraint && !declare[0].check(refsModule)) {
                  args[0].stack.error(1003, refsModule.toString(), declare[0].toString());
                } else {
                  if (Utils.checkDepend(this.module, refsModule)) {
                    args[0].stack.error(1024, args[0].value, this.module.getName(), refsModule.getName());
                  } else if (this.module && this.module.isModule) {
                    const stackModule = this.module.moduleStack;
                    if (stackModule) {
                      const ctx = stackModule.getContext();
                      ctx.extractive(declare[0], refsModule);
                    }
                    this.parentStack.jsxRootElement.getContext().extractive(declare[0], refsModule);
                  }
                }
              }
            }
          }
        }
        this.body.forEach((item2) => {
          item2.parser();
        });
      }
    };
    module.exports = JSXScript;
  }
});

// lib/stacks/JSXSpreadAttribute.js
var require_JSXSpreadAttribute = __commonJS({
  "lib/stacks/JSXSpreadAttribute.js"(exports, module) {
    var Stack = require_Stack();
    var JSXSpreadAttribute = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isJSXSpreadAttribute = true;
        this.jsxElement = parentStack.jsxElement;
        this.argument = this.createTokenStack(compilation, node2.argument, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.argument && this.argument.freeze();
      }
      definition() {
        return null;
      }
      getAttributeDescription(desc, kind = "set") {
        return null;
      }
      reference() {
        return this.argument.reference();
      }
      referenceItems() {
        return this.argument.referenceItems();
      }
      description() {
        return this.argument.description();
      }
      type() {
        return this.argument.type();
      }
      parser() {
        if (this.argument) {
          this.argument.parser();
          this.argument.setRefBeUsed();
        }
      }
    };
    module.exports = JSXSpreadAttribute;
  }
});

// lib/stacks/JSXStyle.js
var require_JSXStyle = __commonJS({
  "lib/stacks/JSXStyle.js"(exports, module) {
    var Stack = require_Stack();
    var path = __require("path");
    var JSXStyle = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isJSXStyle = true;
        this.jsxElement = this;
        this.openingElement = this.createTokenStack(compilation, node2.openingElement, scope, node2, this);
        this.closingElement = this.createTokenStack(compilation, node2.closingElement, scope, node2, this);
        this.absoluteFile = null;
        this.attributeFile = this.openingElement.attributes.find((item2) => item2.name.value().toLowerCase() === "file");
        this.styleContent = node2.children.map((item2) => item2.raw).join("");
        this.styleKey = compilation.jsxStyles.length + 1;
        compilation.jsxStyles.push(this);
        const file = this.attributeFile;
        const target = this.module || this.compilation;
        if (file) {
          const url = file.value.value();
          const resolve = this.compiler.resolveManager.resovleAssets(url, this.file);
          if (!resolve) {
            this.error(1118, url);
          } else {
            this.absoluteFile = resolve;
            if (!target.addAsset(resolve, url, null, path.extname(url), null, null, this)) {
              this.error(1107, url);
            }
          }
        } else {
          const content = this.styleContent.trim();
          if (content) {
            const key = this.styleKey;
            const attributes = {};
            this.openingElement.attributes.forEach((attr) => {
              const key2 = attr.name.value().toLowerCase();
              let value2 = attr.value ? attr.value.value() : true;
              if (value2 === "false" || value2 === "true") {
                value2 = Boolean(value2);
              }
              attributes[key2] = value2;
            });
            let format = "css";
            let lang = attributes.lang || attributes.type;
            if (lang) {
              format = String(lang).trim();
              if (format.includes(".")) {
                format = format.replace(/^\./, "");
              }
            }
            if (!target.addAsset(key + "." + format, null, content, "style", null, attributes, this)) {
              this.error(1107, key);
            }
          }
        }
      }
      get attributes() {
        if (this.isAttrClone) {
          return this._attributes;
        }
        return this.openingElement.attributes.slice(0);
      }
      description() {
        return null;
      }
      value() {
        return this.styleContent;
      }
    };
    module.exports = JSXStyle;
  }
});

// lib/stacks/JSXText.js
var require_JSXText = __commonJS({
  "lib/stacks/JSXText.js"(exports, module) {
    var Literal = require_Literal();
    var JSXText = class extends Literal {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.jsxElement = this;
        this.isJSXText = true;
      }
    };
    module.exports = JSXText;
  }
});

// lib/stacks/LabeledStatement.js
var require_LabeledStatement = __commonJS({
  "lib/stacks/LabeledStatement.js"(exports, module) {
    var Stack = require_Stack();
    var LabeledStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isLabeledStatement = true;
        this.labelChildren = [];
        this.labelParent = null;
        this.label = this.createTokenStack(compilation, node2.label, scope, node2, this);
        this.body = this.createTokenStack(compilation, node2.body, scope, node2, this);
        const labelStack = parentStack && parentStack.getParentStack((stack) => !!(stack.isLabeledStatement || stack.isFunctionExpression));
        if (labelStack && labelStack.isLabeledStatement) {
          this.labelParent = labelStack;
          labelStack.labelChildren.push(this);
        }
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.label);
        super.freeze(this.labelChildren);
        this.body.freeze();
      }
      definition() {
        return {
          comments: this.label.comments,
          expre: null,
          location: this.label.getLocation(),
          file: this.compilation.file
        };
      }
      parser() {
        return this.body.parser();
      }
    };
    module.exports = LabeledStatement;
  }
});

// lib/stacks/LogicalConditionStatement.js
var require_LogicalConditionStatement = __commonJS({
  "lib/stacks/LogicalConditionStatement.js"(exports, module) {
    var Namespace = require_Namespace();
    var Expression = require_Expression();
    var LogicalConditionStatement = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isLogicalConditionStatement = true;
        this.left = this.createTokenStack(compilation, node2.left, scope, node2, this);
        this.right = this.createTokenStack(compilation, node2.right, scope, node2, this);
        this.operator = this.node.operator;
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
      }
      definition() {
        return null;
      }
      description() {
        return this;
      }
      type() {
        return Namespace.globals.get("void");
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.left.parser();
        this.right.parser();
      }
    };
    module.exports = LogicalConditionStatement;
  }
});

// lib/stacks/LogicalExpression.js
var require_LogicalExpression = __commonJS({
  "lib/stacks/LogicalExpression.js"(exports, module) {
    var MergeType = require_MergeType();
    var Namespace = require_Namespace();
    var Expression = require_Expression();
    var LogicalExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isLogicalExpression = true;
        this.left = this.createTokenStack(compilation, node2.left, scope, node2, this);
        this.right = this.createTokenStack(compilation, node2.right, scope, node2, this);
        this.operator = this.node.operator;
        this.isAndOperator = this.operator ? this.operator.charCodeAt(0) === 38 : false;
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
      }
      definition() {
        return null;
      }
      description() {
        return this;
      }
      type() {
        return this.getAttribute("LogicalExpression.type", () => {
          let isAnd = this.isAndOperator;
          let lType = this.hasNestDescription(this.left) ? null : this.left.type();
          let rType = this.hasNestDescription(this.right) ? null : this.right.type();
          if (isAnd) {
            return rType || Namespace.globals.get("any");
          }
          if (lType && lType.isLiteralType) {
            if (!lType.value) {
              return rType || Namespace.globals.get("any");
            } else {
              return lType;
            }
          }
          if (lType || rType) {
            const mergeType = new MergeType();
            mergeType.keepOriginRefs = true;
            mergeType.add(lType, false, true);
            mergeType.add(rType);
            return mergeType.type();
          }
          return Namespace.globals.get("any");
        });
      }
      getContext() {
        return this.getAttribute("getContext", () => {
          let isAnd = this.isAndOperator;
          if (isAnd) {
            return this.right.getContext();
          }
          return this.left.getContext();
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.left.parser();
        this.left.setRefBeUsed();
        this.right.parser();
        this.right.setRefBeUsed();
      }
    };
    module.exports = LogicalExpression;
  }
});

// lib/types/ComputeType.js
var require_ComputeType = __commonJS({
  "lib/types/ComputeType.js"(exports, module) {
    var Namespace = require_Namespace();
    var Utils = require_Utils();
    var Type = require_Type();
    var UnionType = require_UnionType();
    var { extractWrapGenericValue } = require_Inference();
    var ComputeType = class extends Type {
      constructor(target, object, property, keyName) {
        super("$ComputeType");
        this.isComputeType = true;
        this.isAnyType = true;
        this.target = target;
        this.object = object;
        this.property = property;
        this.originObject = object;
        this.originProperty = property;
        this.keyName = keyName;
        this.computed = true;
      }
      get hasGenericType() {
        return !!(this.object.type().hasGenericType || this.property.type().hasGenericType);
      }
      clone(inference) {
        if (!inference || !this.hasGenericType) {
          return this;
        }
        const target = this.getComputeType();
        if (target !== this) {
          return target.clone(inference);
        }
        let object = this.object.type().clone(inference);
        let property = this.property.type().clone(inference);
        if (property.isGenericType && property.hasConstraint) {
          const inherit = property.inherit.clone(inference);
          if (!inherit.hasGenericType) {
            property = inherit;
          }
        }
        if (object.hasGenericType || property.hasGenericType) {
          return this;
        }
        let result = new ComputeType(this.target, object, property, this.keyName);
        result.originObject = this.object;
        result.originProperty = this.property;
        return result;
      }
      isPropertyExists(keyStack) {
        const context = this.target && this.target.isStack ? this.target.getContext() : null;
        const inference = context && context.inference;
        let object = this.object.type();
        let property = this.property.type();
        if (inference) {
          object = object.hasGenericType ? inference(object) : object;
          property = property.hasGenericType ? inference(property) : property;
        }
        return !!this.getComputeValue(object, property, keyStack || this.property);
      }
      getComputeValue(object, property, keyStack) {
        const getProperty2 = (object2, propName, propertyType) => {
          let result = null;
          if (object2.isInstanceofType) {
            if (propName) {
              result = object2.inherit.getDescriptor(propName, (desc, prev) => {
                if ((desc.isPropertyDefinition || desc.isMethodGetterDefinition) && Utils.isModifierPublic(desc)) {
                  return true;
                }
                return prev || desc;
              });
            }
            if (!result) {
              result = object2.inherit.dynamicAttribute(propertyType);
            }
            if (result && result.isStack && !Utils.isModifierPublic(result)) {
              return null;
            }
          } else if (object2.isLiteralObjectType) {
            result = propName && object2.attribute(propName) || object2.dynamicAttribute(propertyType);
          } else if (object2.isLiteralArrayType || object2.isTupleType) {
            const propIndex = propName === null ? -1 : parseInt(propName);
            if (propIndex >= 0 && propIndex < object2.elements.length) {
              result = object2.elements[propName];
            }
            if (!result) {
              result = object2.dynamicAttribute(propertyType);
            }
          } else {
            object2 = Utils.getOriginType(object2);
            if (object2.isInterface && object2.isModule) {
              if (propName) {
                result = object2.getDescriptor(propName, (desc, prev) => {
                  if ((desc.isPropertyDefinition || desc.isMethodGetterDefinition) && Utils.isModifierPublic(desc)) {
                    return true;
                  }
                  return prev || desc;
                });
              }
              if (!result) {
                result = object2.dynamicAttribute(propertyType);
              }
            }
          }
          return result ? result.type() : null;
        };
        const getProperties = (object2, property2) => {
          if (property2.isUnionType || property2.isTupleType || property2.isLiteralArrayType) {
            const reduce = (accumulator, item2) => item2.isUnionType || item2.isTupleType ? item2.elements.reduce(reduce, accumulator) : accumulator.concat(item2.type());
            const keys = property2.elements.reduce(reduce, []).filter((item2) => item2.isLiteralType);
            const values = keys.map((item2) => {
              return getProperty2(object2, item2.value, item2);
            }).filter((item2) => !!item2);
            if (values.length) {
              if (values.length === 1)
                return values[0];
              return new UnionType(values, this.target);
            }
          } else {
            return getProperty2(object2, property2.isLiteralType ? property2.value : null, property2);
          }
          return null;
        };
        const defaultType = Namespace.globals.get("any");
        const getDesc = (name, keyType) => {
          if (object.isLiteralArrayType || object.isLiteralObjectType || object.isGenericType && object.hasConstraint || object.isTupleType || object.isEnumType || object.isIntersectionType || object.isInstanceofType) {
            const desc = name ? object.attribute(name) : null;
            if (desc) {
              return desc.type();
            } else if (object.isLiteralObjectType || object.isLiteralArrayType || object.isTupleType) {
              return getProperties(object, keyType) || defaultType;
            } else if (object.isInstanceofType) {
              return getProperties(object, keyType) || defaultType;
            }
          } else if (name) {
            return getProperty2(object, name, keyType) || defaultType;
          } else {
            return getProperties(object, keyType) || defaultType;
          }
        };
        let key = (property.isUnionType || property.isLiteralArrayType) && keyStack ? property.elements.find((ele) => ele.type().check(keyStack, {}, { toLiteralValue: true })) : property;
        if (key)
          key = key.type();
        return key && key.isLiteralType ? getDesc(key.value, key) : getDesc(null, key || property);
      }
      getComputeType(keyStack, context) {
        const object = this.inferType(this.object.type(), context);
        const property = this.inferType(this.property.type(), context);
        if (object && object.isThisType) {
          return this;
        }
        if (object && property && !(object.isGenericType || property.isGenericType)) {
          const result = this.getComputeValue(object, property, keyStack);
          return result ? result : Namespace.globals.get("any");
        }
        return this;
      }
      getComputeResult(keyStack, context) {
        const object = this.inferType(this.object.type(), context);
        const property = this.inferType(this.property.type(), context);
        if (object && object.isThisType) {
          return this;
        }
        if (object && property && !(object.isGenericType || property.isGenericType)) {
          const result = this.getComputeValue(object, property, keyStack);
          return result ? result : Namespace.globals.get("any");
        }
        return Namespace.globals.get("any");
      }
      getResult(keyStack) {
        const object = this.object.type();
        const property = this.property.type();
        if (!(object.isGenericType || property.isGenericType)) {
          const result = this.getComputeValue(object, property, keyStack);
          if (result)
            return result;
        }
        return Namespace.globals.get("any");
      }
      getInferResult(context, records = /* @__PURE__ */ new Map()) {
        const inference = (type2) => {
          type2 = type2.type();
          const res = records && records.get(type2) || context.infer(type2);
          return res || type2;
        };
        let object = inference(this.object.type());
        let property = inference(this.property.type());
        if (property.isConditionalExpressionType) {
          if (!records.count) {
            records.count = 1;
          }
          records.count++;
          property = property.getInferResult(context, records);
          let result2 = this.getComputeValue(object, property);
          if (result2 && result2.isConditionalExpressionType) {
            result2 = result2.getInferResult(context, records);
          }
          result2 = result2.clone(inference);
          if (records.count < 100 && Utils.getOriginType(result2) === this) {
            const _result = result2.getInferResult(context, records);
            if (_result) {
              result2 = _result;
            }
          }
          return result2;
        }
        if (object.isClassGenericType) {
          const newRecords = extractWrapGenericValue(object);
          if (newRecords) {
            newRecords.forEach((value2, key) => {
              const res = value2.getInferResult(context, records);
              if (res) {
                value2 = res;
              }
              records.set(key, value2);
            });
          }
        }
        let result = this.getComputeResult(null, context);
        result = inference(result);
        if (result && result !== this) {
          let res = result.getInferResult(context, records);
          if (res) {
            return res;
          }
        }
        return result;
      }
      definition() {
        return {
          expre: `(type) ${this.toString()}`
        };
      }
      is(type2, context = {}, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        let object = this.inferType(this.object.type(), context);
        let property = this.inferType(this.property.type(), context);
        if (!(object.isGenericType || property.isGenericType)) {
          return this.inferType(this.getComputeValue(object, property), context).is(type2, context, options);
        }
        return !(type2.isTupleType || type2.isLiteralArrayType);
      }
      toString(context, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        const result = this.getComputeType(null, context);
        if (result !== this) {
          return result.toString(context, options);
        }
        let object = this.object.type();
        let property = this.property.type();
        if (!(object.isGenericType || property.isGenericType)) {
          if (object.isThisType) {
            let labels = "";
            if (property.isLiteralArrayType) {
              labels = property.elements.map((item2) => {
                return item2.type().toString(context, { toLiteralValue: true });
              }).join(" | ");
            } else {
              labels = property.toString(context, Object.assign(options, { toLiteralValue: true }));
            }
            return `${object.toString()}[${labels}]`;
          } else {
            return this.getComputeValue(object, property).toString(context, options);
          }
        }
        return `${this.originObject.type().toString(context, options)}[${this.originProperty.type().toString(context, options)}]`;
      }
    };
    module.exports = ComputeType;
  }
});

// lib/stacks/MemberExpression.js
var require_MemberExpression = __commonJS({
  "lib/stacks/MemberExpression.js"(exports, module) {
    var Stack = require_Stack();
    var Utils = require_Utils();
    var Expression = require_Expression();
    var ComputeType = require_ComputeType();
    var Namespace = require_Namespace();
    var MergeType = require_MergeType();
    var JSModule = require_JSModule();
    var keySymbol = Symbol("key");
    var MemberExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isMemberExpression = true;
        this.object = this.createTokenStack(compilation, node2.object, scope, node2, this);
        this.property = this.createTokenStack(compilation, node2.property, scope, node2, this);
        this._accessor = null;
        this._hasMatchAutoImporter = false;
        this.computed = !!node2.computed;
        this.optional = !!node2.optional;
        this[keySymbol] = {};
        this.addHook();
      }
      get hasMatchAutoImporter() {
        if (this._hasMatchAutoImporter) {
          return true;
        }
        if (this.object.isMemberExpression || this.object.isIdentifier) {
          return this.object.hasMatchAutoImporter;
        }
        return false;
      }
      getReferenceName() {
        if (!this._hasMatchAutoImporter)
          return null;
        const desc = this.description();
        return this.compilation.getDescriptorReferenceName(desc);
      }
      addHook() {
        if (!this.isJSXForContext() && !this.optional) {
          const id = this.value();
          let pp = this.parentStack;
          const maybe = pp.isCallExpression || pp.isNewExpression || pp.isAssignmentPattern && pp.node.right === this.node || pp.isAssignmentExpression && pp.node.right === this.node || pp.isVariableDeclarator && pp.node.init === this.node || //pp.isMemberExpression && pp.node.object === this.node && !pp.optional ||
          pp.isProperty && pp.node.value === this.node && !(pp.parentStack.isObjectPattern || pp.parentStack.isArrayPattern);
          if (maybe) {
            pp = this.getParentStack((stack) => !stack.isMemberExpression);
            if (pp) {
              if (pp.isPackageDeclaration || pp.isAnnotationExpression || pp.isAnnotationDeclaration || pp.isImportDeclaration || pp.isTypeDefinition) {
                return;
              }
            }
          }
          if (maybe && this.checkNeedToLoadTypeById(id)) {
            this.compilation.hookAsync("compilation.create.after", async () => {
              const desc = await this.loadTypeAsync(id);
              if (desc && desc.isModule) {
                this.compilation.addDependency(desc, this.module);
              }
            });
          }
        }
      }
      freeze() {
        super.freeze();
        this.object.freeze();
        this.property.freeze();
      }
      reference(called) {
        const description = this.getDescription();
        if (description !== this && description instanceof Stack) {
          return description.reference(called);
        }
        return this;
      }
      referenceItems(called) {
        const description = this.getDescription();
        if (description !== this && description instanceof Stack) {
          return description.referenceItems(called);
        }
        return [this];
      }
      resolveDefinitionContext(context) {
        const pStack = this.getParentStack((stack) => !stack.parentStack.isMemberExpression);
        if (pStack && pStack.parentStack.isPackageDeclaration) {
          return [pStack, context];
        }
        if (pStack && pStack.parentStack.isAnnotationExpression) {
          return [pStack, context];
        }
        if (this.isTypeDefinitionStack(pStack.parentStack)) {
          return [pStack.parentStack, context || pStack.parentStack.getContext()];
        }
        if (this.parentStack.isCallExpression || this.parentStack.isNewExpression) {
          if (this.parentStack.callee === this) {
            return [this.parentStack, context || this.parentStack.getContext()];
          }
        }
        context = context || this.getContext();
        const desc = this.computed ? this.property.description() : this.description();
        if (!desc)
          return null;
        let object = Utils.inferNotNullType(this.object.type());
        if (desc.isAnyType) {
          if (object.isLiteralObjectType && object.target && object.target.isObjectExpression) {
            const type2 = this.parentStack.isAssignmentExpression ? this.parentStack.right.type().toString(this.parentStack.right.getContext()) : "any";
            return [null, context, {
              expre: `(property) ${this.property.value()}: ${type2}`
            }];
          }
        }
        if (desc.isType && !desc.isModule && this.is(desc.target) && desc.target.compilation) {
          const target = desc.target;
          return [null, context, {
            expre: `(property) ${this.property.value()}: ${this.type().toString(context)}`,
            location: target.getLocation(),
            file: target.compilation.file,
            comments: target.comments
          }];
        }
        if (this.isLiteralObject(object) && Utils.isMergedType(object)) {
          return [desc, context, null, `(property) ${this.property.value()}: ${this.type().toString(context)}`];
        }
        return [desc, context];
      }
      definition(context) {
        const result = this.resolveDefinitionContext(context);
        if (!result)
          return null;
        let [desc, ctx, def, text] = result;
        if (def)
          return def;
        if (!ctx) {
          ctx = this.getContext();
        }
        ctx.setHoverStack(context && context.hoverStack || this);
        let _def = desc.definition(ctx);
        if (text) {
          _def.text = text;
        }
        return _def;
      }
      hover(context) {
        const result = this.resolveDefinitionContext(context);
        if (!result)
          return null;
        let [desc, ctx, def, text] = result;
        if (def) {
          return def;
        }
        if (!ctx) {
          ctx = this.getContext();
        }
        ctx.setHoverStack(context && context.hoverStack || this);
        let _def = desc.hover(ctx);
        if (text) {
          _def.text = text;
        }
        return _def;
      }
      set accessor(val) {
        this._accessor = val;
      }
      getDescription() {
        let property = this.property.value();
        let description = this.object.descriptor();
        let desc = null;
        if (Namespace.is(description)) {
          let ns = description;
          if (this.parentStack.isMemberExpression) {
            desc = description.children.get(property);
            if (desc) {
              ns = desc;
            } else {
              desc = this.getMemberMatchDescriptor(ns, property, this.parentStack.property.value());
            }
          } else {
            if ((this.parentStack.isNewExpression || this.parentStack.isCallExpression) && this.parentStack.callee === this) {
              const descriptors = description.descriptors.get(property);
              if (descriptors && descriptors.length > 0) {
                const result = descriptors.find((d) => d.isDeclaratorVariable);
                if (result) {
                  desc = result;
                }
              }
            }
            if (!desc) {
              desc = description.modules.get(property) || description.getDescriptor(property);
            }
          }
          if (desc && !this.compiler.options.service && this.compilation.isLocalDocument()) {
            this.addAutoImporter(property, ns, desc);
          }
        } else if (description) {
          let object = description.isModuleDeclaration ? description.module : null;
          if (!object) {
            if (description.isExportAssignmentDeclaration) {
              object = description.getExportNamespace();
            } else if (JSModule.is(description)) {
              object = description;
            }
          }
          if (object) {
            desc = object.getDescriptor(property, null, { isMember: true });
          }
        }
        if (desc) {
          this._isGlobalRefs = true;
          return desc;
        }
        if (this.computed) {
          if (this.property.isIdentifier) {
            const refs = this.property.reference();
            const desc2 = this.property.description();
            if (refs === this.property && desc2 && !(desc2.isDeclarator && desc2 instanceof Stack)) {
              this.computed = false;
            }
          }
          if (this.computed) {
            const object = this.object.type();
            if (this.property.isLiteral) {
              const _value = this.getObjectDescriptor(object, property, Utils.isClassType(object) && object === description);
              if (_value) {
                return _value;
              }
            }
            if (object.isLiteralObjectType && object.attributes.size > 1) {
              const merge = new MergeType();
              object.attributes.forEach((attr) => {
                merge.add(attr.type());
              });
              return merge.type();
            }
            const origin = Utils.getOriginType(object, (type2) => {
              return type2.isLiteralObjectType || type2.isLiteralArrayType;
            });
            const ctx = this.getContext();
            const pType = !this.property.isLiteral ? this.property.type() : null;
            let result = pType ? this.getObjectDynamicDescriptor(origin, pType, ctx) : null;
            if (!result) {
              result = this.getObjectDynamicDescriptor(origin, Namespace.globals.get(typeof property === "number" ? "number" : "string"), ctx);
            }
            if (result) {
              return result;
            }
            if (pType && pType.isUniqueType) {
              return null;
            }
            return new ComputeType(this, this.object, this.property);
          }
        }
        let objectType = this.object.type();
        if (!objectType)
          return null;
        if (objectType.isCircularType) {
          objectType = Utils.getOriginType(objectType, (type2) => !type2.isCircularType);
        }
        const isStatic = Utils.isClassType(objectType) && objectType === description;
        if (objectType) {
          desc = this.getObjectDescriptor(objectType, property, isStatic);
          if (desc) {
            return desc;
          }
        }
        return null;
      }
      descriptor() {
        return this.getAttribute("descriptor", () => {
          let _desc = this.description();
          if (!_desc)
            return null;
          if (!this._isGlobalRefs)
            return _desc;
          if (this.parentStack.isCallExpression) {
            if (_desc.isDeclaratorVariable) {
              const type2 = _desc.type();
              if (type2.isFunctionType && type2.target && type2.target.isDeclaratorFunction) {
                _desc = type2.target;
              }
            }
            let key = this.property.value();
            let object = _desc.isNamespaceDeclaration ? _desc.parentStack.module : null;
            if (JSModule.is(_desc)) {
              object = _desc;
            } else if (JSModule.is(_desc.module)) {
              object = _desc.module;
            } else if ((_desc.isDeclaratorVariable || _desc.isDeclaratorFunction) && Namespace.is(_desc.namespace)) {
              key = _desc.value();
              object = _desc.namespace;
            }
            if (object) {
              const result = this.parentStack.getMatchDescriptor(key, object);
              if (result) {
                return result;
              }
            }
          }
          if (_desc.isTypeObjectPropertyDefinition) {
            return this.type();
          }
          return _desc;
        });
      }
      addAutoImporter(property, ns, desc) {
        if (!ns.imports.has(property) || this.hasMatchAutoImporter)
          return;
        const prefix = ns.imports.get(ns.id);
        const has = this.compilation.hasDescriptorReferenceName(desc);
        if (prefix && prefix.namespace) {
          if (!has) {
            this.addImportSpecifierDependency(prefix, desc, this.scope.generateVarName(ns.id));
          }
          if (this.parentStack.isMemberExpression) {
            this._hasMatchAutoImporter = true;
          } else {
            this.object._hasMatchAutoImporter = true;
          }
          return;
        }
        if (!has) {
          this.addImportSpecifierDependency(ns.imports.get(property), desc, this.scope.generateVarName(property));
        }
        this._hasMatchAutoImporter = true;
      }
      description() {
        return this.getAttribute("MemberExpression.description", () => {
          let desc = this.getDescription();
          if (!desc) {
            const module2 = this.module;
            desc = this.getModuleById(this.value()) || null;
            if (desc && Utils.isClassType(desc) && desc !== module2) {
              this.compilation.addDependency(desc, this.module);
            }
          } else if (this.object.isThisExpression && Utils.isStack(desc)) {
            if (!this.compiler.scopeManager.checkDescriptor(desc, this.compilation)) {
              this.error(1178, this.property.value());
              return null;
            }
          }
          if (desc && desc.isProperty && desc.computed) {
            const origin = this.getFirstMemberStack().description();
            const scope = this.scope;
            if (scope && origin && origin.isDeclarator && scope.allowInsertionPredicate()) {
              const predicate = scope.getPredicate(origin);
              if (predicate) {
                return predicate.getAttribute(this.value(), desc);
              }
            }
          }
          return desc;
        });
      }
      type() {
        return this.getAttribute("MemberExpression.type", () => {
          const description = this.description();
          if (description) {
            if (description.isNamespace) {
              return description;
            }
            let type2 = description.isMethodGetterDefinition ? description.getReturnedType(this) : description.type();
            if (type2) {
              if (description.isProperty) {
                let object = Utils.inferNotNullType(this.object.type());
                if (Utils.isMergedType(object)) {
                  if (this.isLiteralObject(object)) {
                    const _desc = object.attribute(this.property.value());
                    if (_desc && Utils.isType(_desc)) {
                      type2 = _desc;
                    }
                  }
                }
              }
              if (description.isDeclaratorVariable && this.parentStack.isNewExpression) {
                type2 = description.declarations[0].type();
              }
              if (this.scope.allowInsertionPredicate()) {
                const predicate = this.scope.getPredicate(description);
                if (predicate && predicate.type) {
                  type2 = predicate.type;
                } else {
                  const state = this.scope.getValidateState(description);
                  if (state) {
                    if (state.value && !state.isAlternate || !state.value && state.isAlternate) {
                      type2 = Utils.inferNotNullType(type2);
                    }
                  }
                }
              }
              if (description.isMethodGetterDefinition) {
                type2 = this.getContext().apply(type2);
              } else if (type2.isGenericType) {
                type2 = this.getContext().fetch(type2) || type2;
              }
              return type2;
            }
          }
          return Namespace.globals.get("any");
        });
      }
      isProtectedAccessible(target) {
        let parent = this.module;
        while (parent) {
          if (Utils.isEqualModule(parent, target))
            return true;
          parent = parent.type().getInheritModule();
        }
        return false;
      }
      getFirstMemberStack() {
        if (this.object.isMemberExpression) {
          return this.object.getFirstMemberStack();
        } else {
          return this.object;
        }
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.object.parser();
        let desc = this.object.description();
        if (!desc && this.object.isIdentifier) {
          this.object.error(1013, this.object.value());
        }
        this.object.setRefBeUsed(desc);
        const description = this.description();
        if (description) {
          this.parserDescriptor(description);
          this.property.setRefBeUsed(description);
          if ((description.isGenericTypeDeclaration || description.isTypeStatement) && !this.scope.isDirective) {
            const parent = this.parentStack;
            if (!parent.isTypeTransformExpression && !(parent.isTypeDefinition || parent.isTypeTupleRestDefinition || parent.isTypeTupleDefinition || parent.isGenericTypeDeclaration || parent.isGenericDeclaration || parent.isTypeObjectDefinition || parent.isBinaryExpression && parent.isIsOperatorFlag || parent.isTypeObjectPropertyDefinition || parent.isTypeFunctionDefinition || parent.isTypeUnionDefinition)) {
              this.error(1059, this.value());
            }
          }
          if (description.isNamespace && !this.parentStack.isMemberExpression) {
            this.error(1059, this.value());
          }
        }
        if (this.computed) {
          this.property.parser();
          this.property.setRefBeUsed();
          const propertyType = this.property.type();
          if (propertyType.isTupleType || propertyType.isLiteralObjectType || propertyType.isLiteralArrayType) {
            this.property.error(1150, propertyType.toString());
          }
        }
        if (!description) {
          if (!this.optional) {
            if (this.computed) {
              this.error(1060, this.raw());
            } else {
              this.property.error(1060, this.raw());
            }
          }
        } else if (description.isMethodDefinition || description.isPropertyDefinition) {
          let object = Utils.getOriginType(this.object.type());
          if (object && object.isModule) {
            if (object.isRemoved(this.property.value(), description)) {
              this.error(1181, this.raw());
            }
            if (object.isDeprecated(this.property.value(), description)) {
              object.getDescriptor(this.property.value(), (desc2) => {
                if (desc2.isDeprecated) {
                  const deprecatedAnnotation = desc2.annotations.find((item2) => item2.name.toLowerCase() === "deprecated");
                  if (deprecatedAnnotation) {
                    const args = deprecatedAnnotation.getArguments();
                    const message = args[0] ? args[0].value : "";
                    this.deprecated(1182, this.raw(), message);
                  }
                }
              });
            }
          }
          const modifier = description.modifier ? description.modifier.value() : "public";
          if (modifier !== "public" && this.scope.type("top")) {
            this.property.error(1061, this.raw());
          } else if (modifier === "private" && !Utils.isEqualModule(description.module, this.module)) {
            this.property.error(1061, this.raw());
          } else if (modifier === "protected" && !this.isProtectedAccessible(description.module)) {
            this.property.error(1061, this.raw());
          }
        }
      }
      value() {
        let optional = this.optional ? "?." : "";
        if (this.computed) {
          return `${this.object.value()}${optional}[${this.property.raw()}]`;
        }
        return `${this.object.value()}${optional || "."}${this.property.value()}`;
      }
    };
    module.exports = MemberExpression;
  }
});

// lib/stacks/MetatypeDeclaration.js
var require_MetatypeDeclaration = __commonJS({
  "lib/stacks/MetatypeDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var BlankScope = require_BlankScope();
    var MetatypeDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        scope = new BlankScope(null);
        super(compilation, node2, scope, parentNode, parentStack);
        this.isMetatypeDeclaration = true;
        this.body = (node2.body || []).map((item2) => {
          return this.createTokenStack(compilation, item2, scope, node2, this);
        });
      }
      freeze() {
        super.freeze();
        super.freeze(this.body);
        (this.body || []).forEach((stack) => stack.freeze());
      }
      get name() {
        return this.node.name;
      }
      description() {
        return this;
      }
      getArguments() {
        const target = [];
        this.body.map((item2, index) => {
          if (item2.isAssignmentPattern) {
            const key = item2.left.value();
            const value2 = item2.right.value();
            const assigned = true;
            target.push({ key, value: value2, assigned, stack: item2 });
          } else {
            const key = index;
            const value2 = item2.value();
            const assigned = false;
            target.push({ key, value: value2, assigned, stack: item2 });
          }
        });
        return target;
      }
    };
    module.exports = MetatypeDeclaration;
  }
});

// lib/stacks/MethodDefinition.js
var require_MethodDefinition = __commonJS({
  "lib/stacks/MethodDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var Constant = require_Constant();
    var InstanceofType = require_InstanceofType();
    var Utils = require_Utils();
    var Namespace = require_Namespace();
    var MethodDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isMethodDefinition = true;
        this._metatypes = [];
        this._annotations = [];
        this.isMethod = true;
        this.static = this.createTokenStack(compilation, node2.static, scope, node2, this);
        this.key = this.createTokenStack(compilation, node2.key, scope, node2, this);
        let name = this.key.value();
        this.dynamicMethod = false;
        if (node2.dynamic) {
          this.dynamicMethod = true;
          if (node2.key.acceptType) {
            this.dynamicType = this.createTokenStack(compilation, node2.key.acceptType, scope, node2, this);
          } else {
            name = this.key.raw();
          }
        }
        if (name === "constructor" || name === this.module.id) {
          this.isConstructor = true;
          this.callable = false;
          if (node2.genericity) {
            this.key.error(1062);
          }
        } else {
          this.callable = true;
        }
        this.expression = this.createTokenStack(compilation, node2.value, scope, node2, this);
        this.modifier = this.createTokenStack(compilation, node2.modifier, scope, node2, this);
        this.override = false;
        this.isFinal = false;
        this.isRemoved = false;
        this.isDeprecated = false;
        this.isNoop = false;
        this.expression.key = this.key;
        this.scope = this.expression.scope;
        this.kind = node2.kind;
        if (!this.static) {
          this.expression.scope.define("this", new InstanceofType(this.module, this, null, true));
        } else {
          this.scope.isStatic = true;
        }
        if (!this.parentStack.isUseExtendStatement) {
          if (!this.dynamicType) {
            this.module.addMember(name, this);
          }
        }
        this.isEnterMethod = false;
        this.policy = Constant.POLICY_NONE;
      }
      freeze() {
        this.key.freeze();
        super.freeze();
        super.freeze(this.scope);
        super.freeze(this.static);
        super.freeze(this._metatypes);
        super.freeze(this._annotations);
        super.freeze(this.modifier);
        super.freeze(this.override);
        super.freeze(this._annotations);
        super.freeze(this.useRefItems);
        this.expression.freeze();
      }
      definition(ctx) {
        let type2 = this.getReturnedType();
        if (Utils.isContext(ctx) && ctx.stack && ctx.stack.isCallExpression) {
          type2 = ctx.apply(type2);
        }
        let complete = false;
        if (!ctx || ctx.stack && (ctx.stack === this.key || ctx.stack === this || ctx.stack.isMemberExpression)) {
          complete = true;
          ctx = {};
        }
        const identifier = this.value();
        const context = this;
        const _thisCtx = this.thisArgumentContext;
        const _params = _thisCtx ? [_thisCtx, ...this.params] : this.params;
        const params = _params.map((item2) => {
          if (item2.isObjectPattern) {
            const properties = item2.properties.map((property) => {
              const name = property.key.value();
              const acceptType = property.type().toString(ctx);
              const init = property.init;
              if (init && init.isAssignmentPattern) {
                return `${init.left.value()}:${acceptType} = ${init.right.raw()}`;
              }
              return `${name}:${acceptType}`;
            });
            return `{${properties.join(",")}}`;
          } else if (item2.isArrayPattern) {
            const properties = item2.elements.map((property) => {
              const acceptType = property.type().toString(ctx);
              if (property.isAssignmentPattern) {
                return `${property.left.value()}:${acceptType} = ${property.right.raw()}`;
              }
              const name = property.value();
              return `${name}:${acceptType}`;
            });
            return `[${properties.join(",")}]`;
          } else {
            const name = item2.value();
            const type3 = item2.type().toString(ctx);
            const rest = item2.isRestElement ? "..." : "";
            const question = item2.question ? "?" : "";
            if (item2.isAssignmentPattern && item2.right) {
              const initial = item2.right.value();
              return `${rest}${name}${question}: ${type3}=${initial}`;
            }
            return `${rest}${name}${question}: ${type3}`;
          }
        });
        const modifier = this.modifier ? this.modifier.value() : "public";
        const _static = this.static ? "static " : "";
        const generics = (this.genericity ? this.genericity.elements : []).map((item2) => {
          return item2.type().toString(ctx, { complete });
        });
        const kind = this.isConstructor ? "constructor" : "method";
        const strGenerics = generics.length > 0 ? `<${generics.join(", ")}>` : "";
        let owner = this.module.getName();
        if (!this.isConstructor) {
          if (this.dynamicMethod) {
            owner = `${owner}[${identifier}]`;
          } else {
            owner = `${owner}.${identifier}`;
          }
        }
        let location = this.key.getLocation();
        const returnType = type2 ? type2.type().toString(ctx, { chain: ["function"] }) : this.isConstructor ? owner : "void";
        return {
          comments: context.comments,
          expre: `(${kind}) ${_static}${modifier} ${owner}${strGenerics}(${params.join(", ")}): ${returnType}`,
          location,
          file: this.compilation.file
        };
      }
      signature() {
        const def = this.definition();
        const _params = this.params;
        const comments = this.parseComments();
        const params = _params.map((item2) => {
          if (item2.isObjectPattern) {
            return {
              label: "ObjectPattern"
            };
          } else if (item2.isArrayPattern) {
            return {
              label: "ArrayPattern"
            };
          } else {
            const name = item2.value();
            const meta = comments && comments.params.find((param) => param.label === name);
            return {
              label: name,
              comment: meta && meta.comment ? meta.comment : item2.comments.join("\n")
            };
          }
        });
        def.params = params;
        return def;
      }
      set metatypes(value2) {
        this._metatypes = value2;
        if (this.isConstructor) {
          if (!this.callable) {
            this.callable = value2.some((metatype) => {
              metatype.additional = this;
              return metatype.name.toLowerCase() === "callable";
            });
          }
          if (this.callable) {
            this.module.callable = this;
          }
        }
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value2) {
        this._annotations = value2;
        value2.forEach((annotation) => {
          annotation.additional = this;
          switch (annotation.name.toLowerCase()) {
            case "override":
              this.override = true;
              break;
            case "callable":
              this.callable = !!this.isConstructor;
              if (this.callable) {
                this.module.addDescriptor("#" + this.module.id, this);
              }
              break;
            case "main":
              this.isEnterMethod = true;
              break;
            case "final":
              this.isFinal = true;
              break;
            case "deprecated":
              this.isDeprecated = true;
              break;
            case "removed":
              this.isRemoved = true;
            case "noop":
              this.isNoop = true;
              break;
          }
        });
      }
      get annotations() {
        return this._annotations;
      }
      get params() {
        return this.expression.params;
      }
      get body() {
        return this.expression.body;
      }
      get genericity() {
        return this.expression.genericity;
      }
      get question() {
        return !!this.key.node.question;
      }
      get thisArgumentContext() {
        return this.expression.thisArgumentContext;
      }
      get hasRecursionReference() {
        return this.expression.hasRecursionReference;
      }
      addRecursionCallStacks(stack) {
        this.expression.addRecursionCallStacks(stack);
      }
      reference(called) {
        return this.expression.reference(called);
      }
      referenceItems(called) {
        return this.expression.referenceItems(called);
      }
      description() {
        return this;
      }
      error(code, ...args) {
        this.key.error(code, ...args);
      }
      warn(code, ...args) {
        this.key.warn(code, ...args);
      }
      getFunType() {
        return this.expression.getFunType();
      }
      inferReturnType(context) {
        return this.expression.inferReturnType(context);
      }
      getReturnedType(caller) {
        if (this.isConstructor) {
          return this.expression._returnType;
        }
        return this.expression.getReturnedType(caller);
      }
      getContext() {
        return this.expression.getContext();
      }
      type() {
        const expr = this.expression;
        const name = this.key.value();
        if ((name === "constructor" || name === this.module.id) && !expr._returnType) {
          return this.module;
        }
        return expr.type();
      }
      get returnType() {
        const expr = this.expression;
        const name = this.key.value();
        if ((name === "constructor" || name === this.module.id) && !expr._returnType) {
          return this.module;
        }
        return expr.returnType;
      }
      value() {
        if (this.dynamicMethod) {
          return this.key.raw();
        }
        return this.key.value();
      }
      getAnnotationAlias(flag = true) {
        const result = this.getAttribute("getAnnotationAlias", () => {
          return this.findAnnotation((annot) => annot.getLowerCaseName() === "alias" ? annot : false);
        });
        if (flag) {
          if (result) {
            const [annot] = result;
            if (annot && annot.isAnnotationDeclaration) {
              const args = annot.getArguments();
              if (args[0]) {
                return args[0].value;
              }
            }
          }
          return null;
        }
        return result;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.dynamicType) {
          this.dynamicType.parser();
          this.module.dynamicProperties.set(this.dynamicType.type(), this);
        } else if (this.dynamicMethod) {
          this.key.parser();
          this.module.dynamicProperties.set(this.key.type(), this);
        }
        if (this.parentStack.isUseExtendStatement) {
          this.expression.parser();
          return true;
        }
        const metatypes = this.metatypes;
        const annotations = this.annotations;
        if (metatypes) {
          metatypes.forEach((item2) => item2.parser());
        }
        if (annotations) {
          annotations.forEach((item2) => item2.parser());
        }
        if (this.module && !this.module.isDeclaratorModule) {
          const kind = this.isAccessor ? "accessor" : "method";
          const accessor = this.isMethodGetterDefinition ? "get" : this.isMethodSetterDefinition ? "set" : null;
          let parent = this.module.getInheritModule();
          if (this.module.isEnum && Namespace.globals.get("Enumeration") === parent) {
            parent = null;
          }
          if (this.override) {
            if (this.static) {
              this.key.warn(1200);
            } else {
              const pMethod = parent && parent.getMember(this.key.value(), accessor, true, false);
              if (!parent || !pMethod) {
                this.key.error(1063, this.key.value(), kind);
              } else if (pMethod.isAccessor !== this.isAccessor) {
                this.key.error(1136, this.key.value(), kind);
              } else if (this.params.length !== pMethod.params.length) {
                if (this.isAccessor) {
                  this.key.error(1089, this.key.value());
                } else {
                  const isRest = this.params.length === 1 && this.params[0].isRestElement;
                  if (!isRest && pMethod.params.length >= this.params.length) {
                    if (!pMethod.params.every((item2, index) => {
                      if (item2.question)
                        return true;
                      return !!this.params[index];
                    })) {
                      this.key.error(1088, this.key.value());
                    }
                  }
                }
              }
              if (pMethod && pMethod.isFinal) {
                this.key.error(1148, this.key.value());
              }
              if (pMethod) {
                this.params.forEach((item2, index) => {
                  if (item2.acceptType)
                    return;
                  const right = pMethod.params[index];
                  if (right && right.acceptType) {
                    item2.inheritInterfaceAcceptType = right;
                  }
                });
              }
            }
          } else if (parent && !this.static) {
            const parentMethod = parent.getMember(this.key.value(), accessor, true, false);
            if (parentMethod && Utils.getModifierValue(parentMethod) !== "private") {
              this.key.error(1064, this.key.value(), kind);
            }
          }
        }
        this.expression.parser();
      }
    };
    module.exports = MethodDefinition;
  }
});

// lib/stacks/MethodGetterDefinition.js
var require_MethodGetterDefinition = __commonJS({
  "lib/stacks/MethodGetterDefinition.js"(exports, module) {
    var Namespace = require_Namespace();
    var MethodDefinition = require_MethodDefinition();
    var MethodGetterDefinition = class extends MethodDefinition {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isMethodGetterDefinition = true;
        this.callable = false;
        this.isAccessor = true;
      }
      definition(ctx) {
        let complete = false;
        if (!ctx || ctx.stack && (ctx.stack === this.key || ctx.stack === this)) {
          complete = true;
          ctx = {};
        }
        const type2 = this.type();
        const identifier = this.key.value();
        const context = this;
        const modifier = this.modifier ? this.modifier.value() : "public";
        let owner = this.module.getName();
        const _static = this.static ? "static " : "";
        const declareGenerics = this.module.getModuleGenerics();
        if (declareGenerics) {
          owner = [owner, "<", declareGenerics.map((type3) => type3.toString(ctx, { complete })).join(", "), ">"].join("");
        }
        return {
          comments: context.comments,
          expre: `(propery) ${_static}${modifier} get ${owner}.${identifier}(): ${type2.toString(ctx)}`,
          location: this.key.getLocation(),
          file: this.compilation.file
        };
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.expression.params.length != 0) {
          this.error(1065, this.key.value());
        }
        const isInterface = this.module && (this.module.isDeclaratorModule || this.module.isInterface);
        if (this.scope.returnItems.length < 1 && !isInterface) {
          this.error(1066, this.key.value());
        }
      }
      getReturnedType(caller) {
        const result = super.getReturnedType(caller);
        let type2 = null;
        if (result) {
          type2 = result.type();
        }
        return type2 || Namespace.globals.get("any");
      }
      type() {
        return this.getReturnedType();
      }
      referenceItems() {
        return super.referenceItems(true);
      }
      reference() {
        return super.reference(true);
      }
      getFunType() {
        return null;
      }
    };
    module.exports = MethodGetterDefinition;
  }
});

// lib/stacks/MethodSetterDefinition.js
var require_MethodSetterDefinition = __commonJS({
  "lib/stacks/MethodSetterDefinition.js"(exports, module) {
    var MethodDefinition = require_MethodDefinition();
    var MethodSetterDefinition = class extends MethodDefinition {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isMethodSetterDefinition = true;
        this.callable = false;
        this.assignValue = null;
        this.assignItems = /* @__PURE__ */ new Set();
        this.isAccessor = true;
      }
      freeze() {
        super.freeze();
        super.freeze(this.assignItems);
      }
      definition(ctx) {
        let complete = false;
        if (!ctx || ctx.stack && (ctx.stack === this.key || ctx.stack === this)) {
          complete = true;
          ctx = {};
        }
        const identifier = this.key.value();
        const context = this;
        const params = this.params.map((item2) => {
          let type2 = item2.type();
          type2 = type2 ? type2.toString(ctx) : "unknown";
          return `${item2.value()}:${type2}`;
        });
        const modifier = this.modifier ? this.modifier.value() : "public";
        let owner = this.module.getName();
        const _static = this.static ? "static " : "";
        const declareGenerics = this.module.getModuleGenerics();
        if (declareGenerics) {
          owner = [owner, "<", declareGenerics.map((type2) => type2.toString(ctx, { complete })).join(", "), ">"].join("");
        }
        return {
          comments: context.comments,
          expre: `(propery) ${_static}${modifier} set ${owner}.${identifier}(${params.join(",")}):void`,
          location: this.key.getLocation(),
          file: this.compilation.file
        };
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.expression.params.length != 1) {
          this.error(1067, this.key.value());
        }
        const param = this.expression.params[0];
        if (param.acceptType) {
          let has = false;
          const type2 = param.acceptType.type();
          const ctx = this.getContext();
          const desc = this.module.getDescriptor(this.key.value(), (desc2) => {
            if (desc2 && desc2.isMethodGetterDefinition) {
              has = true;
              return type2 && type2.check(desc2, ctx);
            }
          });
          if (has) {
            if (!desc) {
              this.error(1068, this.key.raw());
            }
          }
        }
      }
      type() {
        return this.getGlobalTypeById("void");
      }
      getFunType() {
        return null;
      }
      referenceItems() {
        return [];
      }
      reference() {
        return null;
      }
      assignment(value2, stack = null) {
        if (this.assignValue !== value2) {
          const param = this.expression.params[0];
          let acceptType = param.acceptType ? param.acceptType.type() : null;
          if (!acceptType) {
            const desc = this.compilation.getReference(this.key.value(), this.module, !!this.static, "get");
            acceptType = desc ? desc.type() : null;
          }
          const result = this.checkExpressionType(acceptType, value2, stack || this);
          if (result) {
            this.assignItems.add(value2);
            this.assignValue = value2;
          }
          if (value2 && value2.isStack) {
            this.setRefBeUsed(value2.description());
          }
        }
      }
    };
    module.exports = MethodSetterDefinition;
  }
});

// lib/stacks/ModifierDeclaration.js
var require_ModifierDeclaration = __commonJS({
  "lib/stacks/ModifierDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var ModifierDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isModifierDeclaration = true;
      }
    };
    module.exports = ModifierDeclaration;
  }
});

// lib/scope/DeclaratorScope.js
var require_DeclaratorScope = __commonJS({
  "lib/scope/DeclaratorScope.js"(exports, module) {
    var Scope = require_Scope();
    module.exports = class DeclaratorScope extends Scope {
      constructor(parentScope) {
        super(parentScope);
        this.isDeclaratorScope = true;
      }
      type(name) {
        return name === "declarator";
      }
    };
  }
});

// lib/stacks/ModuleDeclaration.js
var require_ModuleDeclaration = __commonJS({
  "lib/stacks/ModuleDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var JSModule = require_JSModule();
    var DeclaratorScope = require_DeclaratorScope();
    var Namespace = require_Namespace();
    var ModuleDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        scope = new DeclaratorScope(scope);
        super(compilation, node2, scope, parentNode, parentStack);
        this.isModuleDeclaration = true;
        this._metatypes = [];
        this._annotations = [];
        this.id = this.createTokenStack(compilation, node2.id, scope, node2, this);
        this.body = [];
        this.exports = [];
        this.externals = [];
        this.imports = [];
        this.annotations = [];
        if (!(parentStack.isProgram || parentStack.isModuleDeclaration || parentStack.isExportNamedDeclaration)) {
          this.id.error(1180, this.id.value());
        }
        compilation.hasDeclareJSModule = true;
        const id = this.id.value();
        let module2 = null;
        if (node2.type === "NamespaceDeclaration") {
          this.isNamespaceDeclaration = true;
          if (this.id.isMemberExpression && parentStack.isNamespaceDeclaration) {
            this.id.error(1197);
          } else {
            let result = id === "global" || !this.module ? JSModule.getNamespace(id, this.namespace) : JSModule.createModuleFromNamespace(id, this.module, this.compilation);
            if (result.isNamespaceModule) {
              module2 = result;
              module2.addStack(this);
              this.namespace = module2.namespace;
            } else {
              this.namespace = result;
              this.compilation.namespace = result;
            }
          }
        } else {
          module2 = JSModule.createModule(id, this.compilation);
          this.namespace = module2.namespace;
          module2.addStack(this);
        }
        this.module = module2;
        const annotations = this.annotations;
        const metatypes = this.metatypes;
        const imports = this.imports;
        const exports2 = this.exports;
        const externals = this.externals;
        node2.body.forEach((item2, index) => {
          const stack = this.createTokenStack(compilation, item2, scope, node2, this);
          if (stack.isAnnotationDeclaration) {
            const annotationStack = this.interceptAnnotation(stack);
            if (annotationStack) {
              annotations.push(annotationStack);
            }
          } else if (stack.isImportDeclaration) {
            imports.push(stack);
          } else if (stack.isExportAllDeclaration || stack.isExportDefaultDeclaration || stack.isExportNamedDeclaration || stack.isExportAssignmentDeclaration) {
            exports2.push(stack);
          } else {
            stack.metatypes = metatypes.splice(0, metatypes.length);
            stack.annotations = annotations.splice(0, annotations.length);
            if (stack.isModuleDeclaration || stack.isClassDeclaration || stack.isEnumDeclaration || stack.isInterfaceDeclaration || stack.isStructTableDeclaration || stack.isDeclaratorDeclaration || stack.isDeclaratorVariable || stack.isDeclaratorFunction || stack.isTypeStatement || stack.isDeclaratorTypeAlias) {
              this.body.push(stack);
              if (module2) {
                if (stack.isNamespaceDeclaration) {
                  if (stack.module) {
                    module2.addDescriptor(stack.value(), stack);
                  }
                } else if (stack.isModuleDeclaration) {
                  const pp = this.getParentStack((stack2) => stack2.isModuleDeclaration, true);
                  if (pp && pp.isModuleDeclaration && pp.module) {
                    pp.module.addJSModuleRefs(stack.module);
                  }
                } else {
                  if (stack.isDeclaratorFunction || stack.isDeclaratorVariable) {
                    module2.addDescriptor(stack.value(), stack);
                  } else {
                    module2.setType(stack.value(), stack);
                  }
                }
              }
            } else {
              externals.push(stack);
            }
          }
        });
      }
      type() {
        if (this.module) {
          return this.module.getExportObjectType();
        }
        return Namespace.globals.get("never");
      }
      description() {
        return this;
      }
      definition(ctx) {
        const kind = this.isNamespaceDeclaration ? "namespace" : "module";
        let id = this.id.value();
        if (!this.isNamespaceDeclaration) {
          id = `"${id}"`;
        }
        return {
          kind,
          text: `${kind} ${id}`,
          location: this.id.getLocation(),
          file: this.file
        };
      }
      set metatypes(value2) {
        value2.forEach((item2) => {
          item2.additional = this;
        });
        this._metatypes = value2;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value2) {
        value2.some((annotation) => {
          annotation.additional = this;
        });
        this._annotations = value2;
      }
      get annotations() {
        return this._annotations;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.id);
        super.freeze(this.body);
        this.body.forEach((stack) => stack.freeze());
      }
      async createCompleted() {
        if (this.imports.length > 0) {
          await this.compiler.callAsyncSequence(this.imports, async (stack) => {
            await stack.addImport();
          });
        }
        if (this.body.length > 0) {
          await Promise.allSettled(this.body.map((item2) => item2.createCompleted()));
        }
        if (this.exports.length > 0) {
          await this.allSettled(this.exports, async (stack) => await stack.createCompleted());
        }
      }
      checkDepend(module2, depModule) {
        return depModule.extends.concat(depModule.implements).some((depModule2) => {
          if (depModule2 === module2)
            return true;
          return this.checkDepend(module2, depModule2);
        });
      }
      value() {
        return this.id.value();
      }
      parser() {
        if (super.parser() === false)
          return false;
        try {
          this.imports.forEach((stack) => stack.parser());
          this.body.forEach((item2) => {
            item2.parser();
          });
          this.exports.forEach((stack) => {
            stack.parser();
          });
          this.externals.forEach((stack) => stack.parser());
        } catch (e) {
          console.error(e);
        }
      }
    };
    module.exports = ModuleDeclaration;
  }
});

// lib/stacks/NamespaceDeclaration.js
var require_NamespaceDeclaration = __commonJS({
  "lib/stacks/NamespaceDeclaration.js"(exports, module) {
    var ModuleDeclaration = require_ModuleDeclaration();
    var NamespaceDeclaration = class extends ModuleDeclaration {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isNamespaceDeclaration = true;
      }
    };
    module.exports = NamespaceDeclaration;
  }
});

// lib/stacks/NewDefinition.js
var require_NewDefinition = __commonJS({
  "lib/stacks/NewDefinition.js"(exports, module) {
    var FunctionExpression = require_FunctionExpression();
    var NewDefinition = class extends FunctionExpression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isNewDefinition = true;
        this.module.addDescriptor("constructor", this);
        this.callable = false;
      }
      getLocation() {
        if (this.node.loc) {
          const loc = Object.create(this.node.loc);
          loc.end.line = loc.start.line;
          loc.end.column = loc.start.column + 3;
          return loc;
        }
        return null;
      }
    };
    module.exports = NewDefinition;
  }
});

// lib/stacks/NewExpression.js
var require_NewExpression = __commonJS({
  "lib/stacks/NewExpression.js"(exports, module) {
    var Utils = require_Utils();
    var Expression = require_Expression();
    var InstanceofType = require_InstanceofType();
    var Namespace = require_Namespace();
    var Module = require_Module();
    var MergeType = require_MergeType();
    var NewExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isNewExpression = true;
        this.callee = this.createTokenStack(compilation, node2.callee, scope, node2, this);
        this.arguments = node2.arguments.map((item2) => {
          return this.createTokenStack(compilation, item2, scope, node2, this);
        });
        this.genericity = null;
        if (node2.genericity) {
          this.genericity = node2.genericity.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
        }
      }
      freeze() {
        super.freeze();
        super.freeze(this.arguments);
        super.freeze(this.genericity);
        this.callee.freeze();
        this.arguments.forEach((stack) => stack.freeze());
        (this.genericity || []).forEach((stack) => stack.freeze());
      }
      definition(context) {
        const ctx = this.getContext();
        if (context) {
          ctx.setHoverStack(context.hoverStack);
        }
        const [classModule, methodConstructor] = this.getConstructMethod();
        if (methodConstructor) {
          if (Module.is(classModule)) {
            let descriptors = (classModule.descriptors.get("constructor") || []).filter((item2) => item2 !== methodConstructor);
            return [methodConstructor.definition(ctx), ...descriptors.map((item2) => item2.definition(ctx))];
          }
          return methodConstructor.definition(ctx);
        }
        if (Utils.isModule(classModule)) {
          return classModule.definition(ctx);
        }
        const desc = this.description();
        if (desc) {
          return desc.definition(ctx);
        }
        return null;
      }
      hover(context) {
        const ctx = this.getContext();
        if (context) {
          ctx.setHoverStack(context.hoverStack);
        }
        const [_, methodConstructor] = this.getConstructMethod();
        if (methodConstructor) {
          return methodConstructor.hover(ctx);
        }
        const desc = this.description();
        if (desc) {
          return desc.hover(ctx);
        }
        const def = {
          expre: `new ${this.value()}`
        };
        return def;
      }
      signature() {
        const [classModule, methodConstructor] = this.getConstructMethod();
        if (methodConstructor) {
          return methodConstructor.signature();
        }
        if (Utils.isModule(classModule)) {
          return classModule.definition();
        }
        const desc = this.description();
        if (desc) {
          return desc.signature();
        }
        return null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      description() {
        return this.callee.description();
      }
      descriptor() {
        let [classModule, method] = this.getConstructMethod() || [];
        if (!classModule)
          return null;
        return method || Namespace.globals.get("any");
      }
      doGetConstructMethod(type2, assigmentGenerics, exclude = null) {
        let result = [];
        if (type2 === exclude)
          return null;
        if (!type2 || type2.isAnyType) {
          if (exclude)
            return null;
          return [type2];
        }
        if (type2.isLiteralObjectType) {
          let method = this.getMatchDescriptor("#new#", type2);
          if (method && method.isTypeFunctionDefinition) {
            let prototype = type2.attribute("prototype");
            if (prototype) {
              let _type = prototype.type();
              if (_type.isClassGenericType) {
                if (_type.isClassType) {
                  _type = _type.types[0].type();
                } else {
                  assigmentGenerics = _type.types.map((item2) => item2.type());
                  _type = _type.inherit.type();
                }
              }
              return [_type, method, assigmentGenerics];
            }
            let returnType = method._returnType;
            if (returnType) {
              let _type = returnType.type();
              if (_type.isClassGenericType) {
                if (_type.isClassType) {
                  _type = _type.types[0].type();
                } else {
                  assigmentGenerics = _type.types.map((item2) => item2.type());
                  _type = _type.inherit.type();
                }
              }
              return [_type, method, assigmentGenerics];
            }
          }
          return [type2, method, assigmentGenerics];
        }
        if (type2.isTypeofType) {
          return this.doGetConstructMethod(type2.origin.type(), assigmentGenerics, type2);
        } else if (type2.isIntersectionType) {
          let lResult = this.doGetConstructMethod(type2.left.type(), assigmentGenerics, type2);
          if (lResult && lResult[1]) {
            return lResult;
          }
          let rResult = this.doGetConstructMethod(type2.right.type(), assigmentGenerics, type2);
          if (rResult && rResult[1]) {
            return rResult;
          }
          return lResult[0] ? lResult : rResult;
        } else if (type2.isUnionType) {
          const els = type2.elements;
          let last = null;
          for (let index = 0; index < els.length; index++) {
            let res = this.doGetConstructMethod(els[index].type(), assigmentGenerics, type2);
            if (res) {
              last = res;
              if (res[1])
                return res;
            }
          }
          return last;
        }
        if (type2.isClassGenericType && type2.isClassType) {
          let assigment = type2.types[0].type();
          if (assigment.isAnyType) {
            result = [assigment];
          } else {
            return this.doGetConstructMethod(assigment, assigmentGenerics, type2);
          }
        } else if (type2.isClassGenericType) {
          return this.doGetConstructMethod(type2.inherit.type(), type2.types, type2);
        } else if (Utils.isTypeModule(type2) && (type2.isClass || type2.isInterface)) {
          this.compilation.addDependency(type2, this.module);
          let method = this.getMatchDescriptor("constructor", type2);
          if (method && method.isDeclaratorVariable) {
            return this.doGetConstructMethod(method.type(), assigmentGenerics, type2);
          }
          result = [type2, method, assigmentGenerics];
        } else {
          result = [type2, null, assigmentGenerics];
        }
        return result;
      }
      getConstructMethod(type2 = null) {
        const records = this.__records || (this.__records = /* @__PURE__ */ new Map());
        const desc = this.description();
        if (!desc)
          return [];
        if (!type2) {
          type2 = this.callee.type();
        }
        if (records.has(type2)) {
          return records.get(type2);
        }
        let res = this.doGetConstructMethod(type2);
        records.set(type2, res);
        return res;
      }
      getInstanceType() {
        return this.getAttribute("NewExpression.getInstanceType", () => {
          const inferContext = this.getContextOfInference();
          let type2 = this.callee.type();
          let [classModule, method, assigns] = this.getConstructMethod(type2) || [type2];
          let origin = classModule;
          if (method) {
            const result = method.getReturnedType();
            if (result) {
              let assignType = result.type();
              assignType = inferContext.fetch(assignType) || assignType;
              let [_type, _method, _assigns] = this.getConstructMethod(assignType);
              if (_type && _type !== classModule) {
                assigns = [];
                if (assignType && assignType.isClassGenericType) {
                  if (assignType.isClassType) {
                    classModule = assignType.types[0].type();
                  } else {
                    classModule = assignType.inherit.type();
                    assigns = assignType.types.map((item2) => {
                      return inferContext.apply(item2.type());
                    });
                    return new InstanceofType(classModule, this, assigns, false);
                  }
                }
              }
              if (_type) {
                classModule = _type.type();
                if (classModule.isTupleType && !_assigns) {
                  let res = classModule.elements.map((el) => inferContext.apply(el.type()));
                  _assigns = [res.length === 1 ? res[0] : MergeType.arrayToUnion(res)];
                }
              }
              if (_assigns)
                assigns = _assigns;
            }
          }
          if (this.genericity && origin === classModule) {
            assigns = this.genericity.map((item2) => item2.type());
          } else {
            if (!assigns || !assigns.length) {
              let [, declareGenerics] = this.getDeclareGenerics(classModule);
              if (declareGenerics && declareGenerics.length) {
                assigns = declareGenerics.map((decl2) => {
                  return inferContext.apply(decl2.type());
                });
              }
            } else {
              assigns = assigns.map((item2) => {
                return inferContext.apply(item2.type());
              });
            }
          }
          return new InstanceofType(classModule || Namespace.globals.get("any"), this, assigns || [], false);
        });
      }
      getRawType() {
        return this.getInstanceType();
      }
      type() {
        return this.getInstanceType();
      }
      parserArguments() {
        this.arguments.forEach((item2) => {
          item2.parser();
          item2.setRefBeUsed();
        });
      }
      getFunDeclareParams() {
        const type2 = this.callee.type();
        const [classModule, methodConstructor] = this.getConstructMethod(type2);
        return methodConstructor && methodConstructor.params || [];
      }
      getDeclareGenerics(classModule, methodConstructor) {
        if (methodConstructor && (methodConstructor.isMethodDefinition || methodConstructor.isNewDefinition || methodConstructor.isTypeFunctionDefinition) && methodConstructor.genericity) {
          return [methodConstructor, methodConstructor.genericity.elements];
        } else if (methodConstructor && methodConstructor.isFunctionType) {
          return [methodConstructor.target || methodConstructor, methodConstructor.generics];
        }
        if (classModule && classModule.isModule && (classModule.isClass || classModule.isInterface)) {
          return classModule.getModuleDeclareGenerics(false, false, true);
        }
        return classModule ? [classModule.moduleStack, []] : [null, []];
      }
      getCalleeDeclareGenerics() {
        const [classModule, methodConstructor] = this.getConstructMethod(this.callee.type());
        if (methodConstructor && (methodConstructor.isMethodDefinition || methodConstructor.isNewDefinition) && methodConstructor.genericity) {
          return methodConstructor.genericity.elements.map((item2) => item2.type());
        } else if (methodConstructor && methodConstructor.isFunctionType) {
          return [methodConstructor.target || methodConstructor, methodConstructor.generics];
        }
        if (classModule.isModule && (classModule.isClass || classModule.isInterface)) {
          const value2 = classModule.getModuleDeclareGenerics();
          if (value2 && value2.length > 0) {
            return value2;
          }
        }
        return null;
      }
      getAssigmentGenerics() {
        const assigments = this.genericity;
        if (assigments)
          return assigments;
        const type2 = this.callee.type();
        const [, , assigmentGenerics] = this.getConstructMethod(type2);
        return assigmentGenerics || null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.genericity && this.genericity.length > 0) {
          this.genericity.forEach((item2) => {
            item2.parser();
          });
        }
        this.callee.parser();
        this.callee.setRefBeUsed();
        this.parserArguments();
        const [classModule, methodConstructor, assigmentGenerics] = this.getConstructMethod() || [];
        if (!classModule) {
          this.callee.error(1069, this.callee.value());
          return true;
        }
        if (classModule.isAnyType || classModule.isGenericType) {
          return true;
        }
        if (classModule.abstract) {
          this.callee.error(1070, this.callee.value());
          return true;
        }
        const args = this.arguments;
        var argsLength = args.length;
        var requireCount = 0;
        var length = 0;
        var hasRest = false;
        const context = super.getContext();
        const [moduleStack, declareGenerics] = this.getDeclareGenerics(classModule, methodConstructor);
        if (methodConstructor) {
          if (this.is(methodConstructor)) {
            methodConstructor.parser();
          }
          const declareParams = methodConstructor.params || [];
          const declareTypeParams = declareParams;
          const requireParams = declareParams.filter((item2) => !(item2.question || item2.isAssignmentPattern || item2.isRestElement));
          length = declareParams.length;
          requireCount = requireParams.length;
          const _assigmentGenerics = this.genericity || assigmentGenerics;
          if (_assigmentGenerics && _assigmentGenerics.length > 0) {
            const lastStack = _assigmentGenerics[_assigmentGenerics.length - 1];
            if (declareGenerics.length < 1) {
              lastStack.error(1004, 0, _assigmentGenerics.length);
            }
            const requires = declareGenerics.filter((item2) => !item2.isGenericTypeAssignmentDeclaration);
            if (requires.length > _assigmentGenerics.length) {
              if (requires.length === declareGenerics.length) {
                lastStack.error(1004, requires.length, _assigmentGenerics.length);
              } else {
                lastStack.error(1005, requires.length, declareGenerics.length, _assigmentGenerics.length);
              }
            }
            _assigmentGenerics.forEach((item2, index) => {
              const declareType = declareGenerics[index] && declareGenerics[index].type();
              if (declareType) {
                if (declareType.hasConstraint) {
                  const constraint = declareType.inherit.type();
                  if (!constraint.check(item2, context)) {
                    item2.error(1003, item2.type().toString(context), constraint.toString(context));
                  }
                }
              }
            });
          }
          if (length > 0) {
            const checkArguments = (index, args2, declareParams2, declareTypes, top = false) => {
              let checkResult = true;
              for (; index < args2.length; index++) {
                const argument = args2[index];
                const argumentType = argument.type();
                const declareParamType = declareTypes[index];
                const declareParamItem = declareParams2[index];
                if (!(declareParamType && declareParamItem))
                  continue;
                let acceptType = declareParamType.type();
                let inferCtx = context.create(declareParamItem, acceptType);
                if (acceptType.isGenericType) {
                  if (acceptType.hasConstraint) {
                    const constraint = acceptType.inherit.type();
                    if (!constraint.check(argument, inferCtx)) {
                      argument.error(1003, argument.type().toString(inferCtx), constraint.toString(inferCtx));
                    }
                  }
                }
                if (argument.isSpreadElement) {
                  if (top)
                    hasRest = true;
                  if (!argumentType.isAnyType) {
                    if (!(argumentType.isTupleType || argumentType.isLiteralArrayType || Namespace.globals.get("array").is(argumentType))) {
                      argument.error(1154);
                      return false;
                    } else {
                      if (declareParamItem.isRestElement) {
                        checkResult = this.checkArgumentItemType(argument, declareParamItem, acceptType, inferCtx);
                      } else {
                        return checkArguments(index, argumentType.elements, declareParams2, declareTypes);
                      }
                    }
                  }
                } else {
                  const isRest = acceptType && acceptType.target && acceptType.target.isTypeTupleRestDefinition;
                  if (isRest || declareParamItem.isRestElement) {
                    if (top)
                      hasRest = true;
                    let restParamType = acceptType;
                    let result = true;
                    for (; index < args2; index++) {
                      let argument2 = args2[index];
                      const res = restParamType.elements.some((declare) => {
                        const acceptType2 = declare.type();
                        if (acceptType2.isTupleType && argument2.isArrayExpression || argument2.isObjectExpression) {
                          return this.checkArgumentItemType(argument2, declare, acceptType2, inferCtx);
                        } else {
                          return acceptType2.check(argument2, inferCtx);
                        }
                      });
                      if (!res) {
                        argument2.error(1002, argument2.type().toString(inferCtx), restParamType.toString(inferCtx));
                        result = false;
                      }
                    }
                    return result;
                  } else {
                    if (!this.checkArgumentItemType(argument, declareParamItem, acceptType, inferCtx)) {
                      checkResult = false;
                    }
                  }
                }
              }
              return checkResult;
            };
            checkArguments(0, args, declareParams, declareTypeParams, true);
          }
        }
        if (!hasRest) {
          if (requireCount > 0 && argsLength < requireCount || length < argsLength) {
            this.callee.error(1e3, requireCount, argsLength);
          }
        }
      }
      value() {
        return this.callee.value();
      }
    };
    module.exports = NewExpression;
  }
});

// lib/types/IntersectionType.js
var require_IntersectionType = __commonJS({
  "lib/types/IntersectionType.js"(exports, module) {
    var Type = require_Type();
    var Utils = require_Utils();
    var IntersectionType = class extends Type {
      constructor(target, left, right) {
        super("Intersection");
        this.isIntersectionType = true;
        this.target = target;
        this.left = left;
        this.right = right;
        this.hasGenericType = left && left.hasGenericType || right && right.hasGenericType;
      }
      clone(inference) {
        if (!inference || !this.hasGenericType) {
          return this;
        }
        return new IntersectionType(this.target, this.left.clone(inference), this.right.clone(inference));
      }
      getProperty(object, property) {
        if (!object)
          return null;
        if (object.isAliasType) {
          return this.getProperty(object.inherit.type(), property);
        }
        if (object.isLiteralArrayType || object.isLiteralObjectType || object.isGenericType || object.isEnumType || object.isIntersectionType) {
          return object.attribute(property);
        } else if (object.isModule) {
          const prop = object.getMember(property, "get");
          if (prop && Utils.isModifierPublic(prop)) {
            return prop;
          }
        }
        return null;
      }
      attribute(property) {
        return this.getProperty(this.left.type(), property) || this.getProperty(this.right.type(), property);
      }
      get attributes() {
        return this.getProperties();
      }
      getProperties(datamap = null) {
        datamap = datamap || /* @__PURE__ */ new Map();
        const make = (type2) => {
          if (type2.isAliasType) {
            make(type2.inherit.type());
          } else if (type2.isLiteralArrayType) {
            type2.elements.forEach((value2, key) => {
              datamap.set(key, value2);
            });
          } else if (type2.isLiteralObjectType || type2.isEnumType || type2.isIntersectionType) {
            type2.attributes.forEach((value2, key) => {
              datamap.set(key, value2);
            });
          } else if (type2.isModule) {
            type2.getProperties(datamap);
          }
        };
        make(this.left.type());
        make(this.right.type());
        return datamap;
      }
      getTypeKeys() {
        return Array.from(this.getProperties().keys());
      }
      check(stack, context, options = {}) {
        const left = this.left;
        const right = this.right;
        const type2 = Utils.getShortType(this.inferType(stack.type(), context));
        if (type2 && type2.isIntersectionType) {
          const items = [type2.left.type(), type2.right.type()];
          return [left.type(), right.type()].every((acceptType) => {
            return items.some((type3) => acceptType.check(type3, context, options));
          });
        }
        return left.type().check(stack, context, options) && right.type().check(stack, context, options);
      }
      checkType(acceptType, assignment, context, options) {
        acceptType = Utils.getShortType(acceptType);
        if (acceptType.isLiteralObjectType) {
          return acceptType.constraint(assignment, context, options);
        }
        return acceptType.is(assignment, context, options);
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        const left = this.left;
        const right = this.right;
        if (type2 && type2.isIntersectionType) {
          const items = [type2.left.type(), type2.right.type()];
          return [left.type(), right.type()].every((acceptType) => {
            return items.some((type3) => acceptType.is(type3, context, options));
          });
        }
        return this.checkType(left.type(), type2, context, options) && this.checkType(right.type(), type2, context, options);
      }
      toString(context, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        const left = this.left.type();
        const right = this.right.type();
        return `${left.toString(context, options)} & ${right.toString(context, options)}`;
      }
    };
    module.exports = IntersectionType;
  }
});

// lib/stacks/ObjectExpression.js
var require_ObjectExpression = __commonJS({
  "lib/stacks/ObjectExpression.js"(exports, module) {
    var Expression = require_Expression();
    var LiteralObjectType = require_LiteralObjectType();
    var Namespace = require_Namespace();
    var IntersectionType = require_IntersectionType();
    var MergeType = require_MergeType();
    var keySymbol = Symbol("key");
    var ObjectExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isObjectExpression = true;
        this.attributes = /* @__PURE__ */ new Map();
        this.dynamicProperties = null;
        this.hasChildComputed = false;
        this.properties = node2.properties.map((item2) => {
          const stack = this.createTokenStack(compilation, item2, scope, node2, this);
          if (!stack.isSpreadElement) {
            const name = stack.value();
            if (this.attributes.has(name)) {
              stack.error(1045, name);
            } else {
              this.attributes.set(stack.value(), stack);
            }
            this.hasChildComputed = this.hasChildComputed || stack.computed;
          }
          return stack;
        });
        this[keySymbol] = {};
      }
      freeze() {
        super.freeze();
        super.freeze(this.properties);
        (this.properties || []).forEach((stack) => stack.freeze());
      }
      definition(ctx) {
        const context = this.parentStack.isProperty && this.parentStack.parentStack.isObjectExpression ? this.parentStack : this;
        return {
          comments: context.comments,
          expre: this.type().toString(ctx || this.getContext()),
          location: context.getLocation(),
          file: context.compilation.file
        };
      }
      attribute(name, value2) {
        if (value2 !== void 0) {
          this.attributes.set(name, value2);
          return value2;
        }
        return this.attributes.get(name) || null;
      }
      hasAttribute(name) {
        return this.attributes.has(name);
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      description() {
        return this;
      }
      type() {
        return this.getAttribute("type", () => {
          const items = this.properties.filter((property) => property.isSpreadElement);
          if (items.length > 0 && this.properties.length === 1) {
            return items[0].type();
          }
          let type2 = new LiteralObjectType(Namespace.globals.get("object"), this);
          let left = items.shift();
          while (items.length > 0) {
            left = new IntersectionType(null, left.type(), items.shift().type());
          }
          if (left) {
            return new IntersectionType(null, left.type(), type2);
          }
          return type2;
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        let cache = {};
        this.properties.forEach((item2) => {
          item2.parser();
          if (item2.isSpreadElement) {
            const propertyType = item2.type();
            if (propertyType && !propertyType.isAnyType) {
              if (propertyType.isLiteralObjectType) {
                const attributes = propertyType.attributes;
                const dynamicProperties = propertyType.dynamicProperties;
                if (attributes) {
                  attributes.forEach((value2, key) => {
                    const property = cache[key];
                    let result = true;
                    if (property) {
                      result = this.checkExpressionType(property.type(), value2, item2);
                    }
                    if (result)
                      this.attributes.set(key, value2);
                  });
                }
                if (dynamicProperties) {
                  if (!this.dynamicProperties) {
                    this.dynamicProperties = /* @__PURE__ */ new Map();
                  }
                  dynamicProperties.forEach((value2, key) => {
                    const property = this.dynamicProperties.get(key);
                    let result = true;
                    if (property) {
                      result = this.checkExpressionType(property.type(), value2, item2);
                    }
                    if (result)
                      this.dynamicProperties.set(key, value2);
                  });
                }
              }
            }
          } else {
            if (item2.computed) {
              if (!this.dynamicProperties) {
                this.dynamicProperties = /* @__PURE__ */ new Map();
              }
              const keyType = item2.key.type();
              const assignType = item2.init ? item2.init.type() : Namespace.globals.get("any");
              const old = this.dynamicProperties.get(keyType);
              if (old) {
                const mergeType = new MergeType();
                mergeType.add(old);
                mergeType.add(assignType);
                this.dynamicProperties.set(keyType, mergeType.type());
              } else {
                this.dynamicProperties.set(keyType, assignType);
              }
            }
            cache[item2.value()] = item2;
          }
        });
      }
      value() {
        return `{${this.properties.map((item2) => item2.value()).join(", ")}}`;
      }
    };
    module.exports = ObjectExpression;
  }
});

// lib/stacks/ObjectPattern.js
var require_ObjectPattern = __commonJS({
  "lib/stacks/ObjectPattern.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var LiteralObjectType = require_LiteralObjectType();
    var ObjectPattern = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isObjectPattern = true;
        this.properties = node2.properties.map((item2) => {
          const stack = this.createTokenStack(compilation, item2, scope, node2, this);
          if (stack.isProperty) {
            if (!stack.hasAssignmentPattern) {
              const context = parentStack.parentStack.kind === "var" ? "function" : "block";
              const name = stack.init.value();
              if (this.parentStack.isVariableDeclarator || this.parentStack.isFunctionExpression) {
                if (scope.isDefine(name, context)) {
                  this.error(1007, name);
                }
                scope.define(name, stack.init);
              }
            }
          }
          return stack;
        });
        if (node2.acceptType) {
          this.acceptType = this.createTokenStack(compilation, node2.acceptType, scope, node2, this);
        }
      }
      freeze() {
        super.freeze();
        super.freeze(this.properties);
        (this.properties || []).forEach((stack) => stack.freeze());
      }
      definition() {
        return null;
      }
      setKind(value2) {
        this.properties.forEach((item2) => {
          item2.kind = value2;
        });
      }
      attribute(name, value2) {
        if (value2 !== void 0) {
          return value2;
        }
        return this.properties.find((property) => property.key.value() === name);
      }
      hasAttribute(name) {
        return this.properties.some((property) => property.key.value() === name);
      }
      type() {
        if (this.acceptType) {
          return this.acceptType.type();
        } else {
          return this.getAttribute("type", () => {
            return new LiteralObjectType(Namespace.globals.get("object"), this);
          });
        }
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.acceptType) {
          this.acceptType.parser();
        }
        if (this.parentStack.isVariableDeclarator) {
          const init = this.parentStack.init;
          if (init) {
            const type2 = init.type();
            const base = Namespace.globals.get("Object");
            if (base && !base.check(type2) || type2.isNullableType) {
              init.error(1074, init.raw());
            }
          } else {
            this.error(1081);
          }
        } else if (this.parentStack.isFunctionExpression) {
          if (this.parentStack.parentStack.isCallExpression || this.parentStack.parentStack.isNewExpression) {
            const call = this.parentStack.parentStack;
            const declareParams = call.isCallExpression ? call.getFunDeclareParams(call.descriptor()) : call.getFunDeclareParams();
            const index = call.arguments.indexOf(this.parentStack);
            if (declareParams[index]) {
              const type2 = declareParams[index].type();
              const base = Namespace.globals.get("Object");
              if (base && !base.check(type2) || type2.isNullableType) {
                this.properties.forEach((item2) => item2.key.error(1074, item2.key.value()));
              }
            } else {
              this.properties.forEach((item2) => item2.key.error(1081, item2.key.value()));
            }
          }
        }
        this.properties.forEach((item2) => item2.parser());
      }
      value() {
        return this.properties.map((item2) => {
          return item2.value();
        }).join(",");
      }
    };
    module.exports = ObjectPattern;
  }
});

// lib/scope/NamespaceScope.js
var require_NamespaceScope = __commonJS({
  "lib/scope/NamespaceScope.js"(exports, module) {
    var Scope = require_Scope();
    module.exports = class NamespaceScope extends Scope {
      constructor(parentScope) {
        super(parentScope);
        this.isNamespaceScope = true;
      }
      type(name) {
        return name === "ns";
      }
    };
  }
});

// lib/stacks/PackageDeclaration.js
var require_PackageDeclaration = __commonJS({
  "lib/stacks/PackageDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var Namespace = require_Namespace();
    var NamespaceScope = require_NamespaceScope();
    var PackageDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        scope = new NamespaceScope(scope);
        super(compilation, node2, scope, parentNode, parentStack);
        this.isPackageDeclaration = true;
        this._metatypes = [];
        this._annotations = [];
        this.id = this.createTokenStack(compilation, node2.id, scope, node2, this);
        this.namespace = compilation.namespace = Namespace.create(this.id ? this.id.value() : null);
        this.namespace.stack = this;
        const metatypes = [];
        const annotations = [];
        const imports = [];
        this.body = [];
        const externals = parentStack.externals || [];
        const exports2 = parentStack.exports || [];
        node2.body.forEach((item2, index) => {
          const stack = this.createTokenStack(compilation, item2, scope, node2, this);
          if (stack.isMetatypeDeclaration) {
            metatypes.push(stack);
          } else if (stack.isAnnotationDeclaration) {
            const annotationStack = this.interceptAnnotation(stack);
            if (annotationStack) {
              annotations.push(annotationStack);
            } else if (stack.name.toLowerCase() === "reference") {
              parentStack.references.push(stack);
            }
          } else if (stack.isImportDeclaration) {
            imports.push(stack);
          } else if (stack.isExportAllDeclaration || stack.isExportDefaultDeclaration || stack.isExportNamedDeclaration || stack.isExportAssignmentDeclaration) {
            exports2.push(stack);
          } else if (stack.isTypeStatement || stack.isDeclaratorTypeAlias) {
            this.body.push(stack);
          } else {
            stack.metatypes = metatypes.splice(0, metatypes.length);
            stack.annotations = annotations.splice(0, annotations.length);
            if (stack.isClassDeclaration || stack.isEnumDeclaration || stack.isInterfaceDeclaration || stack.isStructTableDeclaration || stack.isDeclaratorDeclaration || stack.isDeclaratorVariable || stack.isDeclaratorFunction) {
              stack.imports = imports.splice(0, imports.length);
              if (stack.imports.length > 0 && !(stack.isClassDeclaration || stack.isEnumDeclaration || stack.isInterfaceDeclaration || stack.isDeclaratorDeclaration || stack.isStructTableDeclaration)) {
                stack.imports.forEach((item3) => !item3.source.isLiteral && item3.error(1094));
              }
              this.body.push(stack);
            } else {
              externals.push(stack);
            }
          }
        });
        if (imports.length > 0) {
          parentStack.imports.push(...imports);
        }
      }
      set metatypes(value2) {
        value2.forEach((item2) => {
          item2.additional = this;
        });
        this._metatypes = value2;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value2) {
        value2.some((annotation) => {
          annotation.additional = this;
        });
        this._annotations = value2;
      }
      get annotations() {
        return this._annotations;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.id);
        super.freeze(this.body);
        this.body.forEach((stack) => stack.freeze());
      }
      async createCompleted() {
        await Promise.allSettled(this.body.map((item2) => item2.createCompleted()));
      }
      checkDepend(module2, depModule) {
        return depModule.extends.concat(depModule.implements).some((depModule2) => {
          if (depModule2 === module2)
            return true;
          return this.checkDepend(module2, depModule2);
        });
      }
      definition() {
        return {
          comments: this.comments,
          expre: `(namesapce) ${this.id.value()}`
        };
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.metatypes.forEach((item2) => {
          item2.parser();
        });
        this.annotations.forEach((item2) => {
          item2.parser();
        });
        this.body.forEach((item2) => {
          item2.parser();
        });
      }
    };
    module.exports = PackageDeclaration;
  }
});

// lib/stacks/ParenthesizedExpression.js
var require_ParenthesizedExpression = __commonJS({
  "lib/stacks/ParenthesizedExpression.js"(exports, module) {
    var Stack = require_Stack();
    var ParenthesizedExpression = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isParenthesizedExpression = true;
        this.expression = this.createTokenStack(compilation, node2.expression, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.expression.freeze();
      }
      definition(context) {
        return this.expression.definition(context);
      }
      reference() {
        return this.expression.reference();
      }
      referenceItems() {
        return this.expression.referenceItems();
      }
      type() {
        return this.expression.type();
      }
      description() {
        return this.expression.description();
      }
      getContext() {
        return this.expression.getContext();
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (!this.expression) {
          this.error(1079);
        } else {
          this.expression.parser();
          this.expression.setRefBeUsed();
        }
      }
      value() {
        return this.expression.value();
      }
      raw() {
        return this.expression.raw();
      }
    };
    module.exports = ParenthesizedExpression;
  }
});

// lib/stacks/Program.js
var require_Program = __commonJS({
  "lib/stacks/Program.js"(exports, module) {
    var Stack = require_Stack();
    var ClassScope = require_ClassScope();
    var Namespace = require_Namespace();
    var Program = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isProgram = true;
        this.externals = [];
        this.exports = [];
        this.imports = [];
        this.annotations = [];
        this.metatypes = [];
        this.scripts = [];
        this.references = [];
        this.body = [];
        this.isJSXProgram = false;
        const first = node2.body[0];
        if (first && first.type === "ExpressionStatement" && first.expression.type === "JSXElement") {
          this.compilation.JSX = true;
          this.isJSXProgram = true;
          this.createJsx(node2.body);
        } else {
          this.create(node2.body);
        }
      }
      createJsx(body) {
        const originId = this.compilation.originId;
        const segments = originId ? originId.split(".") : null;
        let className = null;
        if (segments) {
          className = segments.pop();
          this.namespace = Namespace.create(segments.join("."));
        } else {
          className = this.compiler.getFileClassName(this.file);
          this.namespace = Namespace.create(this.compiler.getFileNamespace(this.file));
        }
        this.module = this.compilation.createModule(this.namespace, className);
        this.module.isClass = true;
        this.module.jsxDeclaredSlots = /* @__PURE__ */ new Map();
        this.scope = new ClassScope(this.scope);
        this.scope.jsx = true;
        this.compilation.addModuleStack(this.module, this);
        body.forEach((item2) => {
          if (item2.type === "ExpressionStatement") {
            const stack = this.createTokenStack(this.compilation, item2.expression, this.scope, this.node, this);
            if (stack && stack.jsxElement) {
              this.body.push(stack);
            }
          } else {
            this.compilation.error(item2, 1110);
          }
        });
        if (this.body.length != 1) {
          this.error(1123);
        }
      }
      create(body) {
        const annotations = [];
        const metatypes = [];
        const imports = [];
        body.forEach((item2) => {
          const stack = this.createTokenStack(this.compilation, item2, this.scope, this.node, this);
          if (stack) {
            if (stack.isMetatypeDeclaration) {
              metatypes.push(stack);
            } else if (stack.isAnnotationDeclaration) {
              const annotationStack = this.interceptAnnotation(stack);
              if (annotationStack) {
                annotations.push(annotationStack);
              } else if (stack.name.toLowerCase() === "reference") {
                this.references.push(stack);
              }
            } else if (stack.isImportDeclaration) {
              imports.push(stack);
            } else if (stack.isExportAllDeclaration || stack.isExportDefaultDeclaration || stack.isExportNamedDeclaration || stack.isExportAssignmentDeclaration) {
              this.exports.push(stack);
            } else if (stack.isModuleDeclaration) {
              this.body.push(stack);
              stack.annotations = annotations.splice(0, annotations.length);
              stack.metatypes = metatypes.splice(0, metatypes.length);
              stack.imports.unshift(...imports.splice(0, imports.length));
            } else if (stack.isTypeStatement || stack.isDeclaratorTypeAlias) {
              this.body.push(stack);
            } else if (stack.isPackageDeclaration || stack.isNamespaceDeclaration || stack.isClassDeclaration || stack.isDeclaratorDeclaration || stack.isEnumDeclaration || stack.isInterfaceDeclaration || stack.isStructTableDeclaration || stack.isDeclaratorVariable || stack.isDeclaratorFunction) {
              stack.annotations = annotations.splice(0, annotations.length);
              stack.metatypes = metatypes.splice(0, metatypes.length);
              stack.imports = imports.splice(0, imports.length);
              if (stack.imports.length > 0 && !(stack.isClassDeclaration || stack.isEnumDeclaration || stack.isInterfaceDeclaration || stack.isDeclaratorDeclaration || stack.isStructTableDeclaration)) {
                stack.imports.forEach((item3) => !item3.source.isLiteral && item3.error(1094));
              }
              this.body.push(stack);
            } else {
              this.externals.push(stack);
            }
          }
        });
        if (imports.length > 0) {
          this.imports.push(...imports);
        }
        this.annotations = annotations.splice(0, annotations.length);
        this.annotations.forEach((item2) => {
          item2.additional = this;
        });
        this.metatypes = metatypes.splice(0, metatypes.length);
        this.metatypes.forEach((item2) => {
          item2.additional = this;
        });
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.scope);
        super.freeze(this.body);
        this.body.forEach((stack) => stack.freeze());
        this.externals.forEach((stack) => stack.freeze());
        this.imports.forEach((stack) => stack.freeze());
        this.exports.forEach((stack) => stack.freeze());
      }
      async createCompleted() {
        if (this._createCompletedFlag)
          return;
        this._createCompletedFlag = true;
        if (this.references.length > 0) {
          await Promise.allSettled(this.references.map((stack) => stack.createCompleted()));
        }
        if (this.imports.length > 0) {
          await this.compiler.callAsyncSequence(this.imports, async (stack) => await stack.addImport());
        }
        if (this.body.length > 0) {
          await this.compiler.callAsyncSequence(this.body, async (stack) => await stack.createCompleted());
        }
        if (this.exports.length > 0) {
          await Promise.allSettled(this.exports.map((stack) => stack.createCompleted()));
        }
      }
      async parserAsync() {
        if (this.parser() === false)
          return false;
        if (this.references.length > 0) {
          await Promise.allSettled(this.references.map((stack) => stack.parserAsync()));
        }
        this.imports.forEach((item2) => {
          item2.parser();
        });
        this.metatypes.forEach((item2) => {
          item2.parser();
        });
        this.annotations.forEach((item2) => {
          item2.parser();
        });
        this.body.forEach((item2) => {
          item2.parser();
        });
        this.externals.forEach((item2) => {
          item2.parser();
        });
        let throwWarn = this.compilation.modules.size > 0 && !this.compilation.isDescriptorDocument();
        this.exports.forEach((item2) => {
          item2.parser();
          if (throwWarn) {
            item2.warn(1160);
          }
        });
      }
    };
    module.exports = Program;
  }
});

// lib/stacks/Property.js
var require_Property = __commonJS({
  "lib/stacks/Property.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var AliasType = require_AliasType();
    var Declarator = require_Declarator();
    var Property = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isProperty = true;
        this.hasAssignmentPattern = false;
        this.assignValue = null;
        this._assignItems = /* @__PURE__ */ new Set();
        this.isParamDeclarator = false;
        this.hasInit = node2.value && node2.key !== node2.value;
        if (node2 && parentStack) {
          this.key = this.createTokenStack(compilation, node2.key, scope, node2, this);
          if (parentStack.isObjectPattern) {
            if (node2.value.type == "Identifier") {
              this.init = new Declarator(compilation, node2.value, scope, node2, this);
            } else {
              this.init = this.createTokenStack(compilation, node2.value, scope, node2, this);
            }
          } else {
            this.init = this.createTokenStack(compilation, node2.value, scope, node2, this);
            this.assignValue = this.init;
            this._assignItems.add(this.init);
          }
          if (this.init.isAssignmentPattern) {
            this.hasAssignmentPattern = true;
          }
          this._kind = node2.kind;
          this.computed = !!node2.computed;
          if (parentStack.isObjectPattern && parentStack && parentStack.parentStack) {
            const p = parentStack.parentStack;
            if (p.isFunctionExpression || p.isTypeFunctionDefinition) {
              this.isParamDeclarator = true;
            }
          }
        }
      }
      get acceptType() {
        const parent = this.parentStack;
        if (parent && parent.isObjectPattern) {
          if (parent.acceptType && parent.acceptType.isTypeObjectDefinition) {
            return parent.acceptType.attribute(this.value()) || null;
          }
        }
        return null;
      }
      freeze() {
        super.freeze();
        this.key && this.key.freeze();
        this.init && this.init.freeze();
        this.acceptType && this.acceptType.freeze();
      }
      definition(ctx) {
        if (this.parentStack.isObjectPattern) {
          let location2 = this.key.getLocation();
          let comments2 = this.comments;
          let file2 = this.compilation.file;
          ctx = ctx || this.getContext();
          const type3 = this.type().toString(ctx);
          return {
            comments: comments2,
            location: location2,
            file: file2,
            expre: `(property) ${this.value()}: ${type3}`
          };
        }
        const relate = this.getRelateDescription();
        const identifier = this.value();
        const type2 = this.type().toString();
        let location = this.key.getLocation();
        let comments = this.comments;
        let file = this.compilation.file;
        if (relate && relate.isStack) {
          location = relate.key.getLocation();
          comments = relate.comments;
          file = relate.compilation.file;
        }
        return {
          comments,
          expre: `(property) ${identifier}: ${type2}`,
          location,
          file
        };
      }
      set kind(value2) {
        if (this.hasAssignmentPattern) {
          this.init.kind = value2;
        } else {
          this._kind = value2;
        }
      }
      get kind() {
        if (this.hasAssignmentPattern) {
          return this.init.kind;
        } else {
          return this._kind;
        }
      }
      value() {
        return this.key.value();
      }
      reference() {
        const desc = this.getObjectPatternDescription();
        if (desc) {
          return desc.reference();
        }
        if (this.hasAssignmentPattern) {
          return this.init.reference();
        }
        return this.assignValue ? this.assignValue.reference() : null;
      }
      referenceItems() {
        if (this.hasAssignmentPattern) {
          return this.init.referenceItems();
        }
        let items = [];
        this.assignItems.forEach((item2) => {
          items = items.concat(item2.referenceItems());
        });
        return items;
      }
      get assignItems() {
        if (this.hasAssignmentPattern) {
          return this.init.assignItems;
        }
        return this._assignItems;
      }
      assignment(value2, stack) {
        if (this.parentStack.isObjectPattern) {
          this.init.assignment(value2, stack);
        } else if (this.assignValue !== value2) {
          const first = this.assignValue;
          let acceptType = this.acceptType;
          let isNull = false;
          if (!acceptType && first) {
            const _type = first.type();
            if (_type) {
              isNull = _type.isNullableType || _type.isVoidType;
              if (!isNull) {
                acceptType = _type;
              }
            }
          }
          if (acceptType) {
            this.checkExpressionType(acceptType, value2, stack);
          }
          if (!first || isNull) {
            this.assignValue = value2;
          }
          this._assignItems.add(value2);
          if (value2 && value2.isStack) {
            this.setRefBeUsed(value2.description());
          }
        }
      }
      type() {
        const acceptType = this.acceptType;
        if (acceptType) {
          return acceptType.type();
        }
        const desc = this.getObjectPatternDescription();
        if (desc) {
          const declare = this.parentStack.parentStack;
          if (declare && declare.isVariableDeclarator && declare.init) {
            const ctx = declare.init.getContext();
            return ctx.apply(desc.type());
          } else if (declare && declare.isFunctionExpression && (declare.parentStack.isCallExpression || declare.parentStack.isNewExpression)) {
            const ctx = declare.parentStack.getContext();
            return ctx.apply(desc.type());
          }
          return desc.type();
        }
        if (this.assignValue) {
          if (this.parentStack.isObjectExpression && this.parentStack.parentStack.isVariableDeclarator) {
            if (this.parentStack.parentStack === this.assignValue.description()) {
              return new AliasType(this.parentStack.parentStack.type(), this.parentStack.parentStack.acceptType || this.parentStack.parentStack);
            }
          }
          return this.assignValue.type();
        }
        return Namespace.globals.get("any");
      }
      getObjectPatternDescription() {
        if (this.parentStack.isObjectPattern) {
          const argument = this.parentStack.parentStack;
          if (argument && argument.isVariableDeclarator && argument.init) {
            const object = argument.init.type();
            if (object) {
              return argument.init.getObjectDescriptor(object, this.key.value());
            }
          } else if (argument && argument.isFunctionExpression) {
            const exp = argument.parentStack;
            if (exp.isCallExpression || exp.isNewExpression) {
              let declareParams = [];
              if (exp.isCallExpression) {
                const description = exp.descriptor();
                declareParams = exp.getFunDeclareParams(description);
              } else {
                declareParams = exp.getFunDeclareParams();
              }
              const pos = argument.params.indexOf(this.parentStack);
              const index = exp.arguments.indexOf(argument);
              if (declareParams[index]) {
                const fun = declareParams[index].type();
                if (fun.isFunctionType && fun.params[pos]) {
                  const object = fun.params[pos].type();
                  return exp.getObjectDescriptor(object, this.key.value());
                }
              }
            } else if (exp.isAssignmentExpression) {
              const fun = exp.left.type();
              const pos = argument.params.indexOf(this.parentStack);
              if (fun.isFunctionType && fun.params[pos]) {
                const object = fun.params[pos].type();
                return exp.left.getObjectDescriptor(object, this.key.value());
              }
            }
          } else if (argument && argument.isJSXAttribute) {
            const object = argument.type();
            return argument.getObjectDescriptor(object, this.key.value());
          }
        }
        return null;
      }
      getRelateDescription() {
        let parent = this.parentStack;
        let properties = [this];
        let argument = null;
        while (parent && parent.isObjectExpression) {
          argument = parent;
          parent = parent.parentStack;
          if (parent && parent.isProperty) {
            properties.push(parent);
            parent = parent.parentStack;
          }
        }
        if (parent && (parent.isCallExpression || parent.isNewExpression)) {
          const index = parent.arguments.indexOf(argument);
          if (index >= 0) {
            let declareParams = [];
            if (parent.isCallExpression) {
              const description = parent.descriptor();
              declareParams = parent.getFunDeclareParams(description);
            } else {
              declareParams = parent.getFunDeclareParams();
            }
            const declare = declareParams[index];
            if (declare) {
              let desc = declare.type();
              while (desc && properties.length > 0) {
                desc = parent.getObjectDescriptorForAuxiliary(desc, properties.pop().value());
                if (desc && properties.length > 0) {
                  desc = desc.type();
                }
              }
              return desc;
            }
          }
        }
        return null;
      }
      description() {
        return this;
      }
      parser() {
        if (super.parser() === false)
          return false;
        const acceptType = this.acceptType;
        if (acceptType) {
          acceptType.parser();
        }
        if (this.init) {
          this.init.parser();
          this.init.setRefBeUsed();
        }
        if (this.kind === "dynamic") {
          return true;
        }
        const name = this.value();
        if (!this.parentStack.isObjectPattern) {
          if (this.computed) {
            const refs = this.scope.define(name);
            if (this.key.isIdentifier && !refs) {
              this.error(1013, name);
            } else {
              this.setRefBeUsed(refs);
            }
          }
          return true;
        }
        ;
        if (this.parentStack.parentStack.isFunctionExpression) {
          const argument = this.parentStack.parentStack;
          const exp = argument.parentStack;
          if (exp.isCallExpression || exp.isNewExpression || exp.isAssignmentExpression) {
            const desc = this.getObjectPatternDescription();
            if (!desc) {
              this.error(1080, name);
            }
          }
          return true;
        } else if (this.parentStack.parentStack.isVariableDeclarator) {
          const desc = this.scope.define(name);
          const target = this.parentStack.parentStack.init;
          if (!target)
            return true;
          if (target.isObjectExpression || target.isArrayExpression) {
            const init = target.attribute(name);
            if (!init) {
              this.error(1080, name);
            }
            desc && desc.assignment(init, this.key);
          } else {
            let type2 = target.type();
            if (!type2 || type2.isAnyType) {
              return true;
            }
            if (type2.isLiteralObjectType || type2.isLiteralArrayType || type2.isGenericType) {
              const propertyValue = type2.attribute(name);
              if (!propertyValue) {
              } else {
                desc && desc.assignment(propertyValue, this.key);
              }
            } else if (type2.isModule) {
              const desc2 = target.getObjectDescriptor(type2, name);
              if (!desc2) {
                this.error(1080, name);
              }
            }
          }
        }
      }
      raw() {
        if (this.hasAssignmentPattern) {
          return this.init.raw();
        }
        return super.raw();
      }
      error(code, ...args) {
        this.key.error(code, ...args);
      }
      warn(code, ...args) {
        this.key.warn(code, ...args);
      }
    };
    module.exports = Property;
  }
});

// lib/stacks/PropertyDefinition.js
var require_PropertyDefinition = __commonJS({
  "lib/stacks/PropertyDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var Utils = require_Utils();
    var PropertyDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isPropertyDefinition = true;
        this._metatypes = [];
        this._annotations = [];
        this.kind = node2.kind;
        this.isReadonly = this.kind === "const";
        this.modifier = this.createTokenStack(compilation, node2.modifier, scope, node2, this);
        this.static = this.createTokenStack(compilation, node2.static, scope, node2, this);
        this.declarations = node2.declarations.map((item2) => {
          return this.createTokenStack(compilation, item2, scope, node2, this);
        });
        this.isFinal = false;
        this.isRemoved = false;
        this.isDeprecated = false;
        this.isNoop = false;
        if (this.declarations[0].dynamic) {
          this.module.dynamic = true;
        } else {
          if (!this.parentStack.isUseStatement) {
            this.module.addMember(this.declarations[0].id.value(), this);
          }
        }
        if (!this.compilation.isDescriptorDocument() && !Utils.isModifierPublic(this)) {
          this.compilation.hookAsync("compilation.parser.after", async () => {
            if (!this.useRefItems.size) {
              this.unnecessary(1183, this.value());
            }
          });
        }
      }
      freeze() {
        super.freeze();
        super.freeze(this.declarations);
        this.modifier && this.modifier.freeze();
        this.static && this.static.freeze();
        this.declarations.forEach((stack) => stack.freeze());
      }
      definition(ctx) {
        const context = this;
        const modifier = this.modifier ? this.modifier.value() : "public";
        const _static = this.static ? "static " : "";
        const def = this.declarations[0].definition(ctx);
        return {
          kind: "property",
          comments: context.comments,
          expre: `(property) ${_static}${modifier} ${def.expre}`,
          location: this.declarations[0].id.getLocation(),
          file: this.compilation.file
        };
      }
      set metatypes(value2) {
        value2.forEach((metatype) => {
          metatype.additional = this;
        });
        this._metatypes = value2;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value2) {
        value2.forEach((annotation) => {
          annotation.additional = this;
          switch (annotation.name.toLowerCase()) {
            case "override":
              this.override = true;
              break;
            case "final":
              this.isFinal = true;
              break;
            case "deprecated":
              this.isDeprecated = true;
              break;
            case "removed":
              this.isRemoved = true;
            case "noop":
              this.isNoop = true;
              break;
          }
        });
        this._annotations = value2;
      }
      getContext() {
        return this.declarations[0].getContext();
      }
      get annotations() {
        return this._annotations;
      }
      get init() {
        return this.declarations[0].init;
      }
      get dynamic() {
        return !!this.declarations[0].dynamic;
      }
      get computed() {
        return !!this.declarations[0].computed;
      }
      get question() {
        return !!this.declarations[0].question;
      }
      get id() {
        return this.declarations[0].id;
      }
      get key() {
        return this.declarations[0].id;
      }
      get acceptType() {
        return this.declarations[0].acceptType;
      }
      get dynamicKeyType() {
        return this.declarations[0].dynamicKeyType;
      }
      get assignItems() {
        return this.declarations[0].assignItems;
      }
      get useRefItems() {
        return this.declarations[0].useRefItems;
      }
      addUseRef(stack) {
        this.declarations[0].addUseRef(stack);
      }
      assignment(value2, stack = null, ctx = null) {
        this.declarations[0].assignment(value2, stack, ctx);
      }
      reference() {
        return this.declarations[0].reference();
      }
      referenceItems() {
        return this.declarations[0].referenceItems();
      }
      description() {
        return this.declarations[0].description();
      }
      type() {
        return this.declarations[0].type();
      }
      getAnnotationAlias(flag = true) {
        const result = this.getAttribute("getAnnotationAlias", () => {
          return this.findAnnotation((annot) => annot.getLowerCaseName() === "alias" ? annot : false);
        });
        if (flag) {
          if (result) {
            const [annot] = result;
            if (annot && annot.isAnnotationDeclaration) {
              const args = annot.getArguments();
              if (args[0]) {
                return args[0].value;
              }
            }
          }
          return null;
        }
        return result;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this._annotations.forEach((item2) => item2.parser());
        this._metatypes.forEach((item2) => item2.parser());
        this.declarations[0].parser();
        if (this.parentStack.isUseStatement) {
          return true;
        }
        if (this.dynamic) {
          let acceptType = null;
          if (this.dynamicKeyType) {
            this.dynamicKeyType.parser();
            acceptType = this.dynamicKeyType.type();
          } else {
            this.id.parser();
            acceptType = this.id.type();
          }
          if (acceptType) {
            this.module.dynamicProperties.set(acceptType, this);
          }
        } else if (this.module && !this.module.isDeclaratorModule) {
          const parent = this.module && this.module.getInheritModule();
          if (parent) {
            const modifier = Utils.getModifierValue(this);
            if (modifier !== "private") {
              const parentProperty = parent.getMember(this.id.value());
              if (parentProperty && Utils.getModifierValue(parentProperty) !== "private") {
                if (!parentProperty.isPropertyDefinition) {
                  this.id.error(1082, this.value());
                }
              }
              if (parentProperty && parentProperty.isFinal) {
                this.id.error(1149, this.id.value());
              }
            }
          }
        }
      }
      error(code, ...args) {
        this.declarations[0].error(code, ...args);
      }
      warn(code, ...args) {
        this.declarations[0].warn(code, ...args);
      }
      value() {
        return this.declarations[0].value();
      }
      raw() {
        return this.declarations[0].raw();
      }
    };
    module.exports = PropertyDefinition;
  }
});

// lib/stacks/RestElement.js
var require_RestElement = __commonJS({
  "lib/stacks/RestElement.js"(exports, module) {
    var Declarator = require_Declarator();
    var TupleType = require_TupleType();
    var MergeType = require_MergeType();
    var LiteralObjectType = require_LiteralObjectType();
    var Namespace = require_Namespace();
    var RestElement = class extends Declarator {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2.argument, scope, parentNode, parentStack);
        this.isRestElement = true;
        scope.define(this.value(), this);
      }
      definition(ctx) {
        const type2 = this.type().toString(ctx);
        const identifier = this.value();
        const context = this;
        let kind = this.parentStack.isFunctionExpression || this.parentStack.isTypeFunctionDefinition ? "(parameter)" : this.kind;
        if (this.parentStack.isObjectPattern && this.parentStack.parentStack.isVariableDeclarator) {
          kind = `(local ${kind})`;
        }
        return {
          kind,
          comments: context.comments,
          identifier,
          expre: `${kind} ...${identifier}:${type2}`,
          location: this.getLocation(),
          file: this.compilation.file,
          context
        };
      }
      type() {
        return this.getAttribute("type", () => {
          let type2 = Namespace.globals.get("any");
          if (this.parentStack.isObjectPattern) {
            const pStack = this.parentStack.parentStack;
            if (pStack && pStack.isVariableDeclarator && pStack.init) {
              const _type = pStack.init.type();
              if (_type) {
                const patternProperties = this.parentStack.properties.filter((item2) => {
                  return !item2.isRestElement;
                });
                if (patternProperties.length === 0) {
                  type2 = _type;
                } else {
                  if (_type.isLiteralObjectType) {
                    const properties = new Map(_type.properties);
                    patternProperties.forEach((property) => {
                      if (property.isProperty) {
                        properties.delete(property.key.value());
                      }
                    });
                    type2 = new LiteralObjectType(_type.inherit, _type.target, properties, _type.dynamicProperties, _type.questionProperties);
                  } else if (_type.isInstanceofType) {
                    type2 = _type;
                  }
                }
              }
            }
          } else {
            type2 = this.acceptType ? this.acceptType.type() : type2;
            if (!type2.isTupleType) {
              if (type2.isUnionType) {
                type2 = MergeType.arrayToTuple(type2.elements);
                type2.rest = true;
              } else {
                type2 = new TupleType(Namespace.globals.get("Array"), type2, this, true);
              }
            } else {
              type2.rest = true;
            }
          }
          return type2;
        });
      }
      getItemType() {
        return this.getAttribute("item-type", () => {
          return MergeType.forOfItem(this.type());
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.acceptType) {
          this.acceptType.parser();
          this.acceptType.setRefBeUsed();
        }
      }
    };
    module.exports = RestElement;
  }
});

// lib/stacks/ReturnStatement.js
var require_ReturnStatement = __commonJS({
  "lib/stacks/ReturnStatement.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var Utils = require_Utils();
    var keySymbol = Symbol("key");
    var Predicate = require_Predicate();
    var ReturnStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isReturnStatement = true;
        this.hasReturnStatement = true;
        this.argument = this.createTokenStack(compilation, node2.argument, scope, node2, this);
        const fnScope = scope.getScopeByType("function");
        this.returnIndex = fnScope.returnItems.length;
        if (this.argument) {
          fnScope.returnItems.push(this);
        }
        this[keySymbol] = {};
        this.fnScope = fnScope;
        if (parentStack) {
          let statement = parentStack.isBlockStatement ? parentStack.parentStack : parentStack;
          if (statement) {
            if (statement.isIfStatement || statement.isTryStatement) {
              parentStack.hasReturnStatement = true;
            } else if (statement.isSwitchCase) {
              statement.hasReturnStatement = true;
            }
          }
        }
      }
      freeze() {
        super.freeze();
        this.argument && this.argument.freeze();
      }
      definition() {
        return null;
      }
      reference() {
        if (this.argument) {
          return this.argument.reference();
        }
        return null;
      }
      referenceItems() {
        return this.argument ? this.argument.referenceItems() : [];
      }
      description() {
        if (this.argument) {
          return this.argument.description();
        }
        return null;
      }
      type() {
        if (!this.argument) {
          return Namespace.globals.get("void");
        }
        return this.argument.type();
      }
      getParentFunction() {
        return this.getAttribute("ReturnStatement.getParentFunction", () => {
          let parent = this.getParentStack((parent2) => {
            return !!parent2.isFunctionExpression;
          });
          if (parent && (parent.isFunctionExpression || parent.isMethodDefinition)) {
            return parent;
          }
          return null;
        });
      }
      getContext() {
        let parent = this.getParentFunction();
        if (parent) {
          return parent.getContext();
        }
        return super.getContext();
      }
      parser() {
        if (super.parser() === false)
          return false;
        let pp = this.parentStack;
        if (pp.isBlockStatement)
          pp = pp.parentStack;
        if (pp.isIfStatement) {
          let fp = pp.parentStack;
          if (fp.isBlockStatement)
            fp = fp.parentStack;
          if (fp.isFunctionExpression) {
            const condition = pp.condition;
            this.getConditions(condition).forEach((stack) => {
              let value2 = true;
              if (stack.isUnaryExpression) {
                if (stack.isLogicalFlag) {
                  value2 = stack.isLogicalTrueFlag;
                }
                stack = stack.argument;
                if (stack.isParenthesizedExpression) {
                  stack = stack.expression;
                }
              }
              if (stack.isBinaryExpression && stack.isIsOperatorFlag && value2 === false) {
                const lDesc = stack.left.description();
                this.scope.parent.setPredicate(lDesc, Predicate.create(stack.right.type(), stack.right.description(), lDesc));
                stack = stack.left;
              }
              if (!(stack.isIdentifier || stack.isMemberExpression))
                return;
              if (stack.parentStack.isLogicalExpression && stack.isAndOperator) {
                return;
              }
              const desc = stack.description();
              if (desc) {
                const state = this.scope.getValidateState(desc);
                if (state && state.value === false && condition.scope === state.scope) {
                  this.scope.parent.setValidateState(desc, pp, true, condition);
                }
              }
            });
          }
        }
        let parent = this.getParentFunction();
        if (!parent || !parent.isFunctionExpression) {
          return this.error(1072);
        }
        if (this.argument) {
          this.argument.parser();
          this.argument.setRefBeUsed();
          const rType = this.argument.type();
          if (rType && (rType.isNullableType || rType.isVoidType || rType.isRecursionType)) {
            return true;
          }
          if (parent && parent.async) {
            let returnType2 = parent.returnType;
            if (returnType2) {
              const origin = Utils.getOriginType(returnType2);
              const PromiseType = Namespace.globals.get("Promise");
              let acceptType = returnType2;
              if (origin && PromiseType.is(origin)) {
                if (returnType2.isInstanceofType && returnType2.generics[0]) {
                  acceptType = returnType2.generics[0].type();
                } else if (returnType2.isClassGenericType && returnType2.types[0]) {
                  acceptType = returnType2.types[0].type();
                }
              }
              if (acceptType && !acceptType.isGenericType) {
                this.checkExpressionType(acceptType, this.argument);
              }
            }
            return true;
          }
          let returnType = parent && parent.returnType;
          if (returnType && !returnType.isGenericType) {
            this.checkExpressionType(returnType, this.argument);
          }
        }
      }
      value() {
        return this.argument ? this.argument.value() : "";
      }
      raw() {
        return this.argument ? this.argument.raw() : "";
      }
    };
    module.exports = ReturnStatement;
  }
});

// lib/stacks/SequenceExpression.js
var require_SequenceExpression = __commonJS({
  "lib/stacks/SequenceExpression.js"(exports, module) {
    var Expression = require_Expression();
    var SequenceExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isSequenceExpression = true;
        this.expressions = node2.expressions.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
      }
      freeze() {
        super.freeze();
        super.freeze(this.expressions);
        (this.expressions || []).forEach((stack) => stack.freeze());
      }
      definition() {
        return null;
      }
      description() {
        return this.expressions.length > 0 ? this.expressions[this.expressions.length - 1] : this;
      }
      reference() {
        const description = this.description();
        return description !== this ? description.reference() : this;
      }
      referenceItems() {
        const description = this.description();
        return description !== this ? description.referenceItems() : [this];
      }
      type(ctx) {
        return this.expressions.length > 0 && this.expressions[this.expressions.length - 1].type(ctx);
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.expressions.forEach((item2) => {
          item2.parser();
          item2.setRefBeUsed();
        });
      }
    };
    module.exports = SequenceExpression;
  }
});

// lib/stacks/SpreadElement.js
var require_SpreadElement = __commonJS({
  "lib/stacks/SpreadElement.js"(exports, module) {
    var MergeType = require_MergeType();
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var LiteralObjectType = require_LiteralObjectType();
    var SpreadElement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isSpreadElement = true;
        this.argument = this.createTokenStack(compilation, node2.argument, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
      }
      definition(ctx) {
        return this.argument.definition(ctx);
      }
      description() {
        return this.argument.description();
      }
      reference() {
        return this.argument.reference();
      }
      referenceItems() {
        return this.argument.referenceItems();
      }
      key() {
        return this.argument.key();
      }
      getContext() {
        return this.argument.getContext();
      }
      type() {
        return this.getAttribute("type", () => {
          const type2 = this.argument.type();
          if (this.parentStack.isArrayExpression) {
            if (type2.isTupleType || type2.isLiteralArrayType) {
              return MergeType.arrayToUnion(type2.elements);
            } else {
              const iterator = Namespace.globals.get("Iterator");
              if (type2.is(iterator)) {
                let declareGenerics = iterator.getModuleGenerics();
                if (declareGenerics && declareGenerics[0]) {
                  const ctx = this.getContext();
                  const res = ctx.fetch(declareGenerics[0].type());
                  if (res) {
                    return res;
                  }
                }
              }
            }
            return Namespace.globals.get("any");
          }
          return type2;
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.argument.parser();
        this.argument.setRefBeUsed();
        const type2 = this.argument.type();
        if (this.parentStack.isArrayExpression || this.parentStack.isCallExpression || this.parentStack.isNewExpression) {
          const arrayType = Namespace.globals.get("array");
          const iteratorType = Namespace.globals.get("Iterator");
          if (!(arrayType.is(type2) || iteratorType.is(type2))) {
            this.error(1073, this.argument.value());
          }
        } else if (this.parentStack.isObjectExpression) {
          const objectType = Namespace.globals.get("object");
          if (!objectType.is(type2)) {
            this.error(1074, this.argument.value());
          }
        }
      }
      value() {
        return this.argument.value();
      }
      raw() {
        return this.argument.raw();
      }
      error(code, ...args) {
        this.argument.error(code, ...args);
      }
      warn(code, ...args) {
        this.argument.warn(code, ...args);
      }
    };
    module.exports = SpreadElement;
  }
});

// lib/stacks/StructTableColumnDefinition.js
var require_StructTableColumnDefinition = __commonJS({
  "lib/stacks/StructTableColumnDefinition.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var StructTableColumnDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isStructTableColumnDefinition = true;
        this.isPropertyDefinition = true;
        this.isProperty = true;
        this.question = !!node2.question;
        this.key = this.createTokenStack(compilation, node2.key, scope, node2, this);
        this.typename = this.createTokenStack(compilation, node2.typename, scope, node2, this);
        this.unsigned = node2.typename ? !!node2.typename.unsigned : false;
        this.properties = node2.properties.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
        this.module.addMember(this.key.value(), this);
        this.assignItems = /* @__PURE__ */ new Set();
        this.assignValue = null;
        this._annotations = [];
      }
      definition(ctx) {
        const location = this.key.getLocation();
        const question = this.question ? "?" : "";
        return {
          comments: this.comments,
          expre: `(struct) column ${this.key.value()}${question}: ${this.type().toString(ctx)}`,
          location,
          file: this.compilation.file
        };
      }
      get kind() {
        return "init";
      }
      set metatypes(value2) {
        value2.forEach((metatype) => {
          metatype.additional = this;
        });
        this._metatypes = value2;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value2) {
        value2.forEach((annotation) => {
          annotation.additional = this;
          switch (annotation.name.toLowerCase()) {
            case "override":
              this.override = true;
              break;
            case "final":
              this.isFinal = true;
              break;
            case "deprecated":
              this.isDeprecated = true;
              break;
            case "removed":
              this.isRemoved = true;
            case "noop":
              this.isNoop = true;
              break;
          }
        });
        this._annotations = value2;
      }
      get annotations() {
        return this._annotations;
      }
      assignment(value2, stack = null) {
        if (this.assignValue !== value2) {
          let assignDesc = null;
          if (value2 && value2.isStack) {
            assignDesc = value2.description();
          }
          if (assignDesc) {
            if (assignDesc === this || assignDesc.isStack && assignDesc.description() === this) {
              this.setRefBeUsed(assignDesc);
              return;
            }
          }
          this.checkExpressionType(this.type(), value2, stack);
          this.assignItems.add(value2);
          if (!this.assignValue) {
            this.assignValue = value2;
          }
          if (assignDesc) {
            this.setRefBeUsed(assignDesc);
          }
        }
      }
      reference() {
        return this.assignValue ? this.assignValue.reference() : null;
      }
      referenceItems() {
        let items = [];
        this.assignItems.forEach((item2) => {
          items = items.concat(item2.referenceItems());
        });
        return items;
      }
      get acceptType() {
        return null;
      }
      get id() {
        return this.key;
      }
      get dynamic() {
        return false;
      }
      description() {
        return this;
      }
      type() {
        if (this.typename) {
          return this.typename.type();
        }
        return Namespace.globals.get("any");
      }
      getAnnotationAlias(flag = true) {
        const result = this.getAttribute("getAnnotationAlias", () => {
          return this.findAnnotation((annot) => annot.getLowerCaseName() === "alias" ? annot : false);
        });
        if (flag) {
          if (result) {
            const [annot] = result;
            if (annot && annot.isAnnotationDeclaration) {
              const args = annot.getArguments();
              if (args[0]) {
                return args[0].value;
              }
            }
          }
          return null;
        }
        return result;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.typename) {
          this.typename.parser();
        }
        this.properties.forEach((item2) => {
          if (!(item2.isIdentifier || item2.isMemberExpression)) {
            if (item2.isStructTablePropertyDefinition && item2.key.value().toLowerCase() === "default") {
              if (this.typename) {
                const desc = this.typename.description();
                if (desc) {
                  this.checkExpressionType(desc, item2.init);
                }
              }
            }
            item2.parser();
          }
        });
      }
      value() {
        return this.key.value();
      }
    };
    module.exports = StructTableColumnDefinition;
  }
});

// lib/stacks/StructTableDeclaration.js
var require_StructTableDeclaration = __commonJS({
  "lib/stacks/StructTableDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var Utils = require_Utils();
    var ClassScope = require_ClassScope();
    var StructTableDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        scope = new ClassScope(scope);
        super(compilation, node2, scope, parentNode, parentStack);
        this.isStructTableDeclaration = true;
        this._metatypes = [];
        this._annotations = [];
        this.body = [];
        this.imports = [];
        this.id = this.createTokenStack(compilation, node2.id, scope, node2, this);
        const module2 = this.module = compilation.createModule(this.namespace, this.id.value(), false);
        this.id.module = module2;
        this.extends = (node2.extends || []).map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
        module2.isInterface = true;
        module2.isStructTable = true;
        compilation.addModuleStack(module2, this);
      }
      set metatypes(value2) {
        value2.forEach((item2) => {
          item2.additional = this;
        });
        if (value2.length > 0) {
          this._metatypes = value2;
        }
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value2) {
        value2.forEach((annotation) => {
          annotation.additional = this;
        });
        if (value2.length > 0) {
          this._annotations = value2;
        }
      }
      get annotations() {
        return this._annotations;
      }
      definition(ctx) {
        const any = this.getGlobalTypeById("any").toString();
        const columns = this.body.filter((item2) => item2.isStructTableColumnDefinition).map((item2) => {
          const name = item2.key.value();
          const desc = item2.description();
          let type2 = any;
          if (desc)
            type2 = desc.type().toString();
          if (item2.question) {
            return `${name}?:${type2}`;
          }
          return `${name}:${type2}`;
        });
        return {
          comments: this.comments,
          kind: "struct",
          expre: `struct ${this.module.getName()}:{\r
	${columns.join("\r\n	")}\r
}`,
          location: this.id.getLocation(),
          file: this.compilation.file
        };
      }
      async createCompleted() {
        try {
          const compilation = this.compilation;
          const metatypes = [];
          const annotations = [];
          const self = this.module;
          await this.allSettled(this.imports, async (stack) => await stack.addImport(self, this.parentStack.scope));
          if (this.extends.length > 0) {
            await this.allSettled(this.extends.map(async (stack) => {
              let id = stack.value();
              let module2 = stack.getReferenceModuleType();
              let load = false;
              let local2 = stack.isMemberExpression ? stack.getFirstMemberStack().value() : id;
              if (!this.scope.isDefine(local2)) {
                module2 = await this.loadTypeAsync(id);
                load = true;
              }
              let push = (module3, stack2) => {
                if (!module3) {
                  stack2.error(1027, id);
                } else {
                  if (Utils.checkDepend(self, module3)) {
                    stack2.error(1024, id, self.getName(), module3.getName());
                  } else {
                    self.extends.push(module3);
                    module3.used = true;
                    module3.children.push(self);
                    this.compilation.addDependency(module3, self);
                  }
                }
              };
              if (module2 || !load) {
                push(module2, stack);
              } else if (load) {
                this.compilation.hookAsync("compilation.create.done", () => {
                  push(stack.getReferenceModuleType(), stack);
                });
              }
            }));
          }
          this.node.body.map((item2) => {
            const stack = this.createTokenStack(compilation, item2, this.scope, this.node, this);
            if (stack) {
              if (stack.isMetatypeDeclaration) {
                metatypes.push(stack);
              } else if (stack.isAnnotationDeclaration) {
                annotations.push(stack);
              } else {
                stack.metatypes = metatypes.splice(0, metatypes.length);
                stack.annotations = annotations.splice(0, annotations.length);
                this.body.push(stack);
              }
            }
          });
        } catch (e) {
          this.compilation.throwError(e);
        }
      }
      type() {
        return this.module;
      }
      description() {
        return this;
      }
      parser() {
        if (super.parser() === false)
          return false;
        try {
          const cache = {};
          this.extends.forEach((item2) => {
            item2.parser();
            item2.setRefBeUsed();
          });
          this.body.forEach((item2) => {
            if (!item2)
              return;
            item2.parser();
            if (!(item2.isIdentifier || item2.isMemberExpression)) {
              if (item2.isStructTableKeyDefinition && item2.local?.isStructTableMethodDefinition) {
                const key = item2.local?.key?.value();
                if (cache[key]) {
                  cache[key].error(1168);
                  item2.local.key.error(1168);
                }
                cache[key] = item2.local.key;
              }
            }
          });
        } catch (e) {
          this.compilation.throwError(e);
        }
      }
      value() {
        return this.id.value();
      }
    };
    module.exports = StructTableDeclaration;
  }
});

// lib/stacks/StructTableKeyDefinition.js
var require_StructTableKeyDefinition = __commonJS({
  "lib/stacks/StructTableKeyDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var StructTableKeyDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isStructTableKeyDefinition = true;
        this.key = this.createTokenStack(compilation, node2.key, scope, node2, this);
        this.local = this.createTokenStack(compilation, node2.local, scope, node2, this);
        this.properties = (node2.properties || []).map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
      }
      definition(context) {
        return null;
      }
      value() {
        return this.key.value();
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.local?.parser();
        this.properties.forEach((item2) => {
          if (!(item2.isIdentifier || item2.isMemberExpression)) {
            item2.parser();
          }
        });
      }
    };
    module.exports = StructTableKeyDefinition;
  }
});

// lib/stacks/StructTableMethodDefinition.js
var require_StructTableMethodDefinition = __commonJS({
  "lib/stacks/StructTableMethodDefinition.js"(exports, module) {
    var MergeType = require_MergeType();
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var Utils = require_Utils();
    var StructTableMethodDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isStructTableMethodDefinition = true;
        this.key = this.createTokenStack(compilation, node2.key, scope, node2, this);
        this.params = node2.params.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
        this.addHook();
      }
      addHook() {
        const key = this.key.value();
        const local2 = key && key.toLowerCase();
        if (local2 === "enum") {
          const items = this.params.filter((item2) => {
            if (item2.isIdentifier || item2.isMemberExpression) {
              const id = item2.value();
              return !Utils.isGlobalTypeName(id) && this.checkNeedToLoadTypeById(id);
            }
            return false;
          });
          if (items.length > 0) {
            this.compilation.hookAsync("compilation.create.after", async () => {
              await this.compiler.callAsyncSequence(items, async (item2) => {
                const desc = await this.loadTypeAsync(item2.value());
                if (Utils.isModule(desc)) {
                  this.compilation.addDependency(desc, this.module);
                }
              });
            });
          }
        } else if (!Utils.getStructTableMethodTypeName(local2)) {
          this.compilation.hookAsync("compilation.create.after", async () => {
            const desc = await this.loadTypeAsync(key);
            if (Utils.isModule(desc)) {
              this.compilation.addDependency(desc, this.module);
            }
          });
        }
      }
      definition(context) {
        return null;
      }
      description() {
        if (!this.parentStack.isStructTableColumnDefinition)
          return null;
        return this.getAttribute("description", () => {
          const key = this.key.value();
          const local2 = key.toLowerCase();
          if (local2 === "enum") {
            const mergeType = new MergeType();
            this.params.forEach((item2) => {
              if (item2.isIdentifier || item2.isMemberExpression) {
                let type2 = item2.getReferenceType();
                if (type2) {
                  if (!(type2.isModule && type2.isEnum)) {
                    item2.error(1009, type2.toString(), "Enum");
                  } else {
                    mergeType.add(type2);
                  }
                } else {
                  item2.error(1175, item2.value());
                }
              } else if (item2.isLiteral) {
                mergeType.add(item2.type(), true);
              }
            });
            return mergeType.type();
          }
          const name = Utils.getStructTableMethodTypeName(local2);
          if (name) {
            return Namespace.globals.get(name);
          } else {
            const desc = this.key.getReferenceType();
            if (Utils.isModule(desc)) {
              this.compilation.addDependency(desc, this.module);
            }
            return desc ? desc : null;
          }
        });
      }
      type() {
        const desc = this.description();
        if (!desc)
          return Namespace.globals.get("string");
        return desc.type();
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.parentStack.isStructTableKeyDefinition) {
          if (this.params.length > 0) {
            this.params.forEach((item2) => {
              if (!this.module.hasMember(item2.value())) {
                item2.error(1166, item2.value());
              }
            });
          } else {
            this.key.error(1167);
          }
        } else if (this.parentStack.isStructTableColumnDefinition) {
          this.params.forEach((item2) => {
            if (item2.isIdentifier || item2.isMemberExpression) {
              item2.setRefBeUsed();
            }
          });
          if (!Utils.getStructTableMethodTypeName(this.key.value())) {
            this.key.setRefBeUsed();
          }
        }
      }
      value() {
        return this.key.value();
      }
    };
    module.exports = StructTableMethodDefinition;
  }
});

// lib/stacks/StructTablePropertyDefinition.js
var require_StructTablePropertyDefinition = __commonJS({
  "lib/stacks/StructTablePropertyDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var StructTablePropertyDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isStructTablePropertyDefinition = true;
        this.assignment = !!node2.assignment;
        this.key = this.createTokenStack(compilation, node2.key, scope, node2, this);
        this.init = this.createTokenStack(compilation, node2.init, scope, node2, this);
      }
      definition(context) {
        return null;
      }
      value() {
        return this.key.value();
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.parentStack.isStructTableColumnDefinition) {
          this.init?.parser();
        }
      }
    };
    module.exports = StructTablePropertyDefinition;
  }
});

// lib/stacks/SuperExpression.js
var require_SuperExpression = __commonJS({
  "lib/stacks/SuperExpression.js"(exports, module) {
    var Namespace = require_Namespace();
    var Expression = require_Expression();
    var SuperExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isSuperExpression = true;
        const fnScope = scope.getScopeByType("function");
        if (fnScope.isMethod && fnScope.isConstructor && !fnScope.hasSuper) {
          fnScope.firstSuperIndex = parentStack.childrenStack.length;
          fnScope.hasSuper = true;
        }
      }
      definition(ctx) {
        let parent = this.module.getInheritModule();
        if (parent)
          parent = parent.type();
        const methodConstructor = parent && parent.getConstructMethod();
        if (methodConstructor) {
          parent = methodConstructor;
        }
        return parent && parent.definition(ctx);
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      description() {
        return this;
      }
      // getContext(){
      //     let ctx = this.getAttribute('getContext');
      //     if(ctx)return ctx;
      //     const module = this.module;
      //     const moduleStack = module.moduleStack;
      //     const parent = moduleStack.getContext();
      //     return this.setAttribute('getContext',parent.createChild(this));
      // }
      type() {
        if (this.module) {
          const inherit = this.module.type().getInheritModule();
          if (inherit) {
            return inherit;
          }
        }
        return Namespace.globals.get("never");
      }
      parser() {
        if (super.parser() === false)
          return false;
        const stack = this.getParentStack((stack2) => {
          return !!stack2.isMethodDefinition;
        });
        if (!stack || !stack.isMethodDefinition || stack.static) {
          this.error(1076);
        }
        const module2 = this.module;
        let parent = null;
        if (module2) {
          parent = module2.type().getInheritModule();
        }
        if (!parent) {
          this.error(1075);
        }
      }
      value() {
        return `super`;
      }
      raw() {
        return `super`;
      }
    };
    module.exports = SuperExpression;
  }
});

// lib/stacks/SwitchCase.js
var require_SwitchCase = __commonJS({
  "lib/stacks/SwitchCase.js"(exports, module) {
    var Stack = require_Stack();
    var SwitchCase = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isSwitchCase = true;
        this.hasReturnStatement = false;
        this.condition = this.createTokenStack(compilation, node2.test, scope, node2, this);
        this.consequent = node2.consequent.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this)).filter((item2) => {
          if (item2) {
            if (!this.hasReturnStatement) {
              this.hasReturnStatement = !!(item2.hasReturnStatement || item2.hasThrowStatement);
            }
            return true;
          }
          return false;
        });
      }
      freeze() {
        super.freeze();
        super.freeze(this.consequent);
        this.condition && this.condition.freeze();
        this.consequent.forEach((stack) => stack.freeze());
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.condition) {
          this.condition.parser();
          this.condition.setRefBeUsed();
        }
        this.consequent.forEach((item2) => item2.parser());
      }
    };
    module.exports = SwitchCase;
  }
});

// lib/stacks/SwitchStatement.js
var require_SwitchStatement = __commonJS({
  "lib/stacks/SwitchStatement.js"(exports, module) {
    var Stack = require_Stack();
    var BlockScope = require_BlockScope();
    var SwitchStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isSwitchStatement = true;
        this.condition = this.createTokenStack(compilation, node2.discriminant, scope, node2, this);
        scope = new BlockScope(scope);
        let hasDefault = false;
        this.cases = node2.cases.map((item2) => {
          if (!hasDefault && !item2.test)
            hasDefault = true;
          return this.createTokenStack(compilation, item2, scope, node2, this);
        });
        this.hasReturnStatement = false;
        if (hasDefault) {
          this.hasReturnStatement = this.cases.every((item2) => !!(item2.hasReturnStatement || item2.hasThrowStatement));
        }
      }
      freeze() {
        super.freeze();
        super.freeze(this.cases);
        super.freeze(this.scope);
        this.condition.freeze();
        this.cases.forEach((stack) => stack.freeze());
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.condition.parser();
        this.condition.setRefBeUsed();
        this.cases.forEach((item2) => item2.parser());
      }
    };
    module.exports = SwitchStatement;
  }
});

// lib/stacks/TemplateElement.js
var require_TemplateElement = __commonJS({
  "lib/stacks/TemplateElement.js"(exports, module) {
    var Stack = require_Stack();
    var TemplateElement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTemplateElement = true;
      }
      definition() {
        return null;
      }
      reference() {
        return this;
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type() {
        return this.getGlobalTypeById("string");
      }
      value() {
        return this.node.value.cooked;
      }
      raw() {
        return this.node.value.raw;
      }
    };
    module.exports = TemplateElement;
  }
});

// lib/stacks/TemplateLiteral.js
var require_TemplateLiteral = __commonJS({
  "lib/stacks/TemplateLiteral.js"(exports, module) {
    var Stack = require_Stack();
    var TemplateLiteral = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.expressions = node2.expressions.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
        this.quasis = node2.quasis.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
        this.isTemplateLiteral = true;
      }
      freeze() {
        super.freeze();
        super.freeze(this.quasis);
        super.freeze(this.expressions);
        this.quasis.forEach((stack) => stack.freeze());
        this.expressions.forEach((stack) => stack.freeze());
      }
      definition() {
        return null;
      }
      reference() {
        return this;
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type() {
        return this.getModuleById("string");
      }
      value() {
        return this.node.raw;
      }
      raw() {
        return this.node.raw;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.expressions.forEach((item2) => {
          item2.parser();
          item2.setRefBeUsed();
        });
      }
    };
    module.exports = TemplateLiteral;
  }
});

// lib/stacks/ThisExpression.js
var require_ThisExpression = __commonJS({
  "lib/stacks/ThisExpression.js"(exports, module) {
    var Expression = require_Expression();
    var ThisExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isThisExpression = true;
      }
      definition() {
        return {
          expre: `this: this`,
          location: this.getLocation(),
          file: this.compilation.file
        };
      }
      reference() {
        return this;
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type() {
        return this.scope.define(this.value());
      }
      value() {
        return `this`;
      }
      raw() {
        return `this`;
      }
      parser() {
        if (super.parser() === false)
          return false;
        const desc = this.type();
        if (!desc) {
          this.error(1013, this.raw());
        }
      }
    };
    module.exports = ThisExpression;
  }
});

// lib/stacks/ThrowStatement.js
var require_ThrowStatement = __commonJS({
  "lib/stacks/ThrowStatement.js"(exports, module) {
    var Stack = require_Stack();
    var ThrowStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isThrowStatement = true;
        this.hasThrowStatement = true;
        this.argument = this.createTokenStack(compilation, node2.argument, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
      }
      definition() {
        return null;
      }
      error(code, ...args) {
        this.argument.error(code, ...args);
      }
      warn(code, ...args) {
        this.argument.warn(code, ...args);
      }
      reference() {
        return null;
      }
      referenceItems() {
        return [];
      }
      description() {
        return null;
      }
      parser() {
        return this.argument.parser();
      }
      value() {
        return this.argument.value();
      }
      raw() {
        return this.argument.raw();
      }
    };
    module.exports = ThrowStatement;
  }
});

// lib/stacks/TryStatement.js
var require_TryStatement = __commonJS({
  "lib/stacks/TryStatement.js"(exports, module) {
    var Stack = require_Stack();
    var Declarator = require_Declarator();
    var TryStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTryStatement = true;
        this.param = null;
        this.handler = null;
        if (node2.handler) {
          this.param = new Declarator(compilation, node2.handler.param, scope, node2, this);
          if (node2.handler.param) {
            scope.define(this.param.value(), this.param);
          }
          this.handler = this.createTokenStack(compilation, node2.handler.body, scope, node2, this);
        }
        this.hasReturnStatement = false;
        this.block = this.createTokenStack(compilation, node2.block, scope, node2, this);
        this.finalizer = this.createTokenStack(compilation, node2.finalizer, scope, node2, this);
        if (this.handler && this.block) {
          this.hasReturnStatement = this.block.hasReturnStatement && this.handler.hasReturnStatement;
        } else if (this.finalizer) {
          this.hasReturnStatement = this.finalizer.hasReturnStatement;
        }
      }
      freeze() {
        super.freeze();
        this.block.freeze();
        this.param && this.param.freeze();
        this.handler && this.handler.freeze();
        this.finalizer && this.finalizer.freeze();
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.block.parser();
        this.param && this.param.parser();
        this.handler && this.handler.parser();
        this.finalizer && this.finalizer.parser();
      }
    };
    module.exports = TryStatement;
  }
});

// lib/stacks/TypeAssertExpression.js
var require_TypeAssertExpression = __commonJS({
  "lib/stacks/TypeAssertExpression.js"(exports, module) {
    var Expression = require_Expression();
    var TypeAssertExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeAssertExpression = true;
        this.left = this.createTokenStack(compilation, node2.left, scope, node2, this);
        this.right = this.createTokenStack(compilation, node2.right, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
      }
      definition(ctx) {
        return this.left.definition(ctx);
      }
      description() {
        return this.left.description();
      }
      reference() {
        return this.left.reference();
      }
      referenceItems() {
        return this.left.referenceItems();
      }
      type() {
        return this.right.type();
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.right.parser();
        this.left.parser();
      }
    };
    module.exports = TypeAssertExpression;
  }
});

// lib/stacks/TypeComputeDefinition.js
var require_TypeComputeDefinition = __commonJS({
  "lib/stacks/TypeComputeDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var ComputeType = require_ComputeType();
    var keySymbol = Symbol("key");
    var TypeComputeDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeComputeDefinition = true;
        this.object = this.createTokenStack(compilation, node2.object, scope, node2, this);
        this.property = this.createTokenStack(compilation, node2.property, scope, node2, this);
        this[keySymbol] = {};
      }
      freeze() {
        super.freeze();
        this.object.freeze();
        this.property.freeze();
      }
      definition(ctx) {
        if (this.parentStack.isTypeStatement || this.parentStack.isDeclaratorTypeAlias) {
          return this.parentStack.definition(ctx);
        }
        const type2 = this.type();
        return {
          kind: this.kind,
          comments: this.comments,
          expre: `(type) ${type2.toString()}`,
          location: (this.prefix || this).getLocation(),
          file: this.compilation.file,
          context: this
        };
      }
      description() {
        return this;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type(ctx) {
        if (!this[keySymbol]._type) {
          this[keySymbol]._type = new ComputeType(this, this.object.type(), this.property);
        }
        return this[keySymbol]._type.type();
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.object.parser();
        this.property.parser();
      }
    };
    module.exports = TypeComputeDefinition;
  }
});

// lib/types/ConditionalExpressionType.js
var require_ConditionalExpressionType = __commonJS({
  "lib/types/ConditionalExpressionType.js"(exports, module) {
    var MergeType = require_MergeType();
    var Utils = require_Utils();
    var Type = require_Type();
    var ConditionalExpressionType = class extends Type {
      #_types = null;
      constructor(target) {
        super("$ConditionalExpressionType");
        this.target = target;
        this.isConditionalExpressionType = true;
      }
      getInferResult(context, records = /* @__PURE__ */ new Map(), flag = false) {
        const target = this.target;
        const condition = target.condition.type().getInferResult(context, records);
        let result = null;
        if (condition) {
          result = target.consequent.type();
        } else {
          if (flag)
            return null;
          result = target.alternate.type();
        }
        if (result.isInferGenericType) {
          return result.getInferResult(context, records);
        } else if (result.isConditionalExpressionType) {
          return result.getInferResult(context, records);
        }
        const inference = (type2) => {
          type2 = type2.type();
          const res = records && records.get(type2) || context.infer(type2);
          return res || type2;
        };
        return result.hasGenericType ? result.clone(inference) : result;
      }
      extracts() {
        const target = this.target;
        const consequent = target.consequent.type();
        const alternate = target.alternate.type();
        const items = [];
        if (consequent.isConditionalExpressionType) {
          items.push(...consequent.extracts());
        } else {
          items.push(consequent);
        }
        if (alternate.isConditionalExpressionType) {
          items.push(...alternate.extracts());
        } else {
          items.push(alternate);
        }
        return items;
      }
      toUnionType() {
        const exists = this.#_types;
        if (exists)
          return exists;
        const items = this.extracts();
        return this.#_types = MergeType.arrayToUnion(items);
      }
      is(type2, context) {
        if (Utils.isContext(context)) {
          const result = this.getInferResult(context, /* @__PURE__ */ new Map(), true);
          if (result) {
            return result.is(type2, context);
          }
        }
        return this.toUnionType().is(type2, context);
      }
      toString(context, options = {}) {
        if (Utils.isContext(context)) {
          const result = this.getInferResult(context, /* @__PURE__ */ new Map(), true);
          if (result) {
            return result.toString(context, options);
          }
        }
        return this.toUnionType().toString(context, options);
      }
    };
    module.exports = ConditionalExpressionType;
  }
});

// lib/stacks/TypeConditionalExpression.js
var require_TypeConditionalExpression = __commonJS({
  "lib/stacks/TypeConditionalExpression.js"(exports, module) {
    var Stack = require_Stack();
    var ConditionalExpressionType = require_ConditionalExpressionType();
    var BlankScope = require_BlankScope();
    var TypeConditionalExpression = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        scope = new BlankScope(scope);
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeConditionalExpression = true;
        this.condition = this.createTokenStack(compilation, node2.condition, scope, node2, this);
        this.consequent = this.createTokenStack(compilation, node2.consequent, scope, node2, this);
        this.alternate = this.createTokenStack(compilation, node2.alternate, scope, node2, this);
      }
      definition(ctx) {
      }
      description() {
        return this;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          return new ConditionalExpressionType(this);
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.condition.parser();
        this.consequent.parser();
        this.alternate.parser();
      }
      value() {
        return this.raw();
      }
      raw() {
        return super.raw();
      }
    };
    module.exports = TypeConditionalExpression;
  }
});

// lib/types/ConditionType.js
var require_ConditionType = __commonJS({
  "lib/types/ConditionType.js"(exports, module) {
    var { extractMatchGenerics, extractGenericsFromType } = require_Inference();
    var MergeType = require_MergeType();
    var Type = require_Type();
    var ConditionType = class extends Type {
      constructor(target) {
        super("$ConditionType");
        this.target = target;
        this.isConditionType = true;
      }
      getInferResult(context, records) {
        const target = this.target;
        const constraint = target.extends.type();
        let argumentType = records && records.get(target.argument.type()) || context.infer(target.argument.type());
        if (argumentType) {
          let result = false;
          if (argumentType.isUnionType) {
            const matched = argumentType.elements.find((item2) => constraint.is(item2.type(), context));
            if (matched) {
              argumentType = matched.type();
              result = true;
            }
          } else {
            result = constraint.is(argumentType, context);
          }
          if (result && records) {
            if (argumentType.isLiteralArrayType) {
              argumentType = MergeType.arrayToTuple(argumentType.elements);
            }
            let declareGenerics = [];
            let declareParams = [constraint];
            let assigmentArgs = [argumentType];
            let newRecords = /* @__PURE__ */ new Map();
            if (constraint.isTupleType) {
              declareGenerics = constraint.elements.filter((item2) => item2.type().isInferGenericType);
            } else if (constraint.isClassGenericType) {
              declareGenerics = constraint.types.filter((item2) => item2.type().isInferGenericType);
            } else if (constraint.isFunctionType) {
              declareGenerics = constraint.params.filter((item2) => item2.type().isInferGenericType);
              declareParams = constraint.params.slice(0);
              assigmentArgs = argumentType.params.slice(0);
              let returnType = constraint.getReturnedType();
              if (returnType && returnType.isInferGenericType) {
                let assigmentReturnType = argumentType.getReturnedType();
                if (assigmentReturnType) {
                  extractMatchGenerics(newRecords, [returnType], [returnType], [assigmentReturnType]);
                }
              }
            } else {
              declareGenerics = extractGenericsFromType(constraint);
            }
            extractMatchGenerics(newRecords, declareGenerics, declareParams, assigmentArgs);
            newRecords.forEach((value2, key) => {
              records.set(key, value2);
            });
          }
          return result;
        }
        return false;
      }
      is(type2, context) {
        const target = this.target;
        const constraint = target.extends.type();
        return constraint.is(type2, context);
      }
      toString(context, options = {}) {
        const target = this.target;
        const parts = [];
        const constraint = target.extends.type();
        parts.push(target.argument.value());
        parts.push(` extends ${constraint.toString(context, options)}`);
        return parts.join("");
      }
    };
    module.exports = ConditionType;
  }
});

// lib/stacks/TypeConditionDefinition.js
var require_TypeConditionDefinition = __commonJS({
  "lib/stacks/TypeConditionDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var ConditionType = require_ConditionType();
    var TypeConditionDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeConditionDefinition = true;
        this.argument = this.createTokenStack(compilation, node2.argument, scope, node2, this);
        this.extends = this.createTokenStack(compilation, node2.extends, scope, node2, this);
      }
      definition(ctx) {
      }
      description() {
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          return new ConditionType(this);
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.argument.parser();
        this.extends.parser();
      }
      value() {
        return this.raw();
      }
      raw() {
        return super.raw();
      }
    };
    module.exports = TypeConditionDefinition;
  }
});

// lib/types/CircularType.js
var require_CircularType = __commonJS({
  "lib/types/CircularType.js"(exports, module) {
    var Type = require_Type();
    var CircularType = class extends Type {
      constructor(inherit, target, typeName) {
        super("$CircularType", inherit);
        this.isCircularType = true;
        this.target = target;
        this.typeName = typeName;
      }
      get id() {
        return this.typeName;
      }
      get hasGenericType() {
        return this.inherit.hasGenericType;
      }
      definition(ctx) {
        return this.inherit.definition(ctx);
      }
      clone(inference) {
        if (inference) {
          return new CircularType(inference(this.inherit), this.target, this.typeName);
        }
        return this;
      }
      check(stack, context = {}, options = {}) {
        return this.inherit.check(stack, context, options);
      }
      is(type2, context, options = {}) {
        const acceptType = this.inherit;
        if (acceptType.isLiteralObjectType) {
          return acceptType.constraint(type2, context, options);
        }
        return acceptType.is(type2, context, options);
      }
      toString(context, options = {}) {
        return this.typeName;
      }
    };
    module.exports = CircularType;
  }
});

// lib/stacks/TypeDefinition.js
var require_TypeDefinition = __commonJS({
  "lib/stacks/TypeDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var Utils = require_Utils();
    var InstanceofType = require_InstanceofType();
    var Type = require_Type();
    var Namespace = require_Namespace();
    var CircularType = require_CircularType();
    var TypeDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeDefinition = true;
        this.argument = this.createTokenStack(compilation, node2.value, scope, node2, this);
        this.isThisType = this.argument.value() === "this";
        this.addHook();
      }
      addHook() {
        if (this.argument.isLiteral || this.isThisType) {
          return;
        }
        const id = this.argument.value();
        if (!Utils.isGlobalTypeName(id) && this.checkNeedToLoadTypeById(id)) {
          this.compilation.hookAsync("compilation.create.after", async () => {
            const desc = await this.loadTypeAsync(id, null, false);
            if (desc && desc.isModule) {
              this.compilation.addDependency(desc, this.module);
            }
          });
        }
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
      }
      definition(ctx) {
        const type2 = this.type();
        if (!this.isThisType && Utils.isModule(type2)) {
          return type2.definition(ctx);
        }
        if (Utils.isGlobalShortenType(type2)) {
          return {
            expre: `(type) ${type2.toString()}`
          };
        }
        ctx = ctx || this.getContext();
        if (this.is(type2.target) && type2.target !== this) {
          return type2.target.definition(ctx);
        }
        return {
          comments: this.comments,
          expre: `(type) ${type2.toString(ctx)}`
        };
      }
      error(code, ...args) {
        this.argument.error(code, ...args);
      }
      warn(code, ...args) {
        this.argument.warn(code, ...args);
      }
      description() {
        return this;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      hasLocalDefined() {
        return this.argument.hasLocalDefined();
      }
      type() {
        return this.getAttribute("type", () => {
          if (this.argument.isLiteral) {
            return this.argument.type();
          } else {
            if (this.isThisType) {
              return this.module && this.module.isModule ? new InstanceofType(this.module, this, null, true) : Namespace.globals.get("never");
            } else {
              let type2 = this.argument.getReferenceType();
              if (type2) {
                if (type2.isTypeStatement) {
                  this.argument.setRefBeUsed(type2);
                }
                if (this.checkNestedRefs()) {
                  let id = this.argument.value();
                  return new CircularType(type2.type(), this, id);
                } else {
                  return type2.type();
                }
              } else {
                let descriptors = null;
                let id = this.argument.value();
                if (id) {
                  if (id.includes(".")) {
                    descriptors = Namespace.fetch(id, null, true, true);
                  } else {
                    descriptors = Namespace.fetch(id, this.namespace, true, true);
                  }
                  if (descriptors) {
                    const desc = descriptors.find((item2) => item2.isDeclaratorFunction);
                    if (desc) {
                      this.argument.setRefBeUsed(desc);
                      return desc.type();
                    }
                  }
                }
              }
            }
          }
          return Namespace.globals.get("never");
        });
      }
      checkCircular(type2) {
        if (this.checkedCircular !== void 0) {
          return this.checkedCircular;
        }
        this.checkedCircular = false;
        if (type2) {
          this.getParentStack((stack) => {
            if (stack.isTypeGenericDefinition || stack.isGenericTypeDeclaration || stack.isTypeDefinition || stack.isTypeStatement) {
              if (stack === type2) {
                this.checkedCircular = true;
                this.argument.error(1141, this.value());
              }
              return true;
            } else {
              return false;
            }
          });
        }
        return this.checkedCircular;
      }
      getTypeDefinitionBeginStack(stack) {
        if (!stack.parentStack)
          return stack;
        if (this.isTypeDefinitionStack(stack)) {
          return this.getTypeDefinitionBeginStack(stack.parentStack);
        }
        return stack;
      }
      checkNestedRefs() {
        if (this.isThisType || this.argument.isLiteral)
          return false;
        const begin = this.getTypeDefinitionBeginStack(this.parentStack);
        if (begin !== this.parentStack) {
          let id = this.argument.value();
          if (begin.isTypeStatement) {
            return begin === this.scope.define(id);
          } else if (begin.isDeclaratorTypeAlias) {
            return begin === Namespace.globals.raw(id);
          }
        }
        return false;
      }
      parser() {
        if (super.parser() === false)
          return false;
        let type2 = this.type();
        if (type2 && (type2.isNeverType && this.value() !== "never") || type2 && !type2.isType) {
          type2 = null;
        }
        if (!type2) {
          type2 = this.getModuleById(this.argument.value());
          if (type2) {
            type2 = type2.type();
            this.setAttribute("type", type2);
          }
        }
        if (type2) {
          if (type2.isModule || type2.isDeclaratorTypeAlias) {
            this.parserDescriptor(type2);
          }
          if (!this.isThisType) {
            let desc = null;
            if (this.argument.isIdentifier) {
              let _desc = this.scope.define(this.argument.value());
              if (this.is(_desc) && (_desc.isImportDeclaration || _desc.isImportNamespaceSpecifier || _desc.isImportSpecifier || _desc.isImportDefaultSpecifier)) {
                desc = _desc;
              }
            }
            if (!desc) {
              if (type2.isAliasType && type2.target && type2.target.isDeclaratorTypeAlias) {
                desc = type2.target;
              } else {
                desc = type2;
              }
            }
            this.argument.setRefBeUsed(desc);
          }
        }
        if (!type2) {
          this.argument.error(1083, this.argument.value());
        } else if (!this.parentStack.isDeclaratorTypeAlias) {
          if (!type2 || !(type2 instanceof Type)) {
            this.argument.error(1083, this.value());
          } else if (!this.isThisType && !this.parentStack.isBinaryExpression) {
            let declareGgenerics = null;
            if (type2.isAliasType && type2.target && type2.target.genericity && type2.target.genericity.isGenericDeclaration) {
              declareGgenerics = type2.target.genericity.elements;
            } else if (Utils.isTypeModule(type2)) {
              const result = type2.getModuleDeclareGenerics(false, false, true);
              if (result && result[1]) {
                declareGgenerics = result[1];
              }
            }
            if (declareGgenerics) {
              const requires = declareGgenerics.filter((item2) => !item2.isGenericTypeAssignmentDeclaration);
              const len = requires.length;
              if (len > 0) {
                this.argument.error(1030, type2.toString(), len);
              }
            }
          }
        }
      }
      value() {
        return this.argument.value();
      }
      raw() {
        return this.argument.raw();
      }
    };
    module.exports = TypeDefinition;
  }
});

// lib/stacks/TypeFunctionDefinition.js
var require_TypeFunctionDefinition = __commonJS({
  "lib/stacks/TypeFunctionDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var FunctionType = require_FunctionType();
    var UnionType = require_UnionType();
    var FunctionScope = require_FunctionScope();
    var Declarator = require_Declarator();
    var Namespace = require_Namespace();
    var keySymbol = Symbol("key");
    var TypeFunctionDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        scope = new FunctionScope(scope);
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeFunctionDefinition = true;
        this._returnType = this.createTokenStack(compilation, node2.value, scope, node2, this);
        let assignment = null;
        let hasRest = null;
        this.genericity = this.createTokenStack(compilation, node2.genericity, scope, node2, this);
        this.params = node2.params.map((item2) => {
          if (item2.type == "Identifier") {
            const stack = new Declarator(compilation, item2, scope, node2, this);
            if (assignment) {
              assignment.error(1050, assignment.value());
            }
            return stack;
          } else {
            const stack = this.createTokenStack(compilation, item2, scope, node2, this);
            if (stack.isRestElement) {
              hasRest = stack;
            }
            assignment = stack;
            return stack;
          }
        });
        if (hasRest && this.params[this.params.length - 1] !== hasRest) {
          hasRest.error(1051, hasRest.value());
        }
        this[keySymbol] = {};
      }
      freeze() {
        super.freeze();
        super.freeze(this.params);
        this.returnType && this.returnType.freeze();
        this.params.forEach((stack) => stack.freeze());
      }
      definition(ctx) {
        if (this.parentStack.isTypeStatement || this.parentStack.isDeclaratorTypeAlias) {
          return this.parentStack.definition(ctx);
        }
        ctx = ctx || this.getContext();
        return this.type().definition(ctx);
      }
      signature() {
        const def = this.definition();
        const _params = this.params;
        const comments = this.parseComments();
        const params = _params.map((item2) => {
          if (item2.isObjectPattern) {
            return {
              label: "ObjectPattern"
            };
          } else if (item2.isArrayPattern) {
            return {
              label: "ArrayPattern"
            };
          } else {
            const name = item2.value();
            const meta = comments && comments.params.find((param) => param.label === name);
            return {
              label: name,
              comment: meta && meta.comment ? meta.comment : item2.comments.join("\n")
            };
          }
        });
        def.params = params;
        return def;
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type() {
        return this.getFunType();
      }
      setRefBeUsed() {
      }
      get returnType() {
        return this.getAttribute("returnType", () => {
          return this._returnType ? this._returnType.type() : Namespace.globals.get("void");
        });
      }
      normalization(type2) {
        if (type2 && type2.isUnionType) {
          if (type2.elements.some((type3) => type3.type().isAnyType && !type3.isComputeType)) {
            return Namespace.globals.get("any");
          }
          const elements = type2.elements.filter((type3) => !type3.type().isNullableType);
          if (elements.length === 1) {
            return type2.elements[0].type();
          } else if (!elements.length) {
            return type2.elements[0];
          }
          if (elements.length !== type2.elements.length) {
            return new UnionType(elements, type2.target);
          }
        }
        return type2;
      }
      getReturnedType() {
        return this.returnType;
      }
      getFunType() {
        return this.getAttribute("getFunType", () => {
          return new FunctionType(Namespace.globals.get("Function"), this);
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.genericity) {
          this.genericity.parser();
        }
        this.params.forEach((item2) => item2.parser());
        if (this._returnType) {
          this._returnType.parser();
          if (!this._returnType.type()) {
            this._returnType.error(1083, this._returnType.value());
          }
        }
      }
    };
    module.exports = TypeFunctionDefinition;
  }
});

// lib/stacks/TypeGenericDefinition.js
var require_TypeGenericDefinition = __commonJS({
  "lib/stacks/TypeGenericDefinition.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var Utils = require_Utils();
    var ClassGenericType = require_ClassGenericType();
    var TupleType = require_TupleType();
    var TypeGenericDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeGenericDefinition = true;
        this.argument = this.createTokenStack(compilation, node2.value, scope, node2, this);
        this.elements = node2.typeElements.map((item2) => {
          return this.createTokenStack(compilation, item2, scope, node2, this);
        });
        this.isThisType = this.argument && this.argument.value() === "this";
        this.addHook();
      }
      addHook() {
        if (this.isThisType) {
          return;
        }
        const id = this.argument.value();
        if (this.checkNeedToLoadTypeById(id)) {
          this.compilation.hookAsync("compilation.create.after", async () => {
            const desc = await this.loadTypeAsync(id);
            if (desc && desc.isModule) {
              this.compilation.addDependency(desc, this.module);
            }
          });
        } else {
          const desc = this.scope.define(id);
          if (desc && desc.isModule) {
            this.compilation.addDependency(desc, this.module);
          }
        }
      }
      freeze() {
        super.freeze();
        super.freeze(this.elements);
        this.argument.freeze();
        this.elements.forEach((stack) => stack.freeze());
      }
      definition(ctx) {
        const type2 = this.type();
        if (!type2)
          return null;
        ctx = ctx || this.getContext();
        if (!this.isThisType) {
          const desc = this.argument.getReferenceType();
          if (!desc)
            return null;
          let rawType = desc.type();
          if (rawType && rawType.isAliasType) {
            const result = rawType.definition(ctx);
            if (!result)
              return null;
            return {
              comments: result.comments,
              expre: `(type) ${type2.toString(ctx)}`,
              location: result.location,
              file: result.file
            };
          }
          const origin = Utils.getOriginType(rawType);
          if (origin) {
            return origin.definition(ctx);
          }
          return null;
        }
        return {
          expre: `type ${type2.toString(ctx)}`
        };
      }
      error(code, ...args) {
        this.argument.error(code, ...args);
      }
      warn(code, ...args) {
        this.argument.warn(code, ...args);
      }
      description() {
        return this;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      makeType(type2) {
        if (type2) {
          type2 = type2.type();
          const classType = Namespace.globals.get("Class");
          const isClass = type2 === classType || type2.extends && type2.extends[0] === classType;
          let final = null;
          if (!isClass && !this.isThisType && this.parentStack.isRestElement) {
            let oArray = Namespace.globals.get("Array");
            if (type2 === oArray) {
              final = new TupleType(
                oArray,
                this.elements,
                this
              );
            }
          }
          if (!final) {
            final = new ClassGenericType(
              this.elements,
              isClass ? classType : type2,
              isClass,
              this
            );
          }
          this.setAttribute("type", type2 = final);
        }
        return type2;
      }
      type() {
        return this.getAttribute("type", () => {
          let type2 = this.isThisType ? this.module : this.argument.getReferenceType();
          return this.makeType(type2) || Namespace.globals.get("never");
        });
      }
      getDeclareGenerics(type2 = null) {
        if (!type2) {
          type2 = this.isThisType ? this.module : this.argument.getReferenceType();
        }
        if (type2) {
          type2 = type2.type();
          const originType = Utils.getOriginType(type2);
          if (originType) {
            if (originType.isModule && (originType.isClass || originType.isInterface)) {
              const value2 = originType.getModuleDeclareGenerics(false, false, true);
              if (value2.length > 0)
                return value2;
            }
            if (type2.isAliasType && type2.target && type2.target.genericity) {
              return [type2.target, type2.target.genericity.elements];
            }
          }
        }
        return [];
      }
      parser() {
        if (super.parser() === false)
          return false;
        const value2 = this.argument.value();
        let type2 = this.isThisType ? this.module : this.argument.getReferenceType();
        if (this.type() === Namespace.globals.get("never")) {
          this.makeType(this.getModuleById(this.argument.value()));
        }
        if (type2 && !type2.isAnyType) {
          const [stack, declareGenerics = []] = this.getDeclareGenerics(type2);
          if (stack) {
            this.parserDescriptor(type2.isAliasType ? type2.target : stack);
            let refs = this.scope.define(value2);
            if (refs && refs.isImportDeclaration && refs.type() === type2) {
              refs.addUseRef(this.argument);
            } else {
              stack.addUseRef(this.argument);
            }
          }
          const requires = declareGenerics.filter((item2) => {
            return !item2.isGenericTypeAssignmentDeclaration;
          });
          if (requires.length > this.elements.length || this.elements.length > declareGenerics.length) {
            if (requires.length === declareGenerics.length) {
              this.argument.error(1030, type2.toString(), requires.length);
            } else {
              this.argument.error(1031, type2.toString(), requires.length, declareGenerics.length);
            }
          }
          const sameType = type2.type();
          this.elements.forEach((item2, index) => {
            item2.parser();
            const declareType = declareGenerics[index] && declareGenerics[index].type();
            let type3 = item2.type();
            if (type3 === sameType) {
              item2.error(1177, item2.value());
            } else {
              if (declareType && declareType.hasConstraint) {
                if (type3.isGenericType && type3.assignType) {
                  type3 = type3.assignType;
                }
                if (!type3.isGenericType) {
                  this.checkExpressionType(declareType.inherit, type3, item2);
                }
              }
            }
          });
        } else {
          this.argument.error(1083, this.value());
        }
      }
      value() {
        return this.argument.value();
      }
    };
    module.exports = TypeGenericDefinition;
  }
});

// lib/types/InferGenericType.js
var require_InferGenericType = __commonJS({
  "lib/types/InferGenericType.js"(exports, module) {
    var Namespace = require_Namespace();
    var Utils = require_Utils();
    var GenericType = require_GenericType();
    var { createHash } = __require("crypto");
    var InferGenericType = class extends GenericType {
      #unikey = null;
      constructor(target) {
        super(target);
        this.id = "$InferGenericType";
        this.isInferGenericType = true;
      }
      getUniKey() {
        const exists = this.#unikey;
        if (exists)
          return exists;
        const target = this.target;
        const ns = target.namespace.toString();
        let parent = target.getParentStack(
          (stack) => stack.isFunctionExpression || stack.isTypeFunctionDefinition || stack.isParamDeclarator || stack.isProperty || stack.isGenericTypeDeclaration || stack.isGenericTypeAssignmentDeclaration || stack.isClassDeclaration || stack.isDeclaratorDeclaration || stack.isInterfaceDecorator || stack.isDeclaratorTypeAlias
        );
        let classId = null;
        let methodKey = null;
        let descIndex = null;
        let paramIndex = null;
        if (target.module) {
          classId = target.module.id;
        }
        if (parent.isParamDeclarator) {
          paramIndex = "p" + parent.parentStack.params.indexOf(parent);
          parent = parent.parentStack;
        } else if (parent.isGenericTypeDeclaration || parent.isGenericTypeAssignmentDeclaration) {
          paramIndex = "g" + parent.parentStack.elements.indexOf(parent);
          parent = parent.parentStack.parentStack;
        } else if (parent.isProperty) {
          paramIndex = parent.key.value();
          const _parent = target.getParentStack(
            (stack) => stack.isFunctionExpression || stack.isDeclaratorFunction || stack.isClassDeclaration || stack.isDeclaratorDeclaration || stack.isDeclaratorTypeAlias || stack.isInterfaceDecorator
          );
          if (_parent) {
            parent = _parent;
          }
        }
        if (parent.isCallDefinition || parent.isNewDefinition) {
          const descriptors = parent.module.descriptors.get(parent.isNewDefinition ? "constructor" : "#" + parent.module.id);
          if (descriptors) {
            descIndex = "d" + descriptors.indexOf(parent);
          }
        }
        if (parent.isFunctionExpression && parent.parentStack.isMethodDefinition) {
          parent = parent.parentStack;
          methodKey = parent.key.value();
        } else if (parent.isDeclaratorFunction) {
          methodKey = parent.key.value();
        }
        if (parent.isDeclaratorTypeAlias) {
          classId = parent.id;
        }
        const hash = createHash("sha256").update(target.file || target.compilation.source).digest("hex").substring(0, 16);
        const key = [hash, ns, classId, descIndex, methodKey, paramIndex].filter(Boolean).join("-");
        return this.#unikey = "infer::" + key;
      }
      getInferResult(context, records) {
        let target = this.target;
        if (target.expression) {
          return target.expression.type().getInferResult(context, records);
        } else {
          let result = null;
          if (records) {
            result = records.get(this);
          }
          return result || context.fetch(this) || Namespace.globals.get("unknown");
        }
      }
      is(type2, context) {
        if (Utils.isContext(context)) {
          const result = this.getInferResult(context);
          if (result) {
            return result.is(type2, context);
          }
        }
        return true;
      }
      toString(context, options = {}) {
        const target = this.target;
        const parts = [];
        parts.push("infer ", target.argument.value());
        if (target.expression) {
          parts.push(` extends ${target.expression.type().toString(context, options)}`);
        }
        return parts.join("");
      }
    };
    module.exports = InferGenericType;
  }
});

// lib/stacks/TypeInferDefinition.js
var require_TypeInferDefinition = __commonJS({
  "lib/stacks/TypeInferDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var InferGenericType = require_InferGenericType();
    var TypeInferDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeInferDefinition = true;
        this.argument = this.createTokenStack(compilation, node2.argument, scope, node2, this);
        this.expression = this.createTokenStack(compilation, node2.expression, scope, node2, this);
        const name = this.argument.value();
        const def = scope.define(name);
        if (def && this.is(def) && def.scope === this.scope) {
          this.argument.error(1056, name);
        } else {
          scope.define(name, this);
        }
      }
      definition(ctx) {
        return null;
      }
      description() {
        return this;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          return new InferGenericType(this);
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.argument.parser();
        if (this.expression) {
          this.expression.parser();
        }
      }
      value() {
        return this.argument.value();
      }
      raw() {
        return super.raw();
      }
    };
    module.exports = TypeInferDefinition;
  }
});

// lib/stacks/TypeIntersectionDefinition.js
var require_TypeIntersectionDefinition = __commonJS({
  "lib/stacks/TypeIntersectionDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var IntersectionType = require_IntersectionType();
    var TypeIntersectionDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeIntersectionDefinition = true;
        this.left = this.createTokenStack(compilation, node2.left, scope, node2, this);
        this.right = this.createTokenStack(compilation, node2.right, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
      }
      definition(ctx) {
        if (this.parentStack.isTypeStatement || this.parentStack.isDeclaratorTypeAlias) {
          return this.parentStack.definition(ctx);
        }
        ctx = ctx || this.getContext();
        const type2 = this.type();
        return {
          comments: this.comments,
          expre: `(type) ${type2.toString(ctx)}`,
          location: this.getLocation(),
          file: this.compilation.file
        };
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          return new IntersectionType(this, this.left.type(), this.right.type());
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.left.parser();
        this.right.parser();
      }
      value() {
        if (this.parentStack.isTypeIntersectionDefinition || !this.parentStack.isTypeUnionDefinition) {
          return `${this.left.value()} & ${this.right.value()}`;
        } else {
          return `(${this.left.value()} & ${this.right.value()})`;
        }
      }
      raw() {
        return this.value();
      }
    };
    module.exports = TypeIntersectionDefinition;
  }
});

// lib/types/KeyofType.js
var require_KeyofType = __commonJS({
  "lib/types/KeyofType.js"(exports, module) {
    var UnionType = require_UnionType();
    var LiteralType = require_LiteralType();
    var Type = require_Type();
    var Namespace = require_Namespace();
    var KeyofType = class extends UnionType {
      constructor(target, referenceType) {
        super([], target);
        this.id = "$KeyofType";
        this.isKeyofType = true;
        this.referenceType = referenceType;
        this.hasGenericType = !!referenceType.hasGenericType;
        this.elements = this.getTypeKeys(referenceType);
      }
      clone(inference) {
        if (!inference || !this.hasGenericType) {
          return this;
        }
        const type2 = this.referenceType.type().clone(inference);
        if (type2 !== this.referenceType) {
          return new KeyofType(this.target, type2);
        }
        return this;
      }
      getTypeKeys(type2) {
        type2 = type2 || this.referenceType;
        if (!Type.is(type2))
          return [];
        if (type2.isUnionType)
          return type2.elements.map((el) => el.type());
        if (type2.isGenericType) {
          return [];
        }
        const properties = /* @__PURE__ */ new Set();
        if (type2) {
          const push = (name, type3) => {
            properties.add(new LiteralType(Namespace.globals.get(type3), this.target, name));
          };
          switch (true) {
            case type2.isLiteralObjectType:
            case type2.isEnumType:
              type2.attributes.forEach((value2, key) => {
                push(key, "string");
              });
              break;
            case type2.isLiteralArrayType:
            case type2.isTupleUnion:
              type2.elements.forEach((value2, key) => {
                push(key, "number");
              });
              break;
            case type2.isIntersectionType:
            case type2.isModule:
            case type2.isInstanceofType:
              type2.getTypeKeys().forEach((key) => {
                push(key, "string");
              });
              break;
          }
        }
        return Array.from(properties.values());
      }
      check(stack, context = {}, options = {}) {
        return this.is(stack && stack.type(), context, options);
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        options.toLiteralValue = true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        if (!this.isNeedCheckType(type2))
          return true;
        const infer = (type3) => {
          if (context && context.inference) {
            return context.inference(type3);
          }
          return type3;
        };
        let final = infer(this.referenceType);
        if (final && final.isAnyType && !final.isUnknownType)
          return true;
        const elements = this.getTypeKeys(final);
        if (!elements.length)
          return false;
        if (type2.isUnionType || type2.isLiteralArrayType) {
          return type2.elements.every((item2) => {
            const base = item2.type();
            return elements.some((child) => {
              return base.is(child.type(), context, options);
            });
          });
        }
        return elements.some((base) => base.type().is(type2, context, options));
      }
      toString(context = {}, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        options.toLiteralValue = true;
        if (!options.complete) {
          let infer = (type2) => typeof context.inference === "function" ? context.inference(type2) : type2;
          let refType = infer(this.referenceType.type());
          if (refType.hasGenericType) {
            if (refType.isGenericType && refType.hasConstraint) {
              return `keyof ${refType.inherit.toString(context, options)}`;
            }
          }
          let elements = this.getTypeKeys(refType);
          if (!elements.length) {
            return "keyof never";
          }
          let need = elements.length > 1;
          return elements.map((item2) => {
            if (item2.type().isFunctionType && need) {
              return `(${item2.type().toString(context, options)})`;
            }
            return item2.type().toString(context, options);
          }).join(" | ");
        }
        options = Object.create(options);
        options.onlyTypeName = true;
        return `keyof ${this.referenceType.type().toString(context, options)}`;
      }
    };
    module.exports = KeyofType;
  }
});

// lib/stacks/TypeKeyofDefinition.js
var require_TypeKeyofDefinition = __commonJS({
  "lib/stacks/TypeKeyofDefinition.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var KeyofType = require_KeyofType();
    var TypeKeyofDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeKeyofDefinition = true;
        this.argument = this.createTokenStack(compilation, node2.value, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
      }
      definition(ctx) {
        if (this.parentStack.isTypeStatement || this.parentStack.isDeclaratorTypeAlias) {
          return this.parentStack.definition(ctx);
        }
        const type2 = this.type();
        ctx = ctx || this.getContext();
        return {
          comments: this.comments,
          expre: `(type) ${type2.toString(ctx)}`,
          location: this.getLocation(),
          file: this.compilation.file
        };
      }
      description() {
        return this.argument.argument.description();
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          let type2 = this.argument.type();
          if (type2) {
            if (type2.isTypeofType) {
              type2 = type2.origin;
            }
            return new KeyofType(this, type2);
          } else {
            return Namespace.globals.get("never");
          }
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.argument.parser();
        if (!this.argument.isTypeTypeofDefinition) {
          const target = this.argument.isTypeDefinition ? this.argument.argument : this.argument;
          const desc = target.getReferenceType();
          if (!desc || !(desc.isTypeDefinition || desc.isGenericTypeDeclaration || desc.isGenericTypeAssignmentDeclaration || desc.isDeclaratorTypeAlias || desc.isTypeStatement || desc.isModule)) {
            target.error(1083, target.value());
          }
        }
      }
      value() {
        return this.argument.value();
      }
      raw() {
        return this.argument.value();
      }
    };
    module.exports = TypeKeyofDefinition;
  }
});

// lib/stacks/TypeObjectDefinition.js
var require_TypeObjectDefinition = __commonJS({
  "lib/stacks/TypeObjectDefinition.js"(exports, module) {
    var Namespace = require_Namespace();
    var LiteralObjectType = require_LiteralObjectType();
    var Expression = require_Expression();
    var keySymbol = Symbol("key");
    var TypeObjectDefinition = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeObjectDefinition = true;
        this.attributes = /* @__PURE__ */ new Map();
        this.dynamicProperties = /* @__PURE__ */ new Map();
        this.callDefinitions = null;
        const dynamicProperties = [];
        this.properties = node2.properties.map((item2) => {
          const stack = this.createTokenStack(compilation, item2, scope, node2, this);
          if (!stack.dynamic) {
            const name = stack.value();
            if (name === "#new#" || name === "#call#") {
              const dataset = this.callDefinitions || (this.callDefinitions = /* @__PURE__ */ new Map());
              let defs = dataset.get(name);
              if (!defs) {
                dataset.set(name, defs = []);
              }
              defs.push(stack.init);
              return stack;
            }
            if (this.attributes.has(name)) {
              stack.error(1045, name);
            } else {
              this.attributes.set(stack.value(), stack);
            }
          } else {
            dynamicProperties.push(stack);
          }
          return stack;
        });
        if (dynamicProperties.length > 0) {
          this.compilation.hookAsync("compilation.create.after", () => {
            dynamicProperties.forEach((item2) => {
              if (item2.acceptType) {
                this.dynamicProperties.set(item2.acceptType.type(), item2);
              } else {
                this.dynamicProperties.set(item2.key.type(), item2);
              }
            });
          });
        }
        this[keySymbol] = {};
      }
      freeze() {
        super.freeze();
        super.freeze(this.attributes);
        this.properties.forEach((stack) => stack.freeze());
      }
      attribute(name) {
        return this.attributes.get(name) || null;
      }
      hasAttribute(name, type2) {
        return this.attributes.has(name);
      }
      dynamicAttribute(propertyType, context = null) {
        const properties = this.dynamicProperties;
        if (properties) {
          for (let [key, value2] of properties) {
            if (key.check(propertyType, context)) {
              return value2;
            }
          }
        }
        return null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      definition(ctx) {
        if (this.parentStack.isTypeStatement || this.parentStack.isDeclaratorTypeAlias) {
          return this.parentStack.definition(ctx);
        }
        ctx = ctx || this.getContext();
        const type2 = this.type().toString(ctx);
        return {
          comments: this.comments,
          expre: `(type) ${type2}`,
          location: this.getLocation(),
          file: this.compilation.file
        };
      }
      description() {
        return this;
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          return new LiteralObjectType(Namespace.globals.get("object"), this);
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.properties.forEach((item2) => {
          item2.parser();
        });
      }
      value() {
        return super.raw();
      }
    };
    module.exports = TypeObjectDefinition;
  }
});

// lib/stacks/TypeObjectPropertyDefinition.js
var require_TypeObjectPropertyDefinition = __commonJS({
  "lib/stacks/TypeObjectPropertyDefinition.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var AliasType = require_AliasType();
    var TypeObjectPropertyDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeObjectPropertyDefinition = true;
        this.key = this.createTokenStack(compilation, node2.key, scope, node2, this);
        this.key.acceptType = this.createTokenStack(compilation, node2.key.acceptType, scope, node2, this);
        this.dynamic = !!node2.key.computed;
        this.computed = !!node2.key.computed;
        this.hasInit = !!node2.value;
        this.init = this.createTokenStack(compilation, node2.value || node2.key, scope, node2, this);
        this.question = !!node2.key.question;
        this.isProperty = true;
      }
      freeze() {
        super.freeze();
        this.key.freeze();
        this.init.freeze();
      }
      get acceptType() {
        const acceptType = this.key.acceptType ? this.key.acceptType.type() : Namespace.globals.get("string");
        return acceptType;
      }
      definition(ctx) {
        const question = this.question ? "?" : "";
        let key = this.key.value();
        if (this.dynamic) {
          key = `[${key}:${this.acceptType.toString(ctx)}]`;
        }
        ctx = ctx || this.getContext();
        return {
          comments: this.parentStack.comments,
          expre: `(property) ${key}${question}:${this.type().toString(ctx)}`,
          location: this.key.getLocation(),
          file: this.compilation.file
        };
      }
      value() {
        return this.key.value();
      }
      description() {
        return this;
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          if (this.parentStack.parentStack.isTypeStatement && this.init && this.init.isTypeDefinition && this.init.argument) {
            if (this.parentStack.parentStack === this.init.argument.description()) {
              return new AliasType(this.parentStack.parentStack.type(), this.parentStack.parentStack);
            }
          }
          if (this.init) {
            return this.init.type();
          }
          return Namespace.globals.get("any");
        });
      }
      assignment(value2, stack = null, ctx = null) {
        if (this.init) {
          this.checkExpressionType(this.init.type(), value2, stack, ctx);
        }
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.dynamic) {
          if (this.key.acceptType) {
            this.key.acceptType.parser();
          } else {
            this.key.parser();
            this.key.setRefBeUsed();
          }
        }
        if (this.hasInit) {
          if (this.parentStack.parentStack.isTypeStatement && this.init.isTypeDefinition && this.init.argument) {
            if (this.parentStack.parentStack === this.init.argument.description()) {
              return true;
            }
          }
          this.init.parser();
        } else {
        }
      }
      error(code, ...args) {
        this.key.error(code, ...args);
      }
      warn(code, ...args) {
        this.key.warn(code, ...args);
      }
    };
    module.exports = TypeObjectPropertyDefinition;
  }
});

// lib/types/PredicateType.js
var require_PredicateType = __commonJS({
  "lib/types/PredicateType.js"(exports, module) {
    var Type = require_Type();
    var PredicateType = class extends Type {
      constructor(inherit, value2, argument) {
        super("$PredicateType", inherit);
        this.isPredicateType = true;
        this.value = value2;
        this.argument = argument;
      }
      inferType() {
        return this.value.type();
      }
      is(type2, context, options = {}) {
        return this.inherit.is(type2, context, options);
      }
      toString(ctx, options = {}) {
        const parent = options.chain && options.chain[options.chain.length - 1];
        ctx = this.pushToStringChain(ctx, options);
        if (parent && (parent === "function" || parent.isFunctionType)) {
          const argument = this.argument.raw();
          const value2 = this.inferType().toString(ctx, options);
          return `${argument} is ${value2}`;
        } else {
          return this.inherit.toString(ctx, options);
        }
      }
    };
    module.exports = PredicateType;
  }
});

// lib/stacks/TypePredicateDefinition.js
var require_TypePredicateDefinition = __commonJS({
  "lib/stacks/TypePredicateDefinition.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var PredicateType = require_PredicateType();
    var TypePredicateDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypePredicateDefinition = true;
        this.argument = this.createTokenStack(compilation, node2.argument, scope, node2, this);
        this.value = this.createTokenStack(compilation, node2.value, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
        this.value.freeze();
      }
      definition(ctx) {
        const type2 = this.type();
        ctx = ctx || this.getContext();
        return {
          comments: this.comments,
          expre: `(type) ${type2.toString(ctx)}`,
          location: this.getLocation(),
          file: this.compilation.file
        };
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type() {
        return this.getAttribute("type", () => {
          return new PredicateType(Namespace.globals.get("boolean"), this.value, this.argument);
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.value.parser();
        let desc = null;
        let pp = this.parentStack;
        if (this.argument.isIdentifier && (pp.isFunctionExpression || pp.isTypeFunctionDefinition || pp.isDeclaratorFunction)) {
          let key = this.argument.value();
          pp.params.find((stack) => {
            if (stack.isDeclarator) {
              if (stack.value() === key) {
                desc = stack;
                return true;
              }
            } else if (stack.isObjectPattern) {
              return stack.properties.some((item2) => {
                if (item2.isProperty) {
                  if (item2.init.value() === key) {
                    desc = item2.init;
                    return true;
                  }
                }
              });
            } else if (stack.isArrayPattern) {
              return stack.elements.some((item2) => {
                if (stack.value() === key) {
                  desc = item2;
                  return true;
                }
              });
            }
          });
        } else {
          desc = this.argument.description();
        }
        if (!desc) {
          this.argument.error(1013, this.argument.value());
        } else {
          if (!desc.isParamDeclarator) {
            this.argument.error(1196, this.argument.value());
          }
          this.argument.setRefBeUsed(desc);
        }
      }
      value() {
        return this.expression.value();
      }
      raw() {
        return this.expression.raw();
      }
    };
    module.exports = TypePredicateDefinition;
  }
});

// lib/stacks/TypeStatement.js
var require_TypeStatement = __commonJS({
  "lib/stacks/TypeStatement.js"(exports, module) {
    var Stack = require_Stack();
    var TypeStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeStatement = true;
        this.id = this.createTokenStack(compilation, node2.id, scope, node2, this);
        this.init = this.createTokenStack(compilation, node2.init, scope, node2, this);
        if (this.scope.declarations.has(this.id.value())) {
          this.id.error(1078, this.id.value());
        } else {
          this.scope.define(this.id.value(), this);
        }
      }
      freeze() {
        super.freeze();
        this.id.freeze();
        this.init.freeze();
      }
      type() {
        return this.init.type();
      }
      definition(ctx) {
        ctx = ctx || this.getContext();
        let type2 = this.init.type();
        let typeStr = type2.toString(ctx);
        const identifier = this.id.value();
        const expre = `(type) ${identifier} = ${typeStr}`;
        return {
          comments: this.comments,
          expre,
          location: this.id.getLocation(),
          file: this.compilation.file
        };
      }
      parser() {
        return this.init.parser();
      }
      value() {
        return this.id.value();
      }
      raw() {
        return this.id.raw();
      }
    };
    module.exports = TypeStatement;
  }
});

// lib/stacks/TypeTransformExpression.js
var require_TypeTransformExpression = __commonJS({
  "lib/stacks/TypeTransformExpression.js"(exports, module) {
    var Expression = require_Expression();
    var TypeTransformExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeTransformExpression = true;
        this.argument = this.createTokenStack(compilation, node2.argument, scope, node2, this);
        this.expression = this.createTokenStack(compilation, node2.expression, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
        this.expression.freeze();
      }
      definition(ctx) {
        return this.expression.definition(ctx);
      }
      description() {
        return this.expression.description();
      }
      reference() {
        return this.expression.reference();
      }
      referenceItems() {
        return this.expression.referenceItems();
      }
      type() {
        return this.argument.type();
      }
      isLiteralType(type2) {
        if (!type2)
          return false;
        if (type2.isLiteralType)
          return true;
        if (!type2.isAliasType)
          return false;
        const val = type2.toString();
        if (val === "string" || val === "boolean" || val === "regexp" || val === "uint" || val === "int" || val === "float" || val === "number")
          return true;
        return false;
      }
      getContext(ctx) {
        return this.expression.getContext(ctx);
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.argument.parser();
        this.expression.parser();
        this.expression.setRefBeUsed();
      }
    };
    module.exports = TypeTransformExpression;
  }
});

// lib/stacks/TypeTupleDefinition.js
var require_TypeTupleDefinition = __commonJS({
  "lib/stacks/TypeTupleDefinition.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var LiteralArrayType = require_LiteralArrayType();
    var TupleType = require_TupleType();
    var TypeTupleDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeTupleDefinition = true;
        this.prefix = this.createTokenStack(compilation, node2.prefix, scope, node2, this);
        this.elements = (node2.elements || []).map((item2) => {
          const stack = this.createTokenStack(compilation, item2, scope, node2, this);
          return stack;
        });
      }
      freeze() {
        super.freeze();
        super.freeze(this.elements);
        this.prefix && this.prefix.freeze();
        this.elements.forEach((stack) => stack.freeze());
      }
      definition(ctx) {
        if (this.parentStack.isTypeStatement || this.parentStack.isDeclaratorTypeAlias) {
          return this.parentStack.definition(ctx);
        }
        const type2 = this.type();
        ctx = ctx || this.getContext();
        return {
          comments: this.comments,
          expre: `(type) ${type2.toString(ctx)}`,
          location: (this.prefix || this).getLocation(),
          file: this.compilation.file
        };
      }
      description() {
        return this;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          const elem = this.prefix ? [this.prefix] : this.elements;
          if (elem.length > 0) {
            return new TupleType(
              Namespace.globals.get("Array"),
              elem,
              this
            );
          } else {
            return new LiteralArrayType(Namespace.globals.get("Array"), this, []);
          }
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.prefix && this.elements.length > 0) {
          this.error(1086, this.prefix.raw());
        }
        this.prefix && this.prefix.parser();
        this.elements.forEach((item2) => item2.parser());
        const restElement = this.elements.find((item2) => item2.restElement);
        if (restElement && restElement !== this.elements[this.elements.length - 1]) {
          this.error(1077);
        }
      }
    };
    module.exports = TypeTupleDefinition;
  }
});

// lib/stacks/TypeTupleElementDefinition.js
var require_TypeTupleElementDefinition = __commonJS({
  "lib/stacks/TypeTupleElementDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var TypeTupleElementDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeTupleElementDefinition = true;
        this.key = this.createTokenStack(compilation, node2.key, scope, node2, this);
        this.init = this.createTokenStack(compilation, node2.init, scope, node2, this);
      }
      freeze() {
        super.freeze();
        super.freeze(this.key);
        super.freeze(this.init);
      }
      definition(ctx) {
        return null;
      }
      description() {
        return this;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      type() {
        return this.init.type();
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.init.parser();
      }
    };
    module.exports = TypeTupleElementDefinition;
  }
});

// lib/stacks/TypeTupleRestDefinition.js
var require_TypeTupleRestDefinition = __commonJS({
  "lib/stacks/TypeTupleRestDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var TupleType = require_TupleType();
    var TypeTupleRestDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeTupleRestDefinition = true;
        this.argument = this.createTokenStack(compilation, node2.value, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
      }
      definition(ctx) {
        const type2 = this.type();
        ctx = ctx || this.getContext();
        if (type2.isModule) {
          return type2.definition(ctx);
        }
        return {
          comments: this.comments,
          expre: `(type) ${type2.toString(ctx)}`,
          location: this.argument.getLocation(),
          file: this.compilation.file
        };
      }
      error(code, ...args) {
        this.argument.error(code, ...args);
      }
      warn(code, ...args) {
        this.argument.warn(code, ...args);
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          return new TupleType(this.getGlobalTypeById("array"), this.argument.type(), this, true);
        });
      }
      parser() {
        return this.argument.parser();
      }
      value() {
        return this.argument.value();
      }
      raw() {
        return `...` + this.argument.raw();
      }
    };
    module.exports = TypeTupleRestDefinition;
  }
});

// lib/stacks/TypeTupleUnionDefinition.js
var require_TypeTupleUnionDefinition = __commonJS({
  "lib/stacks/TypeTupleUnionDefinition.js"(exports, module) {
    var TypeTupleDefinition = require_TypeTupleDefinition();
    var TypeTupleUnionDefinition = class extends TypeTupleDefinition {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeTupleUnionDefinition = true;
      }
      value() {
        return this.raw();
      }
      raw() {
        const elems = this.elements.map((item2) => item2.raw());
        return `(${elems.join(" | ")})[]`;
      }
    };
    module.exports = TypeTupleUnionDefinition;
  }
});

// lib/types/TypeofType.js
var require_TypeofType = __commonJS({
  "lib/types/TypeofType.js"(exports, module) {
    var Type = require_Type();
    var TypeofType = class extends Type {
      constructor(origin, displayName = null) {
        super("$TypeofType");
        this.isTypeofType = true;
        if (origin.isTypeofType) {
          origin = origin.origin;
        }
        this.origin = origin;
        this.displayName = displayName;
      }
      get hasGenericType() {
        return this.origin.hasGenericType;
      }
      definition(ctx) {
        return {
          expre: `typeof ${this.displayName || this.origin.toString(ctx)}`
        };
      }
      get attributes() {
        return this.origin.properties;
      }
      attribute(property) {
        return this.origin.attribute(property);
      }
      dynamicAttribute(propertyType, context = null) {
        return this.origin.dynamicAttribute(propertyType, context);
      }
      checkDynamicProperties(type2, context, options = {}, errorHandler = null) {
        return this.origin.checkDynamicProperties(type2, context, options = {}, errorHandler);
      }
      clone(inference) {
        return this.origin.clone(inference);
      }
      constraint(stack, context, options = {}) {
        return this.origin.constraint(stack, context, options);
      }
      check(stack, context, options = {}) {
        return this.origin.check(stack, context, options);
      }
      is(type2, context, options = {}) {
        if (type2 && type2.isTypeofType)
          type2 = type2.origin;
        return this.origin.is(type2, context, options);
      }
      toString(ctx, options = {}) {
        ctx = this.pushToStringChain(ctx, options);
        if (options.onlyTypeName && this.displayName) {
          return `typeof ${this.displayName}`;
        }
        return this.origin.toString(ctx, options);
      }
    };
    module.exports = TypeofType;
  }
});

// lib/stacks/TypeTypeofDefinition.js
var require_TypeTypeofDefinition = __commonJS({
  "lib/stacks/TypeTypeofDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var TypeofType = require_TypeofType();
    var TypeTypeofDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeTypeofDefinition = true;
        this.expression = this.createTokenStack(compilation, node2.value, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.expression.freeze();
      }
      definition(ctx) {
        if (this.parentStack.isTypeStatement || this.parentStack.isDeclaratorTypeAlias) {
          return this.parentStack.definition(ctx);
        }
        ctx = ctx || this.getContext();
        if (ctx.stack === this.expression) {
          const desc = this.expression.description();
          if (desc) {
            return desc.definition(ctx);
          }
        }
        const type2 = this.type();
        ctx = ctx || this.getContext();
        let def = {
          comments: this.comments,
          expre: `(type) ${type2.toString(ctx)}`
        };
        return def;
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type() {
        return this.getAttribute("type", () => {
          let type2 = this.expression.type();
          if (this.expression.isIdentifier || this.expression.isMemberExpression) {
            return new TypeofType(type2, this.expression.value());
          }
          return new TypeofType(type2);
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.expression.parser();
        const desc = this.expression.description();
        if (!desc || (desc.isTypeDefinition || desc.isGenericTypeDeclaration || desc.isTypeStatement)) {
          this.expression.error(1083, this.expression.value());
        } else {
          this.expression.setRefBeUsed(desc);
        }
      }
      value() {
        return this.expression.value();
      }
      raw() {
        return this.expression.raw();
      }
    };
    module.exports = TypeTypeofDefinition;
  }
});

// lib/stacks/TypeUnionDefinition.js
var require_TypeUnionDefinition = __commonJS({
  "lib/stacks/TypeUnionDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var UnionType = require_UnionType();
    var TypeUnionDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeUnionDefinition = true;
        this.elements = node2.elements.map((item2) => {
          const stack = this.createTokenStack(compilation, item2, scope, node2, this);
          return stack;
        });
      }
      freeze() {
        super.freeze();
        super.freeze(this.elements);
        this.elements.forEach((stack) => stack.freeze());
      }
      definition(ctx) {
        if (this.parentStack.isTypeStatement || this.parentStack.isDeclaratorTypeAlias) {
          return this.parentStack.definition(ctx);
        }
        const type2 = this.type();
        ctx = ctx || this.getContext();
        return {
          comments: this.comments,
          expre: `(type) ${type2.toString(ctx)}`,
          location: this.getLocation(),
          file: this.compilation.file
        };
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          if (this.elements.length > 1) {
            if (this.elements.some((stack) => stack.isTypeDefinition && stack.argument.isIdentifier && stack.argument.value() === "any")) {
              return this.getGlobalTypeById("any");
            } else {
              return new UnionType(this.elements, this);
            }
          } else {
            return this.elements[0].type();
          }
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.elements.forEach((item2) => item2.parser());
      }
      value() {
        const elements = this.elements.map((item2) => {
          return item2.value();
        });
        return `${elements.join("|")}`;
      }
      raw() {
        return this.value();
      }
    };
    module.exports = TypeUnionDefinition;
  }
});

// lib/types/UniqueType.js
var require_UniqueType = __commonJS({
  "lib/types/UniqueType.js"(exports, module) {
    var Type = require_Type();
    var UniqueType = class extends Type {
      constructor(origin) {
        super("$UniqueType");
        this.isUniqueType = true;
        if (origin.isUniqueType) {
          origin = origin.origin;
        }
        this.origin = origin;
      }
      is(type2, context, options = {}) {
        return type2 === this;
      }
      toString(ctx, ...args) {
        if (ctx) {
          return `unique ${this.origin.toString(ctx, ...args)}`;
        }
        return this.origin.toString(ctx, ...args);
      }
    };
    module.exports = UniqueType;
  }
});

// lib/stacks/TypeUniqueDefinition.js
var require_TypeUniqueDefinition = __commonJS({
  "lib/stacks/TypeUniqueDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var UniqueType = require_UniqueType();
    var TypeUniqueDefinition = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isTypeUniqueDefinition = true;
        this.expression = this.createTokenStack(compilation, node2.value, scope, node2, this);
      }
      freeze() {
        super.freeze();
        this.expression.freeze();
      }
      definition(ctx) {
        ctx = ctx || this.getContext();
        if (ctx.stack === this.expression) {
          const desc = this.expression.description();
          if (desc) {
            return desc.definition(ctx);
          }
        }
        const type2 = this.type();
        return {
          comments: this.comments,
          expre: `(type) ${type2.toString(ctx)}`
        };
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type() {
        return this.getAttribute("type", () => {
          let type2 = this.expression.type();
          return new UniqueType(type2);
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.expression.parser();
      }
      value() {
        return this.expression.value();
      }
      raw() {
        return this.expression.raw();
      }
    };
    module.exports = TypeUniqueDefinition;
  }
});

// lib/stacks/UnaryExpression.js
var require_UnaryExpression = __commonJS({
  "lib/stacks/UnaryExpression.js"(exports, module) {
    var Namespace = require_Namespace();
    var Expression = require_Expression();
    var UnaryExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isUnaryExpression = true;
        this.argument = this.createTokenStack(compilation, node2.argument, scope, node2, this);
        this.operator = node2.operator;
        this.prefix = node2.prefix;
        this.isLogicalTrueFlag = false;
        this.isLogicalFlag = false;
        if (this.operator && this.operator.charCodeAt(0) === 33) {
          this.isLogicalFlag = true;
          this.isLogicalTrueFlag = this.operator.length % 2 === 0;
        }
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
      }
      definition() {
        return this.argument.definition();
      }
      description() {
        return this.argument.description();
      }
      reference() {
        return this.argument.reference();
      }
      referenceItems() {
        return this.argument.referenceItems();
      }
      getContext() {
        return this.argument.getContext();
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.argument.parser();
        this.argument.setRefBeUsed();
        const operator = this.node.operator;
        const code = operator.charCodeAt(0);
        if (code === 45 || code === 43) {
          const numberType = Namespace.globals.get("Number");
          const type2 = this.argument.type();
          if (type2 && !type2.isAnyType && !numberType.is(type2)) {
            this.error(1087, this.argument.raw());
          }
          return type2;
        }
      }
      value() {
        return super.raw();
      }
      type() {
        const operator = this.operator;
        const code = operator.charCodeAt(0);
        if (code === 33) {
          return Namespace.globals.get("boolean");
        }
        if (code === 45 || code === 43) {
          const numberType = Namespace.globals.get("Number");
          const type2 = this.argument.type();
          if (type2.isAnyType || !numberType.is(type2)) {
            return Namespace.globals.get("int");
          }
          return type2;
        }
        if (operator === "typeof") {
          return Namespace.globals.get("string");
        } else if (operator === "void") {
          return Namespace.globals.get("void");
        }
        return this.argument.type();
      }
    };
    module.exports = UnaryExpression;
  }
});

// lib/stacks/UpdateExpression.js
var require_UpdateExpression = __commonJS({
  "lib/stacks/UpdateExpression.js"(exports, module) {
    var Namespace = require_Namespace();
    var Expression = require_Expression();
    var UpdateExpression = class extends Expression {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isUpdateExpression = true;
        this.argument = this.createTokenStack(compilation, node2.argument, scope, node2, this);
        this.operator = node2.operator;
        this.prefix = node2.prefix;
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
      }
      definition() {
        return null;
      }
      description() {
        return this;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.argument.parser();
        this.argument.setRefBeUsed();
        const type2 = this.argument.type();
        const numberType = Namespace.globals.get("Number");
        if (type2 && !type2.isAnyType && !numberType.is(type2)) {
          this.error(1087, this.argument.raw());
        }
      }
      type(ctx) {
        const numberType = Namespace.globals.get("Number");
        const type2 = this.argument.type(ctx);
        if (type2.isAnyType || !numberType.is(type2)) {
          return Namespace.globals.get("int");
        }
        return this.argument.type(ctx);
      }
    };
    module.exports = UpdateExpression;
  }
});

// lib/stacks/UseExtendSpecifier.js
var require_UseExtendSpecifier = __commonJS({
  "lib/stacks/UseExtendSpecifier.js"(exports, module) {
    var Namespace = require_Namespace();
    var Stack = require_Stack();
    var UseExtendSpecifier = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isUseExtendSpecifier = true;
        this.id = this.createTokenStack(compilation, node2.id, scope, node2, this);
        this.modifier = node2.modifier.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
        this.genericity = null;
        if (node2.genericity) {
          this.genericity = node2.genericity.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
        }
        const id = this.id.value();
        if (id && !this.scope.isDefine(id) && !this.hasModuleById(id)) {
          if (this.compilation.hasManifestResource(id, Namespace.dataset)) {
            this.compilation.hookAsync("compilation.create.after", async () => {
              await this.loadTypeAsync(id);
            });
          }
        }
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.id);
        (this.genericity || []).forEach((stack) => stack.freeze());
        this.modifier.forEach((stack) => stack.freeze());
      }
      definition(context) {
        return null;
      }
      description() {
        const id = this.id.value();
        return this.scope.define(id) || this.getModuleById(id);
      }
      type() {
        const desc = this.description();
        return desc ? desc.type() : Namespace.globals.get("any");
      }
      value() {
        return this.id.value();
      }
      parser() {
        if (super.parser() === false)
          return false;
        const desc = this.description();
        const type2 = desc ? desc.type() : null;
        if (type2 && type2.isModule) {
          this.id.setRefBeUsed(desc);
          this.parserDescriptor(type2);
          const assignments = this.genericity;
          if (assignments && assignments.length > 0) {
            this.parentStack.parentStack.genericsCheck(type2, assignments, this.id);
            this.module.setAssignGenerics(type2, assignments);
          }
        } else {
          this.error(1026, this.id.value());
        }
      }
    };
    module.exports = UseExtendSpecifier;
  }
});

// lib/stacks/UseExtendStatement.js
var require_UseExtendStatement = __commonJS({
  "lib/stacks/UseExtendStatement.js"(exports, module) {
    var Stack = require_Stack();
    var UseExtendStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isUseExtendStatement = true;
        this.isUseStatement = true;
        this.body = node2.body.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
        this.keywords = node2.keywords.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
        this.extends = node2.extends.map((item2) => this.createTokenStack(compilation, item2, scope, node2, this));
      }
      freeze() {
        super.freeze(this);
        this.body.forEach((stack) => stack.freeze());
        this.keywords.forEach((stack) => stack.freeze());
        this.extends.forEach((stack) => stack.freeze());
      }
      definition(context) {
        return null;
      }
      description() {
        return null;
      }
      async createCompleted() {
        const methods = {};
        const dynamic = [];
        const methodItems = [];
        await Promise.allSettled(this.extends.map((stack) => this.loadTypeAsync(stack.id.value())));
        this.body.forEach((item2) => {
          if (item2.isMethodDefinition) {
            if (item2.dynamicType) {
              dynamic.push(item2);
            } else {
              methods[item2.key.value()] = item2;
            }
          } else if (item2.isPropertyDefinition) {
            if (item2.dynamic) {
              dynamic.push(item2);
            } else {
              methods[item2.key.value()] = item2;
            }
          }
          methodItems.push(item2);
        });
        const _extends = [];
        this.extends.forEach((item2) => {
          const modifier = item2.modifier.map((item3) => item3.value().toLowerCase());
          _extends.push({
            module: item2.type(),
            mode: modifier.find((item3) => item3 === "prototype" || item3 === "class"),
            modifier: modifier.filter((item3) => !(item3 === "prototype" || item3 === "class"))
          });
        });
        this.keywords.forEach((item2) => {
          const isStatic = item2.value().toLowerCase() === "static";
          const target = isStatic ? this.module.callMethods : this.module.callMembers;
          if (isStatic) {
            methodItems.forEach((item3) => {
              item3.callableStatic = true;
            });
          }
          target.push({
            isUseExtendStatement: true,
            extends: _extends,
            callableStatic: isStatic,
            dynamic,
            methods
          });
        });
        methodItems.forEach((item2) => {
          this.module.addDescriptor(item2.value(), item2);
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.extends.forEach((item2) => {
          item2.parser();
        });
        this.body.forEach((item2) => {
          item2.parser();
        });
      }
      value() {
        return this.classType.value();
      }
    };
    module.exports = UseExtendStatement;
  }
});

// lib/stacks/VariableDeclaration.js
var require_VariableDeclaration = __commonJS({
  "lib/stacks/VariableDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var VariableDeclaration = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isVariableDeclaration = true;
        this.kind = node2.kind;
        this.declarations = node2.declarations.map((item2) => {
          return this.createTokenStack(compilation, item2, scope, node2, this);
        });
        this.flag = false;
        switch (parentNode && parentNode.type) {
          case "ForStatement":
          case "ForInStatement":
          case "ForOfStatement":
            this.flag = true;
            break;
        }
        if (!(this.parentStack.isExportNamedDeclaration || this.parentStack.isExportDefaultDeclaration)) {
          this.compilation.hookAsync("compilation.parser.after", async () => {
            this.declarations.forEach((decl2) => {
              if (decl2.id.isObjectPattern) {
                decl2.id.properties.forEach((decl3) => {
                  if (!decl3.init.useRefItems.size) {
                    decl3.init.unnecessary(1183, decl3.init.value());
                  }
                });
              } else if (decl2.id.isArrayPattern) {
                decl2.id.elements.forEach((decl3) => {
                  if (!decl3.useRefItems.size) {
                    decl3.unnecessary(1183, decl3.value());
                  }
                });
              } else if (!decl2.useRefItems.size) {
                decl2.id.unnecessary(1183, decl2.value());
              }
            });
          });
        }
      }
      freeze() {
        super.freeze();
        super.freeze(this.declarations);
        this.declarations.forEach((stack) => stack.freeze());
      }
      definition() {
        return null;
      }
      reference() {
        return this.declarations[0].reference();
      }
      referenceItems() {
        return this.declarations[0].referenceItems();
      }
      value() {
        return this.declarations[0].value();
      }
      raw() {
        return this.declarations[0].raw();
      }
      warn(code, ...args) {
        this.declarations[0].warn(code, ...args);
      }
      error(code, ...args) {
        this.declarations[0].error(code, ...args);
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.declarations.forEach((item2) => item2.parser());
      }
    };
    module.exports = VariableDeclaration;
  }
});

// lib/stacks/VariableDeclarator.js
var require_VariableDeclarator = __commonJS({
  "lib/stacks/VariableDeclarator.js"(exports, module) {
    var { isInfer } = require_Inference();
    var JSModule = require_JSModule();
    var Namespace = require_Namespace();
    var Utils = require_Utils();
    var Declarator = require_Declarator();
    var VariableDeclarator = class extends Declarator {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isVariableDeclarator = true;
        this.kind = parentNode.kind;
        this.id = this.createTokenStack(compilation, node2.id, scope, node2, this);
        const init = this.createTokenStack(compilation, node2.init, scope, node2, this);
        this.dynamic = !!node2.dynamic;
        this.computed = !!node2.dynamic;
        this.init = init;
        this._acceptType = this.createTokenStack(compilation, node2.acceptType, scope, node2, this);
        if (this.dynamic && this.parentStack.isPropertyDefinition) {
          this.dynamicKeyType = this.createTokenStack(compilation, node2.id.acceptType, scope, node2, this);
        }
        this.question = !!node2.question;
        this.isPattern = false;
        if (parentStack && !parentStack.isDeclaratorProperty && !parentStack.parentStack.isExportNamedDeclaration) {
          if (this.id.isIdentifier) {
            if (this.init) {
              this.assignItems.add(this.init);
              this.assignValue = this.init;
              this.assignFirstValue = this.init;
            }
            if (!parentStack.isDeclaratorVariable && !parentStack.isPropertyDefinition) {
              const context = this.kind === "var" ? "function" : "block";
              const name = this.id.value();
              if (scope.isDefine(name, context)) {
                this.error(1007, this.value());
              }
              scope.define(name, this);
            }
          } else if (this.id.isObjectPattern || this.id.isArrayPattern) {
            this.isPattern = true;
            this.id.setKind(this.kind);
          }
        }
      }
      freeze() {
        super.freeze();
        this.id.freeze();
        this.acceptType && this.acceptType.freeze();
        this.init && this.init.freeze();
      }
      type() {
        const type2 = super.type();
        if (this.parentStack.flag && type2 === Namespace.globals.get("any")) {
          if (this.parentStack.parentStack.isForInStatement) {
            return Namespace.globals.get("string");
          } else if (this.parentStack.parentStack.isForOfStatement) {
            return this.parentStack.parentStack.forOfType();
          }
        }
        return type2;
      }
      definition(ctx) {
        if (!isInfer(ctx)) {
          ctx = this.getContext();
        }
        let _type = this.type();
        const isProperty = !!this.parentStack.isPropertyDefinition;
        if (!isProperty && this.is(ctx.stack)) {
          const scope = ctx.stack.scope;
          if (scope.allowInsertionPredicate()) {
            const predicate = scope.getPredicate(this);
            if (predicate && predicate.type) {
              _type = predicate.type;
            }
          }
        }
        if (!_type)
          return;
        const type2 = _type.toString(ctx);
        const identifier = this.id.value();
        var token = isProperty ? `${this.module.id}.${identifier}` : identifier;
        if (this.dynamic && this.parentStack.isPropertyDefinition) {
          if (this.init && this.init.isTypeDefinition) {
            token = `${this.module.id}[${identifier}:${this.acceptType.type().toString(ctx)}]`;
          } else {
            token = `${this.module.id}[${identifier}]`;
          }
        }
        const expre = isProperty ? `${this.kind || ""} ${token}:${type2}` : `(local ${this.kind}) ${token}:${type2}`;
        return {
          comments: this.parentStack.comments,
          expre,
          location: this.id.getLocation(),
          file: this.compilation.file
        };
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.init) {
          this.init.parser();
          if (!(this.init.isNewExpression || this.init.isCallExpression)) {
            this.init.setRefBeUsed();
          }
        }
        if (this.id.isObjectPattern || this.id.isArrayPattern) {
          this.id.parser();
        }
        if (!this.dynamic) {
          if (this.module && !this.parentStack.isPropertyDefinition && this.module.id === this.value() && !JSModule.is(this.module)) {
            this.id.error(1008, this.id.value());
          }
          if (this.init) {
            if (!(this.init.isLiteral && this.init.value() === null)) {
              const acceptType = this.acceptType;
              if (acceptType) {
                const atype = acceptType.type();
                if (atype) {
                  let isEmptyObject = false;
                  if (this.init.isObjectExpression) {
                    isEmptyObject = this.init.properties.length === 0 && Utils.isLiteralObjectType(atype);
                  } else if (this.init.isArrayExpression) {
                    isEmptyObject = this.init.elements.length === 0 && Utils.isLiteralArrayType(atype);
                  }
                  if (!isEmptyObject) {
                    this.checkExpressionType(acceptType, this.init, null, this.getContext());
                  }
                }
              }
              const description = this.init.description();
              if (this === description) {
                this.error(1010, this.init.value());
              }
            }
          }
        } else if (!this.parentStack.isPropertyDefinition) {
          this.id.parser();
        }
      }
      value() {
        return this.id.value();
      }
      raw() {
        return this.id.raw();
      }
      error(code, ...args) {
        this.id.error(code, ...args);
      }
      warn(code, ...args) {
        this.id.warn(code, ...args);
      }
    };
    module.exports = VariableDeclarator;
  }
});

// lib/stacks/WhenStatement.js
var require_WhenStatement = __commonJS({
  "lib/stacks/WhenStatement.js"(exports, module) {
    var Stack = require_Stack();
    var BlockScope = require_BlockScope();
    var WhenStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        super(compilation, node2, scope, parentNode, parentStack);
        this.isWhenStatement = true;
        this.condition = this.createTokenStack(compilation, node2.test, scope, node2, this);
        this.consequent = this.createTokenStack(compilation, node2.consequent, new BlockScope(scope), node2, this);
        this.alternate = this.createTokenStack(compilation, node2.alternate, new BlockScope(scope), node2, this);
      }
      freeze() {
        super.freeze();
        this.condition.freeze();
        this.consequent.freeze();
        this.alternate.freeze();
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.consequent.parser();
        this.consequent.setRefBeUsed();
        this.alternate && this.alternate.parser();
        if (this.condition && this.condition.isCallExpression) {
          const name = this.condition.callee.value();
          const methods = this.compiler.options.metaStatementMethods || [];
          if (methods.length > 0 && !methods.includes(name)) {
            this.condition.error(1165, name, methods.join(","));
          }
        } else {
        }
      }
    };
    module.exports = WhenStatement;
  }
});

// lib/stacks/WhileStatement.js
var require_WhileStatement = __commonJS({
  "lib/stacks/WhileStatement.js"(exports, module) {
    var Stack = require_Stack();
    var BlockScope = require_BlockScope();
    var WhileStatement = class extends Stack {
      constructor(compilation, node2, scope, parentNode, parentStack) {
        scope = new BlockScope(scope);
        super(compilation, node2, scope, parentNode, parentStack);
        this.isWhileStatement = true;
        this.condition = this.createTokenStack(compilation, node2.test, scope, node2, this);
        this.body = this.createTokenStack(compilation, node2.body, scope, node2, this);
      }
      definition() {
        return null;
      }
      freeze() {
        super.freeze();
        this.condition.freeze();
        this.body.freeze();
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.condition) {
          this.parseConditionState(this.condition);
          this.condition.parser();
          this.condition.setRefBeUsed();
          const desc = this.condition.description();
          if (this.is(desc) && desc.isLiteral && desc.value()) {
            const find = (body) => {
              if (!body)
                return false;
              return body.some((item2) => {
                if (item2.isReturnStatement || item2.isBreakStatement) {
                  return true;
                }
                if (item2.isIfStatement || item2.isWhenStatement) {
                  if (item2.consequent)
                    return find(item2.consequent.body);
                  if (item2.alternate)
                    return find(item2.alternate.body);
                } else if (item2.isSwitchStatement) {
                  return find(item2.cases);
                } else if (item2.isSwitchCase) {
                  return find(item2.consequent);
                } else if (item2.isWhileStatement) {
                  return find(item2.body.body);
                } else if (item2.isForInStatement || item2.isForOfStatement || item2.isForStatement) {
                  return find(item2.body.body);
                }
                return false;
              });
            };
            if (!find(this.body.body)) {
              this.condition.warn(1042);
            }
          }
        } else {
          return this.error(1041);
        }
        this.body && this.body.parser();
      }
    };
    module.exports = WhileStatement;
  }
});

// lib/tokens.js
var require_tokens = __commonJS({
  "lib/tokens.js"(exports, module) {
    var tokens = {};
    var Stack = require_Stack();
    var create = function(compilation, node2, scope, parentNode, parentStack) {
      if (!node2) {
        return null;
      }
      switch (node2.type) {
        case "MethodDefinition":
          if (node2.kind === "get") {
            return new tokens.MethodGetterDefinition(compilation, node2, scope, parentNode, parentStack);
          } else if (node2.kind === "set") {
            return new tokens.MethodSetterDefinition(compilation, node2, scope, parentNode, parentStack);
          }
          return new tokens.MethodDefinition(compilation, node2, scope, parentNode, parentStack);
        case "Super":
          return new tokens.SuperExpression(compilation, node2, scope, parentNode, parentStack);
        default:
          const stackClass = tokens[node2.type];
          if (stackClass) {
            return new stackClass(compilation, node2, scope, parentNode, parentStack);
          } else {
            compilation.error(node2, 1189, node2.type);
          }
      }
    };
    tokens.AnnotationDeclaration = require_AnnotationDeclaration();
    tokens.AnnotationExpression = require_AnnotationExpression();
    tokens.ArrayExpression = require_ArrayExpression();
    tokens.ArrayPattern = require_ArrayPattern();
    tokens.ArrowFunctionExpression = require_ArrowFunctionExpression();
    tokens.AssignmentExpression = require_AssignmentExpression();
    tokens.AssignmentPattern = require_AssignmentPattern();
    tokens.AwaitExpression = require_AwaitExpression();
    tokens.BinaryExpression = require_BinaryExpression();
    tokens.BlockStatement = require_BlockStatement();
    tokens.BreakStatement = require_BreakStatement();
    tokens.CallDefinition = require_CallDefinition();
    tokens.CallExpression = require_CallExpression();
    tokens.ChainExpression = require_ChainExpression();
    tokens.ClassDeclaration = require_ClassDeclaration();
    tokens.ConditionalExpression = require_ConditionalExpression();
    tokens.ContinueStatement = require_ContinueStatement();
    tokens.Declarator = require_Declarator();
    tokens.DeclaratorDeclaration = require_DeclaratorDeclaration();
    tokens.DeclaratorFunction = require_DeclaratorFunction();
    tokens.DeclaratorTypeAlias = require_DeclaratorTypeAlias();
    tokens.DeclaratorVariable = require_DeclaratorVariable();
    tokens.DoWhileStatement = require_DoWhileStatement();
    tokens.EmptyStatement = require_EmptyStatement();
    tokens.EnumDeclaration = require_EnumDeclaration();
    tokens.EnumProperty = require_EnumProperty();
    tokens.ExportAllDeclaration = require_ExportAllDeclaration();
    tokens.ExportAssignmentDeclaration = require_ExportAssignmentDeclaration();
    tokens.ExportDefaultDeclaration = require_ExportDefaultDeclaration();
    tokens.ExportNamedDeclaration = require_ExportNamedDeclaration();
    tokens.ExportSpecifier = require_ExportSpecifier();
    tokens.Expression = require_Expression();
    tokens.ExpressionStatement = require_ExpressionStatement();
    tokens.ForInStatement = require_ForInStatement();
    tokens.ForOfStatement = require_ForOfStatement();
    tokens.ForStatement = require_ForStatement();
    tokens.FunctionDeclaration = require_FunctionDeclaration();
    tokens.FunctionExpression = require_FunctionExpression();
    tokens.GenericDeclaration = require_GenericDeclaration();
    tokens.GenericTypeAssignmentDeclaration = require_GenericTypeAssignmentDeclaration();
    tokens.GenericTypeDeclaration = require_GenericTypeDeclaration();
    tokens.Identifier = require_Identifier();
    tokens.IfStatement = require_IfStatement();
    tokens.ImportDeclaration = require_ImportDeclaration();
    tokens.ImportDefaultSpecifier = require_ImportDefaultSpecifier();
    tokens.ImportExpression = require_ImportExpression();
    tokens.ImportNamespaceSpecifier = require_ImportNamespaceSpecifier();
    tokens.ImportSpecifier = require_ImportSpecifier();
    tokens.InterfaceDeclaration = require_InterfaceDeclaration();
    tokens.JSXAttribute = require_JSXAttribute();
    tokens.JSXCdata = require_JSXCdata();
    tokens.JSXClosingElement = require_JSXClosingElement();
    tokens.JSXClosingFragment = require_JSXClosingFragment();
    tokens.JSXElement = require_JSXElement();
    tokens.JSXEmptyExpression = require_JSXEmptyExpression();
    tokens.JSXExpressionContainer = require_JSXExpressionContainer();
    tokens.JSXFragment = require_JSXFragment();
    tokens.JSXIdentifier = require_JSXIdentifier();
    tokens.JSXMemberExpression = require_JSXMemberExpression();
    tokens.JSXNamespacedName = require_JSXNamespacedName();
    tokens.JSXOpeningElement = require_JSXOpeningElement();
    tokens.JSXOpeningFragment = require_JSXOpeningFragment();
    tokens.JSXScript = require_JSXScript();
    tokens.JSXSpreadAttribute = require_JSXSpreadAttribute();
    tokens.JSXStyle = require_JSXStyle();
    tokens.JSXText = require_JSXText();
    tokens.LabeledStatement = require_LabeledStatement();
    tokens.Literal = require_Literal();
    tokens.LogicalConditionStatement = require_LogicalConditionStatement();
    tokens.LogicalExpression = require_LogicalExpression();
    tokens.MemberExpression = require_MemberExpression();
    tokens.MetatypeDeclaration = require_MetatypeDeclaration();
    tokens.MethodDefinition = require_MethodDefinition();
    tokens.MethodGetterDefinition = require_MethodGetterDefinition();
    tokens.MethodSetterDefinition = require_MethodSetterDefinition();
    tokens.ModifierDeclaration = require_ModifierDeclaration();
    tokens.ModuleDeclaration = require_ModuleDeclaration();
    tokens.NamespaceDeclaration = require_NamespaceDeclaration();
    tokens.NewDefinition = require_NewDefinition();
    tokens.NewExpression = require_NewExpression();
    tokens.ObjectExpression = require_ObjectExpression();
    tokens.ObjectPattern = require_ObjectPattern();
    tokens.PackageDeclaration = require_PackageDeclaration();
    tokens.ParenthesizedExpression = require_ParenthesizedExpression();
    tokens.Program = require_Program();
    tokens.Property = require_Property();
    tokens.PropertyDefinition = require_PropertyDefinition();
    tokens.RestElement = require_RestElement();
    tokens.ReturnStatement = require_ReturnStatement();
    tokens.SequenceExpression = require_SequenceExpression();
    tokens.SpreadElement = require_SpreadElement();
    tokens.StructTableColumnDefinition = require_StructTableColumnDefinition();
    tokens.StructTableDeclaration = require_StructTableDeclaration();
    tokens.StructTableKeyDefinition = require_StructTableKeyDefinition();
    tokens.StructTableMethodDefinition = require_StructTableMethodDefinition();
    tokens.StructTablePropertyDefinition = require_StructTablePropertyDefinition();
    tokens.SuperExpression = require_SuperExpression();
    tokens.SwitchCase = require_SwitchCase();
    tokens.SwitchStatement = require_SwitchStatement();
    tokens.TemplateElement = require_TemplateElement();
    tokens.TemplateLiteral = require_TemplateLiteral();
    tokens.ThisExpression = require_ThisExpression();
    tokens.ThrowStatement = require_ThrowStatement();
    tokens.TryStatement = require_TryStatement();
    tokens.TypeAssertExpression = require_TypeAssertExpression();
    tokens.TypeComputeDefinition = require_TypeComputeDefinition();
    tokens.TypeConditionalExpression = require_TypeConditionalExpression();
    tokens.TypeConditionDefinition = require_TypeConditionDefinition();
    tokens.TypeDefinition = require_TypeDefinition();
    tokens.TypeFunctionDefinition = require_TypeFunctionDefinition();
    tokens.TypeGenericDefinition = require_TypeGenericDefinition();
    tokens.TypeInferDefinition = require_TypeInferDefinition();
    tokens.TypeIntersectionDefinition = require_TypeIntersectionDefinition();
    tokens.TypeKeyofDefinition = require_TypeKeyofDefinition();
    tokens.TypeObjectDefinition = require_TypeObjectDefinition();
    tokens.TypeObjectPropertyDefinition = require_TypeObjectPropertyDefinition();
    tokens.TypePredicateDefinition = require_TypePredicateDefinition();
    tokens.TypeStatement = require_TypeStatement();
    tokens.TypeTransformExpression = require_TypeTransformExpression();
    tokens.TypeTupleDefinition = require_TypeTupleDefinition();
    tokens.TypeTupleElementDefinition = require_TypeTupleElementDefinition();
    tokens.TypeTupleRestDefinition = require_TypeTupleRestDefinition();
    tokens.TypeTupleUnionDefinition = require_TypeTupleUnionDefinition();
    tokens.TypeTypeofDefinition = require_TypeTypeofDefinition();
    tokens.TypeUnionDefinition = require_TypeUnionDefinition();
    tokens.TypeUniqueDefinition = require_TypeUniqueDefinition();
    tokens.UnaryExpression = require_UnaryExpression();
    tokens.UpdateExpression = require_UpdateExpression();
    tokens.UseExtendSpecifier = require_UseExtendSpecifier();
    tokens.UseExtendStatement = require_UseExtendStatement();
    tokens.VariableDeclaration = require_VariableDeclaration();
    tokens.VariableDeclarator = require_VariableDeclarator();
    tokens.WhenStatement = require_WhenStatement();
    tokens.WhileStatement = require_WhileStatement();
    for (name in tokens) {
      tokens[name].prototype.toString = function(name2) {
        return function() {
          return name2;
        };
      }(name);
    }
    var name;
    Stack.create = create;
    module.exports = { "tokens": tokens, "create": create };
  }
});

// lib/core/Compilation.js
var require_Compilation = __commonJS({
  "lib/core/Compilation.js"(exports, module) {
    var fs = __require("fs");
    var path = __require("path");
    var TopScope = require_TopScope();
    var Parser = require_Parser();
    var Namespace = require_Namespace();
    var Module = require_Module();
    var Utils = require_Utils();
    var Diagnostic = require_Diagnostic();
    var Range = require_Range();
    var EventDispatcher = require_EventDispatcher();
    var Constant = require_Constant();
    var Tokens = require_tokens();
    var symbolKey = Symbol("key");
    var PARSER_TAG_REGEXP = /(?<=(?:[\s\r\n]+|^)\/\/\/)[\s+]?<(scope|reference)\s+(.*?)\/\>/ig;
    var PARSER_TAG_ATTR_REGEXP = /\b(name|inherits|file|isDir)[\s+]?=[\s+]?([\'\"])([^\2]*?)\2/g;
    var SortedMap = {
      "manifest": -5,
      "reference": -5,
      "scans": -5
    };
    var Compilation = class extends EventDispatcher {
      [Utils.IS_COMPILATION] = true;
      static is(value2) {
        return value2 ? value2 instanceof Compilation : false;
      }
      constructor(compiler, file) {
        super();
        this.compiler = compiler;
        this.modules = /* @__PURE__ */ new Map();
        this.stacks = /* @__PURE__ */ new Map();
        this._namespace = null;
        this.namespaceSets = /* @__PURE__ */ new Set();
        this.children = [];
        this.parent = null;
        this.scope = new TopScope(null);
        this.stack = null;
        this.ast = null;
        this.isMain = false;
        this.errors = [];
        this.mtime = null;
        this.file = file;
        this.import = null;
        this.dependencies = /* @__PURE__ */ new Set();
        this.dependencyCompilations = /* @__PURE__ */ new Set();
        this.assets = /* @__PURE__ */ new Map();
        this.requires = /* @__PURE__ */ new Map();
        this.originId = null;
        this.originFile = null;
        this.source = "";
        this.JSX = false;
        this.stackCreating = false;
        this.mainModule = null;
        this[symbolKey] = {
          policy: Constant.POLICY_NONE,
          building: false,
          waitCallback: [],
          waiting: [],
          completed: {},
          hooks: {},
          scope: void 0,
          parserDoneFlag: false,
          parseringFlag: false,
          cacheKey: Date.now()
        };
        this.jsxStyles = [];
        this.jsxElements = [];
        this.pluginScopes = /* @__PURE__ */ Object.create(null);
        this.referenceStacks = /* @__PURE__ */ new Set();
        this.referenceCompilations = /* @__PURE__ */ new Set();
        this.namespace = Namespace.dataset;
        this.loadDependencies = /* @__PURE__ */ new Set();
        this.isGlobalFlag = false;
        this.isDestroyed = false;
        this.emitComments = [];
        this.importModules = /* @__PURE__ */ new Map();
        this.importModuleNameds = /* @__PURE__ */ new Map();
        this.hasDeclareJSModule = false;
        this.changed = false;
      }
      getScopeName() {
        let scope = this[symbolKey].scope;
        if (scope !== void 0)
          return scope;
        return this[symbolKey].scope = this.compiler.scopeManager.resolveScopeName(this.file);
      }
      hasDescriptorReferenceName(desc) {
        const refs = this[symbolKey].descriptorReferences;
        return refs ? refs.has(desc) : false;
      }
      getDescriptorReferenceName(desc) {
        const refs = this[symbolKey].descriptorReferences;
        return refs ? refs.get(desc) : null;
      }
      setDescriptorReferenceName(desc, name) {
        const refs = this[symbolKey].descriptorReferences || (this[symbolKey].descriptorReferences = /* @__PURE__ */ new Map());
        refs.set(desc, name);
      }
      hookAsync(name, callback) {
        const hooks = this[symbolKey].hooks;
        const items = hooks[name] || (hooks[name] = []);
        items.push(callback);
      }
      removeHook(name, callback) {
        const hooks = this[symbolKey].hooks;
        if (hooks) {
          const items = hooks[name];
          if (items) {
            const index = items.indexOf(callback);
            if (index >= 0) {
              items.splice(index, 1);
            }
          }
        }
      }
      async callHookAsync(name, always = false) {
        const hooks = this[symbolKey].hooks;
        const queues = hooks[name] || (hooks[name] = []);
        try {
          const items = always ? queues.slice(0) : queues.splice(0, queues.length);
          await Promise.allSettled(items.map((callback) => callback()));
        } catch (e) {
          console.error(e);
        }
      }
      get isDescriptionType() {
        return this.isDescriptorDocument();
      }
      setPluginScopes(scopes) {
        if (!this.pluginScopes.scope) {
          this.pluginScopes.scope = scopes.scope;
        }
        if (scopes.inherits && Array.isArray(scopes.inherits) && scopes.inherits.length > 0) {
          const old = this.pluginScopes.inherits;
          if (!old) {
            this.pluginScopes.inherits = scopes.inherits.slice(0);
          } else {
            scopes.inherits.forEach((name) => {
              if (!old.includes(name)) {
                old.push(name);
              }
            });
          }
        }
      }
      isDescriptorDocument(isGlobal) {
        if (this[symbolKey].isDescriptorFlag != null) {
          return this[symbolKey].isDescriptorFlag;
        }
        let result = false;
        if (this.file) {
          if (isGlobal && this.pluginScopes.scope !== "global") {
            result = false;
          } else {
            result = this.compiler.isDescriptorFile(this.file);
          }
        }
        return this[symbolKey].isDescriptorFlag = result;
      }
      isLocalDocument() {
        if (this.pluginScopes.scope === "local") {
          return true;
        }
        if (this[symbolKey].isLocalFlag == null) {
          let file = String(this.file).toLowerCase();
          return this[symbolKey].isLocalFlag = this.compiler.getWorkspaceFolders().some((folder) => {
            return file.includes(String(folder).toLowerCase());
          });
        }
        return this[symbolKey].isLocalFlag;
      }
      isGlobalDocument() {
        return this.compiler.globals.has(this);
      }
      addReferenceStack(stack) {
        if (stack && stack.isStack && stack.compilation !== this) {
          this.referenceStacks.add(stack);
        }
      }
      set namespace(value2) {
        this.namespaceSets.add(value2);
        this._namespace = value2;
      }
      get namespace() {
        return this._namespace;
      }
      completed(plugin, value2) {
        if (!plugin || typeof plugin.platform !== "string") {
          throw new Error("Invalid plugin instanced.");
        }
        const key = plugin.name + ":" + plugin.platform;
        if (value2 !== void 0) {
          this[symbolKey].completed[key] = value2;
        }
        return !!this[symbolKey].completed[key];
      }
      get policy() {
        return this[symbolKey].policy;
      }
      setPolicy(policy, module2) {
        if ((Constant.POLICY_ALL & policy) === policy) {
          if (module2) {
            module2.policy = policy;
          } else {
            this[symbolKey].policy = policy;
            this.modules.forEach((module3) => {
              module3.policy = policy;
            });
          }
        }
      }
      isPolicy(policy, module2) {
        const value2 = module2 ? module2.policy : this.policy;
        return (value2 & policy) === value2;
      }
      isServerPolicy(module2, explicit = false) {
        if (!module2)
          return false;
        if (module2 && !module2.isModule)
          return !explicit;
        const value2 = module2 ? module2.policy : this.policy;
        if (value2 === Constant.POLICY_ALL) {
          return true;
        } else if (!explicit && value2 === Constant.POLICY_NONE) {
          if (module2 && module2.inherit) {
            return this.isServerPolicy(module2.inherit);
          } else {
            return true;
          }
        }
        return (value2 & Constant.POLICY_SERVER) === value2;
      }
      setServerPolicy(module2) {
        this.setPolicy(Constant.POLICY_SERVER, module2);
      }
      isClientPolicy(module2, explicit = false) {
        if (!module2)
          return false;
        const value2 = module2 ? module2.policy : this.policy;
        if (module2 && !module2.isModule)
          return !explicit;
        if (value2 === Constant.POLICY_ALL) {
          return true;
        } else if (!explicit && value2 === Constant.POLICY_NONE) {
          if (module2 && module2.inherit) {
            return this.isClientPolicy(module2.inherit);
          } else {
            return true;
          }
        }
        return (value2 & Constant.POLICY_CLIENT) === value2;
      }
      setClientPolicy(module2) {
        this.setPolicy(Constant.POLICY_CLIENT, module2);
      }
      addStack(stack) {
        if (stack.node.start > 0) {
          this.stacks.set(stack.node.start, stack);
        }
      }
      checkDescriptor(desc, document) {
        if (desc && desc.compilation) {
          const ctx = module || this;
          if (desc.compilation === this || desc === module)
            return true;
          const scopes = desc.compilation.pluginScopes;
          if (scopes && scopes.scope !== "global") {
            const plugin = this.compiler.pluginInstances.find((plugin2) => this.compiler.isMatchPluginNameOf(plugin2.name, scopes));
            if (plugin) {
              return this.compiler.isPluginInContext(plugin, ctx);
            }
          }
        }
        return true;
      }
      addDependency(dep, module2) {
        if (dep && dep !== this) {
          if (module2 && module2.isModule) {
            module2.addDepend(dep);
            if (dep.isModule && dep.compilation && dep.compilation !== this) {
              dep.compilation.referenceCompilations.add(this);
              this.dependencyCompilations.add(dep.compilation);
            } else if (dep instanceof Compilation) {
              dep.referenceCompilations.add(this);
              this.dependencyCompilations.add(dep);
            }
          } else {
            dep.used = true;
            this.dependencies.add(dep);
            if (dep.isModule && dep.compilation && dep.compilation !== this) {
              dep.compilation.referenceCompilations.add(this);
              this.dependencyCompilations.add(dep.compilation);
            } else if (dep instanceof Compilation) {
              dep.referenceCompilations.add(this);
              this.dependencyCompilations.add(dep);
            }
          }
        }
      }
      addAsset(resolve, file, content, type2, assign, attrs = null, stack = null) {
        const key = resolve;
        const old = this.assets.get(key);
        const cacheId = this.cacheId;
        if (!old) {
          const obj = {
            file,
            resolve,
            content,
            type: type2,
            assign,
            id: null,
            index: this.assets.size,
            attrs,
            cacheId,
            stack
          };
          this.assets.set(key, obj);
          return obj;
        } else if (old.cacheId !== cacheId) {
          old.cacheId = cacheId;
          return old;
        }
        return false;
      }
      addRequire(key, name, from, resolve, extract, stack = null, isAutoImporter = false) {
        let cacheKey = name + ":" + resolve;
        const cacheId = this.cacheId;
        const old = this.requires.get(cacheKey);
        if (!old) {
          const obj = {
            key,
            name,
            from,
            resolve,
            extract,
            isAutoImporter,
            stack,
            cacheId,
            namespaced: key === "*",
            id: null,
            index: this.requires.size
          };
          this.requires.set(cacheKey, obj);
          return obj;
        } else if (old.cacheId !== cacheId) {
          old.cacheId = cacheId;
          return old;
        }
        return false;
      }
      getDependencies(module2) {
        if (module2 && module2.isModule) {
          return Array.from(module2.dependencies.values());
        }
        return Array.from(this.dependencies.values());
      }
      getCompilationsOfDependency() {
        return this.dependencyCompilations;
      }
      getStackByAt(startAt, tryNum = 3, both = 0) {
        let stack = this.stacks.get(startAt);
        if (!stack) {
          let offset = 0;
          if (tryNum < 0) {
            tryNum = both === 0 ? this.stacks.size / 2 : this.stacks.size;
          }
          while (!stack && offset < tryNum) {
            offset++;
            if (both === 0) {
              stack = this.stacks.get(startAt - offset) || this.stacks.get(startAt + offset);
            } else if (both < 0) {
              stack = this.stacks.get(startAt - offset);
            } else if (both > 0) {
              stack = this.stacks.get(startAt + offset);
            }
          }
        }
        return stack;
      }
      addModuleStack(module2, stack) {
        if (module2 && module2.isModule) {
          module2.moduleStack = stack;
        }
      }
      getStackByModule(module2) {
        if (module2 && module2.isModule) {
          return module2.moduleStack;
        }
        return null;
      }
      hasSameDiagnostic(node2, code, range = null, kind = 0) {
        return this.errors.some((error) => {
          if (this.file === error.file && error.code === code && error.kind === kind) {
            if (range) {
              if (range.start.line === error.range.start.line && range.end.line === error.range.end.line) {
                return range.end.column === error.range.end.column;
              }
            } else if (node2.loc && typeof node2.loc.start === "object") {
              if (node2.loc.start.line === error.range.start.line && node2.loc.end.line === error.range.end.line) {
                return node2.loc.start.column === error.range.end.column;
              }
            }
          }
        });
      }
      error(node2, code, ...args) {
        const range = this.getRangeByNode(node2);
        if (this.hasSameDiagnostic(node2, code, range, 0)) {
          return;
        }
        const message = Diagnostic.getMessage(code, args);
        const error = new Diagnostic(this.file, message, range, Diagnostic.ERROR, node2, code);
        if (this.compiler.options.debug) {
          Utils.debug(error.toString());
          if (node2 instanceof Error) {
            console.log(node2);
          }
        }
        if (this.compiler.options.diagnose) {
          this.errors.push(error);
          this.compiler.errors.push(error);
        } else if (!this.compiler.options.debug) {
          Utils.error(error.toString());
        }
      }
      warn(node2, code, ...args) {
        const range = this.getRangeByNode(node2);
        if (this.hasSameDiagnostic(node2, code, range, 1)) {
          return;
        }
        const message = Diagnostic.getMessage(code, args);
        const warn = new Diagnostic(this.file, message, range, Diagnostic.WARN, node2, code);
        if (this.compiler.options.debug) {
          Utils.debug(warn.toString());
          if (node2 instanceof Error) {
            console.log(node2);
          }
        }
        if (this.compiler.options.diagnose) {
          this.errors.push(warn);
          this.compiler.errors.push(warn);
        } else if (!this.compiler.options.debug) {
          Utils.warn(warn.toString());
        }
      }
      deprecated(node2, code, ...args) {
        const range = this.getRangeByNode(node2);
        if (this.hasSameDiagnostic(node2, code, range, 2)) {
          return;
        }
        const message = Diagnostic.getMessage(code, args);
        const warn = new Diagnostic(this.file, message, range, Diagnostic.DEPRECATED, node2, code);
        if (this.compiler.options.diagnose) {
          this.errors.push(warn);
          this.compiler.errors.push(warn);
        }
      }
      unnecessary(node2, code, ...args) {
        const range = this.getRangeByNode(node2);
        if (this.hasSameDiagnostic(node2, code, range, Diagnostic.UNNECESSARY)) {
          return;
        }
        const message = Diagnostic.getMessage(code, args);
        const warn = new Diagnostic(this.file, message, range, Diagnostic.UNNECESSARY, node2, code);
        if (this.compiler.options.diagnose) {
          this.errors.push(warn);
          this.compiler.errors.push(warn);
        }
      }
      getReference(key, target, isStatic, kind = null) {
        if (target && target instanceof Module) {
          if (isStatic) {
            return target.getMethod(key, kind);
          }
          return target.getMember(key, kind);
        } else if (target instanceof Namespace) {
          return target.get(key);
        }
        return !target ? this.getModuleById(key) : null;
      }
      getDescriptor(key, target, filter) {
        if (target && target instanceof Module) {
          return target.getDescriptor(key, filter);
        } else if (target instanceof Namespace) {
          return target.get(key);
        }
        return !target ? this.getModuleById(key) : null;
      }
      getReferenceName(desc, context = null, flag = false) {
        if (!context) {
          context = this.mainModule;
        }
        if (this.importModuleNameds.has(desc)) {
          return this.importModuleNameds.get(desc);
        }
        if (context) {
          if (Module.is(context)) {
            return context.getReferenceNameByModule(desc, flag);
          }
          if (context !== this && Compilation.is(context)) {
            return context.getReferenceName(desc, context, flag);
          }
        }
        if (Module.is(desc)) {
          const key = desc.id;
          const req = this.requires.get(key);
          if (req && req.isAutoImporter)
            return req.name;
          if (!flag) {
            return desc.getName("_");
          }
        }
        return null;
      }
      getRangeByNode(node2) {
        if (node2.loc) {
          if (node2.loc.start && node2.loc.end) {
            return new Range(node2.loc.start, node2.loc.end);
          } else {
            return new Range(node2.loc, Object.assign({}, node2.loc, { column: node2.loc.column + (node2.raisedAt - node2.pos) }));
          }
        }
        const str = this.source.substring(0, node2.start + 1);
        const lines = str.split(/\r\n/);
        const startLineText = lines.length > 0 ? lines[lines.length - 1] : str;
        const column = node2.start - (str.length - startLineText.length);
        const start = { line: lines.length, column };
        const endStr = this.source.substring(node2.start, node2.end + 1);
        const endLines = endStr.split(/\r\n/);
        const endLineText = endLines.length > 0 ? endLines[endLines.length - 1] : endStr;
        const endColumn = node2.end - (endStr.length - endLineText.length);
        const end = { line: endLines.length + lines.length, column: endColumn };
        return new Range(start, end);
      }
      getTypeValue(type2, isLoadDependency = false) {
        if (isLoadDependency && type2) {
          const compilation = type2.compilation;
          if (compilation instanceof Compilation && !compilation.parserDoneFlag) {
            this.loadDependencies.add(compilation);
          }
        }
        if (type2 && Utils.isStack(type2)) {
          if (type2.isDeclaratorFunction || type2.isDeclaratorVariable) {
            return type2;
          }
          return type2.type();
        }
        return type2;
      }
      getTypeById(id) {
        if (this.modules.has(id)) {
          return this.getTypeValue(this.modules.get(id));
        }
        return Namespace.globals.get(id);
      }
      getGlobalTypeById(id) {
        return Namespace.globals.get(id);
      }
      async createChildCompilation(file, context, originId = null, notLoadDescribeFile = false) {
        const compilation = await this.compiler.createCompilation(file, context, notLoadDescribeFile, false, this);
        if (compilation) {
          if (compilation !== this && !compilation.stack && !this.stackCreating) {
            compilation.originId = originId || file;
            Object.assign(compilation.pluginScopes, this.pluginScopes);
            compilation.createStack();
          }
          this.dependencyCompilations.add(compilation);
        }
        return compilation;
      }
      hasModuleById(id, context) {
        if (context && context.isNamespace) {
          if (context.has(id)) {
            return true;
          }
        } else if (context && context.isModule) {
          if (context.imports.has(id) || context.namespace.has(id)) {
            return true;
          }
        }
        if (this.importModules.has(id)) {
          return true;
        }
        if (this.modules.has(id)) {
          return true;
        }
        if (Namespace.globals.has(id)) {
          return true;
        }
        return false;
      }
      getModuleById(id, context = null) {
        if (context && context.isNamespace) {
          if (context.has(id)) {
            return this.getTypeValue(context.get(id), true);
          }
        } else if (context && context.isModule) {
          const result = context.getImport(id) || context.namespace.get(id);
          if (result) {
            return this.getTypeValue(result, true);
          }
        }
        if (this.importModules.has(id)) {
          return this.getTypeValue(this.importModules.get(id), true);
        }
        if (this.modules.has(id)) {
          return this.getTypeValue(this.modules.get(id), true);
        }
        if (Namespace.globals.has(id)) {
          return this.getTypeValue(Namespace.globals.get(id), true);
        }
        return null;
      }
      async loadTypeAsync(id, context = null, isImporter = false, checkScope = false) {
        let type2 = null;
        let ns = null;
        if (!isImporter) {
          type2 = this.getModuleById(id, context, true);
          if (type2 === false)
            return null;
          if (type2)
            return type2;
          ns = this.namespace;
          if (context) {
            if (Namespace.is(context)) {
              ns = context;
            } else if (Module.is(context)) {
              ns = context.namespace;
            }
          }
        }
        let idString = String(id);
        let file = null;
        if (!this.isDescriptorDocument()) {
          if (idString.includes(".")) {
            file = this.compiler.resolveManager.resolveFile(idString.replaceAll(".", "/"));
          } else {
            let code = idString.charCodeAt(0);
            if (code >= 65 && code <= 90) {
              if (isImporter) {
                file = this.compiler.resolveManager.resolveFile(idString);
              } else if (this.file) {
                file = this.compiler.resolveManager.resolveFile(idString, this.file);
              }
            }
          }
        } else if (this.file && !idString.includes(".")) {
          file = this.compiler.resolveManager.resolveFile(path.join(path.dirname(this.file), idString));
        }
        if (file) {
          const compilation = await this.createChildCompilation(file, null, id);
          if (compilation && compilation !== this) {
            if (!compilation.parserDoneFlag) {
              this.loadDependencies.add(compilation);
            }
            type2 = compilation.namespace.get(id) || Namespace.globals.get(id);
          }
        }
        if (!type2) {
          id = await this.loadManifest(id, ns, false, checkScope);
          if (id) {
            type2 = Namespace.globals.get(id);
          }
        }
        return this.getTypeValue(type2);
      }
      checkNeedToLoadTypeById(id, context) {
        if (this.hasModuleById(id, context)) {
          return false;
        }
        if (this.hasManifestResource(id, context)) {
          return true;
        }
        if (!this.isDescriptorDocument()) {
          id = String(id);
          if (id.includes(".")) {
            return !!this.compiler.resolveManager.resolveFile(id.replaceAll(".", "/"));
          } else {
            return !!this.compiler.resolveManager.resolveFile(id, this.file);
          }
        }
        return false;
      }
      hasManifestResource(id, context) {
        let ns = this.namespace;
        if (context) {
          if (context.isNamespace) {
            ns = context;
          } else if (context.isModule) {
            ns = context.namespace;
          }
        }
        id = this.compiler.manifester.resolveId(id, ns);
        return this.compiler.manifester.hasResource(id);
      }
      async loadManifest(id, ns = null, isModule = false, checkScope = false) {
        if (!isModule) {
          if (ns) {
            id = this.compiler.manifester.resolveId(id, ns);
          }
          if (Namespace.globals.has(id))
            return id;
        }
        const manifestInfo = this.compiler.manifester.getFileinfo(id, true, isModule);
        if (manifestInfo && !manifestInfo._loaded) {
          await Promise.allSettled(manifestInfo.files.map(async (file) => {
            if (checkScope && this.pluginScopes.scope && !this.compiler.scopeManager.checkDocumentor(manifestInfo.scope, this)) {
              return;
            }
            const compilation = await this.compiler.createCompilation(file, null, true, false, this);
            if (compilation) {
              compilation.import = "manifest";
              compilation.pluginScopes.scope = manifestInfo.scope;
              compilation.pluginScopes.inherits = manifestInfo.inherits;
              compilation.createStack();
              this.loadDependencies.add(compilation);
            }
          }));
          manifestInfo._loaded = true;
          return id;
        }
        return null;
      }
      parseModuleIdByFile(file) {
        file = this.compiler.resolveManager.resolveFile(file, this.file);
        if (file) {
          const ns = this.compiler.getFileNamespace(file);
          const name = this.compiler.getFileClassName(file);
          return ns ? `${ns}.${name}` : name;
        } else {
          return null;
        }
      }
      getAllModulesByPolicy(policy) {
        const modules = [];
        this.modules.forEach((module2) => {
          if (this.isPolicy(policy, module2)) {
            modules.push(module2);
          }
        });
        this.children.forEach((childCompilation) => {
          const result = childCompilation.getModulesByPolicy(policy);
          for (const item2 of result) {
            modules.push(item2);
          }
        });
        return modules;
      }
      getModulesByPolicy(policy) {
        const modules = [];
        this.modules.forEach((module2) => {
          if (this.isPolicy(policy, module2)) {
            modules.push(module2);
          }
        });
        this.children.forEach((childCompilation) => {
          childCompilation.modules.forEach((module2) => {
            if (childCompilation.isPolicy(policy, module2)) {
              modules.push(module2);
            }
          });
        });
        return modules;
      }
      getServerCompilations(explicit = false) {
        const compilations = [];
        const map = /* @__PURE__ */ new WeakSet();
        const push = (compilation) => {
          if (!map.has(compilation)) {
            map.add(compilation);
            compilations.push(compilation);
          }
        };
        this.modules.forEach((module2) => {
          if (this.isServerPolicy(module2, explicit)) {
            push(module2.compilation);
          }
        });
        this.children.forEach((child) => {
          child.getServerCompilations(explicit).forEach((compilation) => {
            push(compilation);
          });
        });
        return compilations;
      }
      getClientCompilations(explicit = false) {
        const compilations = [];
        const map = /* @__PURE__ */ new WeakSet();
        const push = (compilation) => {
          if (!map.has(compilation)) {
            map.add(compilation);
            compilations.push(compilation);
          }
        };
        this.modules.forEach((module2) => {
          if (this.isClientPolicy(module2, explicit)) {
            push(module2.compilation);
          }
        });
        this.children.forEach((child) => {
          child.getClientCompilations(explicit).forEach((compilation) => {
            push(compilation);
          });
        });
        return compilations;
      }
      readSibling(flag = false, context = "") {
        const dir = this.file && path.dirname(this.file);
        if (dir) {
          const files = (Utils.readdir(path.join(dir, context.replace(".", "/")), true) || []).map((filename) => {
            const stat = fs.statSync(filename);
            const folder = stat ? stat.isDirectory() : false;
            const name = path.basename(filename, this.compiler.suffix);
            return { name, folder, filename };
          });
          if (flag) {
            const uniqueNs = /* @__PURE__ */ new Set();
            Array.from(this.modules.values()).forEach((module2) => {
              uniqueNs.add(module2.namespace);
            });
            const list = [];
            uniqueNs.forEach((ns) => {
              files.forEach((item2) => {
                item2.name = ns.getChain().concat(item2.name).join(".");
                list.push(item2);
              });
            });
            return list;
          }
          return files;
        }
        return [];
      }
      parseAst(source) {
        try {
          const matchedResult = source.matchAll(PARSER_TAG_REGEXP);
          if (matchedResult) {
            const references = /* @__PURE__ */ new Set();
            for (let result of matchedResult) {
              const [, name, attrs] = result;
              const props = attrs.matchAll(PARSER_TAG_ATTR_REGEXP);
              if (props) {
                const data = {};
                for (let item2 of props) {
                  let [, key, , value2] = item2;
                  data[key.trim()] = value2.trim();
                }
                if (name === "scope") {
                  if (data.name) {
                    this.pluginScopes.scope = data.name;
                  }
                  if (data.inherits) {
                    const inherits = this.pluginScopes.inherits || (this.pluginScopes.inherits = []);
                    const items = data.inherits.split(",").map((val) => val.trim());
                    inherits.push(...items);
                  }
                } else if (name === "reference" && data.file) {
                  this.readReferenceFiles(references, data.file, this.file);
                }
              }
            }
            if (references.size > 0) {
              this.hookAsync("compilation.create.before", async () => {
                const context = this.file;
                const files = Array.from(references).map((file) => this.createChildCompilation(file, context));
                const items = await Promise.allSettled(files);
                await this.compiler.callAsyncSequence(items, async (result) => {
                  const compilation = result.value;
                  if (!compilation)
                    return null;
                  if (!compilation.import)
                    compilation.import = "reference";
                  await compilation.createCompleted();
                });
              });
            }
          }
          const options = this.compiler.options;
          if (options.enableComments) {
            this.emitComments.length = 0;
            options.parser.onComment = (block, text, start, end, startLoc, endLoc) => {
              this.emitComments.push({
                type: block ? "Block" : "Line",
                value: text,
                start,
                end,
                startLoc,
                endLoc
              });
            };
          }
          options.parser.onErrorCallback = (message, line, column, pos) => {
            const loc = { line, column };
            const error = new Diagnostic(this.file, message, new Range(loc, loc), Diagnostic.ERROR, null, 5100);
            if (this.compiler.options.diagnose) {
              this.errors.push(error);
              this.compiler.errors.push(error);
            } else if (!this.compiler.options.debug) {
              Utils.error(error.toString());
            }
          };
          return Parser.Parser.parse(source, options.parser);
        } catch (e) {
          this.compiler.printLogInfo(`Error: ${e.message} 
 ${e.stack} 
 by ${this.file}`, "parseAst");
          if (this.compiler.options.throwParseError) {
            console.error(e);
            console.error(this.file);
          }
          this.error(e, 1085);
        }
      }
      readReferenceFiles(dataset, file, context) {
        file = this.compiler.resolveManager.resovleDependency(file, context);
        dataset = dataset || /* @__PURE__ */ new Set();
        if (!file)
          return dataset;
        if (fs.existsSync(file)) {
          const stat = fs.statSync(file);
          if (stat.isDirectory()) {
            const list = Utils.readdir(file);
            if (list) {
              list.forEach((filename) => {
                this.readReferenceFiles(dataset, filename, file);
              });
            }
          } else if (stat.isFile() && this.compiler.isDescriptorFile(file)) {
            dataset.add(file);
          }
        }
        return dataset;
      }
      createAst(source) {
        if (!this.ast) {
          this.mtime = this.file ? fs.statSync(this.file).mtimeMs : null;
          this.source = (source || fs.readFileSync(this.file, "utf-8")).toString();
          this.compiler.markMemoryUsage(this);
          this.ast = this.parseAst(this.source);
          const info = this.compiler.getMemoryUsage(this);
          this.compiler.printLogInfo(`CreateAst: ${this.file} (${info.current} MB, total:${info.total} MB)`, "compilation");
        }
        return this.ast;
      }
      createModule(namespace, id, isInternal = false, isStructModule = false, isPrivate = false) {
        let name = id;
        let module2 = null;
        if (!namespace) {
          namespace = this.namespace;
        }
        if (isPrivate) {
          name = namespace.getChain().concat(name).join(".");
          module2 = this.modules.get(name);
          if (!module2) {
            module2 = new Module(this);
            module2.id = id;
            module2.file = this.file;
            module2.fullname = name;
            module2.namespace = namespace;
            module2.isPrivate = true;
            if (!isStructModule) {
              this.modules.set(name, module2);
            }
            this.compiler.dispatcher("onCreatedModule", module2);
          }
        } else {
          if (namespace.has(id)) {
            module2 = namespace.get(id);
          } else if (namespace !== Namespace.dataset) {
            name = namespace.getChain().concat(name).join(".");
          }
          if (module2 && module2.namespace !== namespace) {
            module2 = null;
          }
          if (!module2) {
            module2 = new Module(this);
            module2.id = id;
            module2.file = this.file;
            module2.fullname = name;
            module2.namespace = namespace;
            if (namespace) {
              namespace.set(id, module2);
            }
            if (!isStructModule) {
              this.modules.set(name, module2);
            }
            this.compiler.dispatcher("onCreatedModule", module2);
          } else {
            if (!isStructModule) {
              this.modules.set(name, module2);
            }
          }
        }
        if (!this.isDescriptorDocument()) {
          this.compiler.printLogInfo(`createModule: ${name} -> ${!!module2}, ${this.file}`, "compilation");
        }
        if (!module2.files.includes(this.file)) {
          module2.files.push(this.file);
        }
        module2.policy = this.policy;
        module2.isValid = true;
        module2.mtime = this.mtime;
        return module2;
      }
      createPureModule(id) {
        let module2 = new Module(this);
        module2.namespace = Namespace.dataset;
        module2.id = id;
        module2.file = this.file;
        module2.fullname = id;
        if (!module2.files.includes(this.file)) {
          module2.files.push(this.file);
        }
        module2.policy = this.policy;
        module2.isValid = true;
        module2.mtime = this.mtime;
        this.compiler.dispatcher("onCreatedModule", module2);
        return module2;
      }
      isValid(source = null) {
        if (!this.ast)
          return true;
        if (this.isDestroyed)
          return true;
        for (let [, module2] of this.modules) {
          if (!module2.isValid)
            return false;
        }
        if (source == null && this.file) {
          try {
            const mtime = fs.statSync(this.file).mtimeMs;
            if (mtime === this.mtime) {
              return true;
            }
            source = fs.readFileSync(this.file, "utf-8").toString();
          } catch (e) {
            if (!fs.existsSync(this.file)) {
              this.isDestroyed = true;
              return true;
            }
          }
        }
        const removeblank = /[\r\n\s\t]/g;
        let astr = String(this.source).replace(removeblank, "");
        let bstr = String(source).replace(removeblank, "");
        if (astr.charCodeAt(0) === 65279)
          astr = astr.slice(1);
        if (bstr.charCodeAt(0) === 65279)
          bstr = astr.slice(1);
        return astr === bstr;
      }
      destory() {
        this.scope = null;
        this.errors = null;
        this.namespaceSets = null;
        this.assets = null;
        this.requires = null;
        this.modules = null;
        this.stacks = null;
        this.dependencies = null;
        this.dependencyCompilations = null;
        this[symbolKey] = null;
        this.stack = null;
        this.ast = null;
        this.referenceStacks = null;
        this.jsxStyles = null;
        this.jsxElements = null;
        delete this.scope;
        delete this.errors;
        delete this.namespaceSets;
        delete this.assets;
        delete this.requires;
        delete this.modules;
        delete this.stacks;
        delete this.dependencies;
        delete this.dependencyCompilations;
        delete this[symbolKey];
        delete this.stack;
        delete this.ast;
        delete this.referenceStacks;
        delete this.jsxStyles;
        delete this.jsxElements;
        this.hasDeclareJSModule = false;
        this.isDestroyed = true;
        this.dispatcher("onDestory");
      }
      clear() {
        this.compiler.printLogInfo(`clear: ${this.file}`, "compilation");
        this.modules.forEach((module2) => {
          module2.clear(this);
        });
        this.errors.forEach((error) => {
          const index = this.compiler.errors.indexOf(error);
          if (index >= 0) {
            this.compiler.errors.splice(index, 1);
          }
        });
        this.assets = /* @__PURE__ */ new Map();
        this.requires = /* @__PURE__ */ new Map();
        this.modules = /* @__PURE__ */ new Map();
        this.importModules = /* @__PURE__ */ new Map();
        this.importModuleNameds = /* @__PURE__ */ new Map();
        this.stacks = /* @__PURE__ */ new Map();
        this.dependencies = /* @__PURE__ */ new Set();
        this.dependencyCompilations = /* @__PURE__ */ new Set();
        this.loadDependencies = /* @__PURE__ */ new Set();
        this.JSX = false;
        this.hasDeclareJSModule = false;
        this.stackCreating = false;
        this.namespaceSets.forEach((namespace) => namespace.clear(this));
        this.children.length = 0;
        this.jsxStyles.length = 0;
        this.jsxElements.length = 0;
        this.namespace = Namespace.dataset;
        this.referenceStacks.forEach((stack) => {
          const useRefItems = stack._useRefItems;
          if (useRefItems) {
            Array.from(useRefItems.values()).forEach((stack2) => {
              if (stack2.compilation === this) {
                useRefItems.delete(stack2);
              }
            });
          }
        });
        this.referenceStacks = /* @__PURE__ */ new Set();
        const data = this[symbolKey] = {};
        data.completed = {};
        data.policy = Constant.POLICY_NONE;
        data.hooks = {};
        data.waiting = [];
        data.parserDoneFlag = false;
        data.createCompletedFlag = false;
        data.descriptorReferences = null;
        data.cacheKey = Date.now();
        this.changed = !!(this.ast && this.stack);
        this.errors = [];
        this.stack = null;
        this.ast = null;
        this.hasParsed = false;
        this.hasChecked = false;
        this.hasFreezed = false;
        this.scope = new TopScope(null);
        if (!this.isDestroyed) {
          this.compiler.dispatcher("onChanged", this);
          this.compiler.printLogInfo(`[dispatcher] onChanged: ${this.file}`, "compilation");
          this.dispatcher("onClear");
        }
        return true;
      }
      get cacheId() {
        return this[symbolKey].cacheKey;
      }
      get parserDoneFlag() {
        return this[symbolKey].parserDoneFlag;
      }
      get parseringFlag() {
        return this[symbolKey].parseringFlag;
      }
      get createDoneFlag() {
        return this[symbolKey].createDoneFlag;
      }
      get refreshingFlag() {
        return this[symbolKey].refreshing;
      }
      parser() {
        throw new Error("Compilation.parser is deprecated, please use parserAsync.");
      }
      createStack(source = null, ast = null) {
        try {
          if (!this.stack && !this.stackCreating) {
            this.stackCreating = true;
            const old = this.ast;
            if (!ast) {
              ast = this.createAst(source);
            }
            if (old !== ast || !this.stack) {
              this.compiler.printLogInfo(`create-tokens: ${this.file}`, "compilation");
              this.namespace = Namespace.dataset;
              this.compiler.markMemoryUsage(this);
              this.stack = Tokens.create(this, ast, this.scope, null);
              const info = this.compiler.getMemoryUsage(this);
              this.compiler.printLogInfo(`CreateStack: ${this.file} (${info.current} MB, total:${info.total} MB)`, "compilation");
            }
            this.stackCreating = false;
          }
          return this.stack;
        } catch (e) {
          this.compiler.printLogInfo(`create-tokens-error: ${e.message} 
 ${e.stack} 
 by ${this.file}`, "compilation");
          if (this.compiler.options.throwParseError)
            console.error(e);
          this.error(e, 1085, e.message);
        }
      }
      throwError(e) {
        console.error(e);
        this.compiler.printLogInfo(`Error: ${e.message} 
 ${e.stack} 
 by ${this.file}`, "compilation");
      }
      async createCompleted() {
        if (this[symbolKey].createCompletedFlag)
          return;
        this[symbolKey].createCompletedFlag = true;
        const stack = this.stack;
        if (!this.isDestroyed && stack) {
          this[symbolKey].createDoneFlag = false;
          this.compiler.printLogInfo(`create-tokens-body start: ${this.file}`, "compilation");
          await this.callHookAsync("compilation.create.before");
          try {
            await stack.createCompleted();
          } catch (e) {
            console.log(e);
          }
          this.dispatcher("onCreateCompleted");
          if (this.modules.size > 0) {
            const getOrder = (module2) => {
              const base = module2.isDeclaratorModule ? 4 : 0;
              if (module2.isClass) {
                return 1 + base;
              } else if (module2.isInterface) {
                return 2 + base;
              } else if (module2.isEnum) {
                return 3 + base;
              } else if (module2.isStructTable) {
                return 4 + base;
              }
              return 5 + base;
            };
            let relatedness = /* @__PURE__ */ new Set();
            let modules = Array.from(this.modules.values());
            modules.forEach((module2) => {
              module2.getStacks().forEach((stack2) => {
                if (stack2.compilation !== this && stack2.compilation) {
                  relatedness.add(stack2.compilation);
                }
              });
            });
            if (relatedness.size > 0) {
              await Promise.allSettled(Array.from(relatedness.values()).map((child) => child.createCompleted()));
            }
            if (modules.length > 1) {
              modules = modules.sort((a, b) => {
                let a1 = getOrder(a);
                let b1 = getOrder(b);
                if (a1 === b1)
                  return 0;
                return a1 < b1 ? -1 : 1;
              });
            }
            this.mainModule = modules[0];
          }
          await this.callHookAsync("compilation.create.after");
          const dependencies = new Set(this.children);
          this.getCompilationsOfDependency().forEach((dep) => {
            if (dep !== this) {
              dependencies.add(dep);
            }
          });
          const compilations = Array.from(dependencies.values());
          compilations.sort((a, b) => {
            if (a.isDescriptorDocument())
              return -1;
            if (!b.isDescriptorDocument())
              return 1;
            return 0;
          });
          await this.compiler.callAsyncSequence(compilations, async (child) => {
            await child.createCompleted();
          });
          this[symbolKey].createDoneFlag = true;
          await this.callHookAsync("compilation.create.done");
          this.compiler.printLogInfo(`create-tokens-body done: ${this.file}`, "compilation");
        }
      }
      getUnparseCompilationDependencies(dataset, cache) {
        dataset = dataset || /* @__PURE__ */ new Set();
        cache = cache || /* @__PURE__ */ new WeakSet();
        const push = (dep) => {
          if (!dep.hasParsed && dep !== this) {
            dep.hasParsed = "lock";
            if (!cache.has(dep)) {
              cache.add(dep);
              dep.getUnparseCompilationDependencies(dataset, cache);
            }
            dataset.add(dep);
          }
        };
        this.loadDependencies.forEach(push);
        this.children.forEach(push);
        this.getCompilationsOfDependency().forEach(push);
        return dataset;
      }
      getCompilationSortPower(compilation) {
        let power = SortedMap[compilation.import] || (compilation.isDescriptorDocument() ? -3 : 0);
        if (power === 0) {
          const mainModule = compilation.mainModule;
          if (mainModule) {
            if (mainModule.isInterface || mainModule.isStructTable) {
              return -2;
            } else if (mainModule.isEnum) {
              return -1;
            }
          }
        }
        return power;
      }
      async parserAsync(source = null) {
        if (!this.isDestroyed && this.hasParsed !== true) {
          this.hasParsed = true;
          this.createStack(source);
          this.compiler.markMemoryUsage(this);
          if (this.stack) {
            this[symbolKey].parserDoneFlag = false;
            this[symbolKey].parseringFlag = true;
            try {
              await this.createCompleted();
              this.compiler.printLogInfo(`parser-tokens-start: ${this.file}`, "compilation");
              this.compiler.dispatcher("onParseStart", this);
              const dependencies = Array.from(this.getUnparseCompilationDependencies().values());
              dependencies.sort((a, b) => {
                let a1 = this.getCompilationSortPower(a);
                let b1 = this.getCompilationSortPower(b);
                return a1 - b1;
              });
              await Promise.allSettled(dependencies.map((child) => child.parserAsync()));
              await this.callHookAsync("compilation.parser.before");
              await this.stack.parserAsync();
              await this.callHookAsync("compilation.parser.after");
              if (this.changed && !this.refreshingFlag) {
                this.changed = false;
                if (!this.errors.some((error) => error.kind === Diagnostic.ERROR)) {
                  process.nextTick(() => {
                    this.refresh();
                  });
                }
              }
            } catch (e) {
              this.compiler.printLogInfo(`parser-tokens-error: ${e.message} 
 ${e.stack} 
 by ${this.file}`, "compilation");
            } finally {
              this[symbolKey].parserDoneFlag = true;
              this[symbolKey].parseringFlag = false;
              this.compiler.dispatcher("onParseDone", this);
              this.dispatcher("onParseDone");
              const info = this.compiler.getMemoryUsage(this);
              this.compiler.printLogInfo(`parser-tokens-done: ${this.file} (${info.current} MB, total:${info.total} MB)`, "compilation");
            }
          }
        }
      }
      async refresh() {
        const dataset = /* @__PURE__ */ new Set();
        const cache = /* @__PURE__ */ new WeakSet();
        const dependences = this.getCompilationsOfDependency();
        const getAll = (compilation) => {
          if (cache.has(compilation))
            return;
          cache.add(compilation);
          compilation.referenceCompilations.forEach((dep) => {
            if (!dep.isDescriptorDocument() && dep !== this) {
              if (!dependences.has(dep)) {
                if (dep.getCompilationsOfDependency().has(this)) {
                  dataset.add(dep);
                }
              }
            }
            getAll(dep);
          });
        };
        getAll(this);
        const compilations = Array.from(dataset.values());
        const files = compilations.map((com) => com.file);
        this.compiler.printLogInfo(`refresh-relation-start: ${this.file} -> ${files.join("\n")} `, "compilation");
        const errors = this.compiler.errors;
        const totalErrors = errors.length;
        const effect = this.compiler.options.checker.effect;
        if (errors.length > 0 || this.isDestroyed || effect) {
          this.compiler.printLogInfo(`show-errors: ${errors.map((err) => err.toString()).join("\n")}`, "compilation");
          await this.compiler.callAsyncSequence(compilations, async (com) => {
            if (com[symbolKey].refreshing)
              return;
            com[symbolKey].refreshing = true;
            await com.flush(this.isDestroyed || effect);
            com[symbolKey].refreshing = false;
          });
        }
        this.compiler.dispatcher("onRefreshDone", compilations);
        this.compiler.printLogInfo(`refresh-relation-done: ${this.file} errors: before ${totalErrors}, after:${errors.length}`, "compilation");
      }
      async flush(force = false) {
        if (!this.stack)
          return false;
        const len = this.errors.length;
        if (len > 0 || force) {
          const errors = this.compiler.errors;
          this.errors.forEach((error) => {
            const index = errors.indexOf(error);
            if (index >= 0) {
              errors.splice(index, 1);
            }
          });
          this.errors.length = 0;
          await this.parseStack();
          this.compiler.printLogInfo(`flush: ${this.file} errors: before ${len}, after:${this.errors.length}`, "compilation");
          this.compiler.dispatcher("onFlush", this);
          return true;
        } else {
          this.compiler.printLogInfo(`flush: ${this.file} (no errors)`, "compilation");
          return false;
        }
      }
      async parseStack() {
        if (!this.stack)
          return;
        this[symbolKey].cacheKey = Date.now();
        this.dispatcher("clear-cache");
        await this.callHookAsync("compilation.flush.parse.before");
        await this.stack.parserAsync();
      }
      checker() {
        if (!this.hasChecked) {
          this.hasChecked = true;
          if (this.stack) {
            this.children.forEach((child) => child.checker());
            this.stack.checker();
          }
        }
      }
      freeze() {
        if (!this.hasFreezed) {
          this.hasFreezed = true;
          if (this.stack && this.compiler.options.freeze) {
            this.stack.freeze();
            this.children.forEach((child) => child.freeze());
          }
        }
      }
      async batch(plugins, completed) {
        var task = plugins.length;
        const errors = [];
        plugins.forEach((plugin) => {
          process.nextTick((plugin2) => {
            const done = (error) => {
              task--;
              if (error) {
                errors.push(error);
              }
              if (task < 1) {
                if (completed && typeof completed === "function") {
                  completed(errors.length > 0 ? errors : null, this, plugins);
                }
              }
            };
            this.build(plugin2, done, true);
          }, plugin);
        });
      }
      async build(plugin, completed, flag = false) {
        if (typeof completed === "function") {
          this[symbolKey].waitCallback.push(completed);
        }
        if (!this[symbolKey].building) {
          this[symbolKey].building = true;
          const compilation = this;
          const done = (error, builder) => {
            this[symbolKey].building = false;
            this.compiler.dispatcher("onBuildDone", { error, plugin, builder, compilation });
            let callback = null;
            while (callback = this[symbolKey].waitCallback.shift()) {
              if (error && error instanceof Error) {
                callback(error, this, plugin, builder);
              } else {
                callback(null, this, plugin, builder);
              }
            }
          };
          try {
            await this.parserAsync();
            if (this.stack) {
              this.compiler.dispatcher("onBuildStart", { plugin, compilation });
              if (flag === true) {
                plugin.start(this, done);
              } else {
                plugin.build(this, done);
              }
            } else {
              done(new Error("Parser error. no stack."));
            }
          } catch (error) {
            done(error);
          }
        }
      }
      ready() {
        return new Promise((resolve, reject) => {
          const execute = async () => {
            let waitings = this._readyWaitings || (this._readyWaitings = []);
            if (this._readying) {
              waitings.push([resolve, reject]);
            } else {
              const queues = TaskCache.queues;
              const next = async (error) => {
                this._readying = false;
                while (waitings.length > 0) {
                  let [_resolve, _reject] = waitings.shift();
                  if (error) {
                    this.compiler.printLogInfo(`ready-execute-completed: error -> ${error.message} 
 ${error.stack} 
 by ${this.file}`, "compilation");
                    _reject(error);
                  } else {
                    this.compiler.printLogInfo(`ready-execute-completed: ${this.file}`, "compilation");
                    _resolve(this);
                  }
                }
                if (queues.length > 0) {
                  const task = queues.shift();
                  await task();
                } else {
                  TaskCache.waiting = false;
                  process.nextTick(() => {
                    if (!TaskCache.waiting) {
                      if (TaskCache.timeid) {
                        clearTimeout(TaskCache.timeid);
                      }
                      TaskCache.timeid = setTimeout(() => {
                        TaskCache.timeid = null;
                        this.compiler.dispatcher("onIdle");
                      }, 1e3);
                    }
                  });
                }
              };
              const processor = async () => {
                this._readying = true;
                let error = null;
                try {
                  if (!this.compiler.options.service) {
                    if (!this.isValid() || this.errors.some((error2) => error2.kind === Diagnostic.ERROR)) {
                      this.clear();
                    }
                  }
                  if (!this.parserDoneFlag) {
                    await this.parserAsync();
                  }
                  resolve(this);
                } catch (e) {
                  this.compiler.printLogInfo(`ready-execute-error: ${e.message} 
 ${e.stack} 
 by ${this.file}`, "compilation");
                  reject(error = e);
                } finally {
                  await next(error);
                }
              };
              queues.push(processor);
              if (!TaskCache.waiting) {
                TaskCache.waiting = true;
                const task = queues.shift();
                await task();
              }
            }
          };
          if (this.compiler.restartuping) {
            this.compiler.printLogInfo(`restartuping: ${this.file}`, "compilation");
            this.compiler.once("onRestartupDone", execute);
          } else {
            if (!this.compiler.initializeDone()) {
              this.compiler.once("initialized", execute);
            } else {
              execute();
            }
          }
        });
      }
    };
    var TaskCache = {
      queues: [],
      waiting: false
    };
    module.exports = Compilation;
  }
});

// lib/core/CompilationGroup.js
var require_CompilationGroup = __commonJS({
  "lib/core/CompilationGroup.js"(exports, module) {
    var Compilation = require_Compilation();
    var CompilationGroup = class extends Compilation {
      constructor(compiler, file) {
        super(compiler, file);
        const suffix = String(this.compiler.options.suffix || ".es");
        this.suffix = new RegExp(suffix.replace(".", "\\.") + "$", "i");
        this.isCompilationGroup = true;
        this._resolveCompilations = null;
      }
      createAst() {
        throw new TypeError(`Invalid methods for 'createModule'.`);
      }
      createModule() {
        throw new TypeError(`Invalid methods for 'createModule'.`);
      }
      createStack() {
        throw new TypeError(`Invalid methods for 'createStack'.`);
      }
      isValid() {
        return true;
      }
      clear(destroy = false) {
        if (this._resolveCompilations) {
          this._resolveCompilations.forEach((compilation) => compilation.clear(destroy));
        }
        this._resolveCompilations = null;
        this._createCompletedFlag = false;
        this._parserAsyncFlag = false;
        this.hasParsed = false;
      }
      async resolveCompilations() {
        if (this._resolveCompilations)
          return this._resolveCompilations;
        const compilations = this._resolveCompilations = [];
        const files = this.compiler.resolveFiles(this.file).filter((file) => this.compiler.checkFileExt(file));
        const results = await Promise.allSettled(files.map((file) => this.compiler.createCompilation(file, this.file, true, false, this)));
        const items = results.map((result) => result.value);
        await Promise.allSettled(items.map(async (compilation) => {
          if (compilation) {
            compilation.import = this.import;
            Object.assign(compilation.pluginScopes, this.pluginScopes);
            compilation.createStack();
            compilations.push(compilation);
          }
        }));
        return compilations;
      }
      parser() {
        throw new Error("CompilationGroup.parser is deprecated, please use parserAsync.");
      }
      async createCompleted() {
        if (this._createCompletedFlag)
          return;
        this._createCompletedFlag = true;
        const compilations = await this.resolveCompilations();
        await Promise.allSettled(compilations.map((compilation) => compilation.createCompleted()));
      }
      async parserAsync() {
        if (!this._parserAsyncFlag) {
          this._parserAsyncFlag = true;
          const compilations = await this.resolveCompilations();
          await Promise.allSettled(compilations.map((compilation) => compilation.createCompleted()));
          await Promise.allSettled(compilations.map((compilation) => compilation.parserAsync()));
        }
      }
      checker() {
        if (!this.hasChecked) {
          this.hasChecked = true;
          this.children.forEach((compilation) => compilation.checker());
        }
      }
      freeze() {
        if (!this.hasFreezed) {
          this.hasFreezed = true;
          this.children.forEach((compilation) => compilation.freeze());
        }
      }
    };
    module.exports = CompilationGroup;
  }
});

// lib/core/Manifester.js
var require_Manifester = __commonJS({
  "lib/core/Manifester.js"(exports, module) {
    var path = __require("path");
    var Namespace = require_Namespace();
    var Manifester = class {
      dataset = /* @__PURE__ */ Object.create(null);
      modules = /* @__PURE__ */ Object.create(null);
      datamap = /* @__PURE__ */ new Map();
      cache = /* @__PURE__ */ new Map();
      #compiler = null;
      constructor(compiler) {
        this.#compiler = compiler;
      }
      clear() {
        this.#compiler.printLogInfo(`clear manifester`, "manifester");
        this.datamap.clear();
        this.cache.clear();
        this.dataset = /* @__PURE__ */ Object.create(null);
        this.modules = /* @__PURE__ */ Object.create(null);
      }
      add(manifest, context) {
        if (context && (manifest.types || manifest.modules) && Array.isArray(manifest.files) && manifest.files.length > 0) {
          context = this.#compiler.normalizePath(context);
          this.#compiler.printLogInfo(`add: ${context}`, "manifester");
          if (!this.datamap.has(context)) {
            this.datamap.set(context, manifest);
            if (manifest.types) {
              const dataset = this.dataset;
              const value2 = [manifest, context];
              Object.keys(manifest.types).forEach((key) => {
                if (dataset[key]) {
                  const records = dataset[key][0].types[key];
                  const merges = records.merges || (records.merges = []);
                  merges.push(value2);
                } else {
                  dataset[key] = value2;
                }
              });
            }
            if (manifest.modules) {
              const dataset = this.modules;
              const value2 = [manifest, context];
              Object.keys(manifest.modules).forEach((key) => {
                if (dataset[key]) {
                  const records = dataset[key][0].modules[key];
                  const merges = records.merges || (records.merges = []);
                  merges.push(value2);
                } else {
                  dataset[key] = value2;
                }
              });
            }
          }
        } else {
          this.#compiler.printLogInfo(`Error: Add manifest is invalid. in folders the "${context}".`, "manifester");
        }
      }
      getFileinfo(id, recordsFlag = false, isModule = false) {
        let key = isModule ? "modules:" + id : "types:" + id;
        let records = this.cache.get(key);
        if (records)
          return records;
        const value2 = isModule ? this.modules[id] : this.dataset[id];
        this.#compiler.printLogInfo(`getFileinfo: isModule=${String(isModule)} id=${id} result:${Boolean(value2)}`, "manifester");
        if (value2) {
          const [manifest, context] = value2;
          if (manifest) {
            const inherits = [];
            const scope = manifest.scope.name;
            const files = this.getFiles(id, manifest, context, inherits, isModule);
            if (scope) {
              const index = inherits.indexOf(scope);
              if (index >= 0) {
                inherits.splice(index, 1);
              }
            }
            records = { files, scope, inherits };
            if (recordsFlag) {
              this.cache.set(key, records);
            }
            return records;
          }
        }
        return null;
      }
      hasResource(id, isModule = false) {
        if (isModule) {
          return !!this.modules[id];
        }
        return !!this.dataset[id];
      }
      getFiles(id, manifest, context, scopes = [], isModule = false) {
        const records = isModule ? manifest.modules[id] : manifest.types[id];
        if (records) {
          if (manifest.scope) {
            const names = [];
            if (manifest.scope.name)
              names.push(manifest.scope.name);
            if (manifest.scope.inherits && Array.isArray(manifest.scope.inherits)) {
              names.push(...manifest.scope.inherits);
            }
            names.forEach((name) => {
              if (!scopes.includes(name)) {
                scopes.push(name);
              }
            });
          }
          const files = records.indexers.map((index) => {
            const file = manifest.files[index];
            return path.isAbsolute(file) ? file : path.join(context, file);
          });
          if (records.merges) {
            const merges = records.merges.map(([manifest2, context2]) => this.getFiles(id, manifest2, context2, scopes, isModule));
            files.push(...merges);
          }
          this.#compiler.printLogInfo(`getFiles: scopes:${JSON.stringify(scopes)} 
 ${files.join(",\n")}`, "manifester");
          return files;
        } else {
          return [];
        }
      }
      resolveId(id, namespace) {
        if (Namespace.dataset === namespace)
          return id;
        if (this.dataset[id])
          return id;
        if (namespace && namespace.fullName) {
          if (String(id).includes("."))
            return id;
          const key = namespace.fullName + "." + id;
          if (this.dataset[key])
            return key;
        }
        return id;
      }
      hasRecords(id, isModule = false) {
        let key = isModule ? "modules:" + id : "types:" + id;
        return this.cache.has(key);
      }
      deleteRecords(id) {
        this.cache.delete(id);
      }
    };
    module.exports = Manifester;
  }
});

// lib/core/ScopeManager.js
var require_ScopeManager = __commonJS({
  "lib/core/ScopeManager.js"(exports, module) {
    var Utils = require_Utils();
    var ScopeManager = class {
      #cache = null;
      constructor(compiler) {
        this.compiler = compiler;
        this.configMaps = {};
        this.onlys = [];
        this.resolves = [];
        this.commons = [];
        this.configItems = [];
        this.initConfig();
      }
      clear() {
        this.configItems.splice(0, this.configItems.length);
        const clear = (target) => {
          Object.keys(target).forEach((key) => {
            delete target[key];
          });
        };
        clear(this.configMaps);
        this.commons.length = 0;
        this.resolves.length = 0;
        this.onlys.length = 0;
      }
      reset() {
        this.clear();
        this.initConfig();
      }
      getItem(target, name) {
        return target[name] || target[name + "s"];
      }
      setInherit(config) {
        const inherits = this.getItem(config, "inherit");
        if (inherits) {
          if (Array.isArray(inherits)) {
            config.inherits = inherits;
          } else if (typeof inherits === "string") {
            config.inherits = [inherits];
          } else {
            throw new Error("Scope config.inherit must is string or string[]");
          }
        } else {
          config.inherits = [];
        }
      }
      setResolve(config) {
        let resolves = this.getItem(config, "resolve");
        if (resolves) {
          if (!Array.isArray(resolves)) {
            resolves = [resolves];
          }
          resolves.forEach((test) => {
            if (!test || !(test instanceof RegExp)) {
              throw new Error("Scope config.resolve must is regexp");
            }
          });
          const name = config.name;
          resolves = resolves.map((test) => {
            return { test, name };
          });
          config.resolves = resolves;
          this.resolves.push(...resolves);
        } else {
          config.resolves = [];
        }
      }
      setCommon(config) {
        let commons = this.getItem(config, "common");
        if (commons) {
          if (!Array.isArray(commons)) {
            commons = [commons];
          }
          commons.forEach((test) => {
            if (!test || !(test instanceof RegExp)) {
              throw new Error("Scope config.common must is regexp");
            }
          });
          config.commons = commons;
          const getKey = (item2) => {
            let g = item2.global ? "g" : "";
            let i = item2.ignoreCase ? "i" : "";
            let m = item2.multiline ? "m" : "";
            return item2.source + g + i + m;
          };
          commons.forEach((item2) => {
            if (!this.commons.some((old) => getKey(old) === getKey(item2))) {
              this.commons.push(item2);
            }
          });
        } else {
          config.commons = [];
        }
      }
      getChains(config) {
        const cache = /* @__PURE__ */ new WeakSet();
        const find = (config2) => {
          if (cache.has(config2))
            return [];
          cache.add(config2);
          const items = config2.inherits.map((name) => {
            const config3 = this.configMaps[name];
            if (config3) {
              return find(config3);
            } else {
              return [name];
            }
          }).flat();
          items.unshift(config2.name);
          return items;
        };
        return find(config);
      }
      getPluginId(pluginName) {
        if (pluginName.includes("/") || pluginName.includes("\\")) {
          return pluginName.split(/[\\\/]+/).pop();
        }
        return pluginName;
      }
      initConfig() {
        const configs = this.compiler.options.scopes || [];
        configs.forEach((config) => {
          if (!config.name || typeof config.name !== "string") {
            throw new Error("Scope config rule.name must is string");
          } else {
            config = Object.create(config);
            config.name = this.getPluginId(config.name);
            this.configItems.push(config);
            this.setResolve(config);
            this.setInherit(config);
            this.setCommon(config);
            if (config.only === true) {
              this.onlys.push(config.name);
            }
            this.configMaps[config.name] = config;
          }
        });
        const plugins = this.compiler.options.plugins || [];
        plugins.forEach((plugin) => {
          if (plugin && plugin.options && plugin.options.context) {
            const context = plugin.options.context;
            const name = context.name || (plugin.name || plugin.plugin).toString();
            if (!name || typeof name !== "string") {
              throw new Error("Scope config.name must is string");
            } else {
              const config = Object.create(context);
              config.name = this.getPluginId(name);
              this.configItems.push(config);
              this.setResolve(config);
              this.setInherit(config);
              this.setCommon(config);
              if (config.only === true) {
                this.onlys.push(config.name);
              }
              this.configMaps[config.name] = config;
            }
          }
        });
        this.configItems.forEach((config) => {
          config.matching = this.getChains(config);
        });
        this.#cache = /* @__PURE__ */ Object.create(null);
      }
      rule(test, file) {
        if (typeof test === "string") {
          file.includes(test);
        } else if (test instanceof RegExp) {
          return test.test(file);
        }
        return test === file;
      }
      include(config, file) {
        const includes = this.getItem(config, "include");
        if (includes) {
          if (Array.isArray(includes)) {
            return includes.some((test) => this.rule(test, file));
          }
          return this.rule(includes, file);
        }
        return true;
      }
      exclude(config, file) {
        const excludes = this.getItem(config, "exclude");
        if (excludes) {
          if (Array.isArray(excludes)) {
            return excludes.some((test) => this.rule(test, file));
          }
          return this.rule(excludes, file);
        }
        return false;
      }
      getOnlyConfigs(file, exclude = null) {
        return this.configItems.filter((config) => {
          if (config === exclude || !config.only)
            return false;
          if (this.exclude(config, file)) {
            return false;
          }
          if (config.resolves.some((item2) => item2.test.test(file))) {
            return true;
          }
          return this.include(config, file);
        });
      }
      resolveConfigs(file) {
        return this.configItems.filter((config) => {
          if (this.exclude(config, file)) {
            return false;
          }
          return this.include(config, file);
        });
      }
      isCommonDocumentor(file) {
        return this.commons.some((item2) => item2.test(file));
      }
      resolveScopeName(file, defaultValue = null) {
        const resolve = this.resolves.find((item2) => item2.test.test(file));
        return resolve ? resolve.name : defaultValue;
      }
      findConfigs(name) {
        return this.configItems.filter((config) => {
          return config.name === name || config.inherits.includes(name);
        });
      }
      checkConfig(config, file) {
        if (this.exclude(config, file)) {
          return false;
        }
        if (config.resolves.some((item2) => item2.test.test(file))) {
          return true;
        }
        if (this.include(config, file) || config.commons.some((item2) => item2.test(file))) {
          const others = this.getOnlyConfigs(file, config);
          return !(others.length > 0);
        }
        return false;
      }
      checkDocumentor(name, compilation, globalResult = true) {
        if (Utils.isModule(compilation)) {
          compilation = compilation.compilation;
        }
        if (!Utils.isCompilation(compilation))
          return false;
        const scope = compilation.pluginScopes;
        if (!scope)
          return true;
        if (scope.scope === "global")
          return globalResult;
        const file = compilation.file;
        const key = name + ":" + file;
        if (Object.hasOwn(this.#cache, key)) {
          return this.#cache[key];
        }
        name = this.getPluginId(name);
        const configs = this.findConfigs(name);
        if (configs.length > 0) {
          return this.#cache[key] = configs.some((config) => {
            if (config.matching.includes(scope.scope)) {
              return true;
            } else {
              const inherits = this.getItem(scope, "inherit");
              if (inherits) {
                if (Array.isArray(inherits)) {
                  if (inherits.some((name2) => config.matching.includes(name2))) {
                    return true;
                  }
                } else if (config.matching.includes(inherits)) {
                  return true;
                }
              }
            }
            return this.checkConfig(config, file);
          });
        } else {
          const configs2 = this.resolveConfigs(file);
          if (configs2.length > 0) {
            return this.#cache[key] = configs2.some((config) => config.matching.includes(name));
          }
          return this.#cache[key] = true;
        }
      }
      checkDescriptor(descriptor, contextCompilation, globalResult = true) {
        if (!(Utils.isStack(descriptor) || Utils.isModule(descriptor)))
          return true;
        const ownerCompilation = descriptor.compilation;
        if (ownerCompilation === contextCompilation)
          return true;
        if (!Utils.isCompilation(ownerCompilation))
          return true;
        const scopes = ownerCompilation.pluginScopes || {};
        let scope = this.resolveScopeName(ownerCompilation.file, scopes.scope);
        if (scope === "global")
          return globalResult;
        if (this.isCommonDocumentor(contextCompilation.file)) {
          return this.isCommonDocumentor(ownerCompilation.file);
        }
        const file = contextCompilation.file;
        const configs = this.findConfigs(scope);
        if (configs.length > 0) {
          return configs.some((config) => {
            return this.checkConfig(config, file);
          });
        } else {
          const configs2 = this.resolveConfigs(file);
          if (configs2.length > 0) {
            return configs2.some((config) => this.checkConfig(config, ownerCompilation.file));
          }
          return true;
        }
      }
      checkScope(scopeName, contextCompilation, globalResult = true) {
        if (scopeName === "global")
          return globalResult;
        const configs = this.findConfigs(scopeName);
        if (configs.length > 0) {
          return configs.some((config) => {
            return this.checkConfig(config, contextCompilation.file);
          });
        }
        return true;
      }
      checkFile(file, contextCompilation, globalResult = true) {
        if (!file && typeof file !== "string")
          return true;
        let scope = this.resolveScopeName(file);
        if (scope === "global")
          return globalResult;
        if (this.isCommonDocumentor(contextCompilation.file)) {
          return this.isCommonDocumentor(file);
        }
        const configs = this.findConfigs(scope);
        if (configs.length > 0) {
          return configs.some((config) => {
            return this.checkConfig(config, contextCompilation.file);
          });
        } else {
          const configs2 = this.resolveConfigs(contextCompilation.file);
          if (configs2.length > 0) {
            return configs2.some((config) => this.checkConfig(config, file));
          }
          return true;
        }
      }
    };
    module.exports = ScopeManager;
  }
});

// lib/core/ResolveManager.js
var require_ResolveManager = __commonJS({
  "lib/core/ResolveManager.js"(exports, module) {
    var path = __require("path");
    var fs = __require("fs");
    var ResolveManager = class {
      #extensions = null;
      #resolveFolders = null;
      #comppiler = null;
      #regexp = null;
      #cache = null;
      #nodeModuleFolders = null;
      constructor(comppiler) {
        this.#comppiler = comppiler;
        this.init();
      }
      init() {
        let seg = /[\\|\/]+/;
        let workspaceFolders = this.#comppiler.getWorkspaceFolders();
        let resolveFolders = [
          workspaceFolders,
          workspaceFolders.map((dir) => path.dirname(dir)),
          this.#comppiler.options.resolvePaths
        ].flat().filter((dir) => this.isDir(dir)).map((dir) => path.normalize(dir));
        let extensions = this.#comppiler.options.extensions;
        let nameds = extensions.map((ext) => {
          return ext.startsWith(".") ? ext.substring(1) : ext;
        });
        this.#extensions = extensions.map((ext) => ext.startsWith(".") ? ext : "." + ext);
        this.#regexp = new RegExp(`\\.(${nameds.join("|")})$`);
        this.#resolveFolders = Array.from(new Set(resolveFolders).values()).sort((a, b) => {
          let a1 = a.split(seg).length;
          let b1 = b.split(seg).length;
          return a1 > b1 ? -1 : a1 < b1 ? 1 : 0;
        });
        this.#cache = /* @__PURE__ */ Object.create(null);
        this.#cache.resolve = /* @__PURE__ */ Object.create(null);
        this.#nodeModuleFolders = this.#comppiler.getNodeModuleFolders().map((dir) => path.normalize(dir));
      }
      isDir(dir) {
        if (dir && fs.existsSync(dir)) {
          return fs.statSync(dir).isDirectory();
        }
        return false;
      }
      setCache(key, value2, group = "resolve") {
        return this.#cache[group][key] = value2;
      }
      getCache(key, group = "resolve") {
        return this.#cache[group][key] || null;
      }
      hasCache(key, group = "resolve") {
        return Object.hasOwn(this.#cache[group], key);
      }
      getkey(...args) {
        return args.map((arg) => String(arg)).join("-");
      }
      checkExt(file) {
        if (!file || typeof file !== "string")
          return false;
        return this.#regexp.test(file);
      }
      normalizePath(file) {
        if (!file)
          return file;
        return path.sep === "\\" ? file.replace(/\\/g, "/") : file;
      }
      resolveSource(file, context = null) {
        return this.resolve(file, context, false, true, false);
      }
      resolveFile(file, context = null) {
        return this.resolve(file, context, false, false, false);
      }
      resovleAssets(file, context = null) {
        return this.resolve(file, context, true, false, false);
      }
      resovleDependency(file, context = null) {
        return this.resolve(file, context, false, true, true);
      }
      resolve(file, context = null, requireFlag = false, allowDir = true, dependency = true) {
        if (typeof file !== "string")
          return null;
        let key = this.getkey(file, context, requireFlag, allowDir, dependency);
        if (this.hasCache(key)) {
          return this.getCache(key);
        }
        if (context && typeof context === "string" && fs.existsSync(context)) {
          if (fs.statSync(context).isFile()) {
            context = path.dirname(context);
          } else if (!fs.statSync(context).isDirectory()) {
            context = null;
          }
        } else {
          context = null;
        }
        let value2 = this._resolve(file, context, requireFlag, allowDir);
        if (!value2 && dependency) {
          for (let folder of this.#nodeModuleFolders) {
            value2 = this._resolveFile(path.join(folder, file), false, true);
            if (value2) {
              break;
            }
          }
        }
        if (value2) {
          value2 = this.normalizePath(value2);
        }
        return this.setCache(key, value2);
      }
      _resolveFile(file, addSuffix = false, allowDir = false) {
        if (fs.existsSync(file)) {
          if (!path.isAbsolute(file)) {
            file = path.resolve(file);
          }
          if (allowDir) {
            return file;
          } else if (fs.statSync(file).isFile()) {
            return file;
          }
        }
        if (addSuffix) {
          for (let ext of this.#extensions) {
            let result = this._resolveFile(file + ext, false, allowDir) || this._resolveFile(file + ".d" + ext, false, allowDir);
            if (result) {
              return result;
            }
          }
        }
        return null;
      }
      _resolve(file, context = null, requireFlag = false, allowDir = false) {
        let hasSuffix = this.#regexp.test(file);
        if (path.isAbsolute(file)) {
          return this._resolveFile(file, !hasSuffix, allowDir);
        }
        if (context) {
          let result = this._resolveFile(path.join(context, file), !hasSuffix, allowDir);
          if (result)
            return result;
        }
        for (let folder of this.#resolveFolders) {
          let result = this._resolveFile(path.join(folder, file), !hasSuffix, allowDir);
          if (result)
            return result;
        }
        if (requireFlag) {
          try {
            return __require.resolve(file);
          } catch (e) {
          }
        }
        return null;
      }
    };
    module.exports = ResolveManager;
  }
});

// lib/core/Compiler.js
var require_Compiler = __commonJS({
  "lib/core/Compiler.js"(exports, module) {
    var Compilation = require_Compilation();
    var CompilationGroup = require_CompilationGroup();
    var mergeWith = __require("lodash/mergeWith");
    var path = __require("path");
    var cwd = process.cwd();
    var fs = __require("fs");
    var chokidar = __require("chokidar");
    var Utils = require_Utils();
    var Lang = require_Lang();
    var Manifester = require_Manifester();
    var dirname = __dirname;
    var compilations = /* @__PURE__ */ new Map();
    var EventDispatcher = require_EventDispatcher();
    var Diagnostic = require_Diagnostic();
    var Namespace = require_Namespace();
    var Cache = require_Cache();
    var ScopeManager = require_ScopeManager();
    var ResolveManager = require_ResolveManager();
    var Logger = require_Logger();
    var pluginInterfaces = [
      { name: "name", type: ["string"] },
      { name: "platform", type: ["string"] },
      { name: "version", type: ["string", "number"] },
      { name: "start", type: ["function"] },
      { name: "build", type: ["function"] },
      { name: "getGeneratedCodeByFile", type: ["function"] },
      { name: "getGeneratedSourceMapByFile", type: ["function"] },
      { name: "getTokenNode", type: ["function"] }
    ];
    var SharedInstances = [];
    var globalCompilations = /* @__PURE__ */ new Set();
    var cacheHandle = {
      pkg: Cache.group("pkg"),
      create: Cache.group("create"),
      load: Cache.group("load"),
      folder: Cache.group("folder"),
      appoint: Cache.group("appoint"),
      common: Cache.group("common")
    };
    function merge(...args) {
      return mergeWith(...args, (objValue, srcValue) => {
        if (Array.isArray(objValue) && Array.isArray(srcValue)) {
          if (srcValue[0] === null)
            return srcValue.slice(1);
          srcValue.forEach((value2) => {
            if (!objValue.includes(value2)) {
              objValue.push(value2);
            }
          });
          return objValue;
        }
      });
    }
    function defaultOptions() {
      const globalTypesPath = dirname.endsWith("dist") ? path.resolve(dirname, "types") : path.resolve(dirname, "../typing");
      return {
        throwError: false,
        debug: false,
        logger: {
          enable: false,
          outFile: true,
          outDir: ".es-client-log",
          outServiceDir: ".es-service-log",
          threshold: 60,
          service: false,
          formatDate: true,
          limitSize: 1024 * 1024 * 2
        },
        diagnose: true,
        workspace: "src",
        service: false,
        enableStackMap: false,
        enableComments: false,
        lang: "zh-CN",
        watch: false,
        suffix: ".es",
        plugins: [],
        types: [],
        scanFolders: [],
        cwd,
        scopes: [],
        metadata: {
          http: {
            responseField: null
          }
        },
        literalObjectStrict: false,
        freeze: false,
        watchFolders: [],
        watchOptions: {
          persistent: true,
          ignoreInitial: true,
          ignored: /(^|[\/\\])\../,
          depth: 0
        },
        esc: null,
        annotations: [
          "Provider",
          "Callable",
          "Runtime",
          "Syntax",
          "Env",
          "Router",
          "Post",
          "Get",
          "Delete",
          "Put",
          "Option",
          "Deprecated",
          "Define",
          "Internal",
          "Alias",
          "Override",
          "Dynamic",
          "Embed",
          "SkinClass",
          "Abstract",
          "WebComponent",
          "HostComponent",
          "Require",
          "Required",
          "Import",
          "Main",
          "Reference",
          "DOMAttribute",
          "Injector",
          "Reactive",
          "Hook",
          "URL",
          "Http",
          "Version",
          "Removed",
          "Noop",
          "Bindding"
        ],
        jsx: {
          componentClass: "web.components.Component",
          skinClass: "web.components.Skin",
          slot: {
            "scopeName": "scope",
            "scopeValue": "scope"
          },
          xmlns: {
            sections: {
              "@directives": ["if", "elseif", "else", "for", "each", "show", "custom"],
              "@events": ["*"],
              "@natives": ["*"],
              "@slots": ["*"],
              "@binding": ["*"]
            },
            context: ["for", "each"],
            default: {
              "e": "@events",
              "s": "@slots",
              "d": "@directives",
              "b": "@binding",
              "n": "@natives",
              "u": "web.ui",
              "on": "@events",
              "slot": "@slots",
              "bind": "@binding",
              "native": "@natives",
              "directive": "@directives",
              "ui": "web.ui"
            }
          }
        },
        metaStatementMethods: ["Runtime", "Syntax", "Env", "Version"],
        excludeDescribeFile: [],
        require: {},
        commandLineEntrance: false,
        loadGlobalDescribeFile: true,
        scanTypings: true,
        autoLoadDescribeFile: true,
        describePattern: /(\.d\.es)$/,
        describeSuffix: ".d.es",
        resolvePaths: [],
        references: [],
        extensions: [".es", ".ease"],
        configFileName: "es.config",
        configFileExtensions: [".json", ".js", ".mjs", ".cjs"],
        manifestFileName: "typings.json",
        globalTypes: [globalTypesPath],
        fileQueryParamFieldMap: {
          "id": "id",
          "type": "type",
          "file": "file"
        },
        resourceQueryOrder: [
          { test: /^file\./, order: -1 }
        ],
        parser: {
          sourceType: "module",
          locations: false,
          preserveParens: true,
          ecmaVersion: 12,
          reserved: ["global"]
        },
        checker: {
          effect: true,
          references: {
            exactly: true,
            noNullable: true
          }
        }
      };
    }
    var __compiler = null;
    var Compiler = class extends EventDispatcher {
      static is(value2) {
        return value2 ? value2 instanceof Compiler : false;
      }
      static getCompilations() {
        return compilations;
      }
      static getCompilers() {
        return SharedInstances;
      }
      static compiler() {
        return __compiler || (__compiler = new Compiler());
      }
      constructor(options = {}) {
        super();
        this.rawOptions = options;
        this.compilations = compilations;
        this.globals = globalCompilations;
        this.main = [];
        this.regexpSuffix = /\.[a-zA-Z]+$/;
        this.filesystem = /* @__PURE__ */ new Map();
        this.grammar = /* @__PURE__ */ new Map();
        this.errors = [];
        this.utils = Utils;
        this.restartuping = false;
        this.configFileRecords = null;
        this.resolveConfigFile = null;
        this.diagnostic = Diagnostic;
        this.pluginInstances = [];
        this.watchers = [];
        this.disconnected = false;
        this.initQueues = [];
        this.parseOptions(options);
        this.scopeManager = new ScopeManager(this);
        this.manifester = new Manifester(this);
        this.resolveManager = new ResolveManager(this);
        this.logger = new Logger(this);
        SharedInstances.push(this);
        process.on("exit", () => {
          this.dispose();
        });
      }
      isDescriptorFile(file) {
        if (!file || typeof file !== "string")
          return false;
        const describePattern = this.options.describePattern || /(\.d\.es)$/;
        return describePattern.test(file);
      }
      isExtensionFile(file) {
        return this.extensionRegexp.test(String(file));
      }
      isExtensionName(ext) {
        let _ext = String(ext);
        return this.options.extensions.some((ext2) => {
          if (_ext === ext2)
            return true;
          let name = _ext.startsWith(".") ? _ext.substring(1) : _ext;
          return ext2.startsWith(".") ? ext2.substring(1) === name : name === ext2;
        });
      }
      checkFileExt(file) {
        if (!file)
          return false;
        return this.isExtensionFile(file);
      }
      clearAddDirFileCache(file) {
        Cache.each((key, cache) => {
          if (cache.name === "global") {
            return;
          }
          key = String(key).toLowerCase();
          if (key.includes(file)) {
            cache.clear(key);
          }
        });
      }
      addWatch() {
        let fsWatcher = this.fsWatcher;
        if (!fsWatcher) {
          fsWatcher = this.createWatcher(merge(
            {},
            this.options.watchOptions,
            { depth: 0 }
          ));
          if (!fsWatcher) {
            throw new Error("Watcher create failed.");
          } else {
            this.fsWatcher = fsWatcher;
          }
        }
        let watchFolders = [];
        let timeoutId = null;
        let workspacePaths = this.getWorkspaceFolders();
        if (Array.isArray(this.options.watchFolders)) {
          watchFolders.push(...this.options.watchFolders);
        }
        const cache = {};
        const resolvePath = (dir, wfs2) => {
          return path.isAbsolute(dir) ? dir : this.resolveManager.resolveSource(dir, wfs2.options?.cwd);
        };
        const addDirs = [];
        const addDir = (wfs2) => (dir) => {
          if (dir) {
            if (cache[dir])
              return;
            cache[dir] = true;
            dir = resolvePath(dir, wfs2);
            const key = this.normalizePath(dir).toLowerCase();
            this.clearAddDirFileCache(key);
            if (key.includes("/node_modules/")) {
              addDirs.push(dir);
              if (timeoutId) {
                clearTimeout(timeoutId);
              }
              timeoutId = setTimeout(() => {
                timeoutId = null;
                const dirs = addDirs.splice(0, addDirs.length);
                this.scanTypings(dirs, false).then(async (dataset) => {
                  const result = await this.doLoadPluginTypes(dataset);
                  if (result && Array.isArray(result) && result.length > 0) {
                    this.dispatcher("onAddDirCompilationDone", result.flat(), true);
                    this.printLogInfo(`addDirOrFiles: ${result.flat().join("\n")}`, "watcher");
                  }
                });
              }, 2e3);
            }
          }
        };
        const unlinkDir = (wfs2) => (dir) => {
          if (dir) {
            delete cache[dir];
            dir = resolvePath(dir, wfs2);
            dir = this.normalizePath(dir).toLowerCase();
            const removed = [];
            let check = false;
            this.compilations.forEach((compilation) => {
              if (String(compilation.file).toLowerCase().includes(dir)) {
                if (!check) {
                  check = compilation.isDescriptorDocument();
                }
                this.removeCompilation(compilation, true);
                removed.push(compilation);
              }
            });
            if (removed.length > 0) {
              this.dispatcher("onUnlinkDirCompilationDone", removed, check);
              this.printLogInfo(`unlinkDir: ${removed.join("\n")}`, "watcher");
            }
          }
        };
        fsWatcher.on("unlink", (file2) => {
          file2 = resolvePath(file2, fsWatcher);
          this.printLogInfo(`unlink: ${file2}`, "watcher");
          const compi = this.removeCompilation(file2, true);
          if (compi) {
            this.dispatcher("onUnlinkCompilationDone", compi);
          } else {
            this.printLogInfo(`unlink: ${file2} (remove compilation is null)`, "watcher");
          }
        });
        if (watchFolders.length > 0) {
          watchFolders = Array.from(new Set(watchFolders.map((dir) => {
            if (!path.isAbsolute(dir) && !dir.includes("*")) {
              dir = path.join(process.cwd(), dir);
            }
            return this.normalizePath(dir);
          })).values());
          fsWatcher.add(watchFolders.filter((folder) => !workspacePaths.some((src) => folder.includes(src)))).on("addDir", addDir(fsWatcher)).on("unlinkDir", unlinkDir(fsWatcher));
        }
        const wfs = this.createWatcher(null, 20);
        const addCompilations = /* @__PURE__ */ new Map();
        workspacePaths.forEach((folder) => {
          wfs.add(folder);
        });
        wfs.on("addDir", addDir(wfs)).on("unlinkDir", unlinkDir(wfs)).on("add", (file2) => {
          file2 = resolvePath(file2, wfs);
          if (this.checkFileExt(file2)) {
            this.printLogInfo(`add: ${file2}`, "watcher");
            this.createCompilation(file2).then(async (compi) => {
              if (compi) {
                addCompilations.set(file2, compi);
                await compi.ready();
                this.dispatcher("onAddCompilationDone", compi);
              } else {
                this.printLogInfo(`createCompilation: ${file2} (null)`, "watcher");
              }
            });
          }
        }).on("change", async (file2) => {
          file2 = resolvePath(file2, wfs);
          let compi = this.getCompilation(file2);
          if (compi) {
            if (!compi.isDestroyed) {
              await compi.ready();
            }
          }
        });
        let file = this.resolveConfigFile;
        if (file) {
          let timerId = null;
          file = this.normalizePath(file);
          fsWatcher.add(file).on("change", (changed) => {
            changed = this.normalizePath(resolvePath(changed, fsWatcher));
            if (file !== changed) {
              return;
            }
            if (timerId) {
              clearTimeout(timerId);
            }
            this.printLogInfo(`configFileChange -> ${changed}`, "watcher");
            timerId = setTimeout(() => {
              if (!this.disconnected) {
                this.onConfigFileChanged(file);
              }
              timerId = null;
            }, 1e3);
          });
        }
      }
      createWatcher(options, depth = 0) {
        options = options || {
          persistent: true,
          ignoreInitial: true,
          ignored: /(^|[\/\\])\../,
          depth
        };
        const wfs = new chokidar.FSWatcher(options);
        this.watchers.push(wfs);
        return wfs;
      }
      dispose() {
        this.disconnected = true;
        this.watchers.forEach((wfs) => {
          wfs.close();
        });
        this.watchers.length = 0;
      }
      callUtils(name, ...args) {
        const fun = Utils[name];
        return fun ? fun.apply(Utils, args) : false;
      }
      printLogInfo(info, group = "") {
        this.logger.print(info, group);
      }
      markMemoryUsage(key) {
        this.logger.mark(key);
      }
      getMemoryUsage(key) {
        return this.logger.getMemoryUsage(key);
      }
      getTotalMemoryUsage() {
        return this.logger.getTotalMemoryUsage();
      }
      getEscOptions(options = {}) {
        const loaders = {};
        const loaderConfig = {
          text: [".html", ".xml", ".txt", ".svg", ".svgz"],
          json: [".json"],
          file: [".eot", ".ttf", ".woff", ".woff2"],
          js: [".js", ".mjs", ".cjs"],
          css: [".css", ".less", ".sass", ".scss"],
          dataurl: [".png", ".gif", ".jpeg", ".jpg", ".bmp", ".webp"]
        };
        Object.keys(loaderConfig).forEach((name) => {
          const extensions = loaderConfig[name];
          extensions.forEach((ext) => {
            loaders[ext] = name;
          });
        });
        const base64Suffixes = {};
        [".gif", ".png", ".jpg", ".jpeg", ".bmp"].forEach((key) => {
          base64Suffixes[key] = true;
        });
        return merge({
          watch: false,
          treeShaking: true,
          assets: {
            base64Suffixes,
            base64Callback: (file, extname = null) => {
              if (file) {
                const suffixes = this.options.esc.assets.base64Suffixes || {};
                return !!suffixes[(extname || path.extname(file)).toLowerCase()];
              }
              return false;
            }
          },
          resolve: {
            alias: {},
            extensions: [".es", ".mjs", ".cjs", ".js", ".jsx"],
            paths: []
          },
          styles: {
            preprocess: {}
          },
          loaders,
          typingOptions: {
            dirname: "types",
            byFile: true
          },
          define: {},
          splitting: false
        }, options);
      }
      parseConfigFile(options = {}) {
        if (!options.configFileName || !options.configFileExtensions)
          return options;
        const name = options.configFileName;
        const extensions = options.configFileExtensions || [];
        const file = extensions.concat(path.join(options.cwd, name)).map((ext) => path.join(options.cwd, name + ext)).find((file2) => fs.existsSync(file2));
        if (!file)
          return options;
        const data = this.loadConfigFile(file);
        if (data) {
          return merge(options, data);
        }
        return options;
      }
      parseOptions(assignmentOptions = {}) {
        let options = merge(this.parseConfigFile(defaultOptions()), assignmentOptions);
        let cwd2 = options.cwd;
        if (!fs.existsSync(cwd2)) {
          cwd2 = process.cwd();
          Utils.error(`options.cwd dirname is not exists.`);
        }
        if (options.output) {
          options.output = this.pathAbsolute(options.output);
        } else {
          options.output = path.resolve(cwd2, "build");
        }
        Lang.setLangId(String(options.lang).toLowerCase() === "zh-cn" ? 0 : 1);
        options.workspace = path.isAbsolute(options.workspace) ? options.workspace : path.resolve(cwd2, options.workspace);
        if (!fs.existsSync(options.workspace)) {
          if (options.workspace !== "src") {
            let resolvePath = path.join(cwd2, "src");
            if (fs.existsSync(resolvePath)) {
              options.workspace = resolvePath;
            } else {
              options.workspace = cwd2;
            }
          } else {
            options.workspace = cwd2;
          }
        }
        if (!fs.existsSync(options.workspace)) {
          Utils.error(`options.workspace dirname is not exists.`);
        }
        options.workspace = this.normalizePath(options.workspace);
        if (options.service) {
          options.enableComments = true;
        } else {
          options.esc = this.getEscOptions(options.esc);
        }
        this.options = options;
        this.suffix = options.suffix;
        this.workspace = options.workspace;
        let extensions = this.options.extensions.map((ext) => {
          return ext.startsWith(".") ? ext.substring(1) : ext;
        });
        this.extensionRegexp = new RegExp(`\\.(${extensions.join("|")})($|\\?)`);
        return options;
      }
      setWorkspace(dist) {
        this.workspace = this.normalizePath(path.isAbsolute(dist) ? dist : path.resolve(this.options.cwd || cwd, dist));
        this.options.workspace = this.workspace;
        return this;
      }
      getWorkspaceFolder(context, name, depth = 1) {
        const exclude = ["node_modules"];
        const files = (Utils.readdir(context) || []).map((file) => {
          return file.charCodeAt(0) !== 46 && !exclude.includes(file) && fs.statSync(path.join(context, file)).isDirectory();
        });
        const absolutes = files.map((file) => path.join(context, file));
        var i = 0;
        for (; i < absolutes.length; i++) {
          const dirname2 = path.join(absolutes[i], name);
          if (fs.existsSync(dirname2)) {
            return dirname2;
          }
        }
        if (depth < 3) {
          i = 0;
          for (i = 0; i < absolutes.length; i++) {
            const dirname2 = this.getWorkspaceFolder(absolutes[i], name, depth++);
            if (dirname2) {
              return dirname2;
            }
          }
        }
        return null;
      }
      getWorkspaceFolders() {
        if (cacheHandle.common.has("getWorkspaceFolders")) {
          return cacheHandle.common.get("getWorkspaceFolders");
        }
        let references = this.options.references || [];
        let result = this.workspace ? [this.workspace] : [];
        if (references.length > 0) {
          let workspace = this.options.workspace || "src";
          let cwd2 = this.options.cwd;
          if (path.isAbsolute(workspace)) {
            workspace = path.basename(workspace);
          }
          let _result = references.map((name) => {
            const folder = path.join(cwd2, name, workspace);
            if (fs.existsSync(folder)) {
              return this.normalizePath(folder);
            }
            return null;
          }).filter(Boolean);
          if (_result.length > 0) {
            result = _result;
          }
        }
        cacheHandle.common.set("getWorkspaceFolders", result);
        return result;
      }
      getNodeModuleFolders() {
        if (cacheHandle.common.has("getNodeModuleFolders")) {
          return cacheHandle.common.get("getNodeModuleFolders");
        }
        let references = this.options.references || [];
        let cwd2 = this.options.cwd;
        let result = [this.options.cwd, ...references].map((dir) => {
          if (!path.isAbsolute(dir)) {
            dir = path.join(cwd2, dir, "node_modules");
          } else {
            dir = path.join(dir, "node_modules");
          }
          return fs.existsSync(dir) ? this.normalizePath(dir) : null;
        }).filter(Boolean);
        let value2 = Array.from(new Set(result).values());
        cacheHandle.common.set("getNodeModuleFolders", value2);
        return value2;
      }
      async restartup() {
        const time = Date.now();
        this.restartuping = true;
        this.dispatcher("onRestartupBefore");
        this.printLogInfo(`restartup before`, "compiler");
        await this.clear();
        this.logger.init(this);
        this.watchers.forEach((wfs) => {
          wfs.close();
        });
        if (this.options.service || this.options.watch) {
          this.addWatch();
        }
        await this.__loadGlobalTypes();
        await this.__loadPluginTypes();
        this.restartuping = false;
        this.printLogInfo(`restartup after (${Date.now() - time} ms)`, "compiler");
        this.dispatcher("onRestartupAfter");
      }
      async clear() {
        Namespace.clearAll();
        Cache.clearAll();
        this.errors.splice(0, this.errors.length);
        this.manifester.clear();
        this.scopeManager.reset();
        this.compilations.forEach((compi) => {
          compi.destory();
        });
        this.compilations.clear();
        this.globals.clear();
      }
      compareChanged(oldValue, newValue) {
        const hasOwn = Object.prototype.hasOwnProperty;
        const compare = (oldValue2, newValue2) => {
          const oldType = Array.isArray(oldValue2) ? "array" : typeof oldValue2;
          const newType = Array.isArray(newValue2) ? "array" : typeof newValue2;
          if (oldValue2 && oldType === "object") {
            if (newType !== "object")
              return true;
            return Object.keys(oldValue2).some((key) => {
              if (!hasOwn.call(newValue2, key))
                return true;
              return compare(oldValue2[key], newValue2[key]);
            });
          } else if (oldValue2 && oldType === "array") {
            if (newType !== "array")
              return true;
            if (oldValue2.length !== newValue2.length)
              return true;
            const _oldValue = oldValue2.slice(0).sort();
            const _newValue = newValue2.slice(0).sort();
            return _oldValue.some((old) => {
              return !_newValue.some((value2) => !compare(old, value2));
            });
          } else {
            if (newType !== oldType)
              return true;
            if (newType === "function") {
              return false;
            }
            return String(oldValue2) != String(newValue2);
          }
        };
        return compare(oldValue, newValue);
      }
      onConfigFileChanged(file) {
        const records = this.configFileRecords;
        const oldSource = records.source;
        const newSource = fs.readFileSync(file, { encoding: "utf-8" }).toString();
        if (oldSource === newSource)
          return;
        if (oldSource.replace(/[\r\n\s\t]+/g, "") === newSource.replace(/[\r\n\s\t]+/g, ""))
          return;
        records.source = newSource;
        records.prevent = false;
        this.dispatcher("onConfigChangeBefore", records);
        if (!records.prevent) {
          this.parseOptions(this.rawOptions);
          this.dispatcher("onConfigChanged");
          this.restartup();
        }
      }
      loadConfigFile(file) {
        try {
          const records = this.configFileRecords;
          const id = __require.resolve(file);
          delete __require.cache[id];
          const config = __require(id);
          let data = config === "function" ? config(this) : config;
          this.resolveConfigFile = file;
          if (Object.prototype.toString.call(data) !== "[object Object]") {
            data = {};
            console.error(`config file export data type can only is object. in '${file}'`);
          }
          if (records) {
            records.data = data;
          } else {
            const source = fs.readFileSync(file, { encoding: "utf-8" }).toString();
            this.configFileRecords = {
              file,
              data,
              source
            };
          }
          return data;
        } catch (e) {
          console.error(`${e.message} in '${file}'`);
          return null;
        }
      }
      getOutputFileSystem(syntax) {
        if (this.options.service)
          return;
        return {};
      }
      getInputFileSystem() {
        if (this.options.service)
          return;
        return {};
      }
      resolve(file, context) {
        let isLocal = file.charCodeAt(0) === 64;
        if (isLocal)
          file = file.substr(1);
        if (isLocal) {
          file = this.resolveManager.resolve(file, context);
          if (file) {
            file = this.normalizePath(file);
          }
          return null;
        }
        file = this.resolveManager.resolve(file, context, true);
        if (file) {
          file = this.normalizePath(file);
        }
        return file;
      }
      normalizeModuleFile(moduleOrCompilation, id, type2, resolveFile, attrs = null) {
        const file = this.normalizePath(moduleOrCompilation.file);
        const isModule = moduleOrCompilation.isModule && moduleOrCompilation.isType;
        if (moduleOrCompilation.require && isModule) {
          return file;
        }
        const segments = [];
        const compilation = isModule ? moduleOrCompilation.compilation : moduleOrCompilation;
        if (!id && isModule && compilation.modules && compilation.modules.size > 1) {
          if (compilation.isDescriptorDocument()) {
            id = moduleOrCompilation.getName();
          } else {
            const modules = Array.from(compilation.modules.values()).filter((module2) => !module2.isDeclaratorModule);
            if (modules.length > 1) {
              id = moduleOrCompilation.getName();
            }
          }
        }
        const map = this.options.fileQueryParamFieldMap || {};
        if (attrs && typeof attrs === "object") {
          const excludes = { id, type: type2, file: resolveFile };
          Object.keys(attrs).forEach((key) => {
            if (excludes[key])
              return;
            if (attrs[key]) {
              segments.push(`${key}=${attrs[key]}`);
            } else {
              segments.push(key);
            }
          });
        }
        if (id)
          segments.push(`${map.id || "id"}=${id}`);
        if (type2)
          segments.push(`${map.type || "type"}=${type2}`);
        segments.sort((a, b) => {
          if (!a.includes("=") && b.includes("="))
            return -1;
          if (!b.includes("=") && a.includes("="))
            return 1;
          return a.localeCompare(b);
        });
        if (resolveFile)
          segments.push(`${map.file || "file"}=${resolveFile}`);
        return segments.length > 0 ? `${file}?${segments.join("&")}` : file;
      }
      resolveExtFormat(file, extformat) {
        if (typeof extformat === "string") {
          let info = path.parse(file);
          let extname = extformat.replace("{extname}", info.ext);
          return Utils.normalizePath(path.join(info.dir, info.name + extname));
        } else {
          throw new Error("Invalid extformat. must is string type");
        }
      }
      parseResourceId(module2, query = {}, extformat = null) {
        const isModule = Utils.isTypeModule(module2);
        const compilation = isModule ? module2.compilation : module2;
        let file = Utils.normalizePath(module2.file);
        if (!compilation || !file) {
          throw new Error("Invalid module or compilation");
        }
        if (extformat) {
          file = this.resolveExtFormat(file, extformat);
        }
        if (!query.id && isModule && compilation.modules && compilation.modules.size > 1) {
          if (compilation.mainModule !== module2) {
            query.id = module2.getName();
          }
        }
        const segments = [];
        const orderMaps = {};
        const orders = this.options.resourceQueryOrder || [];
        Object.keys(query).forEach((key) => {
          let value2 = key;
          if (query[key] != null && query[key] !== true) {
            const val = String(query[key]).trim();
            if (val) {
              value2 = `${key}=${val}`;
            }
          }
          let res = orders.find((item2) => item2.test.test(value2));
          orderMaps[value2] = res ? res.order : 0;
          segments.push(value2);
        });
        const len = segments.length;
        if (len > 1) {
          segments.sort((a, b) => {
            let aa = orderMaps[a];
            let bb = orderMaps[b];
            if (aa < 0)
              aa = len + aa;
            if (bb < 0)
              bb = len + bb;
            if (aa > bb)
              return 1;
            if (aa < bb)
              return -1;
            if (!a.includes("="))
              return -1;
            return a.localeCompare(b);
          });
        }
        return segments.length > 0 ? `${file}?${segments.join("&")}` : file;
      }
      normalizePath(file) {
        if (!file)
          return file;
        if (file.includes("\\")) {
          return path.sep === "\\" ? file.replace(/\\/g, "/") : file;
        }
        return file;
      }
      getFileAbsolute(file, context, flagSuffix = true, checkNodeModules = true) {
        return this.resolveManager.resolveSource(file, context);
      }
      resolveDescriptorFile(source, context) {
        const describeSuffix = this.options.describeSuffix;
        if (describeSuffix && !source.endsWith(describeSuffix)) {
          if (context) {
            const at = context.lastIndexOf("/");
            const basename = context.slice(at + 1);
            if (basename === source + describeSuffix) {
              return null;
            }
          }
          return this.resolveManager.resolveFile(
            source + describeSuffix,
            context
          );
        }
        return this.resolveManager.resolveFile(source, context);
      }
      getRelativeWorkspace(file) {
        if (file) {
          file = this.normalizePath(file);
          const folders = this.getWorkspaceFolders();
          for (let folder of folders) {
            if (file.includes(folder)) {
              return path.relative(folder, file);
            }
          }
        }
        return null;
      }
      getFileNamespace(file) {
        file = this.resolveManager.resolveFile(file);
        if (file) {
          file = this.getRelativeWorkspace(file);
          if (file) {
            return path.dirname(file).split(/[\\\/]+/).join(".");
          }
        }
        return null;
      }
      getFileClassName(file, isFull = false) {
        file = this.resolveManager.resolveFile(file);
        if (file) {
          if (isFull) {
            let paths = this.getRelativeWorkspace(file);
            if (paths) {
              const dirname2 = path.dirname(paths);
              const basename = path.basename(paths);
              const index = basename.indexOf(".");
              const name = basename.substring(0, index);
              return [...dirname2.split(/[\\\/]+/), name].join(".");
            }
          } else {
            file = path.basename(file);
            const index = file.indexOf(".");
            return file.substring(0, index);
          }
        }
        return null;
      }
      resolveFiles(folder, depth = -1) {
        const files = [];
        const resolve = (file, existed = false, index = 0) => {
          if (existed || file && fs.existsSync(file)) {
            const stat = fs.statSync(file);
            if (stat.isDirectory()) {
              if (depth < 0 || depth > index) {
                (Utils.readdir(file, true) || []).forEach((file2) => {
                  resolve(file2, true, index + 1);
                });
              }
            } else if (stat.isFile()) {
              files.push(file);
            }
          }
          return files;
        };
        return resolve(folder);
      }
      getRelativeWorkspacePath(file, flag = false) {
        const folders = this.getWorkspaceFolders();
        let value2 = null;
        if (folders.length === 1) {
          value2 = Utils.normalizePath(path.relative(folders[0], file));
        } else {
          value2 = folders.map((folder) => path.relative(folder, file)).filter((a, b) => {
            let a1 = a.startsWith("..") ? 1 : 0;
            let b1 = b.startsWith("..") ? 1 : 0;
            if (a1 > 0) {
              a1 = a.split("..").length;
            }
            if (b1 > 0) {
              b1 = b.split("..").length;
            }
            return a1 - b1;
          })[0];
        }
        if (flag && value2 && value2.includes("..")) {
          return null;
        }
        return Utils.normalizePath(value2 || file);
      }
      resolveRuleFiles(rulePath, ignoreCase = true) {
        if (rulePath.includes("*")) {
          const segs = rulePath.split(/[\\\/]+/);
          const filter = (files, prefix) => {
            if (files.length > 0) {
              const parttern = segs.map((rule2) => {
                if (rule2 === "*")
                  return "(\\w+)";
                if (rule2 === "**")
                  return "(.+?)";
                if (rule2.startsWith("*"))
                  return rule2.replaceAll("*", "(\\w+)");
                return rule2;
              });
              if (prefix)
                parttern.unshift("(" + prefix.join("|") + ")");
              const rule = new RegExp(parttern.join("[\\\\\\/]"), ignoreCase ? "i" : "");
              return files.filter((file) => rule.test(file));
            }
            return files;
          };
          if (rulePath.startsWith("*")) {
            const folders = this.getWorkspaceFolders();
            return filter(folders.map((folder) => {
              return this.resolveFiles(folder);
            }).flat(), folders.map((folder) => path.basename(folder)));
          } else {
            const index = segs.findIndex((item2) => item2 == "*" || item2 == "**");
            const ends = segs.length - 1 === index;
            if (ends) {
              const resolveFile = this.resolveManager.resolveSource(path.dirname(rulePath));
              if (resolveFile) {
                return this.resolveFiles(resolveFile, rulePath.endsWith("**") ? -1 : 1);
              }
            } else {
              const baseDir = this.resolveManager.resolveSource(segs.slice(0, index).join("/"));
              if (baseDir) {
                return filter(this.resolveFiles(baseDir));
              }
            }
          }
        } else {
          const baseDir = this.resolveManager.resolveSource(path.dirname(rulePath));
          if (baseDir) {
            const basename = path.basename(rulePath);
            const files = this.resolveFiles(baseDir, 1);
            return files.filter((file) => {
              return path.basename(file).startsWith(basename);
            });
          }
        }
        return [];
      }
      pathAbsolute(file) {
        return this.normalizePath(path.isAbsolute(file) ? path.resolve(file) : path.resolve(cwd, file));
      }
      removeCompilation(file, flag = false) {
        if (!file)
          return false;
        let compilation = file;
        let rawFile = file;
        let id = null;
        if (typeof file === "string") {
          if (flag) {
            file = this.normalizePath(file);
          } else {
            file = this.resolveManager.resolveSource(file);
          }
          if (file) {
            id = this.getResourceId(file);
            compilation = this.compilations.get(id);
          }
        }
        this.printLogInfo(`removeCompilation: ${rawFile} result:${Utils.isCompilation(compilation)}`, "compiler");
        if (Utils.isCompilation(compilation)) {
          this.dispatcher("onRemoveCompilationBefore", compilation);
          compilation.dispatcher("onRemoved");
          if (id == null) {
            id = this.getResourceId(compilation.file);
          }
          if (id) {
            this.compilations.delete(id);
          }
          compilation.isDestroyed = true;
          compilation.clear();
          return compilation;
        }
        return false;
      }
      getResourceId(resourcePath) {
        resourcePath = String(this.normalizePath(resourcePath)).toLowerCase();
        if (resourcePath.includes("/node_modules/")) {
          return resourcePath.split("/node_modules/").pop();
        } else {
          return resourcePath;
        }
      }
      getCompilation(file, context) {
        file = this.resolveManager.resolveSource(file, context);
        if (file) {
          return this.getCompilationByFile(file);
        }
        return null;
      }
      getCompilationByFile(file) {
        const resourceId = this.getResourceId(file);
        return this.compilations.get(resourceId) || null;
      }
      hasCompilation(file, context) {
        file = this.resolveManager.resolveSource(file, context);
        if (file) {
          const resourceId = this.getResourceId(file);
          return this.compilations.has(resourceId);
        }
        return false;
      }
      async createCompilation(file, context = null, flag = false, isRoot = false, parentCompilation = null) {
        const originFile = file;
        file = this.resolveManager.resolveSource(file, context);
        if (file) {
          const resourceId = this.getResourceId(file);
          if (this.compilations.has(resourceId)) {
            return this.compilations.get(resourceId);
          }
          const isGroup = isRoot ? fs.statSync(file).isDirectory() : false;
          const compilation = isGroup ? new CompilationGroup(this, file) : new Compilation(this, file);
          this.compilations.set(resourceId, compilation);
          compilation.originFile = originFile;
          if (!file.includes("/node_modules/")) {
            const inWorkspace = this.getWorkspaceFolders().some((ws) => file.includes("/" + path.basename(ws) + "/"));
            if (inWorkspace) {
              compilation.pluginScopes.scope = "local";
              compilation.pluginScopes.inherits = [];
            }
            if (this.options.service || this.options.watch) {
              if (this.fsWatcher) {
                this.fsWatcher.add(file);
              }
            }
          }
          if (!flag && !isGroup && this.options.autoLoadDescribeFile && !compilation.isDescriptionType) {
            await this.loadDescriptorFiles(path.dirname(file));
          }
          if (parentCompilation) {
            compilation.parent = parentCompilation;
            parentCompilation.children.push(compilation);
          }
          this.dispatcher("onCreatedCompilation", compilation);
          return compilation;
        }
        return null;
      }
      async loadDescriptorFiles(dirname2) {
        const descFile = this.resolveAppointFile("index", "index.d.es", dirname2);
        if (!cacheHandle.load.records(descFile)) {
          await this.loadTypes([descFile], { scope: "local", inherits: [] });
        } else if (!descFile) {
          const file = this.resolveAppointFile("package", "package.json", dirname2);
          if (file) {
            const data = this.resolveTypingsFromPackage(file);
            if (data && data.size > 0) {
              await Promise.allSettled(Array.from(data.values()).map(this.loadTypes(item.files, item.esconfig)));
            }
          }
        }
      }
      readFolderTypings(data, file, context, esconfig, scopeFile, isRoot = false) {
        file = path.isAbsolute(file) ? file : path.join(context, file);
        file = this.normalizePath(file);
        if (cacheHandle.folder.records(file) || !fs.existsSync(file))
          return;
        const stat = fs.statSync(file);
        if (stat.isDirectory()) {
          const result = Utils.readdir(file);
          if (result) {
            result.forEach((name) => {
              this.readFolderTypings(data, path.join(file, name), file, esconfig, scopeFile, false);
            });
          }
        } else if (stat.isFile() && (this.isDescriptorFile(file) || isRoot && file.endsWith(this.suffix))) {
          let dataset = data.get(scopeFile);
          if (!dataset) {
            dataset = {
              esconfig,
              context,
              files: [file]
            };
            data.set(scopeFile, dataset);
          } else {
            dataset.files.push(file);
          }
        }
      }
      normalizePkgTypings(value2) {
        if (value2) {
          if (typeof value2 === "string") {
            return value2.split(",").map((item2) => item2.trim());
          } else if (Array.isArray(value2)) {
            return value2.map((item2) => item2.trim());
          }
        }
        return [];
      }
      resolveTypingsFromPackage(jsonFile, dataset = null, typings = null) {
        if (cacheHandle.pkg.records(jsonFile)) {
          return null;
        }
        if (!fs.existsSync(jsonFile))
          return null;
        this.printLogInfo(`resolve-types: ${jsonFile}`, "compiler");
        dataset = dataset || /* @__PURE__ */ new Map();
        const pkg = __require(jsonFile);
        const folder = path.dirname(jsonFile);
        let pkgName = String(pkg.name || "").trim();
        if (pkgName.includes("/")) {
          pkgName = pkgName.split("/").pop();
        }
        let esconfig = pkg.esconfig || {
          inherits: [],
          scope: pkgName
        };
        if (esconfig.typings && Array.isArray(esconfig.typings)) {
          esconfig.typings.forEach((file) => {
            this.readFolderTypings(dataset, file, folder, esconfig, jsonFile, true);
          });
        }
        const _typings = typings || this.normalizePkgTypings(pkg.typings);
        if (_typings) {
          if (!esconfig.scope) {
            esconfig.scope = pkgName;
          }
          _typings.forEach((file) => {
            file = path.isAbsolute(file) ? file : path.join(folder, file);
            if (/\.json$/.test(file) && fs.existsSync(file)) {
              try {
                this.manifester.add(__require(file), path.dirname(file));
              } catch (e) {
                throw e;
              }
            } else {
              this.readFolderTypings(dataset, file, folder, esconfig, jsonFile, true);
            }
          });
        }
        return dataset;
      }
      resolveAppointFile(prefix, filename, folder, entry = null, prevs = [], ctx = null) {
        if (!folder)
          return null;
        if (!fs.existsSync(folder))
          return null;
        folder = this.normalizePath(folder);
        entry = entry || folder;
        const key = prefix + ":" + folder;
        const value2 = cacheHandle.appoint.get(key);
        if (value2 !== void 0) {
          return value2;
        }
        if (ctx === null) {
          ctx = this.normalizePath(path.normalize(this.options.cwd || process.cwd()));
        }
        if (!folder.includes(ctx)) {
          return null;
        }
        prevs.push(folder);
        let file = this.normalizePath(path.join(folder, filename));
        if (fs.existsSync(file)) {
          this.printLogInfo(`resolve-types: ${file}[${prefix}] from ${entry} (yes)`, "compiler");
          prevs.forEach((folder2) => {
            const key2 = prefix + ":" + folder2;
            cacheHandle.appoint.set(key2, file);
          });
          return file;
        } else {
          this.printLogInfo(`resolve-types: ${file}[${prefix}] from ${entry} (no)`, "compiler");
          const result = this.resolveAppointFile(prefix, filename, path.dirname(folder), entry, prevs, ctx);
          if (!result && entry === folder) {
            prevs.forEach((folder2) => {
              const key2 = prefix + ":" + folder2;
              cacheHandle.appoint.set(key2, null);
            });
          }
          return result;
        }
      }
      async scanTypings(folders, scanDependencyFlag = true, dataset = null) {
        if (!Array.isArray(folders)) {
          folders = [folders];
        }
        dataset = dataset || /* @__PURE__ */ new Map();
        folders.forEach((folder) => {
          if (!folder)
            return;
          const file = this.resolveAppointFile("package", "package.json", folder);
          if (file && !cacheHandle.pkg.has(file)) {
            this.resolveTypingsFromPackage(file, dataset);
          }
          if (scanDependencyFlag) {
            const context = path.join(file ? path.dirname(file) : folder, "node_modules");
            const deps = Utils.readdir(context, true) || [];
            deps.forEach((dep) => {
              if (dep.endsWith("@easescript")) {
                const _deps = Utils.readdir(dep, true) || [];
                _deps.forEach((dep2) => {
                  this.resolveTypingsFromPackage(this.normalizePath(path.join(dep2, "package.json")), dataset);
                });
              } else {
                this.resolveTypingsFromPackage(this.normalizePath(path.join(dep, "package.json")), dataset);
              }
            });
          }
        });
        return dataset;
      }
      initializeDone() {
        return !!this.initQueues.__done;
      }
      initialize() {
        return new Promise(async (resolve) => {
          if (this.initQueues.__done) {
            resolve(true);
          } else {
            this.initQueues.push(resolve);
            if (!this.initQueues.__waiting) {
              this.initQueues.__waiting = true;
              this.initQueues.__done = false;
              this.markMemoryUsage("compiler:initialize");
              await this.__loadGlobalTypes();
              await this.__loadPluginTypes();
              const info = this.getMemoryUsage("compiler:initialize");
              this.printLogInfo(`initialized (${info.current} MB, totoal:${info.total} MB)`, "compiler");
              this.initQueues.__waiting = false;
              this.initQueues.__done = true;
              if (this.options.service || this.options.watch) {
                this.addWatch();
              }
              let done = null;
              while (done = this.initQueues.shift()) {
                done(true);
              }
              this.dispatcher("initialized");
            }
          }
        });
      }
      async __loadPluginTypes() {
        const options = this.options;
        const cwd2 = path.normalize(options.cwd || process.cwd());
        let dataset = /* @__PURE__ */ new Map();
        if (options.scanTypings) {
          const scanFolders = (options.scanFolders || []).map((item2) => path.normalize(item2));
          if (!scanFolders.includes(cwd2)) {
            scanFolders.push(cwd2);
          }
          await this.scanTypings(scanFolders, true, dataset);
        }
        if (options.types && options.types.length > 0) {
          const needScanTasks = [];
          options.types.forEach((file) => {
            file = path.isAbsolute(file) ? file : path.join(cwd2, file);
            if (fs.existsSync(file) && fs.statSync(file).isFile()) {
              if (this.isDescriptorFile(file)) {
                let folder = path.dirname(file);
                if (!path.isAbsolute(folder)) {
                  folder = path.join(cwd2, folder);
                }
                const json = this.resolveAppointFile("package", "package.json", folder);
                if (json) {
                  dataset = this.resolveTypingsFromPackage(json, dataset, [file]);
                } else if (!dataset.has(file)) {
                  dataset.set(file, {
                    esconfig: {
                      scope: "global",
                      inherits: []
                    },
                    folder,
                    files: [file]
                  });
                }
              }
            } else {
              if (!path.isAbsolute(file) && !String(file).endsWith("node_modules")) {
                file = path.join(cwd2, "node_modules", file);
              }
              needScanTasks.push([file, false, dataset]);
            }
          });
          await Promise.allSettled(needScanTasks.map((args) => this.scanTypings(...args)));
        }
        await this.doLoadPluginTypes(dataset);
      }
      async __loadGlobalTypes() {
        const globalTypes = this.options.globalTypes || [];
        const items = [];
        globalTypes.forEach((filepath) => {
          const types = Utils.readdir(filepath, true);
          if (types) {
            items.push(...types);
          } else if (filepath) {
            items.push(filepath);
          }
        });
        if (items.length > 0) {
          await this.loadTypes(items, {
            scope: "global",
            inherits: []
          }, true);
        }
      }
      async doLoadPluginTypes(dataset) {
        if (dataset && dataset.size > 0) {
          const pluginTypes = Array.from(dataset.values());
          pluginTypes.sort((a, b) => {
            const a1 = a.esconfig.inherits;
            const b1 = b.esconfig.inherits;
            let aa = a1.length;
            let bb = b1.length;
            if (b1.includes(a1.scope)) {
              bb++;
            } else if (a1.includes(b1.scope)) {
              aa++;
            }
            return aa - bb;
          });
          return await this.callSequential(pluginTypes.map((item2) => async () => await this.loadTypes(item2.files, item2.esconfig)));
        }
      }
      async callSequential(asyncQueues) {
        return await new Promise((resolve) => {
          const tasks = asyncQueues.slice(0);
          const items = [];
          const next = (res) => {
            items.push(res);
            execute();
          };
          const execute = () => {
            const callback = tasks.shift();
            if (callback) {
              if (typeof callback === "function") {
                callback().then(next).catch(next);
              } else if (callback instanceof Promise) {
                callback.then(next).catch(next);
              } else {
                throw new TypeError("Compiler.callSequential called an non-promise object.");
              }
            } else {
              resolve(items);
            }
          };
          execute();
        });
      }
      async loadTypes(types, pluginScope, isGlobal = false) {
        if (!pluginScope || typeof pluginScope !== "object") {
          throw new Error("Invalid pluginScope");
        } else if (!pluginScope.scope || typeof pluginScope.scope !== "string") {
          throw new Error("Invalid pluginScope.scope");
        }
        if (typeof types === "string") {
          types = [types];
        }
        if (!Array.isArray(types)) {
          const message = Diagnostic.getMessage(this.options.lang, 1095, [types]);
          throw new Error(message);
        }
        this.markMemoryUsage(this);
        this.printLogInfo(`load-types-start: ${types.join(",\n")}`, "compiler");
        const exclude = (Array.isArray(this.options.excludeDescribeFile) ? this.options.excludeDescribeFile : []).map((file) => this.pathAbsolute(file));
        const compilations2 = [];
        const createAsync = async (file) => {
          const aFile = this.pathAbsolute(file);
          if (exclude.includes(aFile) || cacheHandle.create.records(aFile)) {
            return;
          }
          const compilation = await this.createCompilation(aFile, null, true);
          if (compilation && !compilation.stack && !compilation.stackCreating) {
            compilation.pluginScopes = pluginScope;
            compilation.import = "scans";
            compilation.isGlobalFlag = isGlobal;
            compilation.createStack();
            compilations2.push(compilation);
          }
          if (compilation && pluginScope.scope === "global") {
            this.globals.add(compilation);
          }
        };
        await Promise.allSettled(types.map((file) => createAsync(file)));
        await Promise.allSettled(compilations2.map((compilation) => compilation.createCompleted()));
        await Promise.allSettled(compilations2.map((compilation) => compilation.parserAsync()));
        const info = this.getMemoryUsage(this);
        this.printLogInfo(`load-types-done(current:${info.current} MB, total:${info.total} MB)`, "compiler");
        return compilations2;
      }
      async callAsyncSequence(items, asyncMethod) {
        if (!Array.isArray(items))
          return false;
        if (items.length < 1)
          return false;
        let index = 0;
        items = items.slice(0);
        const callAsync = async () => {
          if (index < items.length) {
            await asyncMethod(items[index], index++);
            await callAsync();
          }
        };
        await callAsync();
      }
      checkPlugin(plugin) {
        const result = pluginInterfaces.find((item2) => {
          const value2 = plugin[item2.name];
          if (!value2 && item2.option !== true) {
            throw new Error(`Plugin interface '${item2.name}' not implemented.`);
          }
          return !item2.type.includes(typeof value2);
        });
        if (result) {
          throw new Error(`Plugin interface '${result.name}' implemented members type not compatible. must is "${result.type.join(",")}"`);
        }
      }
      applyPlugin(plugin) {
        if (!plugin) {
          throw new Error(`Apply plugin invalid. give null`);
        }
        let pluginClass = plugin;
        let pluginOptions = null;
        if (Object.prototype.toString.call(plugin) === "[object Object]") {
          if (Object.prototype.hasOwnProperty.call(plugin, "plugin")) {
            pluginClass = plugin.plugin;
            pluginOptions = plugin.options;
            if (typeof pluginClass === "string") {
              pluginClass = __require(pluginClass);
            }
          } else if (Object.prototype.hasOwnProperty.call(plugin, "name")) {
            pluginClass = __require(plugin.name);
            pluginOptions = plugin.options;
          } else {
            throw new Error(`Plugin config property the 'plugin' is not defined. correct as "{plugin:'plugin-name',options:{}}"`);
          }
        }
        if (typeof pluginClass !== "function") {
          throw new Error(`Plugin is not function.`);
        } else {
          const instance = new pluginClass(this, pluginOptions || {});
          this.checkPlugin(instance);
          this.pluginInstances.push(instance);
          return instance;
        }
      }
      isPluginInContext(plugin, context, globalResult = true) {
        if (typeof plugin === "object") {
          plugin = plugin.name;
        }
        return this.scopeManager.checkDocumentor(plugin, context, globalResult);
      }
      checkContenxtDescriptor(descriptor, context, globalResult = true) {
        return this.scopeManager.checkDescriptor(descriptor, context, globalResult);
      }
      async ready(file) {
        if (!this.initializeDone()) {
          await this.initialize();
        }
        if (file) {
          let compilation = file;
          if (typeof file === "string") {
            file = file.trim();
            if (file.startsWith("esglobal:")) {
              file = file.slice(9);
            }
            compilation = Namespace.globals.has(file) ? Namespace.globals.get(file).compilation : await this.createCompilation(file);
          }
          if (compilation instanceof Compilation) {
            return await compilation.ready();
          } else {
            throw new Error(`The '${String(file)}' file was not resolved.`);
          }
        }
        return null;
      }
    };
    module.exports = Compiler;
  }
});

// lib/index.js
var require_lib = __commonJS({
  "lib/index.js"(exports, module) {
    var Compiler = require_Compiler();
    var Compilation = require_Compilation();
    var Constant = require_Constant();
    var Namespace = require_Namespace();
    var Utils = require_Utils();
    var JSModule = require_JSModule();
    var Module = require_Module();
    var Inference = require_Inference();
    var Diagnostic = require_Diagnostic();
    var Manifester = require_Manifester();
    var ScopeManager = require_ScopeManager();
    var ResolveManager = require_ResolveManager();
    var { acorn, parseJSX, Parser } = require_Parser();
    module.exports = {
      Compiler,
      Compilation,
      Constant,
      Namespace,
      Utils,
      JSModule,
      Module,
      Inference,
      Diagnostic,
      Manifester,
      ScopeManager,
      ResolveManager,
      acorn,
      parseJSX,
      Parser
    };
  }
});
export default require_lib();
