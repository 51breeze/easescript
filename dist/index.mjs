var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc2) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// lib/core/EventDispatcher.js
var require_EventDispatcher = __commonJS({
  "lib/core/EventDispatcher.js"(exports, module) {
    var events = __require("events");
    var keySymbol = Symbol("keySymbol");
    events.EventEmitter.defaultMaxListeners = 1e5;
    var EventDispatcher = class {
      constructor() {
        this[keySymbol] = new events.EventEmitter();
      }
      addListener(event, listener) {
        return this[keySymbol].addListener(event, listener);
      }
      on(event, listener) {
        return this[keySymbol].on(event, listener);
      }
      once(event, listener) {
        return this[keySymbol].once(event, listener);
      }
      removeListener(event, listener) {
        return this[keySymbol].removeListener(event, listener);
      }
      off(event, listener) {
        return this[keySymbol].off(event, listener);
      }
      removeAllListeners(event, listener) {
        return this[keySymbol].removeAllListeners(event, listener);
      }
      dispatcher(event, ...args) {
        return this[keySymbol].emit(event, ...args);
      }
    };
    module.exports = EventDispatcher;
  }
});

// lib/core/Scope.js
var require_Scope = __commonJS({
  "lib/core/Scope.js"(exports, module) {
    var EventDispatcher = require_EventDispatcher();
    var scopeParents = ["block", "function", "class", "top"];
    module.exports = class Scope extends EventDispatcher {
      constructor(parent) {
        super();
        this.parent = parent;
        this.children = [];
        this.level = 0;
        if (parent) {
          parent.children.push(this);
          this.level = parent.level + 1;
          this.asyncParentScopeOf = parent.async ? parent : parent.asyncParentScopeOf;
        }
        if (parent && parent.topDeclarations) {
          this.topDeclarations = parent.topDeclarations;
          this.gathers = parent.gathers;
        } else {
          this.topDeclarations = /* @__PURE__ */ new Set();
          this.gathers = /* @__PURE__ */ Object.create(null);
        }
        this.declarations = /* @__PURE__ */ new Map();
        this.proxyScope = null;
        this.isStatic = false;
      }
      removeChild(childScope) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.removeChild(childScope);
        }
        const index = this.children.indexOf(childScope);
        if (index >= 0) {
          return this.children.splice(index, 1);
        }
        return null;
      }
      hasChildDeclared(name) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.hasChildDeclared(name);
        }
        const check = (item2) => {
          if (item2.isDefine(name)) {
            return true;
          } else {
            return item2.children.some(check);
          }
        };
        return check(this);
      }
      generateVarName(name, flag = false) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.generateVarName(name, flag);
        }
        let count = 0;
        let ref = name;
        while (this.declarations.has(ref) || flag === false && this.topDeclarations.has(ref) || flag === true && this.hasChildDeclared(ref)) {
          count++;
          ref = name + count;
        }
        this.define(ref, this);
        return ref;
      }
      type(name) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.type(name);
        }
        return false;
      }
      getScopeByType(name) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.getScopeByType(name);
        }
        let obj = this;
        while (obj && obj instanceof Scope && !obj.type(name)) {
          obj = obj.parent;
        }
        return obj;
      }
      define(name, stack2) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.define(name, stack2);
        }
        if (stack2 === void 0) {
          let has = this.declarations.has(name);
          if (!has) {
            let parentScope = this.parent;
            while (parentScope && parentScope instanceof Scope) {
              if (parentScope.declarations.has(name)) {
                const res = parentScope.declarations.get(name);
                return res === parentScope ? null : res;
              } else {
                parentScope = parentScope.parent;
              }
            }
            return null;
          }
          return this.declarations.get(name);
        }
        const gathers = this.gathers[name] || (this.gathers[name] = []);
        gathers.push(this);
        this.declarations.set(name, stack2);
        if (this.topDeclarations) {
          this.topDeclarations.add(name);
        }
      }
      getDefine(name, context) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.getDefine(name, context);
        }
        let has = this.declarations.has(name);
        if (!has) {
          let parentScope = this.parent;
          while (parentScope && parentScope instanceof Scope) {
            if (parentScope.declarations.has(name)) {
              const res = parentScope.declarations.get(name);
              return res === parentScope ? null : res;
            } else {
              if (context && (parentScope.type(context) || context === "block" && parentScope.type("function"))) {
                return false;
              }
              parentScope = parentScope.parent;
            }
          }
          return null;
        }
        return this.declarations.get(name);
      }
      getKeys(context) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return proxyScope.getKeys(context);
        }
        let keys = Array.from(this.declarations.keys());
        let parent = this.parent;
        while (parent) {
          const is = !context || context.some((name) => !!parent.type(name));
          if (is) {
            keys = keys.concat(Array.from(parent.declarations.keys()));
            parent = parent.parent;
          }
          break;
        }
        return keys;
      }
      checkDocumentDefineScope(name, excludes = []) {
        const gathers = this.gathers[name];
        if (gathers) {
          if (excludes && excludes.length > 0) {
            return gathers.some((scope) => !excludes.some((name2) => scope.type(name2)));
          } else {
            return true;
          }
        }
        return false;
      }
      getDocumentDefineScopes(name, excludes = []) {
        const gathers = this.gathers[name];
        if (gathers) {
          if (excludes && excludes.length > 0) {
            return gathers.filter((scope) => !excludes.some((name2) => scope.type(name2)));
          }
        }
        return gathers || [];
      }
      isDefine(name, endContext) {
        const proxyScope = this.proxyScope;
        if (proxyScope && proxyScope !== this) {
          return this.proxyScope.isDefine(name, endContext);
        }
        let parentScope = this;
        while (parentScope && parentScope instanceof Scope) {
          if (parentScope.declarations.has(name) && parentScope !== parentScope.declarations.get(name)) {
            return true;
          } else {
            if (endContext) {
              if (parentScope.type(endContext)) {
                return false;
              }
              const at = scopeParents.indexOf(endContext);
              if (at >= 0) {
                const scopes = scopeParents.slice(at + 1);
                if (scopes.length > 0 && scopes.some((name2) => parentScope.type(name2))) {
                  return false;
                }
              }
            }
            parentScope = parentScope.parent;
          }
        }
        return false;
      }
    };
  }
});

// lib/scope/TopScope.js
var require_TopScope = __commonJS({
  "lib/scope/TopScope.js"(exports, module) {
    var Scope = require_Scope();
    module.exports = class TopScope extends Scope {
      constructor(parentScope) {
        super(parentScope);
        this.isTopScope = true;
      }
      type(name) {
        return name === "top";
      }
    };
  }
});

// lib/core/Parser.js
var require_Parser = __commonJS({
  "lib/core/Parser.js"(exports, module) {
    var acorn = __require("acorn");
    var jsx = __require("acorn-jsx");
    var SCOPE_TOP = 1;
    var SCOPE_FUNCTION = 2;
    var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION;
    var SCOPE_ASYNC = 4;
    var SCOPE_GENERATOR = 8;
    var SCOPE_ARROW = 16;
    var SCOPE_SUPER = 64;
    var SCOPE_DIRECT_SUPER = 128;
    var BIND_VAR = 1;
    var BIND_LEXICAL = 2;
    var Parser = acorn.Parser;
    var TokenType = Parser.acorn.TokenType;
    var tokTypes = Parser.acorn.tokTypes;
    var keywordTypes = Parser.acorn.keywordTypes;
    var tokContexts = Parser.acorn.tokContexts;
    function functionFlags(async, generator) {
      return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
    }
    function DestructuringErrors() {
      this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.parenthesizedBindParam = this.doubleProto = -1;
    }
    keywordTypes["is"] = new TokenType("is", { beforeExpr: true, binop: 7, keyword: "is" });
    tokTypes._is = keywordTypes["is"];
    keywordTypes["as"] = new TokenType("as", { beforeExpr: true, binop: 7, keyword: "as" });
    tokTypes._as = keywordTypes["as"];
    keywordTypes["package"] = new TokenType("package", { startsExpr: true, keyword: "package" });
    tokTypes._package = keywordTypes["package"];
    keywordTypes["implements"] = new TokenType("implements", { startsExpr: true, keyword: "implements" });
    tokTypes._implements = keywordTypes["implements"];
    keywordTypes["private"] = new TokenType("private", { startsExpr: true, keyword: "private" });
    tokTypes._private = keywordTypes["private"];
    keywordTypes["protected"] = new TokenType("protected", { startsExpr: true, keyword: "protected" });
    tokTypes._protected = keywordTypes["protected"];
    keywordTypes["public"] = new TokenType("public", { startsExpr: true, keyword: "public" });
    tokTypes._public = keywordTypes["public"];
    keywordTypes["internal"] = new TokenType("internal", { startsExpr: true, keyword: "internal" });
    tokTypes._internal = keywordTypes["internal"];
    keywordTypes["final"] = new TokenType("final", { startsExpr: true, keyword: "final" });
    tokTypes._final = keywordTypes["final"];
    keywordTypes["static"] = new TokenType("static", { startsExpr: true, keyword: "static" });
    tokTypes._static = keywordTypes["static"];
    keywordTypes["when"] = new TokenType("when", { startsExpr: true, keyword: "when" });
    tokTypes._when = keywordTypes["when"];
    keywordTypes["then"] = new TokenType("then", { startsExpr: true, keyword: "then" });
    tokTypes._then = keywordTypes["then"];
    keywordTypes["enum"] = new TokenType("enum", { startsExpr: true, keyword: "enum" });
    tokTypes._enum = keywordTypes["enum"];
    keywordTypes["interface"] = new TokenType("interface", { startsExpr: true, keyword: "interface" });
    tokTypes._interface = keywordTypes["interface"];
    keywordTypes["abstract"] = new TokenType("abstract", { startsExpr: true, keyword: "abstract" });
    tokTypes._abstract = keywordTypes["abstract"];
    keywordTypes["struct"] = new TokenType("struct", { startsExpr: true, keyword: "struct" });
    tokTypes._struct = keywordTypes["struct"];
    tokTypes._declarator = new TokenType("declarator", { startsExpr: true, keyword: "declarator" });
    tokTypes._annotation = new TokenType("@", { startsExpr: false });
    var tokenModifiers = [
      tokTypes._public,
      tokTypes._internal,
      tokTypes._protected,
      tokTypes._private,
      tokTypes._final,
      tokTypes._static
    ];
    var JSXParser = Parser.extend(jsx({ allowNamespaces: true, allowNamespacedObjects: true }));
    var acornJsx = JSXParser.acornJsx;
    var tok = acornJsx.tokTypes;
    var tt = tokTypes;
    var tc_type_statement = new acorn.TokContext("disabled-expr-context", false, false);
    tc_type_statement.updateContext = function() {
      if (this.curContext() === tc_type_statement) {
        this.context.pop();
      }
    };
    tt.colon.updateContext = function() {
      if (this.curContext() === tc_type_statement) {
        this.exprAllowed = false;
      } else if (this.curContext() === tokContexts.b_expr) {
        this.exprAllowed = true;
      }
    };
    tt.name.updateContext = function(prevType) {
      if (this.context[this.context.length - 2] === tc_type_statement || this.curContext() === tc_type_statement) {
        this.exprAllowed = false;
        return;
      }
      var allowed = false;
      if (this.options.ecmaVersion >= 6 && prevType !== tokTypes.dot) {
        if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
          allowed = true;
        }
      }
      this.exprAllowed = allowed;
    };
    var tc_cdata_expr = new acorn.TokContext("<![CDATA[...]]>", true, true);
    var tt_cdata_start = new TokenType("tt_cdata_start", { startsExpr: true });
    var tt_cdata_end = new TokenType("tt_cdata_end");
    var tt_content_text = new TokenType("cssOrScriptText");
    tt_cdata_start.updateContext = function() {
      this.context.push(tc_cdata_expr);
      this.exprAllowed = false;
    };
    tt_cdata_end.updateContext = function(prevType) {
      if (this.curContext() === tc_cdata_expr) {
        this.context.pop();
      }
      if (this.curContext() === tc_script_expr) {
        this.context.pop();
      }
      this.exprAllowed = this.curContext() === acornJsx.tokContexts.tc_expr;
    };
    tt_content_text.updateContext = function(prevType) {
      if (this.curContext() === tc_style_expr) {
        this.context.pop();
      }
    };
    tokTypes.parenR.updateContext = tokTypes.braceR.updateContext = function(prevType) {
      if (this.context.length === 1) {
        this.exprAllowed = true;
        return;
      }
      var out = this.context.pop();
      if (this.curContext() === tc_type_statement) {
        this.context.pop();
      }
      if (out === tokContexts.b_stat && this.curContext().token === "function") {
        out = this.context.pop();
      }
      if (this.curContext() === tc_type_statement) {
        this.exprAllowed = false;
      } else {
        this.exprAllowed = !out.isExpr;
      }
      if (this.context.length === 1 && this.context[0] === tokContexts.b_stat) {
        this.exprAllowed = true;
      }
    };
    tokTypes.braceL.updateContext = function(prevType) {
      let ctx2 = this.braceIsBlock(prevType) ? tokContexts.b_stat : tokContexts.b_expr;
      if (this.disabledJSXExpressionFlag) {
        this.disabledJSXExpressionFlag = false;
        this.context.push(tc_type_statement);
      }
      this.context.push(ctx2);
      this.exprAllowed = true;
    };
    tokTypes.parenL.updateContext = function(prevType) {
      var statementParens = prevType === tokTypes._if || prevType === tokTypes._for || prevType === tokTypes._with || prevType === tokTypes._while || prevType === tokTypes._when;
      this.context.push(statementParens ? tokContexts.p_stat : tokContexts.p_expr);
      this.exprAllowed = true;
    };
    var tc_script_expr = new acorn.TokContext("<script>...</script>", true, false);
    var tc_style_expr = new acorn.TokContext("<style>...</style>", true, true);
    var tt_whitespace = new TokenType("whitespace");
    function getQualifiedJSXName(object) {
      if (!object)
        return object;
      if (object.type === "JSXIdentifier")
        return object.name;
      if (object.type === "JSXNamespacedName")
        return object.namespace.name + ":" + object.name.name;
      if (object.type === "JSXMemberExpression")
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }
    var SyntaxParser = class extends JSXParser {
      constructor(options, input, startPos) {
        super(options, input, startPos);
        this.testTokens = [];
        this.stackComments = [];
        this.keywords = new RegExp(this.keywords.source.replace(")$", "|is|package|implements|static|final|public|internal|protected|private|when|then|enum|interface|abstract|struct)$"));
        if (Array.isArray(options.reserved) && options.reserved.length > 0) {
          this.reservedWords = new RegExp(this.reservedWords.source.replace(")$", "|" + options.reserved.join("|") + ")$"));
        }
      }
      next(ignoreEscapeSequenceInKeyword) {
        if (!this.back()) {
          super.next(ignoreEscapeSequenceInKeyword);
        }
      }
      step() {
        this.testTokens.push({
          type: this.type,
          value: this.value,
          start: this.start,
          startLoc: this.startLoc,
          endLoc: this.endLoc,
          lastTokEnd: this.lastTokEnd,
          lastTokStart: this.lastTokStart,
          lastTokEndLoc: this.lastTokEndLoc,
          lastTokStartLoc: this.lastTokStartLoc,
          pos: this.pos
        });
        super.next();
        return this.type;
      }
      back() {
        if (this.testTokens.length > 0) {
          this.apply(-1);
          this.testTokens.shift();
          return true;
        }
        return false;
      }
      apply(num) {
        const len = this.testTokens.length;
        if (num && num < 0) {
          const index = Math.min(Math.max(len + num, 0), len - 1);
          const nextToken = {
            type: this.type,
            value: this.value,
            start: this.start,
            startLoc: this.startLoc,
            endLoc: this.endLoc,
            lastTokEnd: this.lastTokEnd,
            lastTokStart: this.lastTokStart,
            lastTokEndLoc: this.lastTokEndLoc,
            lastTokStartLoc: this.lastTokStartLoc,
            pos: this.pos
          };
          const [node] = this.testTokens.splice(index, 1, nextToken);
          this.pos = node.pos;
          this.type = node.type;
          this.value = node.value;
          this.start = node.start;
          this.startLoc = node.startLoc;
          this.endLoc = node.endLoc;
          this.lastTokEnd = node.lastTokEnd;
          this.lastTokStart = node.lastTokStart;
          this.lastTokEndLoc = node.lastTokEndLoc;
          this.lastTokStartLoc = node.lastTokStartLoc;
        } else {
          this.testTokens.length = 0;
        }
      }
      isContextual(name) {
        if (this.parseInterfaceElementFlag && name === "of") {
          return true;
        }
        return super.isContextual(name);
      }
      parseMaybeConditional(noIn, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(noIn, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(tokTypes.question)) {
          if (refDestructuringErrors && refDestructuringErrors.parenthesizedBindParam >= 1) {
            refDestructuringErrors.parenthesizedBindParam = 2;
            if (this.type === tokTypes.comma || this.type === tokTypes.parenR) {
              refDestructuringErrors.parenthesizedBindParam = 3;
              expr.question = true;
              return expr;
            } else if (this.type === tokTypes.colon) {
              this.next();
              refDestructuringErrors.parenthesizedBindParam = 3;
              expr.question = true;
              expr.acceptType = this.parseTypeStatement();
              return expr;
            }
          }
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(tokTypes.colon);
          node.alternate = this.parseMaybeAssign(noIn);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          refDestructuringErrors.parenthesizedBindParam = 1;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== tokTypes.parenR) {
            first ? first = false : this.expect(tokTypes.comma);
            if (allowTrailingComma && this.afterTrailingComma(tokTypes.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === tokTypes.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === tokTypes.comma) {
                this.raise(this.start, "Comma is not permitted after the rest element");
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.start, innerEndLoc = this.startLoc;
          this.expect(tokTypes.parenR);
          let returnType = null;
          if (canBeArrow && this.eat(tokTypes.colon)) {
            returnType = this.parseTypeStatement();
          }
          if (canBeArrow && !this.canInsertSemicolon() && this.eat(tokTypes.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            const node = this.parseParenArrowList(startPos, startLoc, exprList);
            node.returnType = returnType;
            return node;
          }
          if (returnType) {
            this.unexpected(returnType.start);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        var par = this.startNodeAt(startPos, startLoc);
        par.expression = val;
        if (val.type !== "SequenceExpression" && !this.canInsertSemicolon() && (this.type === tokTypes._this || this.type === tokTypes.name)) {
          startPos = this.start, startLoc = this.startLoc;
          par.value = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc);
          val = this.finishNode(par, "TypeTransformExpression");
        } else {
          val = this.finishNode(par, "ParenthesizedExpression");
        }
        return val;
      }
      parseExprAtom(refDestructuringErrors) {
        if (this.type === tokTypes._annotation) {
          return this.parseAnnotation(true);
        }
        return super.parseExprAtom(refDestructuringErrors);
      }
      parseParenItem(item2) {
        if (super.eat(tokTypes.colon)) {
          item2.acceptType = this.parseTypeStatement();
        }
        return item2;
      }
      readToken(code) {
        const context = this.curContext();
        if (context === tc_style_expr) {
          return this.jsx_readCDATAToken(code) || this.jsx_readTextToken("style");
        }
        if (code === 64) {
          ++this.pos;
          return this.finishToken(tokTypes._annotation);
        }
        if (context === tc_script_expr) {
          return this.jsx_readCDATAToken(code) || super.readToken(code);
        } else if (context === tc_cdata_expr) {
          return this.jsx_readTextToken();
        } else if (!this.jsx_readCDATAToken(code)) {
          if (!this.exprAllowed && this.curContext() === acornJsx.tokContexts.tc_expr) {
            this.exprAllowed = true;
          }
          return super.readToken(code);
        }
      }
      finishToken(type2, word) {
        if (tokTypes.string !== type2 && word === "as") {
          type2 = tokTypes._as;
        }
        return super.finishToken(type2, word);
      }
      initFunction(node) {
        if (this.type === tokTypes.star) {
          this.raise(this.lastTokStart, `Function generator unsupported`);
        }
        super.initFunction(node);
      }
      parseClassSuper(node) {
        node.superClass = null;
        if (this.eat(tokTypes._extends)) {
          if (this.isStaticClass) {
            this.raise(this.lastTokStart, "Static class cannot extends super class.");
          }
          node.superClass = this.parseChainIdentifier();
          if (node.superClass) {
            node.superClass.genericity = this.getGenerics(true);
          }
        }
        node.implements = null;
        if (this.eat(tokTypes._implements)) {
          if (this.isStaticClass) {
            this.raise(this.lastTokStart, "Static class cannot implements interfaces.");
          }
          node.implements = [];
          do {
            const imp = this.parseChainIdentifier();
            if (imp) {
              imp.genericity = this.getGenerics(true);
            }
            node.implements.push(imp);
          } while (this.eat(tokTypes.comma));
        }
      }
      parseClassId(node, isStatement) {
        super.parseClassId(node, isStatement);
        node.genericity = this.parseGenericType();
      }
      parseMethod(isGenerator, isAsync, allowDirectSuper) {
        const generics = this.parseGenericType();
        const node = super.parseMethod(isGenerator, isAsync, allowDirectSuper);
        node.genericity = generics;
        return node;
      }
      parseFunctionParams(node) {
        node.genericity = this.parseGenericType();
        super.parseFunctionParams(node);
      }
      parseBlock(createNewLexicalScope, node) {
        if (createNewLexicalScope === void 0) {
          createNewLexicalScope = true;
        }
        if (node === void 0) {
          node = this.startNode();
        }
        const scope = this.currentScope();
        switch (scope.flags & SCOPE_FUNCTION) {
          case SCOPE_ARROW:
          case SCOPE_FUNCTION:
          case SCOPE_ASYNC:
          case SCOPE_GENERATOR:
            if (this.eat(tokTypes.colon)) {
              node.acceptType = this.parseTypeStatement();
            }
            break;
        }
        return super.parseBlock(createNewLexicalScope, node);
      }
      checkUnreserved(ref) {
        if (this.__parseBindingAtom && ref.name !== "default") {
          super.checkUnreserved(ref);
        }
      }
      parseBindingAtom() {
        this.__parseBindingAtom = true;
        const node = super.parseBindingAtom();
        this.__parseBindingAtom = false;
        if (!this.__parseVarIdFlag) {
          if (this.eat(tokTypes.question)) {
            node.question = true;
          }
          if (this.eat(tokTypes.colon)) {
            node.acceptType = this.parseTypeStatement();
          }
        }
        return node;
      }
      parseVarId(decl, kind) {
        this.__parseVarIdFlag = true;
        super.parseVarId(decl, kind);
        this.__parseVarIdFlag = false;
        if (this.eat(tokTypes.colon)) {
          decl.acceptType = this.parseTypeStatement();
        }
      }
      parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        const generics = this.parseGenericType();
        super.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        if (prop.value && prop.value.type === "FunctionExpression") {
          prop.value.genericity = generics;
        } else if (generics) {
          this.unexpected(generics.start);
        }
      }
      parseMaybeAssign(noIn, refDestructuringErrors, afterLeftParse) {
        const generics = this.parseGenericType();
        const node = super.parseMaybeAssign(noIn, refDestructuringErrors, afterLeftParse);
        if (node.type === "ArrowFunctionExpression") {
          node.genericity = generics;
        } else if (generics) {
          this.unexpected(generics.start);
        }
        return node;
      }
      parseArrowExpression(node, params, isAsync) {
        let type2 = null;
        if (this.arrowReturnType && this.arrowReturnType[this.lastTokStart]) {
          type2 = this.arrowReturnType[this.lastTokStart];
          delete this.arrowReturnType[this.lastTokStart];
        }
        const fn = super.parseArrowExpression(node, params, isAsync);
        fn.returnType = type2;
        return fn;
      }
      parseFunctionBody(node, isArrowFunction, isMethod) {
        if (!isArrowFunction && this.type === tokTypes.colon) {
          this.next();
          node.returnType = this.parseTypeStatement();
        }
        if (this.parseInterfaceElementFlag) {
          this.parseInterfaceElementFlag = false;
          this.semicolon();
          this.checkParams(node);
          this.exitScope();
          return node;
        }
        super.parseFunctionBody(node, isArrowFunction, isMethod);
      }
      parseNew() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node = this.startNode();
        var meta = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(tokTypes.dot)) {
          node.meta = meta;
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          }
          if (!this.inNonArrowFunction()) {
            this.raiseRecoverable(node.start, "'new.target' can only be used in functions");
          }
          return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc, isImport = this.type === tokTypes._import;
        node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
        if (isImport && node.callee.type === "ImportExpression") {
          this.raise(startPos, "Cannot use new with import()");
        }
        startPos = this.start;
        node.genericity = this.getGenerics(true);
        if (node.genericity && !(node.genericity.length > 0)) {
          this.raise(startPos, "Missing generics arguments.");
        }
        if (this.eat(tokTypes.parenL)) {
          node.arguments = this.parseExprList(tokTypes.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node.arguments = [];
        }
        return this.finishNode(node, "NewExpression");
      }
      parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained) {
        const _startPos = this.start;
        const generics = !noCalls ? this.getGenerics(false) : null;
        const start = this.start;
        const node = super.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained);
        if (node.type === "CallExpression") {
          if (base !== node) {
            if (generics && !(generics.length > 0)) {
              this.raise(_startPos, "Missing generics arguments.");
            }
            node.genericity = generics;
          } else if (generics) {
            this.unexpected(start);
          }
        } else if (generics) {
          this.raise(start, "'(' expected.");
        }
        return node;
      }
      parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {
        if (this.type === tokTypes._as) {
          this.next();
          const node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.left = left;
          node.right = this.parseTypeStatement();
          return this.finishNode(node, "TypeAssertExpression");
        }
        const endToken = this.__$endToken;
        if (endToken && endToken.length > 0) {
          const token = endToken[endToken.length - 1];
          if (this.type === token.value && this.value.charCodeAt(0) === token.endCode) {
            return left;
          }
        }
        return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn);
      }
      parseStatement(context, topLevel, exports2, isDeclaredModule = false) {
        switch (this.type) {
          case tokTypes._package:
            if (!topLevel || isDeclaredModule) {
              this.unexpected();
            }
            return this.parsePackage(this.startNode(), true);
          case tokTypes._abstract:
            if (!topLevel) {
              this.unexpected();
            }
            var abstract = this.startNode();
            abstract.name = "abstract";
            this.next();
            if (this.type !== tokTypes._class) {
              this.unexpected();
            }
            this.finishNode(abstract, "ModifierDeclaration");
            var node = this.parseClass(this.startNode(), true);
            node.abstract = abstract;
            return node;
          case tokTypes._public:
            if (!topLevel) {
              this.unexpected();
            }
            this.next();
            var modifier = this.finishNode(this.startNode(), "ModifierDeclaration");
            modifier.name = "public";
            var node = this.parseStatement(null, topLevel, exports2);
            node.modifier = modifier;
            return node;
          case tokTypes._internal:
            if (!topLevel) {
              this.unexpected();
            }
            this.next();
            var modifier = this.finishNode(this.startNode(), "ModifierDeclaration");
            modifier.name = "internal";
            var node = this.parseStatement(null, topLevel, exports2);
            node.modifier = modifier;
            return node;
          case tokTypes._final:
            if (!topLevel) {
              this.unexpected();
            }
            this.next();
            var modifier = this.finishNode(this.startNode(), "ModifierDeclaration");
            modifier.name = "final";
            var node = this.parseStatement(null, topLevel, exports2);
            node.final = modifier;
            return node;
          case tokTypes._protected:
            if (!topLevel) {
              this.unexpected();
            }
            this.next();
            var modifier = this.finishNode(this.startNode(), "ModifierDeclaration");
            modifier.name = "protected";
            var node = this.parseStatement(null, topLevel, exports2);
            node.modifier = modifier;
            return node;
          case tokTypes._private:
            this.raise(this.lastTokStart, `Private modifier can only be used in class member methods`);
            break;
          case tokTypes._static:
            if (!topLevel) {
              this.unexpected();
            }
            this.next();
            var modifier = this.finishNode(this.startNode(), "ModifierDeclaration");
            modifier.name = "static";
            var node = tokTypes._class === this.type ? this.parseClass(this.startNode(), true) : this.parseStatement(null, topLevel, exports2);
            node.static = modifier;
            return node;
          case tokTypes._import:
            if (!topLevel) {
              return super.parseStatement(context, topLevel, exports2);
            }
            return this.parseImport(this.startNode());
          case tokTypes._when:
            return this.parseWhenStatement(this.startNode());
          case tokTypes._enum:
            return this.parseEnumStatement(this.startNode(), topLevel);
          case tokTypes._interface:
            if (!topLevel) {
              this.unexpected();
            }
            return this.parseInterface(this.startNode(), topLevel);
          case tokTypes._annotation:
            if (topLevel) {
              return this.parseAnnotation();
            }
            break;
          case tokTypes._struct:
            if (topLevel) {
              this.next();
              if (this.type === tokTypes.name && this.value === "table") {
                return this.parseStructTableDeclarator();
              } else {
                this.unexpected();
              }
            } else {
              this.unexpected();
            }
            break;
          default:
        }
        if (topLevel && this.value === "declare") {
          return this.parseDeclarator(this.startNode(), topLevel);
        } else if (this.type === tokTypes.name && this.value === "await" && !this.inAsync) {
          return this.parseAwait();
        } else if (this.type === tokTypes.name && this.value === "type" && !this.isAsyncFunction()) {
          var node = this.startNode();
          var maybeName = this.value, expr = this.parseExpression();
          if (expr.type === "Identifier") {
            if (this.eat(tokTypes.colon)) {
              return this.parseLabeledStatement(node, maybeName, expr, context);
            } else if (this.type === tokTypes.name) {
              node.id = this.parseIdent(false);
              this.expect(tokTypes.eq);
              node.init = this.parseTypeStatement();
              this.finishNode(node, "TypeStatement");
              this.semicolon();
              return node;
            }
          }
          return this.parseExpressionStatement(node, expr);
        }
        return super.parseStatement(context, topLevel, exports2);
      }
      parseStructTableDeclarator() {
        this.disabledJSXExpressionFlag = true;
        this.next();
        const node = this.startNode();
        node.id = this.parseIdent(false);
        node.extends = [];
        node.body = [];
        if (this.eat(tokTypes._extends)) {
          do {
            node.extends.push(this.parseIdent(false));
          } while (this.eat(tokTypes.comma));
        }
        this.expect(tokTypes.braceL);
        const parseNode = (isIdent) => {
          let node2 = null;
          if (this.type === tokTypes.backQuote) {
            node2 = this.startNode();
            const start = this.start;
            this.next();
            node2.name = this.value;
            this.next();
            this.expect(tokTypes.backQuote);
            node2.raw = this.input.slice(start, this.lastTokEnd);
            this.finishNode(node2, "Identifier");
          } else if (isIdent) {
            node2 = this.parseIdent(true);
          }
          if (node2) {
            return this.parseChainIdentifier(node2);
          }
          return this.type === tokTypes.name ? this.parseIdent(true) : this.parseLiteral(this.value);
        };
        const parseToken = () => {
          const start = this.start, startLoc = this.startLoc;
          let value = parseNode();
          if (value.type === "Identifier" || value.type === "MemberExpression") {
            if (this.eat(tokTypes.parenL)) {
              const token = this.startNodeAt(start, startLoc);
              token.key = value;
              token.params = [];
              while (tokTypes.parenR !== this.type) {
                token.params.push(parseNode());
                this.eat(tokTypes.comma);
              }
              this.expect(tokTypes.parenR);
              return this.finishNode(token, "StructTableMethodDefinition");
            } else {
              const key = value.name.toLowerCase();
              if (key === "default" || key === "character" || key === "collate" || key === "comment" || key === "using") {
                const token = this.startNodeAt(start, startLoc);
                token.assignment = false;
                token.key = value;
                token.init = parseNode();
                return this.finishNode(token, "StructTablePropertyDefinition");
              } else if (key === "unsigned") {
                this.raise(start, "The `unsigned` keywords must follow `column-type`");
              }
            }
          }
          return value;
        };
        const parseProperties = () => {
          const items = [];
          while (true) {
            if (this.eat(tokTypes.comma) || this.eat(tokTypes.semi) || this.canInsertSemicolon()) {
              break;
            }
            items.push(parseToken());
          }
          return items;
        };
        const check = (token, start, id, message) => {
          if (!(token && token.type === "StructTableMethodDefinition" && (id === "*" || token.key.name.toLowerCase() === id))) {
            this.raise(start, message);
            return false;
          }
          return true;
        };
        while (tokTypes.braceR !== this.type) {
          const column = this.startNode();
          const key = parseNode(true);
          const question = this.eat(tokTypes.question);
          const start = this.start;
          if (this.eat(tokTypes.colon)) {
            column.key = key;
            column.question = question;
            column.typename = parseToken();
            if (check(column.typename, start, "*", "Expect token is `column-type(...)`")) {
              if (this.type === tokTypes.name && this.value.toLowerCase() === "unsigned") {
                column.typename.unsigned = true;
                this.next();
              }
            }
            column.properties = parseProperties();
            node.body.push(column);
            this.finishNode(column, "StructTableColumnDefinition");
          } else if (!question) {
            const name = key.name.toLowerCase();
            column.key = key;
            if (name === "primary" || name === "unique" || name === "fulltext" || name === "key") {
              if (!(name === "key" || name === "primary")) {
                if (!(this.type === tokTypes.name && this.value.toLowerCase() === "key")) {
                  this.raise(this.start, "Expect token is `key` keywords.");
                } else {
                  this.next();
                }
              }
              column.local = parseToken();
              if (name === "primary") {
                check(column.local, start, "key", "Expect token is `primary key(column-name...)`");
              } else {
                check(column.local, start, "*", "Expect token is `key name(column-name...)`");
              }
              column.properties = parseProperties();
              this.finishNode(column, "StructTableKeyDefinition");
              node.body.push(column);
            } else {
              column.properties = parseProperties();
              this.finishNode(column, "StructTableKeyDefinition");
              node.body.push(column);
            }
          } else {
            this.unexpected(start);
          }
        }
        this.expect(tokTypes.braceR);
        while (this.type === tokTypes.name || this.type === tokTypes.backQuote) {
          const property = this.startNode();
          property.key = parseNode(true);
          property.init = null;
          if (this.eat(tokTypes.eq)) {
            property.assignment = true;
            property.init = parseNode();
          }
          node.body.push(property);
          this.finishNode(property, "StructTablePropertyDefinition");
        }
        this.semicolon();
        return this.finishNode(node, "StructTableDeclaration");
      }
      parseUseStatement() {
        this.disabledJSXExpressionFlag = true;
        const node = this.startNode();
        node.keywords = [this.parseIdent(true)];
        node.extends = [];
        if (this.eat(tokTypes.comma)) {
          node.keywords.push(this.parseIdent(true));
        }
        if (this.eat(tokTypes._extends)) {
          do {
            const object = this.startNode();
            object.id = this.parseChainIdentifier();
            object.genericity = this.getGenerics(true);
            object.modifier = [];
            while (this.eat(tokTypes.colon)) {
              const token = this.parseIdent(true);
              object.modifier.push(token);
            }
            node.extends.push(this.finishNode(object, "UseExtendSpecifier"));
          } while (this.eat(tokTypes.comma));
        }
        const body = [];
        if (this.eat(tokTypes.braceL)) {
          while (this.type !== tokTypes.braceR) {
            this.parseInterfaceElementFlag = true;
            const element = this.parseClassElement(false, true, true);
            this.parseInterfaceElementFlag = false;
            if (element) {
              body.push(element);
            }
          }
          this.expect(tokTypes.braceR);
        }
        node.body = body;
        this.semicolon();
        return this.finishNode(node, "UseExtendStatement");
      }
      parseWhenStatement(node) {
        const currentScope = this.currentScope();
        const inherit = (scope, inherit2) => {
          scope.var = scope.var.concat(inherit2.var);
          scope.lexical = scope.lexical.concat(inherit2.lexical);
          scope.functions = scope.functions.concat(inherit2.functions);
        };
        this.next();
        node.test = this.parseParenExpression();
        this.enterScope(SCOPE_FUNCTION | SCOPE_SUPER);
        const whenScope = this.currentScope();
        inherit(whenScope, currentScope);
        node.consequent = super.parseStatement("when");
        this.exitScope();
        this.enterScope(SCOPE_FUNCTION | SCOPE_SUPER);
        const thenScope = this.currentScope();
        inherit(thenScope, currentScope);
        node.alternate = this.eat(tokTypes._then) ? super.parseStatement("then") : null;
        this.exitScope();
        inherit(currentScope, whenScope);
        inherit(currentScope, thenScope);
        return this.finishNode(node, "WhenStatement");
      }
      parseEnumProperty() {
        const node = this.startNode();
        node.key = this.startNode();
        if (this.type === tokTypes.name) {
          node.key.name = this.value;
          this.checkUnreserved(node.key);
          this.finishNode(node.key, "Identifier");
        } else {
          this.unexpected();
        }
        this.next();
        if (this.eat(tokTypes.eq)) {
          node.init = this.type === tokTypes.num ? this.parseLiteral(this.value) : this.parseExprAtom();
        }
        return this.finishNode(node, "EnumProperty");
      }
      parseEnumStatement(node) {
        this.disabledJSXExpressionFlag = true;
        this.next();
        node.key = this.parseIdent(false, false);
        this.expect(tokTypes.braceL);
        this.enterScope(1);
        const properties = [];
        while (this.type !== tokTypes.braceR) {
          if (this.type !== tokTypes.name) {
            this.unexpected();
          }
          properties.push(this.parseEnumProperty());
          if (this.type === tokTypes.comma) {
            this.next();
          }
        }
        node.properties = properties;
        this.expect(tokTypes.braceR);
        this.semicolon();
        this.exitScope();
        return this.finishNode(node, "EnumDeclaration");
      }
      parseClass(node, isStatement) {
        this.disabledJSXExpressionFlag = true;
        return super.parseClass(node, isStatement);
      }
      parseInterface(node) {
        this.disabledJSXExpressionFlag = true;
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, true);
        if (this.type === tokTypes._extends) {
          this.next();
          node.extends = this.parseChainIdentifier();
          if (node.extends) {
            node.extends.genericity = this.getGenerics(true);
          }
        }
        if (this.eat(tokTypes._implements)) {
          node.implements = [];
          do {
            const imp = this.parseChainIdentifier();
            if (imp) {
              imp.genericity = this.getGenerics(true);
            }
            node.implements.push(imp);
          } while (this.eat(tokTypes.comma));
        }
        var body = [];
        this.expect(tokTypes.braceL);
        this.enterScope(1);
        while (this.type !== tokTypes.braceR) {
          this.parseInterfaceElementFlag = true;
          var element = this.parseClassElement(false);
          if (element) {
            body.push(element);
          }
        }
        node.body = body;
        this.strict = oldStrict;
        this.expect(tokTypes.braceR);
        this.exitScope();
        return this.finishNode(node, "InterfaceDeclaration");
      }
      parseDeclarator(node) {
        this.disabledJSXExpressionFlag = true;
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        node.kind = "class";
        var [modifier, staticNode, finalNode] = this.parseModifier();
        node.modifier = modifier;
        node.static = staticNode;
        node.final = finalNode;
        if (this.type === tokTypes._const || this.type === tokTypes._var) {
          const kind = this.value;
          node.expression = this.parseVarStatementDefinition(node, "var", false, true);
          node.expression.kind = kind;
          node.kind = kind;
          return this.finishNode(node, "DeclaratorVariable");
        } else if (this.type === tokTypes._function) {
          this.next();
          node.kind = "function";
          node.id = this.parseIdent();
          const generics = this.parseGenericType();
          this.expect(tokTypes.parenL);
          node.genericity = generics;
          node.params = this.parseBindingList(tokTypes.parenR, false, true);
          if (this.eat(tokTypes.colon)) {
            node.returnType = this.parseTypeStatement();
          }
          this.semicolon();
          this.finishNode(node, "DeclaratorFunction");
          return node;
        } else if (this.type === tokTypes._class) {
          this.next();
          node.kind = "class";
        } else if (this.type === tokTypes._interface) {
          this.next();
          node.kind = "interface";
        } else if (this.value === "module") {
          node.kind = "module";
          this.parseDeclareModule(node);
          return node;
        }
        this.parseClassId(node, false);
        if (this.type === tokTypes._extends) {
          this.next();
          node.extends = this.parseChainIdentifier();
          if (node.extends) {
            node.extends.genericity = this.getGenerics(true);
          }
        }
        if (this.eat(tokTypes._implements)) {
          node.implements = [];
          do {
            const imp = this.parseChainIdentifier();
            if (imp) {
              imp.genericity = this.getGenerics(true);
            }
            node.implements.push(imp);
          } while (this.eat(tokTypes.comma));
        }
        if (this.type !== tokTypes.braceL && node.id && node.id.name === "type") {
          delete node.id;
          node.left = this.parseIdent(true);
          node.genericity = this.parseGenericType();
          node.kind = "type";
          if (this.eat(tokTypes.eq)) {
            node.right = this.parseTypeStatement(false);
          } else {
            this.unexpected();
          }
          this.semicolon();
          return this.finishNode(node, "DeclaratorTypeAlias");
        }
        var body = [];
        this.expect(tokTypes.braceL);
        this.enterScope(1);
        while (this.type !== tokTypes.braceR) {
          this.parseInterfaceElementFlag = true;
          var element = this.parseClassElement(node.kind === "class", true);
          if (element) {
            body.push(element);
          }
        }
        this.expect(tokTypes.braceR);
        this.strict = oldStrict;
        node.body = body;
        this.exitScope();
        this.finishNode(node, "DeclaratorDeclaration");
        return node;
      }
      eatContextual(k) {
        if (k === "as" && this.eat(tokTypes._as))
          return true;
        const result = super.eatContextual(k);
        if (result && (k === "get" || k === "set") && this.tryPropertyContextualFlag) {
          this.tryPropertyContextualGenerics = this.parseGenericType();
          this.tryPropertyContextualFlag = false;
        }
        return result;
      }
      parseChainIdentifier(base = null, isImporter = false) {
        const startPos = this.start, startLoc = this.startLoc;
        const type2 = this.type;
        base = base || super.parseIdent(type2 === tokTypes._void || type2 === tokTypes._class || type2 === tokTypes._this);
        while (this.eat(tokTypes.dot)) {
          if (isImporter && this.canInsertSemicolon()) {
            if (this.keywords.test(this.value) && this.input.charCodeAt(this.start + this.value.length) === 32) {
              this.unexpected(this.lastTokEnd);
            }
          }
          const node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          node.property = this.parseIdent(this.options.allowReserved !== "never");
          base = this.finishNode(node, "MemberExpression");
        }
        return base;
      }
      parseGenericType() {
        if (this.type === tokTypes.relational && this.value && this.value.charCodeAt(0) === 60) {
          const generics = this.startNode();
          const elements = [];
          const endToken = this.__$endToken || (this.__$endToken = []);
          endToken.push({ token: tokTypes.bitShift, value: tokTypes.relational, endCode: 62 });
          this.next();
          do {
            let start = this.start, startLoc = this.startLoc;
            let left = this.parseTypeStatement();
            let type2 = left;
            if (this.eat(tokTypes.eq)) {
              type2 = this.startNodeAt(start, startLoc);
              type2.left = left;
              type2.right = this.parseTypeStatement();
              this.finishNode(type2, "GenericTypeAssignmentDeclaration");
            } else {
              if (this.eat(tokTypes._extends)) {
                left.extends = this.parseTypeStatement();
              }
              this.finishNode(type2, "GenericTypeDeclaration");
            }
            elements.push(type2);
          } while (this.eat(tokTypes.comma));
          if (!(this.type === tokTypes.relational && this.value.charCodeAt(0) === 62)) {
            this.unexpected();
          } else {
            this.next();
          }
          endToken.pop();
          generics.elements = elements;
          return this.finishNode(generics, "GenericDeclaration");
        }
        return null;
      }
      testTupleUnion() {
        const content = this.input;
        let index = this.start;
        let balancer = 1;
        let comment = false;
        while (index < content.length) {
          const code = content.charCodeAt(index);
          if (comment === false && code === 47 && content.charCodeAt(index + 1) === 42) {
            comment = 47;
            index++;
          } else if (code === 42 && content.charCodeAt(index + 1) === comment) {
            comment = false;
            index++;
          } else if (comment === false && code === 47 && content.charCodeAt(index + 1) === 47) {
            comment = 10;
            index++;
          } else if (comment === code) {
            comment = false;
          } else if (comment === false) {
            if (code === 40) {
              balancer++;
            } else if (code === 41) {
              balancer--;
            }
            if (code === 59 || balancer === 0) {
              break;
            }
          }
          index++;
        }
        if (balancer === 0) {
          while (index < content.length && content.charCodeAt(index + 1) === 32 && index++)
            ;
          return {
            arrow: content.charCodeAt(index + 1) === 61 && content.charCodeAt(index + 2) === 62,
            array: content.charCodeAt(index + 1) === 91
          };
        }
        return null;
      }
      testGenericsContext() {
        const content = this.input;
        let index = this.start;
        let balancer = 0;
        let comment = false;
        while (index < content.length) {
          const code = content.charCodeAt(index);
          if (comment === false && code === 47 && content.charCodeAt(index + 1) === 42) {
            comment = 47;
            index++;
          } else if (code === 42 && content.charCodeAt(index + 1) === comment) {
            comment = false;
            index++;
          } else if (comment === false && code === 47 && content.charCodeAt(index + 1) === 47) {
            comment = 10;
            index++;
          } else if (comment === code) {
            comment = false;
          } else if (comment === false) {
            if (code === 60) {
              balancer++;
            } else if (code === 62) {
              balancer--;
            }
            if (balancer > 0 && (code === 123 || code === 91))
              return true;
            const allow = code >= 97 && code <= 122 || code >= 65 && code <= 93 || code >= 48 && code <= 57 && index > this.start || code === 44 || code === 13 || code === 10 || code === 36 || code === 32 || code === 95 || code === 60 || code === 62 || code === 46;
            if (!allow || balancer === 0) {
              break;
            }
          }
          index++;
        }
        return balancer === 0;
      }
      getGenerics(flag, node) {
        if (this.type === tokTypes.relational && this.value && this.value.charCodeAt(0) === 60) {
          if (!flag) {
            flag = this.testGenericsContext();
          }
          if (flag) {
            this.next();
            const generics = [];
            const endToken = this.__$endToken || (this.__$endToken = []);
            endToken.push({ token: tokTypes.bitShift, value: tokTypes.relational, endCode: 62 });
            while (!(this.type === tokTypes.relational && this.value.charCodeAt(0) === 62 && this.value.length === 1)) {
              const type2 = this.parseTypeStatement();
              if (type2.restElement) {
                this.raise(type2.start, "Rest type can only appear in tuple types");
              }
              generics.push(type2);
              if (!this.eat(tokTypes.comma)) {
                break;
              }
            }
            endToken.pop();
            if (this.type === tokTypes.relational && this.value.charCodeAt(0) === 62 && this.value.length === 1) {
              this.next();
            } else {
              this.raise(this.start, `Expected '>'`);
            }
            if (node) {
              node.typeElements = generics;
              this.finishNode(node, "TypeGenericDefinition");
            }
            return generics;
          }
        }
        return null;
      }
      readToken_lt_gt(code) {
        if (code === 62) {
          const endToken = this.__$endToken;
          if (endToken && endToken.length > 0) {
            return super.finishOp(tokTypes.relational, 1);
          }
        }
        return super.readToken_lt_gt(code);
      }
      parseTypeStatement(prefix) {
        if (tokTypes._typeof === this.type) {
          this.next();
          let node2 = this.startNode();
          node2.value = this.parseExpression();
          return this.finishNode(node2, "TypeTypeofDefinition");
        }
        let start = this.start, startLoc = this.startLoc;
        let node = this.parseTypeStatementItem(prefix);
        let unions = [node];
        let _startLoc = this.startLoc;
        while (true) {
          if (this.eat(tokTypes.bitwiseOR)) {
            unions.push(this.parseTypeStatementItem());
          } else if (this.eat(tokTypes.bitwiseAND)) {
            const left = unions.pop();
            const intersection = this.startNodeAt(left.start, _startLoc);
            intersection.left = left;
            intersection.right = this.parseTypeStatementItem();
            unions.push(intersection);
            this.finishNode(intersection, "TypeIntersectionDefinition");
            _startLoc = this.startLoc;
          } else {
            break;
          }
        }
        if (unions.length > 1) {
          const unionNode = this.startNodeAt(start, startLoc);
          unionNode.elements = unions;
          return this.finishNode(unionNode, "TypeUnionDefinition");
        }
        return unions[0];
      }
      parseTypeStatementItem(prefix) {
        let node = prefix ? this.startNodeAt(prefix.start, prefix.loc ? prefix.loc.start : 0) : this.startNode();
        let typeName = "TypeDefinition";
        let declGenerics = this.parseGenericType();
        if (this.type === tokTypes._void) {
          node.value = this.parseChainIdentifier();
          this.finishNode(node, typeName);
        } else if (this.type === tokTypes.name || this.type === tokTypes._class || this.type === tokTypes._this) {
          if (this.value === "keyof") {
            this.next();
            node.value = this.parseTypeStatement();
            this.finishNode(node, "TypeKeyofDefinition");
          } else {
            node.value = this.parseChainIdentifier();
            if (!this.canInsertSemicolon()) {
              const generics = this.getGenerics(true);
              if (generics) {
                node.typeElements = generics;
                typeName = "TypeGenericDefinition";
              }
            }
            this.finishNode(node, typeName);
            if (this.type === tokTypes.bracketL && !this.canInsertSemicolon()) {
              node = this.parseTypeStatement(node);
            }
          }
        } else if (this.eat(tokTypes.bracketL)) {
          const elements = [];
          while (!(this.type === tokTypes.bracketR)) {
            const start = this.start, startLoc = this.startLoc;
            const restElement = !!this.eat(tokTypes.ellipsis);
            let nodeType = this.parseTypeStatement();
            if (restElement) {
              const restNode = this.startNodeAt(start, startLoc);
              restNode.value = nodeType;
              this.finishNode(restNode, "TypeTupleRestDefinition");
              nodeType = restNode;
            }
            elements.push(nodeType);
            if (!this.eat(tokTypes.comma)) {
              break;
            }
          }
          this.expect(tokTypes.bracketR);
          if (prefix && elements.length === 1) {
            node.object = prefix;
            node.property = elements[0];
            typeName = "TypeComputeDefinition";
          } else {
            node.prefix = prefix;
            node.elements = elements;
            typeName = "TypeTupleDefinition";
          }
          this.finishNode(node, typeName);
          if (this.type === tokTypes.bracketL && !this.canInsertSemicolon()) {
            node = this.parseTypeStatement(node);
          }
        } else if (this.eat(tokTypes.braceL)) {
          let first = true;
          node.properties = [];
          const propHash = {};
          const parseProperty = () => {
            const prop = this.startNode();
            if (this.eat(tokTypes.bracketL)) {
              prop.key = this.parseIdent(false);
              this.expect(tokTypes.colon);
              prop.key.acceptType = this.parseTypeStatement();
              prop.key.computed = true;
              this.expect(tokTypes.bracketR);
            } else {
              prop.key = this.parseIdent(this.options.allowReserved !== "never");
            }
            if (this.eat(tokTypes.question)) {
              prop.key.question = true;
            }
            if (this.eat(tokTypes.colon)) {
              prop.value = this.parseTypeStatement();
            }
            if (propHash[prop.key.name]) {
              this.raiseRecoverable(prop.key.start, "Redefinition of property");
            }
            propHash[prop.key.name] = true;
            return this.finishNode(prop, "TypeObjectPropertyDefinition");
          };
          while (!this.eat(tokTypes.braceR)) {
            if (!first) {
              this.expect(tokTypes.comma);
              if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(tokTypes.braceR)) {
                break;
              }
            } else {
              first = false;
            }
            node.properties.push(parseProperty());
          }
          this.finishNode(node, "TypeObjectDefinition");
          if (this.type === tokTypes.bracketL && !this.canInsertSemicolon()) {
            node = this.parseTypeStatement(node);
          }
        } else if (this.eat(tokTypes.parenL)) {
          if (this.type === tokTypes.parenL) {
            node = this.parseTypeStatement();
            this.expect(tokTypes.parenR);
          } else {
            const result = this.testTupleUnion();
            if (result && !result.arrow && result.array) {
              const tynode = this.parseTypeStatement();
              this.expect(tokTypes.parenR);
              this.expect(tokTypes.bracketL);
              this.expect(tokTypes.bracketR);
              if (tynode.type === "TypeUnionDefinition" || tynode.type === "TypeIntersectionDefinition") {
                typeName = "TypeTupleUnionDefinition";
                node = tynode;
              } else {
                typeName = "TypeTupleDefinition";
                node.prefix = tynode;
                node.elements = [];
              }
            } else {
              const params = this.parseBindingList(tokTypes.parenR, false, this.options.ecmaVersion >= 8);
              this.expect(tokTypes.arrow);
              node.params = params;
              node.value = this.parseTypeStatement();
              node.genericity = declGenerics;
              typeName = "TypeFunctionDefinition";
            }
            this.finishNode(node, typeName);
          }
        } else if (tokTypes.num === this.type || tokTypes.string === this.type || tokTypes._null === this.type || tokTypes._true === this.type || tokTypes._false === this.type) {
          node.value = this.parseExprAtom();
          this.finishNode(node, typeName);
        } else if (tokTypes.plusMin === this.type) {
          const value = this.value;
          this.next();
          if (tokTypes.num === this.type) {
            node.value = this.parseExprAtom();
            if (String(value).charCodeAt(0) === 45) {
              node.value.value = -node.value.value;
              node.value.raw = String(node.value.value);
            }
            this.finishNode(node, typeName);
          } else {
            this.unexpected();
          }
        } else {
          this.unexpected();
        }
        if (declGenerics && node.type !== "TypeFunctionDefinition") {
          this.unexpected();
        }
        return node;
      }
      parseAnnotation(nonStatement) {
        const node = this.startNode();
        this.next();
        node.name = this.value;
        var n = node.name;
        this.next();
        if (this.eat(tokTypes.parenL)) {
          node.body = [];
          const getParamNode = () => {
            var startPos = this.start, startLoc = this.startLoc;
            switch (this.type) {
              case tokTypes.string:
              case tokTypes.num:
              case tokTypes._null:
              case tokTypes._true:
              case tokTypes._false:
                return super.parseExprAtom();
              default:
                const node2 = this.parseMaybeDefault(startPos, startLoc);
                if (node2.type === "Identifier") {
                  return this.parseSubscripts(node2, startPos, startLoc, true);
                } else if (node2.type === "AssignmentPattern" || node2.type === "ArrayPattern" || node2.type === "ObjectPattern") {
                  return node2;
                } else {
                  this.raise(this.pos, `Annotation expression parameters can only is scalar type`);
                }
            }
          };
          while (this.type !== tokTypes.parenR) {
            const param = getParamNode();
            if (param) {
              node.body.push(param);
            }
            if (!this.eat(tokTypes.comma)) {
              break;
            }
          }
          this.expect(tokTypes.parenR);
        }
        if (nonStatement === true) {
          this.finishNode(node, "AnnotationExpression");
          if (this.canInsertSemicolon()) {
            this.semicolon();
          }
          return node;
        } else {
          this.semicolon();
          return this.finishNode(node, "AnnotationDeclaration");
        }
      }
      parseMetatype() {
        const node = this.startNode();
        node.name = this.value;
        this.next();
        if (this.eat(tokTypes.parenL)) {
          node.body = [];
          while (this.type !== tokTypes.parenR) {
            const elem = this.startNode();
            const left = this.startNode();
            elem.name = this.value;
            left.name = this.value;
            this.next();
            if (this.eat(tokTypes.eq)) {
              elem.left = this.finishNode(left, "Identifier");
              elem.right = this.parseMaybeAssign();
            }
            node.body.push(elem);
            if (elem.right) {
              this.finishNode(elem, "AssignmentPattern");
            } else {
              this.finishNode(elem, "Identifier");
            }
            if (!this.eat(tokTypes.comma)) {
              break;
            }
          }
          this.expect(tokTypes.parenR);
        }
        this.expect(tokTypes.bracketR);
        this.semicolon();
        return this.finishNode(node, "MetatypeDeclaration");
      }
      parseModifier() {
        const modifierItems = Array(3);
        while (tokenModifiers.includes(this.type)) {
          const modifier = this.startNode();
          const name = this.type.label;
          modifier.name = name;
          this.next();
          this.finishNode(modifier, "ModifierDeclaration");
          if (name === "final") {
            modifierItems[3] = modifier;
          } else if (name === "static") {
            modifierItems[1] = modifier;
          } else {
            modifierItems[0] = modifier;
          }
        }
        return modifierItems;
      }
      parseClassProperty(node, kind, bracketStarted, isDeclareInterface) {
        node = this.parseVarStatementDefinition(node, kind, bracketStarted, isDeclareInterface);
        if (isDeclareInterface && node.type === "MethodDefinition" && bracketStarted) {
          return node;
        }
        if (node.declarations && node.declarations.length > 1) {
          this.raise(node.start, `Only one class property member can be defined in a declaration`);
        }
        return this.finishNode(node, "PropertyDefinition");
      }
      parseVarStatementDefinition(node, kind, bracketStarted, isDeclareInterface) {
        if (!bracketStarted)
          this.next();
        const start = this.start;
        const startLoc = this.startLoc;
        const dynamic = this.eat(tokTypes.bracketL);
        var decl = this.startNodeAt(start, startLoc);
        var id = this.parseIdent(false);
        this.checkLVal(id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
        decl.dynamic = dynamic;
        if (dynamic) {
          this.expect(tokTypes.colon);
          id.acceptType = this.parseTypeStatement();
          this.expect(tokTypes.bracketR);
        }
        if (bracketStarted && isDeclareInterface) {
          var genericity = this.parseGenericType();
          if (this.type === tokTypes.parenL) {
            decl.key = id;
            this.tryPropertyContextualGenerics = genericity;
            return this.parseClassMethod(decl);
          } else if (genericity) {
            this.unexpected();
          }
        }
        if (this.eat(tokTypes.question)) {
          decl.question = true;
        }
        if (this.eat(tokTypes.colon)) {
          decl.acceptType = this.parseTypeStatement();
        }
        if (this.eat(tokTypes.eq)) {
          decl.init = this.parseMaybeAssign();
        }
        decl.id = id;
        node.declarations = [this.finishNode(decl, "VariableDeclarator")];
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      parseClassElement(constructorAllowsSuper, isDeclareInterface, isUseStatement) {
        if (this.type === tokTypes._annotation) {
          return this.parseAnnotation();
        }
        if (this.eat(tokTypes.semi)) {
          return null;
        }
        var start = this.start, startLoc = this.startLoc;
        var isNew = this.eat(tokTypes._new);
        const declGenerics = this.parseGenericType();
        if (tokTypes.parenL === this.type || isNew) {
          const node = this.startNodeAt(start, startLoc);
          node.genericity = declGenerics;
          this.enterScope(functionFlags(true));
          super.parseFunctionParams(node);
          if (this.eat(tokTypes.colon)) {
            node.returnType = this.parseTypeStatement();
          }
          if (tokTypes.braceL === this.type) {
            this.raise(this.start, `Definition '${isNew ? "new" : "call"}' description can only is abstracts`);
          }
          this.exitScope();
          return this.finishNode(node, isNew ? "NewDefinition" : "CallDefinition");
        }
        const modifier = this.parseModifier();
        const isBracket = this.type === tokTypes.bracketL;
        const isProperty = isBracket || this.type === tokTypes._const || this.type === tokTypes._var;
        this.tryPropertyContextualFlag = true;
        this.isDeclareInterfaceFlag = isDeclareInterface;
        this.isUseStatement = isUseStatement;
        if (!isUseStatement && !isProperty && this.value === "use" && !modifier.some((item2) => !!item2)) {
          const type2 = this.step();
          if (type2 === tokTypes._static || type2 === tokTypes._this) {
            this.apply();
            return this.parseUseStatement();
          } else {
            this.apply(-1);
          }
        }
        const element = isProperty ? this.parseClassProperty(this.startNode(), isBracket ? "var" : this.value, isBracket, isDeclareInterface || isUseStatement) : super.parseClassElement(constructorAllowsSuper);
        if (element && element.kind === "method" && element.isPropertyDefinition) {
          var decl = this.startNodeAt(start, startLoc);
          var key = element.key;
          decl.id = key;
          decl.question = !!key.question;
          decl.acceptType = key.acceptType;
          decl.init = key.init;
          element.declarations = [decl];
          element.kind = "var";
          this.finishNode(decl, "VariableDeclarator");
          this.finishNode(element, "PropertyDefinition");
          delete key.init;
          delete key.acceptType;
          delete key.question;
          delete element.key;
          delete element.isPropertyDefinition;
        }
        const generics = this.tryPropertyContextualGenerics;
        if (generics && element.type === "MethodDefinition") {
          element.value.genericity = generics;
        }
        this.tryPropertyContextualGenerics = null;
        if (modifier[0]) {
          element.modifier = modifier[0];
        }
        if (modifier[1]) {
          element.static = modifier[1];
        }
        if (modifier[2]) {
          element.final = modifier[2];
        }
        return element;
      }
      parsePropertyName(prop) {
        if (!prop.key && (prop.kind === "get" || prop.kind === "set")) {
          if (this.type === tokTypes.question || this.type === tokTypes.parenL) {
            const node2 = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
            node2.question = this.type === tokTypes.question;
            node2.name = prop.kind;
            prop.kind = "method";
            prop.key = node2;
            this.finishNode(node2, "Identifier");
            this.next();
            return node2;
          }
        }
        const node = super.parsePropertyName(prop);
        if (prop.kind === "method") {
          if (this.eat(tokTypes.question)) {
            node.question = true;
          }
          if (prop.key) {
            if (this.eat(tokTypes.colon)) {
              prop.isPropertyDefinition = true;
              prop.key.acceptType = this.parseTypeStatement();
            }
            if (this.eat(tokTypes.eq)) {
              prop.isPropertyDefinition = true;
              prop.key.init = super.parseMaybeAssign();
            }
            if (tokTypes.parenL !== this.type) {
              if (tokTypes.semi === this.type || this.canInsertSemicolon()) {
                prop.isPropertyDefinition = true;
              }
            }
            if (prop.isPropertyDefinition) {
              if (this.isDeclareInterfaceFlag) {
                this.isDeclareInterfaceFlag = false;
                this.eat(tokTypes.comma);
              }
              this.semicolon();
            }
          }
        }
        return node;
      }
      parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper) {
        if (method.isPropertyDefinition) {
          return method;
        } else {
          return super.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
        }
      }
      parseImportSpecifiers() {
        var nodes = [], first = true;
        if (this.type === tokTypes.name) {
          var node = this.startNode();
          node.local = this.parseChainIdentifier(null, true);
          nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
          if (!this.eat(tokTypes.comma)) {
            return nodes;
          }
          this.checkLVal(node.local, BIND_LEXICAL);
        }
        if (this.type === tokTypes.star) {
          var node$1 = this.startNode();
          this.next();
          this.expect(tokTypes._as);
          node$1.local = this.parseIdent();
          this.checkLVal(node$1.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
          return nodes;
        }
        this.expect(tokTypes.braceL);
        while (!this.eat(tokTypes.braceR)) {
          if (!first) {
            this.expect(tokTypes.comma);
            if (this.afterTrailingComma(tokTypes.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var node$2 = this.startNode();
          node$2.imported = this.parseIdent(true);
          if (this.eat(tokTypes._as)) {
            node$2.local = this.parseIdent();
          } else {
            this.checkUnreserved(node$2.imported);
            node$2.local = node$2.imported;
          }
          this.checkLVal(node$2.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node$2, "ImportSpecifier"));
        }
        return nodes;
      }
      checkLocalExport() {
      }
      parseImport(node) {
        this.next();
        if (this.type === tokTypes.string) {
          node.specifiers = [];
          node.source = this.parseExprAtom();
        } else {
          this.enterScope(SCOPE_TOP);
          const specifiers = this.parseImportSpecifiers();
          if (this.eatContextual("from")) {
            node.specifiers = specifiers;
            node.source = this.type === tokTypes.string ? this.parseExprAtom() : this.unexpected();
          } else {
            if (specifiers.length === 1 && specifiers[0].type === "ImportDefaultSpecifier") {
              node.specifiers = [];
              node.source = specifiers[0].local;
              if (this.eat(tokTypes._as)) {
                if (this.type !== tokTypes.name) {
                  this.unexpected();
                }
                node.alias = super.parseIdent();
              }
            } else {
              this.unexpected();
            }
          }
          this.exitScope();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      parsePackage(node, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        node.body = [];
        node.id = null;
        if (this.type === tokTypes.semi) {
          this.next();
        } else if (tokTypes.braceL !== this.type) {
          node.id = this.parseChainIdentifier();
          if (this.type === tokTypes.semi) {
            this.next();
          }
        }
        const metatype = () => {
          if (this.type === tokTypes._annotation) {
            return this.parseAnnotation();
          }
          return null;
        };
        if (this.eat(tokTypes.braceL)) {
          node.isBlock = true;
          while (!this.eat(tokTypes.braceR)) {
            const item2 = metatype();
            if (item2) {
              node.body.push(item2);
            } else {
              node.body.push(this.parseStatement(null, true));
            }
          }
        } else {
          node.isBlock = false;
          while (!(tokTypes.eof === this.type || tokTypes._package === this.type)) {
            const item2 = metatype();
            if (item2) {
              node.body.push(item2);
            } else {
              node.body.push(this.parseStatement(null, true));
            }
          }
        }
        this.strict = oldStrict;
        return this.finishNode(node, "PackageDeclaration");
      }
      parseDeclareModule(node) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        node.body = [];
        node.id = null;
        if (this.type === tokTypes.semi) {
          this.raise(this.start, "Declared module identifier cannot is empty.");
        } else if (tokTypes.braceL !== this.type) {
          node.id = this.parseExprSubscripts();
          if (this.type === tokTypes.semi) {
            this.next();
          }
        }
        if (!node.id) {
          this.raise(this.start, "Declared module missing identifier.");
        }
        const metatype = () => {
          if (this.type === tokTypes._annotation) {
            return this.parseAnnotation();
          }
          return null;
        };
        if (this.eat(tokTypes.braceL)) {
          node.isBlock = true;
          while (!this.eat(tokTypes.braceR)) {
            const item2 = metatype();
            if (item2) {
              node.body.push(item2);
            } else {
              node.body.push(this.parseStatement(null, true, false, true));
            }
          }
        } else {
          this.unexpected();
        }
        this.strict = oldStrict;
        return this.finishNode(node, "ModuleDeclaration");
      }
      hasBacklash(pos) {
        let num = 0;
        while (this.input.charCodeAt(pos--) === 92 && pos > 0) {
          num++;
        }
        return num % 2 === 1;
      }
      jsx_readWhitespaceToken(code) {
        const start = this.pos;
        let isNewLine = false;
        while (code === 32 || (isNewLine = acorn.isNewLine(code))) {
          ++this.pos;
          if (isNewLine) {
            isNewLine = false;
            if (code === 13 && this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
          }
          code = this.input.charCodeAt(this.pos);
        }
        if (this.pos !== start) {
          this.finishToken(tt_whitespace, this.input.slice(start, this.pos));
          return true;
        }
        return false;
      }
      jsx_readTextToken(endTag) {
        let out = "", chunkStart = this.pos;
        this.start = chunkStart;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated JSX contents");
          }
          let ch = this.input.charCodeAt(this.pos);
          if (acorn.isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.jsx_readNewLine(true);
            chunkStart = this.pos;
          } else if (endTag) {
            if (ch === 60 && this.input.charCodeAt(this.pos + 1) === 47) {
              if (!this.hasBacklash(this.pos - 1)) {
                if (this.input.substr(this.pos + 2, endTag.length).toLowerCase() === endTag) {
                  out += this.input.slice(chunkStart, this.pos);
                  return this.finishToken(tt_content_text, out);
                }
              }
            }
            ++this.pos;
          } else {
            if (ch === 93 && this.input.charCodeAt(this.pos + 1) === 93 && this.input.charCodeAt(this.pos + 2) === 62) {
              if (!this.hasBacklash(this.pos - 1)) {
                out += this.input.slice(chunkStart, this.pos);
                return this.finishToken(tt_content_text, out);
              }
            }
            ++this.pos;
          }
        }
      }
      jsx_parseOpeningElementAt(startPos, startLoc) {
        let node = this.startNodeAt(startPos, startLoc);
        node.attributes = [];
        let nodeName = this.jsx_parseElementName();
        if (nodeName)
          node.name = nodeName;
        while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)
          node.attributes.push(this.jsx_parseAttribute());
        node.selfClosing = this.eat(tt.slash);
        if (nodeName && typeof nodeName.name === "string" && !node.selfClosing) {
          const name = nodeName.name.toLowerCase();
          if (name === "script" || name === "style") {
            if (name === "script") {
              this.context.push(tc_script_expr);
            } else {
              this.context.push(tc_style_expr);
            }
          }
        }
        this.expect(tok.jsxTagEnd);
        return this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
      }
      jsx_parseElementAt(startPos, startLoc) {
        let node = this.startNodeAt(startPos, startLoc);
        let children = [];
        let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
        let closingElement = null;
        let scriptType = null;
        if (openingElement.name) {
          const tagName = getQualifiedJSXName(openingElement.name).toLowerCase();
          if (tagName === "style") {
            scriptType = "Style";
          } else if (tagName === "script") {
            scriptType = "Script";
          }
        }
        if (!openingElement.selfClosing) {
          const curCtx = this.curContext();
          if (curCtx === tc_style_expr && this.type !== tt_cdata_start) {
            const scriptNode = this.startNode();
            scriptNode.body = [];
            while (this.type !== tok.jsxTagStart) {
              switch (this.type) {
                case tt_whitespace:
                case tt_content_text:
                case tok.jsxText:
                  children.push(this.finishNode(this.parseLiteral(this.value), "JSXText"));
                  break;
                default:
                  this.unexpected();
              }
            }
            scriptType = "Style";
            startPos = this.start;
            startLoc = this.startLoc;
            this.expect(tok.jsxTagStart);
            this.expect(tt.slash);
            closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
          } else if (curCtx === tc_script_expr && this.type !== tt_cdata_start) {
            this.enterScope(1);
            while (this.type !== tok.jsxTagStart) {
              if (this.type === tokTypes._import) {
                children.push(this.parseImport(this.startNode()));
              } else {
                children.push(this.parseClassElement(true));
              }
            }
            this.exitScope();
            scriptType = "Script";
            startPos = this.start;
            startLoc = this.startLoc;
            this.expect(tok.jsxTagStart);
            this.expect(tt.slash);
            closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
          } else {
            contents:
              for (; ; ) {
                switch (this.type) {
                  case tok.jsxTagStart:
                    startPos = this.start;
                    startLoc = this.startLoc;
                    this.next();
                    if (this.eat(tt.slash)) {
                      closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                      break contents;
                    }
                    children.push(this.jsx_parseElementAt(startPos, startLoc));
                    break;
                  case tok.jsxText:
                    children.push(this.parseExprAtom());
                    break;
                  case tt.braceL:
                    children.push(this.jsx_parseExpressionContainer());
                    break;
                  case tt_cdata_start:
                    this.next();
                    children.push(this.finishNode(this.parseLiteral(this.value), "JSXCdata"));
                    this.expect(tt_cdata_end);
                    break;
                  case tt_content_text:
                    children.push(this.finishNode(this.parseLiteral(this.value), "JSXText"));
                    break;
                  case tt_whitespace:
                    children.push(this.finishNode(this.parseLiteral(this.value), "JSXText"));
                    break;
                  default:
                    this.unexpected();
                }
              }
          }
          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
            this.raise(
              closingElement.start,
              "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">"
            );
          }
        }
        let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
        node["opening" + fragmentOrElement] = openingElement;
        node["closing" + fragmentOrElement] = closingElement;
        node.children = children;
        if (this.type === tt.relational && this.value === "<") {
          this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
        }
        if (scriptType) {
          return this.finishNode(node, "JSX" + scriptType);
        } else {
          return this.finishNode(node, "JSX" + fragmentOrElement);
        }
      }
      jsx_readCDATAToken(code, noSkip) {
        if (!noSkip && this.jsx_readWhitespaceToken(code)) {
          return true;
        }
        let pos = this.pos;
        if (code === 60 && this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 91 && this.input.charCodeAt(pos + 8) === 91 && this.input.substr(pos + 3, 5) === "CDATA") {
          this.pos += 9;
          this.finishToken(tt_cdata_start);
          return true;
        } else if (code === 93 && this.input.charCodeAt(pos + 1) === 93 && this.input.charCodeAt(pos + 2) === 62) {
          this.pos += 3;
          this.finishToken(tt_cdata_end);
          return true;
        }
      }
      updateContext(prevType) {
        if (this.type === tt.slash && prevType === tok.jsxTagStart) {
          const context = this.context[this.context.length - 3];
          if (context === tc_script_expr || context === tc_style_expr) {
            this.context.splice(this.context.length - 3, 1);
          }
        } else if (prevType === tt_cdata_start && this.curContext() === tc_cdata_expr) {
          this.context.pop();
        }
        super.updateContext(prevType);
        if (this.exprAllowed && this.context[this.context.length - 2] === tc_type_statement) {
          this.exprAllowed = false;
        } else if (!this.exprAllowed) {
          const ctx2 = this.curContext();
          if (ctx2 === tc_script_expr) {
            this.exprAllowed = this.type === tt.braceR || this.type === tok.jsxTagEnd;
          } else if (ctx2 === tokContexts.b_stat || ctx2 === tokContexts.b_expr) {
            this.exprAllowed = this.type === tok.jsxTagEnd;
          }
        }
      }
    };
    Parser.extend(function() {
      return SyntaxParser;
    });
    SyntaxParser.parse = function parse(input, options) {
      options = Object.assign({ preserveParens: true }, options || {});
      const obj = new SyntaxParser(options, input);
      const res = obj.parse();
      return res;
    };
    SyntaxParser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
      options = Object.assign({ preserveParens: true }, options || {});
      var parser = new SyntaxParser(options, input, pos);
      if (options.isMethod) {
        parser.enterScope(functionFlags(!!options.isAsync, !!options.generator) | SCOPE_SUPER | (!!options.allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      }
      parser.nextToken();
      return parser.parseExpression();
    };
    var parseJSX = Parser.extend(jsx({ allowNamespaces: true, allowNamespacedObjects: true }));
    SyntaxParser.jsx = function jsx2(input, options) {
      return parseJSX.parse(input, options);
    };
    module.exports = {
      acorn,
      parseJSX,
      Parser: SyntaxParser
      // lessParser:(function(){
      //     const less = require('less');
      //     const defaultOptions = lodash.merge({}, less.options);
      //     return {
      //         _options:defaultOptions,
      //         input:'',
      //         option( options ){
      //             if( options ){
      //                 this._options = lodash.merge(this._options, options);
      //             }
      //             return this._options;
      //         },
      //         render(input){
      //         },
      //         getRangeByNode(node){
      //             if( node && this.input && node._index >= 0 ){
      //                const liens = this.input.substr(0,node._index).split(/\n/);
      //                return {
      //                    line:liens.length,
      //                    column:liens[liens.length].length
      //                }
      //             }
      //             return null;
      //         },
      //         toCSS( rootNode, imports){
      //             const tree = new less.ParseTree(rootNode, imports || this.imports )
      //             return tree.toCSS(this.callOptions || this._options);
      //         },
      //         parse(input, callback){
      //             this.input = input;
      //             less.parse(input, this._options, (err, root, imports, options)=>{
      //                 this.imports = imports;
      //                 this.callOptions = options;
      //                 callback(err, root, imports, options)
      //             })
      //         }
      //     };
      // }())
    };
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports, module) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = __require("color-convert");
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module) {
    "use strict";
    module.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module) {
    "use strict";
    var os = __require("os");
    var tty = __require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/chalk/source/util.js
var require_util = __commonJS({
  "node_modules/chalk/source/util.js"(exports, module) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "node_modules/chalk/source/templates.js"(exports, module) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/chalk/source/index.js"(exports, module) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self, string) => {
      if (self.level <= 0 || !string) {
        return self._isEmpty ? "" : string;
      }
      let styler = self._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(
          String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i])
        );
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module.exports = chalk;
  }
});

// lib/core/Lang.js
var require_Lang = __commonJS({
  "lib/core/Lang.js"(exports, module) {
    var chalk = require_source();
    var chalkInfo = chalk.keyword("orange");
    var chalkBgWarn = chalk.bgMagenta;
    var chalkWarn = chalk.magenta;
    var messages = {};
    var langIndexs = [0, 1];
    var langId = 0;
    function define(code, value) {
      messages[code] = value;
    }
    define("note", [
      chalk.bgRed("[\u63D0\u793A]"),
      chalk.bgRed("[Note]")
    ]);
    define("error", [
      `${chalk.red("\u2718")} ${chalk.bgRed("[\u9519\u8BEF]")}`,
      `${chalk.red("\u2718")} ${chalk.bgRed("[Error]")}`
    ]);
    define("warn", [
      `${chalkWarn("\u203B")} ${chalkBgWarn("[\u8B66\u544A]")}`,
      `${chalkWarn("\u203B")} ${chalkBgWarn("[Warn]")}`
    ]);
    define("info", [
      chalkInfo("\u261E [\u4FE1\u606F]"),
      chalkInfo("\u261E [Info]")
    ]);
    define(100, [
      `\u6709${chalk.red(" %s ")}\u4E2A\u7F16\u8BD1\u9519\u8BEF\u9700\u8981\u4FEE\u590D\u3002\u8BF7\u5173\u6CE8\u8F93\u51FA\u4FE1\u606F`,
      `there ${chalk.red("has %s errors")} compilation that need to be fixed. please review the output`
    ]);
    define(101, [
      `\u5728\u7F16\u8BD1\u8FC7\u7A0B\u4E2D\u53D1\u73B0\u4E86\u4E00\u4E9B\u9519\u8BEF\uFF0C\u9700\u8981\u5148\u66F4\u6B63\u4E4B\u540E\u518D\u6784\u5EFA`,
      `There has errors found during compilation that need to corrected before building`
    ]);
    function getMessage(langId2, code, args = []) {
      let dataset = messages[code];
      let value = dataset ? dataset[langId2] : null;
      if (!value) {
        value = "unknown";
        if (typeof code === "string") {
          value = code;
        }
        return value;
      }
      let index = 0;
      return value.replace(/(?<!\\)(%([s|S]|\d+))/g, (name) => {
        const at = parseInt(name.substr(1, 1));
        const result = at > 0 ? args[at - 1] : args[index++];
        return result === void 0 ? "unknown" : result;
      });
    }
    module.exports = {
      setLangId(value) {
        if (langIndexs.includes(value)) {
          langId = value;
        } else {
          throw new Error(`Lang index invaild. allow indexs [${langIndexs.join(",")}]`);
        }
      },
      getLangId() {
        return langId;
      },
      define,
      get(code, ...args) {
        return getMessage(langId, code, args);
      },
      fetch(id, code, ...args) {
        return getMessage(id, code, args);
      },
      has(code) {
        return Object.prototype.hasOwnProperty.call(messages, code);
      },
      make(langId2) {
        if (!langIndexs.includes(langId2)) {
          throw new Error(`Lang index invaild. allow indexs [${langIndexs.join(",")}]`);
        }
        return (code, ...args) => {
          return getMessage(langId2, code, args);
        };
      }
    };
  }
});

// lib/core/Utils.js
var require_Utils = __commonJS({
  "lib/core/Utils.js"(exports, module) {
    var fs = __require("fs");
    var path = __require("path");
    var Lang = require_Lang();
    var chalk = require_source();
    var directiveMap = {
      "Runtime": true,
      "Syntax": true
    };
    module.exports = {
      checkDirective(name) {
        return directiveMap[name];
      },
      getPropertyModifierName(method) {
        return method.modifier ? method.modifier.value() : "public";
      },
      existsSync(pathName) {
        return fs.existsSync(pathName);
      },
      getFileStatSync(pathName) {
        return fs.statSync(pathName);
      },
      readdir(pathName, isFull) {
        if (!fs.existsSync(pathName)) {
          return null;
        }
        if (!fs.statSync(pathName).isDirectory()) {
          return null;
        }
        var files = fs.readdirSync(pathName);
        files = files.filter(function(a) {
          return !(a === "." || a === "..");
        });
        if (isFull) {
          return files.map(function(name) {
            return path.join(pathName, name);
          });
        }
        return files;
      },
      getStackByName(name) {
        const stacks = this.getStacks();
        return stacks[name] || null;
      },
      isStackByName(target, name, flag) {
        const fn = this.getStackByName(name);
        const result = fn && target instanceof fn;
        return result && flag ? target : result;
      },
      info(msg) {
        console.info(msg);
      },
      log(msg) {
        console.log(msg);
      },
      debug(msg) {
        msg = String(msg);
        const orange = chalk.keyword("orange");
        console.trace(orange("[Debug]") + " " + msg + "\n");
      },
      warn(msg) {
        console.warn(`${Lang.get("warn")} ${chalk.yellow(msg)}
`);
      },
      error(msg) {
        console.error(`${Lang.get("error")} ${chalk.red(msg)}
`);
      },
      reportDiagnosticMessage(diagno) {
        const file = diagno.file;
        const range = diagno.range;
        const kind = diagno.kind;
        const message = diagno.message;
        const code = diagno.code;
        if (kind >= 0) {
          const lightGray = chalk.rgb(240, 240, 240);
          const blackGray = chalk.rgb(50, 50, 50);
          let mes = lightGray(file ? `(${file}:${range.start.line}:${range.start.column}) ${code}` : `${code}`);
          if (kind === 0) {
            console.error(`${Lang.get("error")} ${blackGray(message)} ${mes}
`);
          } else if (kind === 1) {
            console.warn(`${Lang.get("warn")} ${blackGray(message)} ${mes}
`);
          } else {
            console.info(`${Lang.get("info")} ${blackGray(message)} ${mes}
`);
          }
        }
      },
      scalarMap: ["number", "boolean", "float", "int", "uint", "double", "regexp", "string"],
      isScalar(type2) {
        return type2 && !type2.isModule && !type2.isInstanceofType && (type2.isLiteralType || type2.isAliasType && this.scalarMap.includes(type2.toString()));
      },
      isTypeModule(type2) {
        return type2 && type2.isModule && (type2.isClass || type2.isInterface || type2.isStructTable || type2.isEnum) === true;
      },
      isWrapType(type2) {
        return type2 && type2.isType && (type2.isTupleType || type2.isGenericType || type2.isClassGenericType || type2.isInstanceofType || type2.isLiteralType || type2.isLiteralObjectType || type2.isLiteralArrayType || type2.isFunctionType || type2.isAliasType) === true;
      },
      isLiteralObjectType(type2) {
        return type2 && type2.isType && (type2.isTupleType || type2.isLiteralObjectType || type2.isLiteralArrayType) === true;
      },
      isClassType(type2) {
        if (type2 && type2.isType && type2.isModule && (type2.isClass || type2.isEnum)) {
          return true;
        }
        return false;
      },
      isLocalModule(module2) {
        if (!this.isTypeModule(module2))
          return false;
        const compilation = module2.compilation;
        return compilation && compilation.isLocalDocument();
      },
      isGlobalModule(module2) {
        return module2 && module2.isDeclaratorModule && this.isTypeModule(module2);
      },
      isInterface(module2) {
        return module2 && module2.isInterface && this.isTypeModule(module2);
      },
      checkTypeForBoth(left, right, isStrict = true) {
        if (left === right) {
          return true;
        } else if (!left || !right) {
          return false;
        }
        if (left.isLiteralObjectType || left.isLiteralType || left.isLiteralArrayType || left.isEnumType || left.isClassType || left.isAnyType || left.isVoidType || left.isUnknownType || left.isNullableType || left.isNeverType) {
          if (!isStrict && left.isLiteralType) {
            return right.check(left);
          }
          return left.check(right);
        } else if (left.isFunctionType) {
          if (!right.isFunctionType)
            return false;
          const lParams = left.params;
          const rParams = right.params;
          if (lParams.length !== rParams.length)
            return false;
          const lReturnType = left.inferReturnType();
          const rReturnType = right.inferReturnType();
          if (lReturnType && !rReturnType)
            return false;
          if (!lReturnType && rReturnType)
            return false;
          if (!this.checkTypeForBoth(lReturnType, rReturnType, isStrict))
            return false;
          return lParams.every((item2, index) => {
            const lType = item2.type();
            if (!isStrict && lType.isTupleType && lType.rest) {
              return true;
            }
            if (!rParams[index])
              return false;
            return this.checkTypeForBoth(lType, rParams[index].type(), isStrict);
          });
        } else if (left.isUnionType) {
          if (!right.isUnionType)
            return false;
          return left.elements.every((item2, index) => {
            if (!right.elements[index])
              return false;
            return this.checkTypeForBoth(item2.type(), right.elements[index].type(), isStrict);
          });
        } else if (left.isTupleType) {
          if (!right.isTupleType || left.prefix !== right.prefix || left.isTupleUnion !== right.isTupleUnion)
            return false;
          return left.elements.every((item2, index) => {
            if (!right.elements[index])
              return false;
            return this.checkTypeForBoth(item2.type(), right.elements[index].type(), isStrict);
          });
        } else if (left.isInstanceofType) {
          if (left.isThisType) {
            return left.isThisType === right.isThisType;
          }
          if (!right.isInstanceofType || left.isThisType !== right.isThisType || left.generics.length !== right.generics.length)
            return false;
          if (this.checkTypeForBoth(left.inherit.type(), right.inherit.type(), isStrict)) {
            return left.generics.every((item2, index) => {
              if (!right.generics[index])
                return false;
              return this.checkTypeForBoth(item2.type(), right.generics[index].type(), isStrict);
            });
          }
          return false;
        } else if (left.isClassGenericType) {
          if (!right.isClassGenericType || left.isClassType !== right.isClassType || left.isThisType !== right.isThisType)
            return false;
          if (this.checkTypeForBoth(left.inherit.type(), right.inherit.type(), isStrict)) {
            return left.elements.every((item2, index) => {
              if (!right.elements[index])
                return false;
              return this.checkTypeForBoth(item2.type(), right.elements[index].type(), isStrict);
            });
          }
          return false;
        } else if (left.isIntersectionType) {
          if (!right.isIntersectionType)
            return false;
          return this.checkTypeForBoth(left.left.type(), right.left.type(), isStrict) && this.checkTypeForBoth(left.right.type(), right.right.type(), isStrict);
        } else if (left.isAliasType) {
          if (!right.isAliasType)
            return false;
          return this.checkTypeForBoth(left.inherit.type(), right.inherit.type(), isStrict);
        } else if (left.isKeyofType) {
          if (!right.isKeyofType)
            return false;
          return this.checkTypeForBoth(left.referenceType.type(), right.referenceType.type(), isStrict);
        } else if (left.isGenericType) {
          if (!right.isGenericType || left.hasConstraint !== right.hasConstraint)
            return false;
          if (left.hasConstraint) {
            return this.checkTypeForBoth(left.inherit.type(), right.inherit.type(), isStrict);
          }
          return true;
        }
        return left.id === right.id && left.namesapce === right.namesapce;
      },
      isArray(type2) {
        return type2 && type2.id === "Array" && type2.isDeclaratorModule && type2.isModule && type2.isClass;
      },
      isObject(type2) {
        return type2 && type2.id === "Object" && type2.isDeclaratorModule && type2.isModule && type2.isClass;
      },
      isFunction(stack2) {
        if (!stack2 || !stack2.isStack)
          return false;
        if (stack2.isCallExpression || stack2.isAccessor) {
          return false;
        }
        if (stack2.isProperty && stack2.init) {
          stack2 = stack2.init;
        }
        if (stack2.isFunctionExpression || stack2.isMethodDefinition || stack2.isTypeFunctionDefinition) {
          return true;
        }
        return false;
      },
      firstToUpper(name) {
        return name.substr(0, 1).toUpperCase() + name.substr(1);
      },
      checkDepend(module2, depModule) {
        const check = (module3, depModule2) => {
          if (!module3 || !depModule2)
            return false;
          if (!module3.isModule || !depModule2.isModule)
            return false;
          const classStack = depModule2.moduleStack;
          const inherit = classStack && classStack.inherit;
          if (inherit) {
            const inheritModule = classStack.getModuleById(inherit.value());
            if (inheritModule === module3) {
              return true;
            }
            return check(module3, inheritModule);
          }
          return false;
        };
        return check(module2, depModule) && check(depModule, module2);
      },
      getOriginType(type2) {
        if (!type2)
          return type2;
        if (type2.isClassGenericType && type2.isClassType) {
          type2 = type2.types[0];
        }
        while (this.isWrapType(type2) && type2.extends && type2.extends[0]) {
          type2 = type2.extends[0];
        }
        return type2 && type2.isModule ? type2.type() : type2;
      },
      getFunctionType(type2) {
        if (!type2)
          return type2;
        if (type2.isFunctionType)
          return type2;
        if (type2.isAliasType) {
          return this.getFunctionType(type2.inherit.type());
        } else if (type2.isUnionType) {
          return type2.elements.find((el) => !!this.getFunctionType(el.type()).isFunctionType);
        }
        return type2;
      },
      toTypeUniqueArray(array) {
        const data = /* @__PURE__ */ new Set();
        const items = [];
        array.forEach((value) => {
          const key = value.type().toString();
          if (!data.has(key)) {
            data.add(key);
            items.push(value);
          }
        });
        return items;
      },
      toTypeString(type2, inference) {
        return this.inferTypeValue(type2, inference).toString();
      },
      inferTypeValue(type2, inference) {
        if (!type2)
          return type2;
        type2 = type2.hasGenericType ? type2.clone(inference) : type2;
        if (type2.isComputeType) {
          type2 = type2.getComputeType().clone(inference);
        }
        return type2;
      },
      isModifierPublic(stack2) {
        return this.getModifierValue(stack2) === "public";
      },
      isModifierProtected(stack2) {
        return stack2 && stack2.isStack && stack2.modifier && stack2.modifier.value() === "protected";
      },
      isModifierPrivate(stack2) {
        return stack2 && stack2.isStack && stack2.modifier && stack2.modifier.value() === "private";
      },
      getModifierValue(stack2) {
        if (stack2 && stack2.isStack) {
          if (stack2.modifier) {
            return stack2.modifier.value();
          } else if (stack2.isMethodDefinition || stack2.isPropertyDefinition || stack2.isClassDeclaration || stack2.isInterfaceDeclaration || stack2.isEnumDeclaration && !stack2.isExpressionDeclare) {
            return "public";
          }
        }
        return null;
      },
      isIterableIteratorType(type2, iteratorType) {
        if (!type2 || type2.isAnyType)
          return false;
        if (type2 === iteratorType)
          return true;
        if (iteratorType && iteratorType.isModule && iteratorType.is(type2)) {
          return type2.isInstanceofType || this.getOriginType(type2) === iteratorType;
        }
        type2 = this.getOriginType(type2);
        return type2.isModule && type2.getName() === "Iterator" && type2.isDeclaratorModule;
      },
      isStaticDescriptor(desc2) {
        if (!desc2)
          return false;
        const module2 = (desc2.isStack ? desc2.module : desc2) || desc2;
        if (this.isClassType(module2) && module2.static) {
          return true;
        }
        if (!(desc2.isMethodDefinition || desc2.isPropertyDefinition))
          return false;
        return !!desc2.static;
      },
      extractFunTypeFromType(type2, ctx2) {
        if (!type2)
          return null;
        if (type2.isFunctionType) {
          return [type2, ctx2];
        } else if (type2.isAliasType) {
          return this.extractFunTypeFromType(type2.inherit.type(), ctx2);
        } else if (type2.isClassGenericType) {
          const inherit = type2.inherit.type();
          if (inherit.isAliasType) {
            if (inherit.target.isDeclaratorTypeAlias && inherit.target.genericity) {
              const declareGenerics = inherit.target.genericity.elements;
              if (declareGenerics && declareGenerics.length > 0) {
                const target = inherit.inherit.type();
                if (type2.elements.length === 1) {
                  if (target === declareGenerics[0].type()) {
                    return this.extractFunTypeFromType(type2.elements[0].type(), ctx2);
                  }
                }
                return this.extractFunTypeFromType(target, ctx2);
              }
            }
            return this.extractFunTypeFromType(inherit, ctx2);
          }
        } else if (type2.isUnionType) {
          for (let el of type2.elements) {
            const res = this.extractFunTypeFromType(el.type(), ctx2);
            if (res) {
              return res;
            }
          }
        } else if (type2.isIntersectionType) {
          return this.extractFunTypeFromType(type2.left.type(), ctx2) || this.extractFunTypeFromType(type2.right.type(), ctx2);
        }
        return null;
      }
    };
  }
});

// lib/core/Namespace.js
var require_Namespace = __commonJS({
  "lib/core/Namespace.js"(exports, module) {
    var Utils2 = require_Utils();
    var privateKey = Symbol("key");
    var NamespaceGlobal = class {
      constructor() {
        this.globals = /* @__PURE__ */ new Map();
      }
      getKey(name) {
        return name && name.substring(0, 7) === "global." ? name.substring(7) : name;
      }
      set(name, value) {
        this.globals.set(this.getKey(name), value);
      }
      get(name) {
        let result = this.globals.get(this.getKey(name));
        if (!result)
          return null;
        if (!result.isType && result.isStack) {
          if (result.isDeclaratorFunction || result.isDeclaratorVariable) {
            return result;
          }
          result = result.type();
        }
        return result;
      }
      raw(name) {
        return this.globals.get(this.getKey(name));
      }
      has(name) {
        return this.globals.has(this.getKey(name));
      }
      delete(name) {
        this.globals.delete(this.getKey(name));
      }
    };
    var globals = new NamespaceGlobal();
    var Namespace2 = class {
      static get globals() {
        return globals;
      }
      static clearAll() {
        const clear = (ns) => {
          ns.children.forEach(clear);
          ns.modules.clear();
          ns.children.clear();
          ns.descriptors.clear();
        };
        clear(Namespace2.dataset);
        globals.globals.clear();
      }
      constructor(id) {
        this.modules = /* @__PURE__ */ new Map();
        this.children = /* @__PURE__ */ new Map();
        this.identifier = id;
        this.fullName = id;
        this.parent = null;
        this.isNamespace = true;
        this.stack = null;
        this.chainItems = null;
        this.descriptors = /* @__PURE__ */ new Map();
      }
      set(name, value) {
        const flag = this.addDescriptor(name, value);
        if (!this.modules.has(name)) {
          this.modules.set(name, value);
          if (this.fullName) {
            globals.set(`${this.fullName}.${name}`, value);
          } else {
            globals.set(`${name}`, value);
          }
        }
        return flag;
      }
      has(name) {
        return this.modules.has(name);
      }
      del(name) {
        if (this.fullName) {
          globals.delete(`${this.fullName}.${name}`);
        } else {
          globals.delete(`${name}`);
        }
        return this.modules.delete(name);
      }
      get(name) {
        let result = this.modules.get(name);
        if (!result)
          return null;
        if (!result.isType && result.isStack) {
          if (result.isDeclaratorFunction || result.isDeclaratorVariable) {
            return result;
          }
          result = result.type();
        }
        return result;
      }
      raw(name) {
        return this.modules.get(name);
      }
      addDescriptor(name, descriptor) {
        if (!descriptor || !(descriptor.isDeclaratorFunction || descriptor.isDeclaratorVariable))
          return;
        let dataset = this.descriptors.get(name);
        if (!dataset) {
          dataset = [];
          this.descriptors.set(name, dataset);
        }
        dataset.push(descriptor);
        return true;
      }
      checkDescriptors(name, descriptor) {
        let dataset = this.descriptors.get(name);
        if (dataset && dataset.length > 1) {
          if (descriptor.isDeclaratorTypeAlias)
            return false;
          return !dataset.some((item2) => {
            if (item2 === descriptor)
              return false;
            if (!item2.isSameSource(descriptor))
              return false;
            if (descriptor.isDeclaratorFunction && item2.isDeclaratorFunction) {
              const oldP = item2.params;
              const newP = descriptor.params;
              if (oldP && newP && oldP.length === newP.length) {
                return oldP.every((oldT, index) => {
                  const newT = newP[index];
                  if (oldT && newT) {
                    return Utils2.checkTypeForBoth(oldT.type(), newT.type());
                  }
                });
              }
            } else if (descriptor.isDeclaratorVariable && item2.isDeclaratorVariable) {
              return Utils2.checkTypeForBoth(descriptor.type(), item2.type());
            }
            return false;
          });
        }
        return true;
      }
      sorting(dataset) {
        const priority = (item2) => {
          const type2 = item2.type();
          if (!type2 || type2.isGenericType)
            return 1;
          if (type2.isLiteralType && type2.isLiteralValueType) {
            return 6;
          } else if (type2.isIntersectionType) {
            return 5;
          } else if (type2.isClassGenericType) {
            const wrap = type2.inherit.type();
            if (wrap && wrap.target && wrap.target.isDeclaratorTypeAlias && wrap.target.genericity) {
              return 4;
            }
          } else if (type2.isUnionType) {
            return 2;
          }
          return 3;
        };
        dataset.sort((a, b) => {
          if (!a.isDeclaratorFunction) {
            if (!b.isDeclaratorFunction)
              return 0;
            return 1;
          }
          if (!b.isDeclaratorFunction) {
            if (!a.isDeclaratorFunction)
              return 0;
            return -1;
          }
          if (a.params.length < b.params.length) {
            return -1;
          } else if (a.params.length > b.params.length) {
            return 1;
          }
          const a1 = a.params.reduce((acc, item2) => {
            if (item2.question)
              acc--;
            return acc + priority(item2);
          }, 0);
          const b1 = b.params.reduce((acc, item2) => {
            if (item2.question)
              acc--;
            return acc + priority(item2);
          }, 0);
          if (a1 === b1)
            return 0;
          return a1 > b1 ? -1 : 1;
        });
        return dataset;
      }
      hasDescriptor(name) {
        return this.descriptors.has(name);
      }
      getDescriptor(name, filter, { isNew, isCall } = {}, result = null) {
        const dataset = this.descriptors.get(name);
        if (dataset) {
          if (!filter) {
            return dataset[0] || result;
          } else {
            if (!dataset[privateKey]) {
              dataset[privateKey] = true;
              this.sorting(dataset);
            }
            for (let i = 0; i < dataset.length; i++) {
              const desc2 = dataset[i];
              const value = filter(desc2, result, i, dataset);
              if (value) {
                if (value === true) {
                  return desc2;
                } else {
                  result = value;
                }
              }
            }
          }
        }
        if (isCall) {
          const module2 = this.modules.get(name);
          if (module2 && module2.isModule) {
            if (isNew) {
              result = module2.getDescriptor(`constructor`, filter, { isNew, isCall }, result);
            } else {
              result = module2.getDescriptor(`#${module2.id}`, filter, { isNew, isCall }, result);
            }
          }
        }
        return result;
      }
      clear(compilation) {
        if (!compilation)
          return;
        this.descriptors.forEach((items, key) => {
          items.slice(0).forEach((descriptor) => {
            if (descriptor.compilation === compilation) {
              const index = items.indexOf(descriptor);
              if (index >= 0) {
                items.splice(index, 1);
              }
            }
          });
          if (!items.length) {
            this.descriptors.delete(key);
          }
        });
        this.modules.forEach((module2, key) => {
          if (module2.compilation === compilation) {
            this.del(key);
          }
        });
      }
      toString() {
        return this.getChain().join(".");
      }
      definition() {
        const kind = "namespace";
        return {
          expre: `${kind} ${this.toString()}`
        };
      }
      getChain() {
        if (this.chainItems)
          return this.chainItems;
        if (this.parent) {
          return this.chainItems = this.parent.getChain().concat(this.identifier);
        }
        return this.chainItems = [];
      }
      getChildrenKeys() {
        const children = [];
        this.children.forEach((value, key) => {
          const obj = {};
          obj[key] = value.getChildrenKeys();
          children.push(obj);
        });
        return children;
      }
      static create(identifier, flag) {
        if (!identifier) {
          return Namespace2.dataset;
        }
        const items = identifier.split(".");
        let key = null;
        let base = flag ? new Namespace2() : Namespace2.dataset;
        if (items[0] === "global") {
          items.shift();
        }
        while (key = items.shift()) {
          if (base.children.has(key)) {
            base = base.children.get(key);
          } else {
            const np = new Namespace2(key);
            np.parent = base;
            base.children.set(key, np);
            base = np;
          }
        }
        base.fullName = identifier;
        return base;
      }
      static fetch(id, base = null, onlyNs = false) {
        if (!id) {
          return Namespace2.dataset;
        }
        const items = (id + "").split(".");
        const name = items.pop();
        let key = null;
        base = base || Namespace2.dataset;
        if (items[0] === "global") {
          items.shift();
        }
        while ((key = items.shift()) && base) {
          base = base.children.has(key) ? base.children.get(key) : null;
        }
        if (!base || !(base instanceof Namespace2)) {
          return null;
        }
        if (onlyNs) {
          return base.children.get(name);
        }
        return base.has(name) ? base.get(name) : base.children.get(name);
      }
    };
    Namespace2.dataset = new Namespace2("");
    Namespace2.top = Namespace2.dataset;
    module.exports = Namespace2;
  }
});

// lib/types/Type.js
var require_Type = __commonJS({
  "lib/types/Type.js"(exports, module) {
    var EventDispatcher = require_EventDispatcher();
    var Type = class extends EventDispatcher {
      constructor(id, inherit) {
        super();
        this._id = id;
        this._extends = null;
        this.extends = inherit;
        this.alias = null;
        this.isType = true;
        this.mtime = null;
      }
      set id(name) {
        this._id = name;
      }
      get id() {
        return this._id;
      }
      set extends(_extends) {
        if (_extends) {
          if (_extends instanceof Array) {
            if (_extends.length > 0) {
              this._extends = _extends;
            }
          } else if (_extends) {
            this._extends = [_extends];
          }
        }
      }
      get extends() {
        return this._extends || [];
      }
      get inherit() {
        return this._extends ? this._extends[0] : null;
      }
      isSameSource(type2) {
        if (!type2)
          return false;
        const aCompilation = this.compilation || this.target && this.target.compilation;
        const bCompilation = type2.compilation || type2.target && type2.target.compilation;
        return aCompilation === bCompilation && type2.mtime === this.mtime;
      }
      clone(inference) {
        if (this.isGenericType && inference) {
          return inference(this);
        }
        return this;
      }
      definition(ctx2) {
        return {
          expre: `(type) ${this.toString(ctx2)}`
        };
      }
      check(stack2, context, options = {}) {
        return this.is(stack2 && stack2.type(), context, options);
      }
      type(ctx2) {
        return this;
      }
      isNeedCheckType(type2) {
        if (type2 === this || type2.isNullableType || type2.isAnyType || this.target && type2.target === this.target) {
          return false;
        }
        return true;
      }
      inferType(type2, context) {
        if (type2 && context && type2.isGenericType) {
          return context.isContext && context.apply ? context.apply(type2) : type2;
        }
        return type2;
      }
      getWrapAssignType(type2) {
        if (!type2 || !type2.isClassGenericType)
          return type2;
        const inherit = type2.inherit.type();
        if (inherit.isAliasType && inherit.target.isDeclaratorTypeAlias && inherit.target.genericity) {
          const declareGenerics = inherit.target.genericity.elements;
          if (declareGenerics && declareGenerics.length > 0) {
            const target = inherit.inherit.type();
            if (type2.elements.length === 1) {
              if (target === declareGenerics[0].type()) {
                return this.getWrapAssignType(type2.elements[0].type());
              }
            }
            const ctx2 = inherit.target.newContext();
            declareGenerics.forEach((decl, index) => {
              const value = type2.elements[index];
              if (value) {
                ctx2.extractive(decl.type(), this.getWrapAssignType(value.type()));
              }
            });
            return ctx2.apply(target);
          }
        }
        return type2;
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        if (this === type2)
          return true;
        while (type2 && (type2 = type2.inherit)) {
          if (this === type2) {
            return true;
          }
        }
        return false;
      }
      pushToStringChain(context = {}, options = {}) {
        options.chain = options.chain || [];
        if (options.chain.includes(this)) {
          options.onlyTypeName = true;
          options.hasExists = true;
          context = {};
        } else {
          options.chain.push(this);
        }
        return context;
      }
      toString() {
        return this._id;
      }
    };
    module.exports = Type;
  }
});

// lib/core/Constant.js
var require_Constant = __commonJS({
  "lib/core/Constant.js"(exports, module) {
    var Constant = {};
    Constant.POLICY_NONE = 1;
    Constant.POLICY_SERVER = 2;
    Constant.POLICY_CLIENT = 4;
    Constant.POLICY_ALL = 7;
    Constant.MODULE_YES_WEB_COMPONENT = 1;
    Constant.MODULE_NO_WEB_COMPONENT = 2;
    Constant.MODULE_YES_SKIN_COMPONENT = 4;
    Constant.MODULE_NO_SKIN_COMPONENT = 8;
    module.exports = Constant;
  }
});

// lib/core/Module.js
var require_Module = __commonJS({
  "lib/core/Module.js"(exports, module) {
    var Type = require_Type();
    var Namespace2 = require_Namespace();
    var Utils2 = require_Utils();
    var symbolKey = Symbol("key");
    var Constant = require_Constant();
    var Module = class extends Type {
      constructor(compilation) {
        super(null, null);
        this.compilation = compilation;
        this.id = null;
        this.static = false;
        this.abstract = false;
        this.isFinal = false;
        this.isClass = false;
        this.isInterface = false;
        this.isEnum = false;
        this.isDeclaratorModule = false;
        this.isLocalModule = false;
        this.namespace = null;
        this._implements = [];
        this.methods = {};
        this.members = {};
        this.annotations = [];
        this.metatypes = [];
        this.making = false;
        this.dependencies = /* @__PURE__ */ new Set();
        this.imports = /* @__PURE__ */ new Map();
        this.importAlias = /* @__PURE__ */ new Map();
        this.isModule = true;
        this.methodConstructor = null;
        this.comments = null;
        this.file = null;
        this.files = [];
        this.used = false;
        this.callable = null;
        this.children = [];
        this.policy = null;
        this.dynamic = false;
        this.dynamicProperties = /* @__PURE__ */ new Map();
        this.isFragment = false;
        this.required = false;
        this.assets = /* @__PURE__ */ new Map();
        this.requires = /* @__PURE__ */ new Map();
        this.isValid = true;
        this.fullname = null;
        this.metadataFlags = 0;
        this.jsxDeclaredSlots = null;
        this.callMethods = [];
        this.callMembers = [];
        this[symbolKey] = {
          stacks: [],
          stack: null
        };
        this.removedNamedDescriptors = /* @__PURE__ */ Object.create(null);
        this.deprecatedNamedDescriptors = /* @__PURE__ */ Object.create(null);
        this.annotationDescriptors = /* @__PURE__ */ Object.create(null);
        this.descriptors = /* @__PURE__ */ new Map();
      }
      get moduleStack() {
        return this[symbolKey].stack || null;
      }
      set moduleStack(value) {
        if (value && value.isStack) {
          this[symbolKey].stacks.push(value);
          this[symbolKey].stack = value;
        }
      }
      getStacks() {
        return this[symbolKey].stacks.filter((stack2) => !stack2.compilation.isDestroyed);
      }
      isWebComponent() {
        if (!this.isClass)
          return false;
        if (this.metadataFlags > 0) {
          if ((Constant.MODULE_YES_WEB_COMPONENT & this.metadataFlags) === Constant.MODULE_YES_WEB_COMPONENT) {
            return true;
          } else if ((Constant.MODULE_NO_WEB_COMPONENT & this.metadataFlags) === Constant.MODULE_NO_WEB_COMPONENT) {
            return false;
          }
        }
        let result = false;
        const stacks = this.getStacks();
        for (let i = 0; i < stacks.length; i++) {
          const stack2 = stacks[i];
          if (stack2.findAnnotation((annotation) => annotation.name.toLowerCase() === "webcomponent")) {
            result = true;
            break;
          }
        }
        this.metadataFlags |= result ? Constant.MODULE_YES_WEB_COMPONENT : Constant.MODULE_NO_WEB_COMPONENT;
        return result;
      }
      isSkinComponent() {
        if (!this.isClass)
          return false;
        if (this.metadataFlags > 0) {
          if ((Constant.MODULE_YES_SKIN_COMPONENT & this.metadataFlags) === Constant.MODULE_YES_SKIN_COMPONENT) {
            return true;
          } else if ((Constant.MODULE_NO_SKIN_COMPONENT & this.metadataFlags) === Constant.MODULE_NO_SKIN_COMPONENT) {
            return false;
          }
        }
        let result = false;
        const stacks = this.getStacks();
        for (let i = 0; i < stacks.length; i++) {
          const stack2 = stacks[i];
          if (stack2.findAnnotation((annotation) => annotation.name.toLowerCase() === "skinclass")) {
            result = true;
            break;
          }
        }
        this.metadataFlags |= result ? Constant.MODULE_YES_SKIN_COMPONENT : Constant.MODULE_NO_SKIN_COMPONENT;
        return result;
      }
      getAnnotations(filter, inheritFlag = true) {
        const stacks = this.getStacks();
        for (let i = 0; i < stacks.length; i++) {
          const stack2 = stacks[i];
          const result = stack2.findAnnotation(filter, inheritFlag);
          if (result) {
            return result;
          }
        }
        return null;
      }
      get implements() {
        return this._implements;
      }
      set implements(value) {
        if (Array.isArray(value)) {
          this._implements = value;
        }
      }
      isRemoved(name, descriptor) {
        if (!descriptor)
          return false;
        if (descriptor && descriptor.isStack && descriptor.isRemoved) {
          return true;
        }
        if (this.removedNamedDescriptors[name]) {
          return this.removedNamedDescriptors[name].some((item2) => {
            return !!descriptor.static === !!item2.static;
          });
        }
        if (this.extends.some((item2) => item2.isRemoved(name, descriptor))) {
          return true;
        }
        if (this.implements.some((item2) => item2.isRemoved(name, descriptor))) {
          return true;
        }
        if (this.getUsingExtendsModules().some((item2) => item2.isRemoved(name, descriptor))) {
          return true;
        }
        return false;
      }
      isDeprecated(name, descriptor) {
        if (!descriptor)
          return false;
        if (descriptor && descriptor.isStack && descriptor.isDeprecated) {
          return true;
        }
        if (this.deprecatedNamedDescriptors[name]) {
          return this.deprecatedNamedDescriptors[name].some((item2) => {
            return !!descriptor.static === !!item2.static;
          });
        }
        if (this.extends.some((item2) => item2.isDeprecated(name, descriptor))) {
          return true;
        }
        if (this.implements.some((item2) => item2.isDeprecated(name, descriptor))) {
          return true;
        }
        if (this.getUsingExtendsModules().some((item2) => item2.isDeprecated(name, descriptor))) {
          return true;
        }
        return false;
      }
      getUsingExtendsModules() {
        const result = [];
        const fetch = (usingExtends) => {
          if (usingExtends && usingExtends.length > 0) {
            for (let i = 0; i < usingExtends.length; i++) {
              const ctx2 = usingExtends[i];
              for (let b = 0; b < ctx2.extends.length; b++) {
                const ext = ctx2.extends[b];
                if (ext.module && ext.module !== this && !result.includes(ext.module)) {
                  if (!this.extends.includes(ext.module) && !this.implements.includes(ext.module)) {
                    result.push(ext.module);
                  }
                }
              }
            }
          }
        };
        fetch(this.callMethods);
        fetch(this.callMembers);
        return result;
      }
      addDescriptor(name, descriptor) {
        let dataset = this.descriptors.get(name);
        if (!dataset) {
          dataset = [];
          this.descriptors.set(name, dataset);
        }
        dataset.push(descriptor);
        return true;
      }
      compareDescriptor(left, right) {
        if (!left || !right)
          return false;
        const token = right.toString();
        if (left.isPropertyDefinition) {
          if (token === "PropertyDefinition") {
            const oldT = left.type();
            const newT = right.type();
            if (oldT && newT) {
              return Utils2.checkTypeForBoth(oldT.type(), newT.type());
            }
          }
        } else if (left.isMethodGetterDefinition) {
          if (token === "MethodGetterDefinition") {
            const oldT = left.inferReturnType();
            const newT = right.inferReturnType();
            if (oldT && newT) {
              return Utils2.checkTypeForBoth(oldT.type(), newT.type());
            }
          }
        } else if (left.isMethodSetterDefinition) {
          if (token === "MethodSetterDefinition") {
            const oldP = left.params[0];
            const newP = right.params[0];
            if (oldP && newP) {
              return Utils2.checkTypeForBoth(oldP.type(), newP.type());
            }
          }
        } else if (left.isMethodDefinition) {
          if (right.isMethodDefinition) {
            const oldP = left.params;
            const newP = right.params;
            if (oldP && newP && oldP.length === newP.length) {
              return oldP.every((oldT, index) => {
                const newT = newP[index];
                if (oldT && newT) {
                  return Utils2.checkTypeForBoth(oldT.type(), newT.type());
                }
              });
            }
          }
        }
        return false;
      }
      checkDescriptors(descriptors) {
        if (descriptors && descriptors.length > 1) {
          const sameitems = [];
          const push = (desc2, result2) => {
            if (result2) {
              sameitems.push(desc2);
            }
            return result2;
          };
          const result = descriptors.every((descriptor) => {
            const has = descriptors.some((item2) => {
              if (item2 === descriptor)
                return false;
              if (!!descriptor.static != !!item2.static)
                return false;
              if (!item2.isSameSource(descriptor))
                return false;
              return push(descriptor, this.compareDescriptor(item2, descriptor));
            });
            return !has;
          });
          return [result, sameitems];
        }
        return [true, []];
      }
      ckeckAllDescriptors() {
        this.descriptors.forEach((list, name) => {
          list.forEach((item2) => {
            if (item2.isRemoved) {
              const removed = this.removedNamedDescriptors[name] || (this.removedNamedDescriptors[name] = []);
              removed.push(item2);
            }
            if (item2.isDeprecated) {
              const deprecated = this.deprecatedNamedDescriptors[name] || (this.deprecatedNamedDescriptors[name] = []);
              deprecated.push(item2);
            }
          });
          const [result, sameitems] = this.checkDescriptors(list);
          if (!result) {
            sameitems.forEach((desc2) => {
              desc2.error(1045, name);
            });
          }
        });
      }
      getDescriptor(name, filter, ctx2 = {}, defaultResult = null) {
        var isBreak = false;
        var cache = null;
        const findExtends = (name2, usingExtends, result2 = null) => {
          if (isBreak)
            return result2;
          if (usingExtends && usingExtends.length > 0) {
            cache = cache || /* @__PURE__ */ new WeakSet();
            for (let i = 0; i < usingExtends.length; i++) {
              const ctx3 = usingExtends[i];
              for (let b = 0; b < ctx3.extends.length; b++) {
                const ext = ctx3.extends[b];
                const classModule = ext.module;
                if (!cache.has(classModule)) {
                  cache.add(classModule);
                  result2 = findAll(name2, classModule, result2, ctx3);
                  if (isBreak) {
                    return result2;
                  }
                }
              }
            }
          }
          return result2;
        };
        const findAll = (name2, module2, result2 = null, extendsContext = null, isSelf = false) => {
          if (name2 === "*") {
            const keys = Array.from(module2.descriptors.keys());
            for (let index = 0; index < keys.length; index++) {
              result2 = findAll(keys[index], module2, result2, extendsContext, isSelf);
              if (result2 && !filter)
                return result2;
              if (isBreak)
                return result2;
            }
            return result2;
          }
          const dataset = module2.descriptors.get(name2);
          if (dataset) {
            if (!filter) {
              return dataset[0] || result2;
            } else {
              if (!dataset[symbolKey]) {
                dataset[symbolKey] = true;
                const priority = (item2) => {
                  const type2 = item2.type();
                  if (!type2 || type2.isGenericType)
                    return 1;
                  if (type2.isLiteralType && type2.isLiteralValueType) {
                    return 6;
                  } else if (type2.isIntersectionType) {
                    return 5;
                  } else if (type2.isClassGenericType) {
                    const wrap = type2.inherit.type();
                    if (wrap && wrap.target && wrap.target.isDeclaratorTypeAlias && wrap.target.genericity) {
                      return 4;
                    }
                  } else if (type2.isUnionType) {
                    return 2;
                  }
                  return 3;
                };
                dataset.sort((a, b) => {
                  if (!a.isMethodDefinition) {
                    if (!b.isMethodDefinition)
                      return 0;
                    return 1;
                  }
                  if (!b.isMethodDefinition) {
                    if (!a.isMethodDefinition)
                      return 0;
                    return -1;
                  }
                  if (a.params.length < b.params.length) {
                    return -1;
                  } else if (a.params.length > b.params.length) {
                    return 1;
                  }
                  const a1 = a.params.reduce((acc, item2) => {
                    if (item2.question)
                      acc--;
                    return acc + priority(item2);
                  }, 0);
                  const b1 = b.params.reduce((acc, item2) => {
                    if (item2.question)
                      acc--;
                    return acc + priority(item2);
                  }, 0);
                  if (a1 === b1)
                    return 0;
                  return a1 > b1 ? -1 : 1;
                });
              }
              for (let i = 0; i < dataset.length; i++) {
                const desc2 = dataset[i];
                if (!isSelf && Utils2.isModifierPrivate(desc2)) {
                  continue;
                }
                const value = filter(desc2, result2, i, dataset, extendsContext);
                if (value) {
                  if (value === true) {
                    isBreak = true;
                    return desc2;
                  } else {
                    result2 = value;
                  }
                }
              }
            }
          }
          const items = module2.extends.concat(module2.implements);
          for (let i = 0; i < items.length; i++) {
            result2 = findAll(name2, items[i], result2, extendsContext);
            if (isBreak) {
              return result2;
            }
          }
          if ("constructor" !== name2) {
            result2 = findExtends(name2, module2.callMethods, result2);
            if (!isBreak) {
              result2 = findExtends(name2, module2.callMembers, result2);
            }
          }
          return result2;
        };
        let result = findAll(name, this, defaultResult, null, true);
        if (result || "constructor" === name) {
          return result;
        }
        result = findExtends(name, this.callMethods, result);
        if (!isBreak) {
          result = findExtends(name, this.callMembers, result);
        }
        if (result) {
          return result;
        }
        const base = this.compilation.getGlobalTypeById("Object");
        return base && base !== this ? findAll(name, base) : null;
      }
      clear(compilation) {
        this.imports.clear();
        this.importAlias.clear();
        this.dynamicProperties.clear();
        this._implements = [];
        this._extends = null;
        this.assets.clear();
        this.requires.clear();
        this.static = false;
        this.abstract = false;
        this.isFinal = false;
        this.isClass = false;
        this.isInterface = false;
        this.isEnum = false;
        this.isDeclaratorModule = false;
        this.isLocalModule = false;
        this.methodConstructor = null;
        this.comments = null;
        this.dynamic = null;
        this.isFragment = false;
        this.required = false;
        this.isValid = false;
        this.fullname = null;
        this.jsxDeclaredSlots = null;
        this.descriptors.clear();
        this.dependencies.clear();
        this.methods = {};
        this.members = {};
        this.annotations = [];
        this.metatypes = [];
        this.making = false;
        this.callMethods = [];
        this.callMembers = [];
        this.removedNamedDescriptors = /* @__PURE__ */ Object.create(null);
        this.deprecatedNamedDescriptors = /* @__PURE__ */ Object.create(null);
        this.annotationDescriptors = /* @__PURE__ */ Object.create(null);
      }
      addAsset(resolve, file, content, type2, assign, attrs = null, stack2 = null) {
        if (!this.assets.has(resolve)) {
          this.assets.set(resolve, { file, resolve, content, type: type2, assign, id: this.getName(), index: this.assets.size, attrs, stack: stack2 });
          return true;
        }
        return false;
      }
      addRequire(key, name, from, resolve, extract, stack2 = null) {
        if (!this.requires.has(name)) {
          this.requires.set(name, { key, name, from, resolve, extract, stack: stack2, id: this.getName(), index: this.requires.size });
          return true;
        }
        return false;
      }
      definition(context) {
        const stack2 = this.moduleStack;
        if (stack2) {
          if (stack2.isStructTableDeclaration) {
            return stack2.definition(context);
          }
          const kind = this.isInterface ? "interface" : this.isEnum ? "enum" : "class";
          context = context || {};
          context.scopeGenerics = true;
          var location = (stack2.id || stack2).getLocation();
          if (this.compilation.JSX) {
            const program = this.compilation.stack;
            if (program && program.body[0]) {
              location = program.body[0].getLocation();
            }
          }
          return {
            comments: this.comments,
            expre: `${kind} ${this.toString(context)}`,
            location,
            file: this.file
          };
        }
        return null;
      }
      getName(segment = ".", suffix = null) {
        if (segment === "." && suffix === null) {
          return this.getFullName();
        }
        let name = this.id;
        if (this.namespace) {
          name = this.namespace.getChain().concat(this.id).join(segment);
        }
        return suffix ? name + this.compilation.compiler.suffix : name;
      }
      getFullName() {
        let fullname = this.fullname;
        if (fullname) {
          return fullname;
        }
        let name = this.id;
        if (this.namespace) {
          name = this.namespace.getChain().concat(name).join(".");
        }
        return this.fullname = name;
      }
      type() {
        if (!this.isValid) {
          return this.namespace.get(this.id) || this;
        }
        return this;
      }
      is(type2, context) {
        if (!this.isValid) {
          const newType = this.type();
          if (newType !== this) {
            return newType.is(type2, context);
          }
        }
        if (!type2 || !(type2 instanceof Type))
          return false;
        if (context && context.isContext && context.inference) {
          type2 = context.inference(type2);
        }
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context));
        }
        if (!this.isNeedCheckType(type2))
          return true;
        if (this.id === "Interface" && (!this.namespace || this.namespace.identifier === "") && Utils2.isInterface(type2)) {
          return true;
        }
        if (type2.isEnumType) {
          return type2.owner === this || type2.inherit === this || type2.inherit.is(this, context);
        }
        if (type2.isIntersectionType) {
          return this.is(type2.left.type(), context) ? true : this.is(type2.right.type(), context);
        }
        const nullType = this.compilation.getGlobalTypeById("nullable");
        const objectType = this.compilation.getGlobalTypeById("Object");
        const classType = this.compilation.getGlobalTypeById("Class");
        if (this === objectType && !Utils2.isScalar(type2)) {
          return true;
        }
        if (this === classType) {
          if (type2.isClassGenericType && type2.extends[0]) {
            type2 = type2.extends[0];
          }
          return !!(type2 instanceof Module && type2.isClass);
        }
        if ((this.isInterface || this.isStructTable) && type2.isLiteralObjectType) {
          const dynamic = this.dynamicProperties;
          if (dynamic && dynamic.size > 0) {
            const keyType = this.compilation.getGlobalTypeById("String");
            return dynamic.has(keyType);
          }
          const properties = Object.keys(this.members);
          const errorHandler = context && context.errorHandler || ((result2) => result2);
          const result = properties.every((propName) => {
            const attr = type2.attribute(propName);
            const property = this.members[propName];
            if (attr) {
              const acceptType = property.type();
              return errorHandler(acceptType.check(attr, context), acceptType, attr.key, attr.type());
            }
            return !!property.question;
          });
          if (!result)
            return false;
          if (this.extends.length > 0 && !this.extends.every((item2) => {
            const mType = item2.type();
            return mType !== this && mType.is(type2);
          })) {
            return false;
          }
          if (this.implements.length > 0 && !this.implements.every((item2) => item2.type().is(type2))) {
            return false;
          }
          return true;
        }
        type2 = Utils2.getOriginType(type2);
        if (type2 === nullType || type2 === this) {
          return true;
        }
        if (!(type2 instanceof Module)) {
          return false;
        }
        if (this[symbolKey]._processing === type2) {
          return this.toString() === type2.toString();
        }
        this[symbolKey]._processing = type2;
        const check = (left, right) => {
          if (!right)
            return false;
          if (left === right) {
            return true;
          }
          if (right.extends && right.extends.some((right2) => check(left, right2))) {
            return true;
          }
          if (right.implements && right.implements.length > 0) {
            if (right.implements.some((right2) => check(left, right2))) {
              return true;
            }
          }
          if (!this[symbolKey].checkImpls && left.isInterface && right.members) {
            const properties = Object.keys(left.members);
            const errorHandler = context && context.errorHandler || ((result2) => result2);
            const _check = (leftMember, rightMember) => {
              if (rightMember) {
                const acceptType = leftMember.type();
                return errorHandler(acceptType.check(rightMember, context), acceptType, rightMember.key, rightMember.type());
              }
              return !!leftMember.question;
            };
            const result = properties.every((propName) => {
              let rightMember = right.members[propName];
              let leftMember = left.members[propName];
              if (leftMember.isAccessor) {
                if (rightMember) {
                  if (!rightMember.isAccessor)
                    return false;
                  if (leftMember.get && !_check(leftMember.get, rightMember.get)) {
                    return false;
                  }
                  if (leftMember.set && !_check(leftMember.set, rightMember.set)) {
                    return false;
                  }
                  return true;
                } else {
                  return [leftMember.get, leftMember.set].every((item2) => item2 ? _check(item2) : true);
                }
              }
              return _check(leftMember, rightMember);
            });
            if (left.dynamicProperties && left.dynamicProperties.size > 0) {
              if (!(right.dynamicProperties && right.dynamicProperties.size > 0))
                return false;
              const keys = this.dynamicProperties.keys();
              for (let key of keys) {
                if (!right.dynamicProperties.has(key.type())) {
                  return false;
                }
              }
            }
            if (result)
              return true;
          }
          return false;
        };
        let _res = false;
        if (type2.isInterface && check(type2, this)) {
          _res = true;
        } else {
          _res = check(this, type2);
        }
        this[symbolKey]._processing = null;
        return _res;
      }
      isof(type2, context) {
        this[symbolKey].checkImpls = true;
        let result = this.is(type2, context);
        this[symbolKey].checkImpls = false;
        return result;
      }
      publish() {
        const alias = this.metatypes.find((item2) => item2.name === "Alias");
        if (alias) {
          const metatype = {};
          alias.params.forEach((item2) => {
            const name = item2.value ? item2.name : "name";
            const value = item2.value ? item2.value : item2.name;
            metatype[name] = value;
          });
          this.alias = metatype.name;
          this.namespace.set(metatype.name, this);
          if (Boolean(metatype.origin) !== false) {
            this.namespace.set(this.id, this);
          }
        } else {
          this.namespace.set(this.id, this);
        }
      }
      getUseExtendMethod(name, kind, isStatic) {
        const extendMethods = isStatic ? this.callMethods : this.callMembers;
        const len = extendMethods.length;
        for (let index = 0; index < len; index++) {
          const item2 = extendMethods[index];
          const methods = item2.methods;
          const dynamic = item2.dynamic;
          let result = null;
          if (methods && Object.prototype.hasOwnProperty.call(methods, name)) {
            let desc2 = methods[name];
            if (desc2.isAccessor) {
              desc2 = kind == "set" ? desc2.set : desc2.get;
            }
            if (desc2) {
              if (!isStatic && !desc2.static) {
                return desc2;
              } else if (isStatic) {
                return desc2;
              }
            }
          }
          const _extends = item2.extends;
          const _len = _extends.length;
          for (let i = 0; i < _len; i++) {
            const target = _extends[i];
            const classModule = target && target.module ? target.module.type() : null;
            if (classModule) {
              result = target.mode === "class" ? classModule.getMethod(name, kind) : classModule.getMember(name, kind);
              if (result) {
                if (target.modifier.length > 0) {
                  if (target.modifier.includes(Utils2.getModifierValue(result))) {
                    return result;
                  }
                } else {
                  return result;
                }
              }
            }
          }
          if (dynamic && dynamic.length > 0) {
            const stringType = Namespace2.globals.get("String");
            result = stringType ? dynamic.find((method) => {
              if (method.isMethodDefinition && method.dynamicType) {
                const acceptType = method.dynamicType;
                return acceptType && stringType.is(acceptType.type());
              }
              return false;
            }) : false;
            if (result) {
              return result;
            }
          }
        }
        const imps = this.extends.concat(this.implements);
        const total = imps.length;
        for (let i = 0; i < total; i++) {
          let module2 = imps[i];
          module2 = module2.type();
          if (module2 && module2 !== this && !(this.namespace === module2.namespace && this.id === module2.id)) {
            if (!module2.extends.includes(this)) {
              const result = module2.getUseExtendMethod(name, kind, isStatic);
              if (result) {
                return result;
              }
            }
          }
        }
        return null;
      }
      getAnnotationCallMethodAllConfig(isMember = true) {
        const data = isMember ? this.callMembers.slice(0) : this.callMethods.slice(0);
        const imps = this.extends.concat(this.implements);
        const total = imps.length;
        for (let i = 0; i < total; i++) {
          let module2 = imps[i];
          module2 = module2.type();
          if (module2 && module2 !== this && !(this.namespace === module2.namespace && this.id === module2.id)) {
            if (!module2.extends.includes(this)) {
              data.push(...module2.getAnnotationCallMethodAllConfig(isMember));
            }
          }
        }
        return data;
      }
      getAnnotationCallMethods(isMember = true) {
        const configs = this.getAnnotationCallMethodAllConfig(isMember);
        const len = configs.length;
        const properties = /* @__PURE__ */ new Set();
        const excludes = isMember ? this.getMemberKeys() : Object.keys(this.methods);
        const merge = (classModule, mode, modifier, methods) => {
          if (!classModule || classModule === this)
            return;
          const dataset = mode === "class" ? classModule.methods : classModule.members;
          for (let name in dataset) {
            if (excludes.includes(name))
              continue;
            if (methods && Object.prototype.hasOwnProperty.call(methods, name))
              continue;
            let desc2 = dataset[name];
            if (desc2.isAccessor) {
              if (desc2.get)
                properties.add(desc2.get);
              if (desc2.set)
                properties.add(desc2.set);
            } else {
              properties.add(desc2);
            }
          }
          classModule.extends.concat(classModule.implements).forEach((item2) => merge(item2.type(), mode, modifier));
        };
        for (let index = 0; index < len; index++) {
          const item2 = configs[index];
          const methods = item2.methods;
          for (let name in methods) {
            let desc2 = methods[name];
            if (desc2.isAccessor) {
              if (desc2.get)
                properties.add(desc2.get);
              if (desc2.set)
                properties.add(desc2.set);
            } else {
              properties.add(desc2);
            }
          }
          item2.extends.forEach((specifier) => {
            const module2 = specifier.module;
            const mode = specifier.mode;
            const modifier = specifier.modifier;
            if (module2) {
              merge(module2.type(), mode, modifier, methods);
            }
          });
        }
        return Array.from(properties);
      }
      getMethod(name, kind = null) {
        const target = Object.prototype.hasOwnProperty.call(this.methods, name) ? this.methods[name] : null;
        if (target && target.isAccessor) {
          return kind == "set" ? target.set : target.get;
        }
        if (!target) {
          return this.getUseExtendMethod(name, kind, true);
        }
        return target;
      }
      hasMember(name) {
        const members = this.members;
        if (Object.prototype.hasOwnProperty.call(members, name)) {
          return true;
        }
        for (var i = 0; i < this.extends.length; i++) {
          const inherit = this.extends[i].type();
          if (inherit !== this && !inherit.extends.includes(this)) {
            const result2 = inherit.hasMember(name);
            if (result2) {
              return true;
            }
          }
        }
        const result = this.hasInterfaceMember(name);
        if (result) {
          return true;
        }
        const base = this.compilation.getGlobalTypeById("Object");
        if (base && base !== this) {
          const result2 = base.hasMember(name);
          if (result2) {
            return true;
          }
        }
        return false;
      }
      getMember(name, kind = null, excludeInterface = false) {
        const members = this.members;
        if (Object.prototype.hasOwnProperty.call(members, name)) {
          const target = members[name];
          if (target && target.isAccessor) {
            return kind == "set" ? target.set : target.get;
          }
          return target;
        }
        for (var i = 0; i < this.extends.length; i++) {
          let inherit = this.extends[i];
          inherit = inherit ? inherit.type() : null;
          if (inherit !== this) {
            if (!inherit.extends.includes(this)) {
              const result2 = inherit.getMember(name, kind);
              if (result2) {
                return result2;
              }
            }
          }
        }
        const result = excludeInterface ? null : this.getInterfaceMember(name, kind);
        if (result) {
          return result;
        }
        const base = this.compilation.getGlobalTypeById("Object");
        if (base && base !== this) {
          const result2 = base.getMember(name, kind);
          if (result2) {
            return result2;
          }
        }
        return this.getUseExtendMethod(name, kind);
      }
      dynamicAttribute(propertyType) {
        const properties = this.dynamicProperties;
        for (let [key, value] of properties) {
          if (key.check(propertyType)) {
            return value;
          }
        }
        const inherit = this.inherit;
        if (inherit && inherit.isModule && inherit !== this && !inherit.extends.includes(this)) {
          const result = inherit.dynamicAttribute(propertyType);
          if (result) {
            return result;
          }
        }
        if (this.implements) {
          for (const impl of this.implements) {
            const result = impl.dynamicAttribute(propertyType);
            if (result) {
              return result;
            }
          }
        }
        return null;
      }
      getMemberKeys() {
        const members = this.members;
        const keys = Object.keys(members);
        for (var i = 0; i < this.extends.length; i++) {
          let inherit = this.extends[i];
          inherit = inherit.type();
          if (inherit && inherit !== this && !inherit.extends.includes(this)) {
            keys.push(...inherit.getMemberKeys());
          }
        }
        if (this.implements) {
          for (const impl of this.implements) {
            keys.push(...impl.getMemberKeys());
          }
        }
        return keys;
      }
      getTypeKeys() {
        return Array.from(this.getProperties().keys());
      }
      getProperties(propertyMap) {
        propertyMap = propertyMap || /* @__PURE__ */ new Map();
        let members = this.members;
        for (var name in members) {
          let member = members[name];
          if (member.isAccessor)
            member = member.get;
          if (member) {
            const modifier = Utils2.getModifierValue(member);
            if (modifier === "public") {
              propertyMap.set(name, member);
            }
          }
        }
        const inherit = this.inherit;
        if (inherit && inherit.isModule && inherit !== this && !inherit.extends.includes(this)) {
          inherit.getProperties(propertyMap);
        }
        if (this.isInterface) {
          this.implements.forEach((imp) => imp.getProperties(propertyMap));
        }
        return propertyMap;
      }
      getInterfaceMember(name, kind = null) {
        const imps = this.implements;
        const len = imps.length;
        for (let i = 0; i < len; i++) {
          let impModule = imps[i];
          impModule = impModule ? impModule.type() : null;
          if (impModule && impModule !== this && !impModule.extends.includes(this)) {
            const result = impModule.getMember(name, kind);
            if (result) {
              return result;
            }
          }
        }
        return null;
      }
      hasInterfaceMember(name) {
        const imps = this.implements;
        const len = imps.length;
        for (let i = 0; i < len; i++) {
          let impModule = imps[i];
          impModule = impModule.type();
          if (impModule && impModule !== this && !impModule.extends.includes(this)) {
            const result = impModule.hasInterfaceMember(name);
            if (result) {
              return true;
            }
          }
        }
        return false;
      }
      getConstructMethod(flag) {
        if (!flag) {
          return this.methodConstructor || null;
        }
        let inherit = this;
        while (inherit) {
          let method = inherit.methodConstructor;
          if (method) {
            return method;
          }
          ;
          inherit = inherit.extends ? inherit.extends[0] : null;
        }
        return null;
      }
      addDepend(module2) {
        if (module2 !== this) {
          module2.used = true;
          this.dependencies.add(module2);
        }
      }
      getReferenceNameByModule(module2) {
        if (module2 === this) {
          return module2.id;
        }
        if (this.importAlias.has(module2)) {
          return this.importAlias.get(module2);
        }
        if (module2.required || this.imports.has(module2.id)) {
          return module2.id;
        }
        return module2.namespace.getChain().concat(module2.id).join("_");
      }
      addMember(name, desc2, flag = false) {
        if (desc2 && desc2.isConstructor) {
          const result = this.addDescriptor("constructor", desc2);
          if (!result) {
            if (this.methodConstructor && desc2.isSameSource(this.methodConstructor)) {
              desc2.error(1045, "constructor");
            }
          }
          this.methodConstructor = desc2;
        } else {
          const result = this.addDescriptor(name, desc2);
          if (desc2.dynamicMethod)
            return;
          const isStatic = !!(desc2.static || this.static);
          const target = isStatic || flag ? this.methods : this.members;
          if (desc2.kind === "get" || desc2.kind === "set") {
            const obj = Object.prototype.hasOwnProperty.call(target, name) ? target[name] : target[name] = { isAccessor: true };
            if (!result) {
              if (!obj.isAccessor) {
                desc2.error(1045, name);
              } else if (Object.prototype.hasOwnProperty.call(obj, desc2.kind)) {
                let old = obj[desc2.kind];
                if (old && desc2.isSameSource(old)) {
                  desc2.error(1045, name);
                }
              }
            }
            if (!obj[desc2.kind] || !desc2.isSameSource(obj[desc2.kind])) {
              obj[desc2.kind] = desc2;
            }
          } else {
            if (!result) {
              if (Object.prototype.hasOwnProperty.call(target, name)) {
                let old = target[name];
                if (old && desc2.isSameSource(old)) {
                  desc2.error(1045, name);
                }
              }
            }
            if (!target[name] || !desc2.isSameSource(target[name])) {
              target[name] = desc2;
            }
          }
        }
      }
      addImport(name, module2, isAlias = false, topScope = null) {
        if (module2 === this) {
          return false;
        }
        topScope = topScope || this.compilation.scope;
        if (!this.isDeclaratorModule) {
          if (this.imports.has(name)) {
            return false;
          } else if (topScope.isDefine(name)) {
            const old = topScope.define(name);
            if (!old.isAnnotationCreated)
              return false;
          }
        }
        if (isAlias) {
          this.importAlias.set(module2, name);
        }
        topScope.define(name, module2);
        this.imports.set(name, module2);
        return true;
      }
      getImport(name) {
        return this.imports.get(name);
      }
      getModuleGenerics() {
        const result = this.getModuleDeclareGenerics();
        return result.length > 0 ? result : null;
      }
      getModuleDeclareGenerics(flag = false, onlyread = false, origin = false) {
        const statcks = this.getStacks().filter((stack2) => !!stack2.genericity).sort((a, b) => {
          return a.genericity.elements.length - b.genericity.elements.length;
        });
        if (statcks.length > 0) {
          if (origin) {
            return [statcks[0], statcks[0].genericity.elements];
          }
          if (flag) {
            return [statcks[0], statcks[0].genericity.elements.map((item2) => item2.type())];
          }
          if (onlyread) {
            return statcks[0].genericity;
          }
          return statcks[0].genericity.elements.map((item2) => item2.type());
        }
        return [];
      }
      toString(context, options = {}) {
        const name = this.namespace.getChain().concat(this.id).join(".");
        const stacks = this.getStacks();
        options.complete = false;
        if (context && context.stack) {
          if (stacks.some((item2) => item2.id === context.stack)) {
            options.complete = true;
          }
        }
        const [stackModule, declareGenerics] = this.getModuleDeclareGenerics(true);
        if (stackModule && declareGenerics && declareGenerics.length > 0) {
          const ctx2 = context && context.isContext ? context : stackModule.getContext();
          const elements = declareGenerics.map((item2) => {
            if (options.fetchDeclareGenericsDefaultValue && options.inbuild) {
              if (item2.type().assignType) {
                return item2.type().assignType.type().toString({}, options);
              }
              return "any";
            }
            const type2 = ctx2.fetch(item2.type(), true);
            if (type2 === this) {
              return type2.id;
            }
            if (options.complete) {
              return type2.toString({}, options);
            } else {
              return stackModule.getTypeDisplayName(type2, context, options);
            }
          });
          return `${name}<${elements.join(",")}>`;
        }
        return name;
      }
    };
    module.exports = Module;
  }
});

// lib/core/Diagnostic.js
var require_Diagnostic = __commonJS({
  "lib/core/Diagnostic.js"(exports, module) {
    var Lang = require_Lang();
    var constant = {};
    var define = (code, name, message) => {
      if (Lang.has(code)) {
        throw new Error(`code '${code}' already exists.`);
      } else {
        Lang.define(code, message);
        constant[name] = code;
      }
    };
    var Diagnostic = class {
      constructor(file, message, range, kind, node, code) {
        this.file = file;
        this.message = message;
        this.range = range;
        this.kind = kind;
        if (message === code && typeof code === "string") {
          code = "";
        }
        this.node = node;
        this.code = code;
      }
      toString() {
        let message = this.message;
        let range = this.range;
        if (this.file) {
          message += ` (${this.file}:${range.start.line}:${range.start.column}) ${this.code}`;
        } else {
          message += ` (${range.start.line}:${range.start.column}) ${this.code}`;
        }
        return message;
      }
      static defineError(code, name, value) {
        if (code >= 1e4) {
          define(code, name, value);
        } else {
          throw new Error(`code '${code}' already exists.`);
        }
      }
      static getCodeByName(name) {
        return constant[name];
      }
      static getMessage(code, args = []) {
        return Lang.get(code, ...args);
      }
    };
    Diagnostic.LANG_CN = 0;
    Diagnostic.LANG_EN = 1;
    Diagnostic.ERROR = 0;
    Diagnostic.WARN = 1;
    Diagnostic.DEPRECATED = 2;
    Diagnostic.UNNECESSARY = 3;
    define(1e3, "MISSING_ARGUMENT", [
      "\u51FD\u6570\u53C2\u6570\u671F\u671B\u6709%s\u4E2A\uFF0C\u5F53\u524D\u7ED9\u4E86%s\u4E2A",
      "Expected %s arguments, but got %s"
    ]);
    define(1001, "INCONSISTENT_ARGUMENT", [
      "\u51FD\u6570\u53C2\u6570\u671F\u671B\u6709%s\u4E2A\uFF0C\u5F53\u524D\u7ED9\u4E86%s\u4E2A",
      "Expected %s arguments, but got %s"
    ]);
    define(1002, "TYPE_ASSIGNABLE_NOT_MATCHED", [
      "\u6307\u5B9A\u7684\u5B9E\u53C2\u7C7B\u578B(%s), \u4E0D\u80FD\u5206\u914D\u7ED9\u58F0\u660E\u7684\u5F62\u53C2\u7C7B\u578B(%s)",
      `Argument of type '%s' is not assignable to parameter of type '%s'`
    ]);
    define(1003, "GENERIC_ASSIGNABLE_NOT_CONSTRAINT", [
      "\u6307\u5B9A\u7684\u7C7B\u578B(%s)\u4E0D\u80FD\u6EE1\u8DB3\u58F0\u660E\u7684\u7EA6\u675F\u7C7B\u578B(%s)",
      "Type '%s' does not satisfy the constraint '%s'"
    ]);
    define(1004, "GENERIC_ARGUMENT_NUMBER_INCONFORMITY", [
      "\u6CDB\u578B\u53C2\u6570\u671F\u671B\u662F %s \u4E2A\uFF0C\u4F46\u6307\u5B9A\u4E86 %s \u4E2A",
      "Expected %s type arguments, but got %s"
    ]);
    define(1005, "GENERIC_ARGUMENT_NUMBER_INCONFORMITY_RANGE", [
      "\u6CDB\u578B\u53C2\u6570\u671F\u671B\u662F %s-%s \u4E2A\uFF0C\u4F46\u6307\u5B9A\u4E86 %s \u4E2A",
      "Expected %s-%s type arguments, but got %s"
    ]);
    define(1006, "REFS_FUN_IS_NOT_CALLABLE", [
      "\u5F15\u7528\u540D(%s)\uFF0C\u4E0D\u662F\u4E00\u4E2A\u53EF\u8C03\u7528\u7684\u65B9\u6CD5",
      "'%s' is not callable"
    ]);
    define(1007, "REFS_VARIABLE_CANNOT_REDECLARE", [
      "\u53D8\u91CF\u4E0D\u80FD\u91CD\u590D\u58F0\u660E(%s)",
      "Variable '%s' cannot redeclare"
    ]);
    define(1008, "REFS_VARIABLE_CONFLICTS_WITH_CLASS", [
      "\u58F0\u660E\u7684\u53D8\u91CF\u540D(%s)\u4E0E\u7C7B\u540D\u51B2\u7A81",
      "Variable '%s' conflicts with the current class name."
    ]);
    define(1009, "REFS_TYPE_ASSIGNABLE_NOT_MATCHED", [
      "\u5F15\u7528\u7684\u8868\u8FBE\u5F0F\u7C7B\u578B(%s)\u4E0D\u80FD\u5206\u914D\u7ED9\u6307\u5B9A\u7684\u7C7B\u578B(%s)",
      "Type '%s' is not assignable to assignment of type '%s'"
    ]);
    define(1010, "REFS_VARIABLE_CANNOT_IS_ITSELF", [
      "\u6307\u5B9A\u5F15\u7528\u7684\u53D8\u91CF\u4E0D\u80FD\u662F\u81EA\u8EAB(%s)",
      "Variable '%s' cannot reference to itself."
    ]);
    define(1011, "REFS_VARIABLE_CANNOT_IS_ITSELF", [
      "\u53D8\u91CF\u540D(%s),\u9690\u542B\u7740(any)\u7C7B\u578B,\u4F46\u662F\u53EF\u4EE5\u4E3A\u5176\u8D4B\u503C\u540E\u80FD\u63A8\u65AD\u51FA\u66F4\u9002\u5408\u7684\u7C7B\u578B",
      "Variable '%s' implicitly has an 'any' type, but a better type may is inferred from usage."
    ]);
    define(1012, "REFS_SPREAD_NOT_IS_ARRAY", [
      "\u5C55\u5F00\u6570\u7EC4\u8868\u8FBE\u5F0F(%s)\u7684\u7C7B\u578B\u5FC5\u987B\u662F\u4E00\u4E2A\u6570\u7EC4\uFF0C\u5F53\u524D\u5F15\u7528\u7684\u7C7B\u578B(%s)",
      "Spread '%s' expression, must is an array type. give %s"
    ]);
    define(1013, "REFS_IS_NOT_DEFINED", [
      "\u5F15\u7528\u540D(%s)\u6CA1\u6709\u5B9A\u4E49",
      "'%s' is not defined"
    ]);
    define(1014, "REFS_SPREAD_ARRAY_OUT_INDEX_RANGE", [
      "\u5C55\u5F00\u6570\u7EC4(%s[%s]),\u5DF2\u8D85\u51FA\u7D22\u5F15\u4E0B\u6807",
      "Spread %s[%s] out of range, is not assign initial value."
    ]);
    define(1015, "REFS_IS_NOT_WRITABLE", [
      "\u5F15\u7528\u540D(%s)\u662F\u4E00\u4E2A\u4E0D\u53EF\u5199\u7684\u58F0\u660E",
      "'%s' is not writable"
    ]);
    define(1016, "PARAMETER_CANNOT_HAVE_QUESTION_AND_INITIAL", [
      "\u6709\u521D\u59CB\u503C\u7684\u53C2\u6570\u4E0D\u9700\u8981\u6807\u8BB0\u4E3A\u53EF\u9009\u53C2\u6570",
      "Parameter with a initial value cannot is marked as optional"
    ]);
    define(1017, "AWAIT_EXPRESSION_MUST_ASYNC_FUN", [
      "\u8868\u8FBE\u5F0F(await),\u53EA\u80FD\u5F15\u7528\u58F0\u660E\u4E3A\u540C\u6B65\u7684\u51FD\u6570",
      "Await expression are only allowed within async function"
    ]);
    define(1018, "AWAIT_EXPRESSION_MUST_RETURN_PROMISE", [
      "\u8868\u8FBE\u5F0F(await),\u53EA\u80FD\u5F15\u7528\u58F0\u660E\u4E3A\u540C\u6B65\u7684\u51FD\u6570",
      "Await expression needs to return a promise type"
    ]);
    define(1019, "REFS_IS_NOT_INSTANCE_OBJECT", [
      "\u5F15\u7528(%s),\u4E0D\u662F\u4E00\u4E2A\u5B9E\u4F8B\u5BF9\u8C61",
      "The refs '%s' is not instance object"
    ]);
    define(1020, "REFS_MAYBE_IS_NOT_INSTANCE_OBJECT", [
      "\u5F15\u7528(%s),\u53EF\u80FD\u4E0D\u662F\u4E00\u4E2A\u5B9E\u4F8B\u5BF9\u8C61",
      "The refs '%s' maybe is not instance object"
    ]);
    define(1021, "OPERATOR_RIGHT_HAND_NOT_IS_CLASS", [
      "\u5B9E\u4F8B\u8FD0\u7B97\u7B26(%s),\u5728\u53F3\u8FB9\u8868\u8FBE\u5F0F\u4E2D\u5FC5\u987B\u662F\u4E00\u4E2A\u7C7B\u578B\u5F15\u7528",
      "Operator the '%s' right-hand refs is not class type"
    ]);
    define(1022, "BREAK_JUMP_CANNOT_CROSS_BLOCK", [
      "\u8BED\u6CD5(Break)\u6307\u5B9A\u7684\u6807\u7B7E(%s)\u8868\u8FBE\u5F0F\u4E0D\u5B58\u5728\u6216\u8005\u5DF2\u8DE8\u8D8A\u8FB9\u754C",
      "Jump target is not exists or has crossed boundary"
    ]);
    define(1023, "BREAK_NOT_IN_LOOP", [
      "\u8BED\u6CD5(Break)\u53EA\u80FD\u51FA\u73B0\u5728\u5FAA\u73AF\u8BED\u53E5\u4E2D",
      "Break must is contain in the 'switch,while,do,for'"
    ]);
    define(1024, "IMPORT_REFS_TO_CIRCULAR_DEPS", [
      "%s\u662F\u4E00\u4E2A\u5FAA\u73AF\u5F15\u7528. %s > %s > %2",
      "%s to circular dependency. %s > %s > %2"
    ]);
    define(1025, "IMPORT_REFS_ALREADY_EXISTS", [
      "\u5BFC\u5165\u7684\u6A21\u5757(%s)\u5DF2\u7ECF\u5B58\u5728",
      "Import '%s' module already exists."
    ]);
    define(1026, "IMPORT_REFS_NOT_EXISTS", [
      "\u5BFC\u5165\u7684\u6A21\u5757(%s)\u6CA1\u6709\u627E\u5230",
      "Import '%s' is not exists."
    ]);
    define(1027, "CLASS_REFS_NOT_EXISTS", [
      "\u5F15\u7528\u7684\u7C7B(%s)\u4E0D\u5B58\u5728",
      "Class '%s' is not exists"
    ]);
    define(1028, "IMPLEMENTS_REFS_NOT_INTERFACE", [
      "\u5728\u7C7B\u7684(implements)\u8868\u8FBE\u5F0F\u4E2D,\u6307\u5B9A\u7684\u6807\u8BC6\u7B26\u4E0D\u662F\u63A5\u53E3\u7C7B\u578B",
      "Implements '%s' is not interface"
    ]);
    define(1029, "IMPLEMENTS_REFS_NOT_INTERFACE", [
      "\u5728\u7C7B\u7684(implements)\u8868\u8FBE\u5F0F\u4E2D,\u6307\u5B9A\u7684\u63A5\u53E3\u7C7B\u578B\u4E0D\u5B58\u5728",
      "Implements '%s' is not exists"
    ]);
    define(1030, "CLASS_GENERIC_MISSING_ARGS", [
      "\u6307\u5B9A\u7684\u6CDB\u7C7B\u578B\u9700\u8981\u6709 %s \u4E2A\u7C7B\u578B\u53C2\u6570",
      "Generic '%s' requires %s type arguments"
    ]);
    define(1031, "CLASS_GENERIC_MISSING_ARGS_RANGE", [
      "\u7C7B\u6CDB\u578B(%s)\u9700\u8981\u6709 %s-%s \u4E2A\u7C7B\u578B\u53C2\u6570",
      "Generic '%s' requires %s-%s type arguments"
    ]);
    define(1032, "INTERFACE_MEMBER_NOT_IMPLEMENTED", [
      "\u6307\u5B9A\u7684\u63A5\u53E3\u6210\u5458(%1),\u6CA1\u6709\u5728\u6B64\u7C7B\u4E2D\u5B9E\u73B0",
      "The '%s' %s in the %s is not implemented in the %s"
    ]);
    define(1033, "INTERFACE_RETURN_TYPE_NOT_MATCHED", [
      "\u5B9E\u73B0\u63A5\u53E3\u6210\u5458(%s)\u7684\u7C7B\u578B\u4E0D\u5339\u914D",
      "Implementing the type mismatch of the interface member '%s'. must is '%s' type"
    ]);
    define(1034, "INTERFACE_MEMBER_INCONFORMITY", [
      "\u5B9E\u73B0\u63A5\u53E3\u6210\u5458(%1)\u4E0D\u517C\u5BB9",
      "The '%s' inconformity with the %s in the '%s'"
    ]);
    define(1035, "INTERFACE_MEMBER_MISSING_PARAMS", [
      "\u5B9E\u73B0\u63A5\u53E3(%1)\u4E2D,\u53C2\u6570\u7F3A\u5931",
      "The '%s' %s params missing with the %s params in the '%s'"
    ]);
    define(1036, "INTERFACE_MEMBER_PARAMS_NOT_MATCHED", [
      "\u5B9E\u73B0\u63A5\u53E3(%1)\u4E2D\uFF0C\u53C2\u6570\u7684\u7C7B\u578B\u4E0D\u5339\u914D",
      "The '%s' %s params type not matched with the %s params in the '%s3'"
    ]);
    define(1037, "INTERFACE_MEMBER_GENERIC_PARAMS_NUM_INCONSISTENCY", [
      "\u5B9E\u73B0\u63A5\u53E3(%1)\u4E2D\uFF0C\u6CDB\u578B\u7684\u6570\u76EE\u4E0D\u4E00\u81F4",
      "The '%s' %s declare generics number inconsistency in the '%s'"
    ]);
    define(1038, "INTERFACE_MEMBER_GENERIC_NOT_SATISFY_CONSTRAINTS", [
      "\u5B9E\u73B0\u63A5\u53E3(%1),\u6CDB\u578B\u7EA6\u675F\u7C7B\u578B\u4E0D\u5339\u914D",
      "The '%s' %s generics does not satisfy constraint with the '%s'"
    ]);
    define(1039, "INTERFACE_MEMBER_MODIFIER_NOT_CONSISTENT", [
      "\u5B9E\u73B0\u63A5\u53E3(%1)\u4E2D,\u8BBF\u95EE\u547D\u540D\u7A7A\u95F4\u7684\u4FEE\u9970\u7B26\u4E0D\u4E00\u81F4",
      "the '%s' %s modifier is not consistent with the %s modifier in the '%1'"
    ]);
    define(1040, "DECLARE_ALIAS_TYPE_NOT_ASSIGNMENT_VALUE", [
      "\u58F0\u660E\u7684\u522B\u540D\u7C7B\u578B(%s)\u5FC5\u987B\u6307\u5B9A\u4E00\u4E2A\u7C7B\u578B\u503C",
      "Declare '%s' alias type must assignment a type"
    ]);
    define(1041, "MISSING_CONDITION", [
      "\u7F3A\u5C11\u6761\u4EF6",
      "Missing condition"
    ]);
    define(1042, "LOOP_MAYBE_INFINITE_EXECUTE", [
      "\u5FAA\u73AF\u8BED\u53E5\u4F53\u4E2D\u7F3A\u5C11\u9000\u51FA\u8BED\u53E5\uFF0C\u53EF\u80FD\u4F1A\u5BFC\u81F4\u65E0\u9650\u5FAA\u73AF",
      "The absence of an exit statement in the body of a do while statement may result in an infinite loop"
    ]);
    define(1043, "TOKEN_INVALID", [
      "\u65E0\u6548\u7684\u6807\u8BC6\u7B26",
      "Token(%s) invalid"
    ]);
    define(1044, "PROPERTY_INITIAL_VALUE_NOT_NUMBER", [
      "\u679A\u4E3E\u5C5E\u6027(%s)\u7684\u521D\u59CB\u503C\u53EA\u80FD\u662F\u6570\u5B57\u6216\u8005\u5B57\u7B26\u4E32",
      "Enum property the '%s' initial value of can only is number or string"
    ]);
    define(1045, "PROPERTY_REDEFINED", [
      "\u5C5E\u6027(%s)\u5DF2\u7ECF\u5B58\u5728\uFF0C\u4E0D\u80FD\u91CD\u590D\u5B9A\u4E49",
      "Property the '%s' already exists. cannot redefined"
    ]);
    define(1046, "REFS_VALUE_NOT_OBJECT", [
      "\u5F15\u7528\u7684\u503C\u5FC5\u987B\u662F\u5BF9\u8C61",
      "The refs value of '%s' is not an object"
    ]);
    define(1047, "LOOP_ONLY_SINGLE_VARIABLE", [
      "\u5FAA\u73AF(%s)\u4E2D\u53EA\u80FD\u58F0\u660E\u5355\u4E2A\u53D8\u91CF",
      "Only a single variable declaration is allowed in a '%s' statement"
    ]);
    define(1048, "LOOP_CANNOT_HAVE_INITIAL", [
      "\u5FAA\u73AF(%s)\u58F0\u660E\u7684\u53D8\u91CF\u4E0D\u80FD\u6709\u521D\u59CB\u503C",
      "The variable declaration of a '%s' statement cannot have an initial"
    ]);
    define(1049, "REFS_VALUE_MAYBE_NOT_OBJECT", [
      "\u5F15\u7528\u7684\u503C\u53EF\u80FD\u4E0D\u662F\u5BF9\u8C61\u503C",
      "The refs value of '%s' maybe is not an object"
    ]);
    define(1050, "PARAMETER_OPTION_ONLY_DECLARE_AFTER", [
      "\u5E26\u6709\u521D\u59CB\u503C\u7684\u53C2\u6570(\u53EF\u9009\u53C2\u6570)\u53EA\u80FD\u8DDF\u5728\u5FC5\u586B\u53C2\u6570\u7684\u540E\u9762",
      "The '%s' parameter with an initial value in method can only is declared after the parameter"
    ]);
    define(1051, "PARAMETER_REST_MUST_AT_END", [
      "\u5269\u4F59\u53C2\u6570\u53EA\u80FD\u5728\u53C2\u6570\u7684\u7ED3\u5C3E",
      "The '%s' rest parameter can only appear at the end of the params"
    ]);
    define(1052, "CONSTRUCTOR_NOT_RETURN_VALUE", [
      "\u6784\u9020\u51FD\u6570\u4E2D\u4E0D\u9700\u8981\u6709\u8FD4\u56DE\u503C",
      "Constructor does not need to return value"
    ]);
    define(1053, "CONSTRUCTOR_FIRST_CALL_SUPER", [
      "\u6784\u9020\u51FD\u6570\u4E2D\u5FC5\u987B\u5148\u8C03\u7528\u8D85\u7C7B\u65B9\u6CD5(super)",
      "Constructor must first call super"
    ]);
    define(1054, "FUN_MUST_HAVE_RETURN_VALUE", [
      "\u51FD\u6570\u58F0\u660E\u7684\u7C7B\u578B\u5FC5\u987B\u6709\u8FD4\u56DE\u503C",
      "A function whose declared type is neither 'void' nor 'any' must return a value"
    ]);
    define(1055, "FUN_ASYNC_MUST_RETURN_PROMISE", [
      "\u58F0\u660E\u4E3A\u5F02\u6B65\u7684\u51FD\u6570\u5FC5\u987B\u8FD4\u56DE\u4E13\u6709\u7C7B\u578B(%s)",
      "The return type of an async function or method must is the '%s' type"
    ]);
    define(1056, "GENERIC_DECLARE_ALREADY_EXISTS", [
      "\u58F0\u660E\u7684\u6CDB\u578B\u5DF2\u7ECF\u5B58\u5728",
      "Generic '%s' is already exists"
    ]);
    define(1057, "GENERIC_NAME_CONFLICTS_WITH_TYPE", [
      "\u58F0\u660E\u7684\u6CDB\u578B\u4E0E\u7C7B\u578B\u540D\u51B2\u7A81",
      "Generic '%s' conflicts with type name."
    ]);
    define(1058, "GENERIC_DECLARE_REQUIRED_PARAM_NOT_FOLLOW_OPTIONAL", [
      "\u58F0\u660E\u6CDB\u578B\u7684\u53C2\u6570\uFF0C\u4E0D\u80FD\u8DDF\u5728\u53EF\u9009\u53C2\u6570\u7684\u540E\u9762",
      "Required type parameters may not follow optional type parameters"
    ]);
    define(1059, "REFS_TO_TYPE_NOT_USED_VALUE", [
      "\u5F53\u524D\u7684\u5F15\u7528(%s)\u6307\u5411\u4E00\u4E2A\u7C7B\u578B\uFF0C\u4E0D\u80FD\u5F53\u4F5C\u503C\u4F20\u9012",
      "'%s' only refers to a type, but is being used as a value here."
    ]);
    define(1060, "REFS_IS_NOT_EXIST", [
      "\u5F15\u7528(%s)\u4E0D\u5B58\u5728",
      "'%s' does not exist."
    ]);
    define(1061, "REFS_IS_NOT_ACCESSIBLE", [
      "\u5F15\u7528(%s)\u4E0D\u53EF\u8BBF\u95EE",
      "'%s' is not accessible."
    ]);
    define(1062, "GENERIC_CANNOT_DECLARE_ON_CONSTRUCTOR", [
      "\u4E0D\u80FD\u5728\u6784\u9020\u51FD\u6570\u4E0A\u58F0\u660E\u6CDB\u578B",
      "Generic cannot is declared on constructor"
    ]);
    define(1063, "METHOD_NOT_HAVE_OVERRIDE", [
      "\u7C7B\u4E2D\u6210\u5458\u65B9\u6CD5(%1)\u5728\u7236\u7C7B\u4E2D\u4E0D\u5B58\u5728\uFF0C\u4E0D\u9700\u8981\u6807\u8BB0\u91CD\u5199(@Override))\u6CE8\u89E3\u7B26",
      "The '%s' %s does not exists in the superclass. remove the '@Override' annotator if not overwrite."
    ]);
    define(1064, "METHOD_NEED_HAVE_OVERRIDE", [
      "\u7C7B\u4E2D\u6210\u5458\u65B9\u6CD5(%1)\u5728\u7236\u7C7B\u4E2D\u5B58\u5728\uFF0C\u9700\u8981\u6807\u8BB0\u91CD\u5199(@Override)\u6CE8\u89E3\u7B26",
      "the '%s' %s already exists in the superclass. use the '@Override' annotator if need overwrite"
    ]);
    define(1065, "METHOD_GET_ACCESSOR_NOT_PARAM", [
      "\u83B7\u53D6\u8BBF\u95EE\u5668(%s)\u4E0D\u9700\u8981\u58F0\u660E\u53C2\u6570",
      "'%s' getter does not defined param"
    ]);
    define(1066, "METHOD_GET_ACCESSOR_NOT_PARAM", [
      "\u83B7\u53D6\u8BBF\u95EE\u5668(%s)\u9700\u8981\u8FD4\u56DE\u503C",
      "'%s' getter accessor must have a return value"
    ]);
    define(1067, "METHOD_SET_ACCESSOR_NEED_PARAM", [
      "\u8BBE\u7F6E\u8BBF\u95EE\u5668(%s)\u9700\u8981\u58F0\u660E\u4E00\u4E2A\u53C2\u6570",
      "'%s' setter must have one param"
    ]);
    define(1068, "METHOD_ACCESSOR_TYPE_NOT_MATCHED", [
      "\u8BBF\u95EE\u5668(%s)\u7684\u63A5\u6536\u7C7B\u578B\u4E0D\u5339\u914D",
      "'%s' setter and getter parameter types do not match"
    ]);
    define(1069, "NEW_IS_CANNOT_INSTANTIATED", [
      "\u5F53\u524D\u5F15\u7528(%s)\u4E0D\u662F\u4E00\u4E2A\u53EF\u88AB\u5B9E\u4F8B\u5316\u7684\u7C7B\u5BF9\u8C61",
      "Reference the '%s' is not an instantiable class object"
    ]);
    define(1070, "NEW_IS_ABSTRACT_CANNOT_INSTANTIATED", [
      "\u5F53\u524D\u5F15\u7528(%s)\u662F\u4E00\u4E2A\u62BD\u8C61\u7C7B\uFF0C\u4E0D\u80FD\u88AB\u5B9E\u4F8B\u5316\u5BF9\u8C61",
      "'%s' is an abstract class. cannot is instantiated."
    ]);
    define(1071, "REST_TYPE_NOT_MATCHED", [
      "\u5269\u4F59\u53C2\u6570\u53EA\u80FD\u662F\u4E00\u4E2A\u5143\u7EC4\u7C7B\u578B",
      "Rest accept type must is tuple type"
    ]);
    define(1072, "RETURN_MUST_FUN_BODY", [
      "\u8FD4\u56DE\u8868\u8FBE\u5F0F\u53EA\u80FD\u5728\u51FD\u6570\u4F53\u4E2D",
      "Return expression must in function body"
    ]);
    define(1073, "CONNOT_CONVERT_ARRAY", [
      "\u5F53\u524D\u7684\u5F15\u7528\u4E0D\u80FD\u8F6C\u6362\u4E3A\u4E00\u4E2A\u6570\u7EC4",
      "The '%s' cannot convert a reference to an array"
    ]);
    define(1074, "CONNOT_CONVERT_OBJECT", [
      "\u5F53\u524D\u7684\u5F15\u7528\u4E0D\u80FD\u8F6C\u6362\u4E3A\u4E00\u4E2A\u5BF9\u8C61",
      "The '%s' cannot convert a reference to an object"
    ]);
    define(1075, "NOT_CALL_SUPER", [
      "\u8C03\u7528\u8D85\u7C7B(super)\u65B9\u6CD5\u9700\u8981\u5728\u5B50\u7C7B\u4E2D",
      "'super' no inherit parent class"
    ]);
    define(1076, "SUPER_ONLY_IN_METHODS_CALLED", [
      "\u8D85\u7C7B\u65B9\u6CD5(super)\u53EA\u80FD\u5728\u7C7B\u65B9\u6CD5\u4E2D\u8C03\u7528",
      "'super' can only is called in class methods"
    ]);
    define(1077, "TUPLE_REST_MUST_FOLLOW_END", [
      "\u5143\u7EC4\u7C7B\u578B\u4E2D\u58F0\u660E\u7684\u5269\u4F59\u7C7B\u578B\u53EA\u80FD\u51FA\u73B0\u5728\u5143\u7D20\u7684\u7ED3\u5C3E",
      "Tuple type rest parameter must follow the end"
    ]);
    define(1078, "TYPE_DECLARE_ALREADY_EXISTS", [
      "\u58F0\u660E\u7684\u7C7B\u578B(%s)\u5DF2\u7ECF\u5B58\u5728",
      "Declare type '%s' already exists"
    ]);
    define(1079, "MISSING_TYPE_EXPRESSION", [
      "\u7F3A\u5C11\u7C7B\u578B\u5F15\u7528",
      "Missing type expression"
    ]);
    define(1080, "PROPERTY_NOT_EXISTS", [
      "\u5C5E\u6027\u540D(%s)\u4E0D\u5B58\u5728",
      "Property '%s' is not exists"
    ]);
    define(1081, "SPREAD_OBJECT_EXPRES_MUST_HAVE_INITIAL", [
      "\u5C55\u5F00\u5BF9\u8C61\u8868\u8FBE\u5F0F\u5FC5\u987B\u8BBE\u7F6E\u4E00\u4E2A\u521D\u59CB\u503C",
      "Spread object expression, must have initial"
    ]);
    define(1082, "PROPERTY_WITH_PARENT_MEMBER_CONFLICTS", [
      "\u5F53\u524D\u5C5E\u6027(%s)\u4E0E\u7236\u7C7B\u4E2D\u7684\u6210\u5458\u6709\u51B2\u7A81",
      "Property '%s' conflicts with a member of the parent class"
    ]);
    define(1083, "TYPE_IS_NOT_EXISTS", [
      "\u5F15\u7528(%s)\u7684\u7C7B\u578B\u4E0D\u5B58\u5728",
      "Type '%s' is not exists"
    ]);
    define(1084, "REQUIRED_PARAM_NOT_FOLLOW_OPTIONAL", [
      "\u58F0\u660E\u7684\u53C2\u6570\uFF0C\u4E0D\u80FD\u8DDF\u5728\u53EF\u9009\u53C2\u6570\u7684\u540E\u9762",
      "Required parameters may not follow optional type parameters"
    ]);
    define(1085, "ERROR", [
      "\u7F16\u8BD1\u9519\u8BEF(%s)",
      "%s"
    ]);
    define(1086, "SPECIFIES_TYPE_ARRAY_ELEMENT_NOT_SPECIFIED_INDEX_TYPE", [
      "\u6307\u5B9A\u7C7B\u578B\u4E3A(%s)\u7684\u6570\u7EC4\u5143\u7D20\uFF0C\u4E0D\u80FD\u5728\u6570\u7EC4\u7D22\u5F15\u4F4D\u7F6E\u6307\u5B9A\u7C7B\u578B",
      "Specifies an array element of '%s' type. the type cannot is specified at the array index"
    ]);
    define(1087, "UPDATE_EXPRESSION_MUST_IS_NUMERIC", [
      "\u66F4\u65B0\u8868\u8FBE\u5F0F(%s)\u7684\u5F15\u7528\u7C7B\u578B\u5FC5\u987B\u662F\u4E00\u4E2A\u6570\u5B57\u7C7B\u578B",
      "The reference type of the update expression '%s' must is a numeric type"
    ]);
    define(1088, "METHOD_NOT_HAVE_OVERRIDE", [
      "\u9700\u8981\u91CD\u5199\u7684\u65B9\u6CD5(%s)\u53C2\u6570\u6570\u76EE\u4E0D\u4E00\u81F4",
      "Inconsistent number of the '%s' method arguments to override"
    ]);
    define(1089, "METHOD_NOT_HAVE_OVERRIDE", [
      "\u9700\u8981\u91CD\u5199\u7684\u5B58\u50A8\u5668(%s)\u53C2\u6570\u6570\u76EE\u4E0D\u4E00\u81F4",
      "Inconsistent number of the '%s' setter arguments to override"
    ]);
    define(1090, "INTERFACE_MEMBER_INCONSISTENT_NUMBER_PARAMS", [
      "\u5B9E\u73B0\u63A5\u53E3(%s)\u4E2D\u7684\u53C2\u6570\u4E0D\u517C\u5BB9",
      "Implemented interface parameters is not compatible in the '%s' method"
    ]);
    define(1091, "FRAGMENT_EXPRESSION_ERROR", [
      "\u7247\u6BB5\u8868\u8FBE\u5F0F\u53EA\u80FD\u51FA\u73B0\u5728\u7ED3\u5C3E",
      "fragment expressions can only appear at the end"
    ]);
    define(1092, "ANNOTATIONS_RUNTIME_METHOD_PARAM_INVALID", [
      "\u6CE8\u89E3Runtime\u65B9\u6CD5\u53C2\u6570\u503C\u53EA\u80FD\u662F'server,client'",
      "Annotations runtime method parameters can only is 'server' or 'client'"
    ]);
    define(1093, "ANNOTATIONS_LOCATION_INVALID", [
      "\u6CE8\u89E3\u65B9\u6CD5\u5728\u6B64\u4F4D\u7F6E\u672A\u751F\u6548",
      "Annotation method not in effect at this location"
    ]);
    define(1094, "IMPORT_DECLAREATION_STATEMENT_INVALID", [
      "\u5728\u6B64\u5904\u58F0\u660E\u7684\u5BFC\u5165\u8BED\u65E0\u6548",
      "The import declared here is invalid"
    ]);
    define(1095, "LOAD_TYPE_DESCRIPTION_FILE_INVALID", [
      "\u6307\u5B9A\u52A0\u8F7D\u7684\u7C7B\u578B\u63CF\u8FF0\u6587\u4EF6\u65E0\u6548",
      "The type description file specified to load is invalid"
    ]);
    define(1096, "FUN_GLOBALS_DECLARE_ALREADY_EXISTS", [
      "\u58F0\u660E\u7684\u5168\u5C40\u51FD\u6570(%s)\u5DF2\u7ECF\u5B58\u5728",
      "Declare globals function '%s' already exists"
    ]);
    define(1097, "PROP_GLOBALS_DECLARE_ALREADY_EXISTS", [
      "\u58F0\u660E\u7684\u5C5E\u6027(%s)\u5DF2\u7ECF\u5B58\u5728",
      "Declare globals property '%s' already exists"
    ]);
    define(1098, "XML_NAMESPACE_NOT_EXISTS", [
      "\u6307\u5B9A\u7684XML\u547D\u540D\u7A7A\u95F4(%s)\u6CA1\u6709\u5B9A\u4E49",
      "The specified XML namespace '%s' is not defined"
    ]);
    define(1099, "REFS_NAMESPACE_NOT_EXISTS", [
      "\u5F15\u7528\u7684\u547D\u540D\u7A7A\u95F4\u4E0D\u5B58\u5728",
      "The '%s' namespace does not exist"
    ]);
    define(1100, "EMBED_FILE_WAS_NOT_FOUND", [
      "\u5D4C\u5165\u7684\u6587\u4EF6\u6CA1\u6709\u627E\u5230",
      "Embed file '%s' not found"
    ]);
    define(1101, "EMBED_FILE_MISSING", [
      "\u7F3A\u5931\u5D4C\u5165\u7684\u6587\u4EF6",
      "Embed file missing"
    ]);
    define(1102, "EMBED_ANNOTATIONS_ERROR", [
      "\u5D4C\u5165\u6CE8\u89E3\u7B26\u53EA\u80FD\u5B9A\u4E49\u5728\u5305\u6216\u8005\u9876\u7EA7\u57DF\u4E2D",
      "Embed annotations can only is defined in a package or top-level scope"
    ]);
    define(1103, "ANNOTATIONS_ERROR", [
      "\u6CE8\u89E3\u7B26(%s)\u53EA\u80FD\u5B9A\u4E49\u5728\u9876\u7EA7\u57DF\u3001\u5305\u6216\u8005\u7C7B\u4E2D",
      "%s annotations can only is defined in a top-level scope or package or class"
    ]);
    define(1104, "ANNOTATIONS_ERROR", [
      "\u6CE8\u89E3\u7B26(%s)\u53EA\u80FD\u5B9A\u4E49\u5728\u65B9\u6CD5\u6216\u8005\u5C5E\u6027\u4E0A",
      "%s annotations can only is defined in a methods or property of class members"
    ]);
    define(1105, "ANNOTATIONS_ERROR", [
      "\u6CE8\u89E3\u7B26(%s)\u53EA\u80FD\u5B9A\u4E49\u5728\u7C7B\u4E0A",
      "%s annotations can only is defined in a class"
    ]);
    define(1106, "EMBED_ANNOTATIONS_ASSETS_EXISTS", [
      "\u5D4C\u5165\u6CE8\u89E3\u7B26\u6307\u5B9A\u7684\u8D44\u6E90\u5DF2\u7ECF\u5B58\u5728",
      "Embed annotations '%s' assets already exists"
    ]);
    define(1107, "REFS_DECLARE_ALREADY_EXISTS", [
      "\u58F0\u660E\u7684\u5F15\u7528(%s)\u5DF2\u7ECF\u5B58\u5728",
      "Declare refs '%s' already exists"
    ]);
    define(1108, "JSX_ELEMENT_MISSING_NAMESPACE", [
      "\u5143\u7D20\u6807\u7B7E\u540D\u4E0D\u7B26\u5408\u6807\u51C6",
      "JSX element tag name does not is standard"
    ]);
    define(1109, "JSX_SUBCLASS_PARENT_MUST_COMPONENTS", [
      "\u5B50\u7C7B\u7684\u7236\u7EA7\u5FC5\u987B\u662F\u4E00\u4E2A\u6839\u5143\u7D20\u7EC4\u4EF6",
      "JSX the parent of subclass must is root element components"
    ]);
    define(1110, "JSX_Unsupported", [
      "\u4E0D\u652F\u6301\u7684\u4EE3\u7801\u5757",
      "JSX Unsupported"
    ]);
    define(1111, "COMPONENT_NOT_EXISTS", [
      "\u5143\u7D20\u7EC4\u4EF6(%s)\u4E0D\u5B58\u5728",
      "Component '%s' is not exists"
    ]);
    define(1112, "JSX_SUBCLASS_ALREADY_EXIST", [
      "\u5728\u6839\u5143\u7D20\u7EC4\u4EF6\u4E2D\u7684\u5B50\u7C7B\u5DF2\u7ECF\u5B58\u5728",
      "JSX subclass already exist in the root element components"
    ]);
    define(1113, "JSX_CAN_ONLY_AN_EXPRESSION", [
      "\u5143\u7D20\u5C5E\u6027\u7684\u5B50\u7EA7\u53EA\u80FD\u662F\u4E00\u4E2A\u8868\u8FBE\u5F0F",
      "JSX the value of element properties can only is a expression"
    ]);
    define(1114, "JSX_ELEMENT_DIRECTIVE_INVALID", [
      "\u5143\u7D20\u6307\u4EE4\u65E0\u6548",
      "JSX element directive '%s' invalid"
    ]);
    define(1115, "JSX_ROOT_ELEMENT_DIRECTIVE_INVALID", [
      "\u6839\u5143\u7D20\u4E0A\u4E0D\u80FD\u4F7F\u7528\u6307\u4EE4",
      "JSX directives cannot is used on the root element"
    ]);
    define(1116, "JSX_ROOT_ELEMENT_DIRECTIVE_INVALID", [
      "\u5143\u7D20\u6307\u4EE4(each)\u8868\u8FBE\u5F0F\u9519\u8BEF, \u6B63\u786E\u5199\u6CD5\u662F:'item of fromArray'",
      "JSX element directives 'each' expression error, correct be: 'item of fromArray'"
    ]);
    define(1117, "XML_NAMESPACE_ONLY_DEFINE_AT_ROOT_ELEMENT", [
      "XML\u547D\u540D\u7A7A\u95F4\u53EA\u80FD\u5B9A\u4E49\u5728\u6839\u5143\u7D20\u4E0A",
      "JSX namespaces can only is defined on the root element"
    ]);
    define(1118, "FILE_WAS_NOT_FOUND", [
      "\u6CA1\u6709\u627E\u5230\u6307\u5B9A\u7684\u6587\u4EF6",
      "Not found the '%s'"
    ]);
    define(1119, "JSX_DIRECTIVE_FOREACH_NOT_ARRAY", [
      "\u6307\u4EE4(EACH)\u7684\u5F15\u7528\u53EA\u80FD\u662F\u4E00\u4E2A\u6570\u7EC4. \u5F53\u524D\u4E3A(%s)",
      "JSX references to the 'each' directive can only is an array. but got '%s'"
    ]);
    define(1120, "JSX_DIRECTIVE_FOR_INVALID", [
      "\u6307\u4EE4(FOR)\u7684\u5F15\u7528\u7C7B\u578B\u5FC5\u987B\u662F\u4E00\u4E2A\u53EF\u8FED\u4EE3\u7684\u5BF9\u8C61",
      "JSX references to the 'for' directive must is an iterator object. but got '%s'"
    ]);
    define(1121, "JSX_ROOT_ELEMENT_DIRECTIVE_FOR_INVALID", [
      "\u5143\u7D20\u6307\u4EE4(for)\u8868\u8FBE\u5F0F\u9519\u8BEF, \u6B63\u786E\u5199\u6CD5\u662F:'value in fromIteration'",
      "JSX element directives 'for' expression error, correct be: '(value,key[optional],index[optional]) in fromIteration'"
    ]);
    define(1122, "REQUIRE_IS_NOT_EXIST", [
      "\u52A0\u8F7D\u4F9D\u8D56(%s)\u6587\u4EF6\u4E0D\u5B58\u5728\u3002\u8BF7\u5148\u5B89\u88C5\u6B64\u4F9D\u8D56",
      "Require '%s' does not exist. try npm install %1"
    ]);
    define(1123, "JSX_MULTIPLE_ELEMENTS_MUST_WRAPPED", [
      "\u591A\u4E2A\u5143\u7D20\u5FC5\u987B\u5305\u88F9\u5728\u4E00\u4E2A\u5BB9\u5668\u4E2D",
      "JSX Multiple elements must is wrapped in a container"
    ]);
    define(1124, "MEMBER_PROPERTY_NAME_BE_RESERVED", [
      "'%s' \u662F\u4E00\u4E2A\u88AB\u4FDD\u7559\u7684\u6807\u8BC6\u7B26",
      "The '%s' is a reserved identifier"
    ]);
    define(1125, "JSX_AVAILABLE_ELEMENTS_IN_SPECIFIED_NAMESPACE", [
      "\u6307\u5B9A\u7684\u547D\u540D\u7A7A\u95F4\u4E0B\u53EF\u7528\u5143\u7D20\u4E3A:%s",
      "JSX the '%s' available elements in the specified namespace"
    ]);
    define(1126, "JSX_SLOT_IS_NOT_DEFINED_IN_PARENT_COMPONENT", [
      "\u5F15\u7528\u63D2\u69FD(%s)\u5728\u7236\u7EC4\u4EF6\u4E2D\u6CA1\u6709\u5B9A\u4E49",
      "JSX refs of the slot '%s' is not defined in the parent component"
    ]);
    define(1127, "JSX_PARENT_OF_SLOT_IS_NOT_WEB_COMPONENT", [
      "\u63D2\u69FD(%s)\u7684\u7236\u7EA7\u4E0D\u662F\u4E00\u4E2Aweb\u7EC4\u4EF6",
      "JSX parent of the slot '%s' is not web-component"
    ]);
    define(1128, "JSX_SLOT_USED_PARAMS_IS_NOT_DEFINED", [
      "\u63D2\u69FD(%s)\u4F7F\u7528\u7684\u53C2\u6570\u5728\u7236\u7EA7\u7EC4\u4EF6\u7684\u63D2\u69FD\u4E2D\u6CA1\u6709\u5B9A\u4E49",
      "JSX the slot '%s' used parameters is not defined in the slot of the parent component"
    ]);
    define(1129, "JSX_SLOT_IS_ALREADY_DEFINED", [
      "\u63D2\u69FD(%s)\u5DF2\u7ECF\u5B9A\u4E49\u8FC7",
      "JSX the slot (%s) is already defined"
    ]);
    define(1130, "JSX_SLOT_DOES_NOT_DECLARED_A_SCOPE", [
      "\u63D2\u69FD(%s)\u6CA1\u6709\u58F0\u660E\u4F5C\u7528\u57DF",
      "JSX the slot '%s' does not declared scope"
    ]);
    define(1131, "JSX_COMPONENT_NOT_DEFINED_SLOTS_NEED_DELETE_DISCARD_CHILD_ELEMENTS", [
      "\u8FD9\u4E9B\u5B50\u7EA7\u5143\u7D20\u4F1A\u88AB\u629B\u5F03,\u53EF\u4EE5\u5728\u7236\u7EA7\u4E2D\u6307\u5B9A\u9ED8\u8BA4\u63D2\u69FD\u6765\u63A5\u6536\u8FD9\u4E9B\u5143\u7D20\u6216\u8005\u5220\u9664",
      "JSX these child elements will discarded, can specify default slot in the parent to receive them. also is can removed them"
    ]);
    define(1132, "REFERENCE_FILE_NOT_EXIST", [
      "\u5F15\u7528\u7684\u6587\u4EF6(%s)\u4E0D\u5B58\u5728",
      "References file '%s' does not exist"
    ]);
    define(1133, "CONSTRUCTOR_NOT_RETURN_VALUE", [
      "\u7F3A\u5C11\u8FD4\u56DE\u8868\u8FBE\u5F0F",
      "Missing return expression"
    ]);
    define(1134, "COMPONENT_MUST_INHERIT_WEB_COMPONENT", [
      "JSX \u5143\u7D20\u7EC4\u4EF6(%s)\u5FC5\u987B\u7EE7\u627F'web-component'",
      "JSX the '%s' element components must inherit 'web-component'"
    ]);
    define(1135, "ANNOTATION_EXPRESSION_ARGUMENT_IS_INVALID", [
      "\u6CE8\u89E3(%s)\u8868\u8FBE\u5F0F\u53C2\u6570\u65E0\u6548",
      "The '%s' annotation expression arguments is invalid"
    ]);
    define(1136, "ACCESSOR_CANNOT_OVERRIDE", [
      "\u6210\u5458\u5C5E\u6027(%s)\u4E0D\u80FD\u88AB\u91CD\u5199",
      "The '%s' members property cannot is overridden"
    ]);
    define(1137, "MAIN_ENTER_METHOD_CAN_ONLY_SINGLE", [
      "\u6CE8\u89E3\u7B26(%s)\u4E0D\u80FD\u7ED1\u5B9A\u591A\u4E2A\u5165\u53E3\u65B9\u6CD5",
      "Annotation the '%s' cannot bind multiple entry methods in an class"
    ]);
    define(1138, "MAIN_ENTER_METHOD_CAN_ONLY_STATIC_AND_PUBLIC", [
      "\u6CE8\u89E3\u7B26(%s)\u53EA\u80FD\u7ED1\u5B9A\u5728\u516C\u5F00\u4E14\u4E3A\u9759\u6001\u7684\u65B9\u6CD5\u4E0A",
      "Annotation the '%s' can only is bound to public and static methods"
    ]);
    define(1139, "PROPERTY_DYNAMIC_CAN_ONLY_IS_STRING", [
      "\u52A8\u6001\u5C5E\u6027\u7684\u7D22\u5F15(%s)\u7C7B\u578B\u53EA\u80FD\u662F\u5B57\u7B26\u4E32\u6216\u8005\u6570\u5B57\u7C7B\u578B",
      "The '%s' index type of dynamic property can only is string or number"
    ]);
    define(1140, "ANNOTATION_IS_NOT_EXISTS", [
      "\u6CE8\u89E3\u7B26(%s)\u4E0D\u5B58\u5728\u3002\u53EF\u4EE5\u5728(compiler.options.annotations)\u4E2D\u6DFB\u52A0\u6CE8\u89E3\u7B26",
      "Annotation the '%s' does not exist. but you can also register annotations through 'compiler.options.annotations'"
    ]);
    define(1141, "TYPE_REFS_TO_CIRCULAR_DEPS", [
      "\u7C7B\u578B(%s)\u662F\u4E00\u4E2A\u5FAA\u73AF\u5F15\u7528",
      "Type '%s' refs to circular"
    ]);
    define(1142, "TYPE_REFS_TO_CIRCULAR_DEPS", [
      "\u6210\u5458(%s)\u662F\u4E00\u4E2A\u53EA\u8BFB\u5C5E\u6027",
      "The '%s' property is readonly"
    ]);
    define(1143, "DIRECTIVE_CONTAINER_CAN_NO_LONGER_SET_DIRECTIVE_PROPERTY", [
      "\u5BB9\u5668\u6307\u4EE4\u4E0D\u80FD\u518D\u6307\u5B9A\u5C5E\u6027\u6307\u4EE4",
      "Directives container can no longer set attribute directive"
    ]);
    define(1144, "DIRECTIVE_CONTAINER_MISSING_PARAMS", [
      "\u5BB9\u5668\u6307\u4EE4\u7F3A\u5C11\u5C5E\u6027",
      "Directives container missing attributes. expect '%s'"
    ]);
    define(1145, "DIRECTIVE_CONTAINER_EXPECT_ATTRIBUTES", [
      "\u5BB9\u5668\u6307\u4EE4\u5C5E\u6027\u671F\u671B%s\u4E2A,\u4F46\u8BBE\u7F6E\u4E86%1\u4E2A",
      "Directives container attributes expect %s. but got %s"
    ]);
    define(1146, "DIRECTIVE_CONTAINER_ATTRIBUTES_MUST_IS_EXPRESSION", [
      "\u5BB9\u5668\u6307\u4EE4\u5C5E\u6027\u7684\u503C\u53EA\u652F\u6301\u8868\u8FBE\u5F0F",
      "Only expressions is supported for value of container directive properties"
    ]);
    define(1147, "", [
      "\u7C7B\u578B(%s)\u4E0D\u80FD\u7EE7\u627F\u4E3A\u7EC8\u6001\u7C7B(%s)\u7684\u5B50\u7C7B",
      "Type '%s' cannot is inherited as a subclass of the final class '%s'"
    ]);
    define(1148, "", [
      "\u7EC8\u6001\u65B9\u6CD5(%s)\u4E0D\u80FD\u88AB\u91CD\u5199",
      "The final method '%s' cannot is overridden"
    ]);
    define(1149, "", [
      "\u7EC8\u6001\u5C5E\u6027(%s)\u4E0D\u80FD\u88AB\u91CD\u5199",
      "The final property '%s' cannot is overridden"
    ]);
    define(1150, "", [
      "\u7C7B\u578B(%s)\u4E0D\u80FD\u7528\u4F5C\u7D22\u5F15\u7C7B\u578B",
      "Type '%s' cannot is used as an index type"
    ]);
    define(1151, "", [
      "\u4E0D\u80FD\u5728\u6269\u5C55\u53C2\u6570\u4F53\u4E4B\u5916\u6307\u5B9A\u7C7B\u578B",
      "Type cannot is specified outside of an spread parameter body"
    ]);
    define(1152, "", [
      "\u7F3A\u5C11\u5BF9\u8C61\u5C5E\u6027(%s)",
      "Missing object property the '%s'"
    ]);
    define(1153, "", [
      "\u679A\u4E3E\u6210\u5458\u5FC5\u987B\u5177\u6709\u521D\u59CB\u5316\u503C",
      "Enum member must have initializer"
    ]);
    define(1154, "", [
      "\u6269\u5C55\u53C2\u6570\u5FC5\u987B\u5177\u6709\u5143\u7EC4\u7C7B\u578B\u6216\u4F20\u9012\u7ED9\u5269\u4F59\u53C2\u6570",
      "A spread argument must either have a tuple type or is passed to a rest parameter"
    ]);
    define(1155, "", [
      "\u957F\u5EA6\u4E3A'%s'\u7684\u5143\u7EC4\u7C7B\u578B'%s',\u5728\u7D22\u5F15'%s'\u5904\u6CA1\u6709\u5143\u7D20",
      "Tuple type '%s' of length '%s' has no element at index '%s'"
    ]);
    define(1156, "", [
      "\u6307\u4EE4'else'\u53EA\u80FD\u51FA\u73B0\u5728'if'\u6761\u4EF6\u4E4B\u540E",
      "Directives the 'else' can only appear after the 'if' condition"
    ]);
    define(1157, "", [
      "\u6307\u5B9A\u5177\u6709\u63D2\u69FD(%s)\u5143\u7D20\u7684\u7236\u7EA7\u5FC5\u987B\u662F\u4E00\u4E2Aweb\u7EC4\u4EF6\u7C7B\u578B",
      "Specifies that the parent with slot(%s) elements must is a Web component type"
    ]);
    define(1158, "", [
      "\u5C5E\u6027(%s)\u662F\u4E00\u4E2A\u5FAA\u73AF\u5F15\u7528",
      "The '%s' is a circular references"
    ]);
    define(1159, "", [
      "\u5BFC\u51FA\u8BED\u53E5\u53EA\u80FD\u51FA\u73B0\u5728\u9876\u7EA7\u5757\u4E2D",
      "Export statements can only appear in top-level blocks"
    ]);
    define(1160, "", [
      "\u975E\u63CF\u8FF0\u6587\u4EF6\u548C\u7247\u6BB5\u6587\u4EF6\u4E2D\u7684\u5BFC\u51FA\u8BED\u53E5\u4F1A\u88AB\u5FFD\u7565",
      "Export statements in non-description and fragment files are ignored"
    ]);
    define(1161, "", [
      "\u6A21\u5757(%s)\u4E0D\u80FD\u88AB\u5BFC\u5165,\u56E0\u4E3A(%1)\u4E0D\u662F\u4E3B\u6A21\u5757",
      "The '%s' cannot is imported. because '%1' is not the main module."
    ]);
    define(1162, "", [
      "\u6307\u5B9A\u7684\u6765\u6E90(%s)\u6CA1\u6709\u5BFC\u51FA\u5185\u5BB9",
      "The specified source does not have an export statement. in '%s'"
    ]);
    define(1163, "", [
      "\u4E00\u4E2A\u6A21\u5757\u4E2D\u4E0D\u80FD\u6709\u591A\u4E2A\u9ED8\u8BA4\u5BFC\u51FA",
      "A module cannot have multiple default exports"
    ]);
    define(1164, "", [
      `\u6A21\u5757(%s)\u6CA1\u6709\u5BFC\u51FA\u6210\u5458(%s),\u60A8\u662F\u5426\u6253\u7B97\u4F7F\u7528"import %2 from '%1'"`,
      `Module '%s' has no exported member '%s'. Did you mean to use "import %2 from '%1'" instead?`
    ]);
    define(1165, "", [
      "\u5F15\u7528\u5143\u8BED\u53E5(%s)\u4E0D\u5B58\u5728, \u53EF\u7528\u7684\u65B9\u6CD5:%2",
      "Reference meta statement '%s' does not exist, available methods:'%2'"
    ]);
    define(1166, "", [
      "\u5F15\u7528\u7684\u5B57\u6BB5\u540D(%s)\u4E0D\u5B58\u5728",
      "The '%s' field name does not exist"
    ]);
    define(1167, "", [
      "\u81F3\u5C11\u9700\u8981\u6307\u5B9A\u4E00\u4E2A\u5B57\u6BB5\u540D",
      "Least one field name needs to is specified"
    ]);
    define(1168, "", [
      "\u7D22\u5F15\u540D\u4E0D\u80FD\u91CD\u590D\u5B9A\u4E49",
      "The index name already defined"
    ]);
    define(1169, "", [
      "\u63D2\u69FD\u7684\u4F5C\u7528\u57DF\u53C2\u6570\u540D\u5FC5\u987B\u662F\u4E00\u4E2A\u5B57\u9762\u91CF\u6807\u8BC6\u7B26",
      "The scope parameter name of the slot must is literal identifier"
    ]);
    define(1170, "", [
      "\u58F0\u660E\u63D2\u69FD\u7684\u4F5C\u7528\u57DF\u53C2\u6570(%s)\u5FC5\u987B\u7ED9\u4E00\u4E2A\u521D\u59CB\u503C\u6216\u8005\u5F15\u7528",
      "Slots scope arguments the '%s' must have a initial value when declared"
    ]);
    define(1171, "", [
      "\u5C5E\u6027\u6307\u4EE4\u8868\u8FBE\u5F0F\u5FC5\u987B\u662F\u4E00\u4E2A\u5B57\u9762\u5BF9\u8C61\u7C7B\u578B",
      "Attributes directive-expression must is a literal-object and contains 'name,value' properties."
    ]);
    define(1172, "", [
      "\u7F3A\u5C11\u5C5E\u6027\u503C",
      "Missing attribute value"
    ]);
    define(1173, "", [
      "\u81EA\u5B9A\u4E49\u6307\u4EE4\u5FC5\u987B\u5305\u542B'name'\u548C'value'\u5C5E\u6027",
      "Custom directives must contains name and value properties."
    ]);
    define(1174, "", [
      "\u6307\u4EE4\u7EC4\u4EF6\u7684\u5B50\u7EA7\u53EA\u80FD\u662F\u4E00\u4E2AVNode\u7684\u7C7B\u578B",
      "Child of directive-component can only is of a VNode"
    ]);
    define(1175, "", [
      "\u5F15\u7528\u7684\u7C7B\u578B(%s)\u4E0D\u5B58\u5728",
      "Reference type '%s' does not exist"
    ]);
    define(1176, "", [
      "\u4E0D\u652F\u6301\u7684\u8868\u8FBE\u5F0F(%s)",
      "Expression the '%s' is not supported"
    ]);
    define(1177, "", [
      "\u4E0D\u652F\u6301\u540C\u7C7B\u578B\u5D4C\u5957\u5206\u914D",
      "Nested assignments of the same type '%s' is not supported"
    ]);
    define(1178, "", [
      '\u8868\u8FBE\u5F0F"%s"\u7684\u5F15\u7528,\u6709\u88AB\u8BBE\u7F6E\u4E3A\u4E13\u5C5E\u4F5C\u7528\u57DF\uFF0C\u5728\u5F53\u524D\u4F5C\u7528\u57DF\u4E2D\u53EA\u80FD\u5F53\u7C7B\u578B\u5F15\u7528',
      "Reference expression the '%s' was set proprietary plugin scope. so it can only be referenced as a type in the current doucument"
    ]);
    define(1179, "", [
      "\u6839\u5143\u7D20\u7EC4\u4EF6(%s)\u5FC5\u987B\u7EE7\u627F'web.components.Skin' \u6216\u8005 'web.components.Component'",
      "the '%s' root element components must inherit 'web.components.Skin' or 'web.components.Component'"
    ]);
    define(1180, "", [
      "\u58F0\u660E\u7684\u6A21\u5757(%s)\u7C7B\u578B\u5FC5\u987B\u5728\u6587\u6863\u7684\u9876\u7EA7\u4F5C\u7528\u57DF\u4E2D",
      "Declared module type the '%s' must is in the top-level scope of the document"
    ]);
    define(1181, "", [
      "\u5F15\u7528\u7684\u65B9\u6CD5\u6216\u8005\u5C5E\u6027\u5DF2\u88AB\u6807\u8BB0\u4E3A\u5DF2\u5220\u9664",
      "Referenced the '%s' method or property is removed"
    ]);
    define(1182, "", [
      "\u5F15\u7528\u7684\u65B9\u6CD5\u6216\u8005\u5C5E\u6027\u5DF2\u5F03\u7528",
      "Referenced the '%s' method or property is deprecated. %s"
    ]);
    define(1183, "", [
      "'%s'\u5DF2\u58F0\u660E\uFF0C\u4F46\u662F\u6CA1\u6709\u4EFB\u4F55\u5F15\u7528",
      "'%s' is declared but its value is never read"
    ]);
    define(1184, "", [
      "\u68C0\u6D4B\u5230\u4E0D\u4F1A\u6267\u884C\u7684\u4EE3\u7801",
      "Unreachable code detected"
    ]);
    define(1185, "", [
      "\u8C03\u7528\u4E86\u4E00\u4E2A\u7A7A\u64CD\u4F5C\u7684\u51FD\u6570",
      "A meaningless function was called"
    ]);
    module.exports = Diagnostic;
  }
});

// lib/core/Range.js
var require_Range = __commonJS({
  "lib/core/Range.js"(exports, module) {
    var Range = class {
      constructor(start, end) {
        this.start = start;
        this.end = end;
      }
    };
    module.exports = Range;
  }
});

// lib/types/LiteralObjectType.js
var require_LiteralObjectType = __commonJS({
  "lib/types/LiteralObjectType.js"(exports, module) {
    var Utils2 = require_Utils();
    var Namespace2 = require_Namespace();
    var Type = require_Type();
    var LiteralObjectType = class extends Type {
      constructor(inherit, target, properties = null, dynamicProperties = null, questionProperties = null) {
        super("$LiteralObjectType", inherit);
        this.target = target;
        this.isLiteralObjectType = true;
        this.properties = properties || (target ? target.attributes : null);
        this.dynamicProperties = dynamicProperties || (target ? target.dynamicProperties : null);
        this.questionProperties = questionProperties;
        this._hasGenericType = void 0;
      }
      get hasGenericType() {
        if (this._hasGenericType !== void 0) {
          return this._hasGenericType;
        }
        this._hasGenericType = false;
        if (this.properties && Array.from(this.properties.values()).some((item2) => item2.type().hasGenericType)) {
          this._hasGenericType = true;
        }
        if (this.dynamicProperties && Array.from(this.dynamicProperties.values()).some((item2) => item2.type().hasGenericType)) {
          this._hasGenericType = true;
        }
        return this._hasGenericType;
      }
      clone(inference, flag = false) {
        if (!flag && (!inference || !this.hasGenericType)) {
          return this;
        }
        const properties = /* @__PURE__ */ new Map();
        let dynamicProperties = null;
        this.properties.forEach((item2, key) => {
          if (inference) {
            properties.set(key, item2.type().clone(inference));
          } else {
            properties.set(key, item2);
          }
        });
        const dynamics = this.dynamicProperties || this.target && this.target.dynamicProperties;
        if (dynamics) {
          dynamicProperties = /* @__PURE__ */ new Map();
          dynamics.forEach((item2, key) => {
            dynamicProperties.set(key, item2.type().clone(inference));
          });
        }
        return new LiteralObjectType(this.inherit, this.target, properties, dynamicProperties);
      }
      attribute(property) {
        return this.properties.get(property);
      }
      dynamicAttribute(propertyType) {
        const properties = this.dynamicProperties || this.target && this.target.dynamicProperties;
        if (properties) {
          for (let [key, value] of properties) {
            if (key.check(propertyType)) {
              return value;
            }
          }
        }
        return null;
      }
      get attributes() {
        return this.properties;
      }
      check(stack2, context, options = {}) {
        return this.constraint(stack2.type(), context, options);
      }
      constraint(type2, context = {}, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isAliasType) {
          return this.constraint(type2.inherit.type(), context, options);
        }
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.constraint(item2.type(), context, options));
        }
        const errorHandler = context.errorHandler || ((result2) => result2);
        const qp = this.questionProperties || {};
        if (!this.isBaseObject(type2, context, options)) {
          type2 = Utils2.getOriginType(type2);
          return type2.isModule && type2.id === "Object";
        }
        if (!(type2.isLiteralObjectType || type2.isIntersectionType || type2.isGenericType))
          return false;
        if (type2.isLiteralObjectType && type2.properties.size === 0) {
          return true;
        }
        if (this.properties.size === 0 && this.dynamicProperties && this.dynamicProperties.size === 0) {
          return true;
        }
        let result = false;
        if (this.properties.size > 0) {
          const properties = Array.from(this.properties);
          result = properties.every((item2) => {
            const [name, base] = item2;
            const right = type2.attribute(name);
            const acceptType = base.type();
            if (!right) {
              const origin = this.target && this.target.attribute(name);
              const question = origin && origin.question || qp[name];
              return errorHandler(!!question, acceptType, right);
            }
            return errorHandler(acceptType.check(right, context, options), acceptType, right);
          });
        }
        if (!result) {
          result = this.checkDynamicProperties(type2, context, options, errorHandler);
        }
        return result;
      }
      isBaseObject(type2, context, options) {
        if (type2.isGenericType && type2.hasConstraint)
          type2 = type2.inherit.type();
        type2 = type2.isLiteralObjectType ? type2.inherit : type2;
        if (type2.isIntersectionType) {
          return this.isBaseObject(type2.left.type(), context, options) || this.isBaseObject(type2.right.type(), context, options);
        }
        return this.inherit.is(type2, context, options);
      }
      checkDynamicProperties(type2, context, options = {}, errorHandler = null) {
        const properties = this.dynamicProperties;
        if (properties && properties.size > 0) {
          let numberType = Namespace2.globals.get("Number");
          const regexp = /^\d+$/;
          const entries = type2.attributes.entries();
          let checkResult = true;
          for (let [key, value] of properties) {
            const matchType = key.type();
            const acceptType = value.init.type();
            let hasMatched = false;
            for (const [name, property] of entries) {
              if (matchType === numberType && !regexp.test(name)) {
                continue;
              }
              hasMatched = true;
              const val = acceptType.check(property, context, options);
              const result = errorHandler ? errorHandler(val, acceptType, property) : val;
              if (!result)
                checkResult = false;
            }
            if (!hasMatched && !value.question) {
              return false;
            }
          }
          return checkResult;
        }
        return true;
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        } else if (type2.isClassGenericType) {
          const inherit = type2.inherit.type();
          if (inherit.isAliasType) {
            return this.is(inherit, context, options);
          }
        } else if (type2.isIntersectionType) {
          return this.is(type2.left.type(), context, options) || this.is(type2.right.type(), context, options);
        }
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        type2 = type2.isLiteralObjectType ? type2.inherit : type2;
        return this.inherit.is(type2, context, options);
      }
      toString(context = {}, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        let depth = 1;
        if (!options.depth) {
          options.depth = 1;
        } else {
          options.depth++;
          depth = options.depth;
        }
        if (options.inbuild) {
          options.rawcode = false;
          options.onlyTypeName = true;
        }
        const properties = Array.from(this.properties).map((item2) => {
          const [name, base] = item2;
          const type2 = base.type();
          const origin = this.target && this.target.attribute(name);
          if (origin && origin.computed) {
            return `[${name}]: ` + type2.toString(context, options);
          }
          let question = origin && origin.question ? "?" : "";
          if (this.questionProperties && this.questionProperties[name]) {
            question = "?";
          }
          return `${name}${question}: ` + type2.toString(context, options);
        });
        if (this.dynamicProperties) {
          this.dynamicProperties.forEach((item2, key) => {
            const kn = item2.key ? item2.key.value() : "key";
            properties.push(`[${kn}:${key.type().toString()}]: ` + item2.type().toString(context, options));
          });
        }
        if (!properties.length) {
          return `{}`;
        }
        const newLine = `\r
`;
        const indent = `	`.repeat(depth);
        const end = depth > 1 ? `	`.repeat(depth - 1) : "";
        return `{${newLine}${indent}${properties.join(`,${newLine}${indent}`)}${newLine}${end}}`;
      }
    };
    module.exports = LiteralObjectType;
  }
});

// lib/types/TupleType.js
var require_TupleType = __commonJS({
  "lib/types/TupleType.js"(exports, module) {
    var Utils2 = require_Utils();
    var Namespace2 = require_Namespace();
    var Type = require_Type();
    var TupleType = class extends Type {
      constructor(inherit, elements, target, rest = false, isTupleUnion = false, prefix = false) {
        super("$TupleType", inherit);
        this.elements = [].concat(elements);
        const len = this.elements.length;
        this.rest = rest;
        this.requireCount = rest && len > 1 ? len - 1 : len;
        this.isTupleType = true;
        this.prefix = prefix ? true : !!(target && target.prefix);
        this.isTupleUnion = isTupleUnion ? true : !!(target && target.isTypeTupleUnionDefinition);
        this.target = target;
      }
      get hasGenericType() {
        return this.elements.some((type2) => {
          type2 = type2.type();
          return type2 && type2.hasGenericType;
        });
      }
      attribute(index) {
        if (!this.prefix && /\d+/.test(String(index))) {
          return this.elements[index] || null;
        }
        return null;
      }
      dynamicAttribute(type2) {
        const arrClass = Namespace2.globals.get("Array");
        return arrClass && arrClass.dynamicProperties.get(Utils2.getOriginType(type2));
      }
      clone(inference, flag = false) {
        if (!flag && (!inference || !this.hasGenericType)) {
          return this;
        }
        const elements = inference ? this.elements.map((item2) => {
          return item2.type().clone(inference);
        }) : this.elements.slice(0);
        return new TupleType(this.inherit, elements, this.target, this.rest, this.isTupleUnion);
      }
      checkItems(items, errorItems = [], context = {}, options = {}) {
        const errorHandler = context.errorHandler || ((result) => result);
        const checkItem = (base, item2, flag = true) => {
          let baseType = base.type();
          let type2 = this.getWrapAssignType(item2.type());
          if (baseType === type2 || this === type2)
            return true;
          if ((baseType.isThisType || baseType.target && baseType.target.isThisType) && !type2.isInstanceofType) {
            errorItems.push([baseType, item2]);
            if (options.forceResult)
              return true;
            return flag ? errorHandler(false, baseType, item2) : false;
          }
          if (baseType && !baseType.is(type2, context, options)) {
            errorItems.push([baseType, item2]);
            if (options.forceResult)
              return true;
            return flag ? errorHandler(false, baseType, item2) : false;
          }
          return true;
        };
        if (this.prefix || this.rest || this.isTupleUnion) {
          return items.every((item2) => {
            return errorHandler(this.elements.some((base) => {
              return checkItem(base, item2, false);
            }), this.elements, item2);
          });
        }
        const len = this.elements.length;
        const rest = len > 0 ? this.elements[len - 1] : null;
        const hasRest = rest && rest.type().rest;
        const requireCount = hasRest ? this.requireCount - 1 : this.requireCount;
        if (hasRest && items.length < requireCount) {
          return false;
        } else if (!hasRest && items.length !== requireCount) {
          let result = this.prefix;
          items.slice(requireCount).forEach((item2) => {
            result = errorHandler(false, null, item2);
          });
          return result;
        }
        return items.every((item2, index) => {
          let base = this.elements[index];
          if (base && !(hasRest && base === rest)) {
            return checkItem(base, item2);
          } else {
            if (hasRest && rest) {
              return checkItem(rest, item2);
            } else {
              return errorHandler(this.elements.some((base2) => {
                return checkItem(base2, item2, false);
              }), this.elements, item2);
            }
          }
        });
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        } else if (type2.isIntersectionType) {
          return [type2.left, type2.right].some((item2) => this.is(item2.type(), context, options));
        }
        if (this.isTupleUnion && !this.inherit.is(type2.inherit, context, options)) {
          return false;
        }
        let items = null;
        if (type2.isTupleType || type2.isLiteralArrayType) {
          items = type2.elements;
        } else if (this.rest) {
          items = [type2];
        } else {
          return false;
        }
        if (type2.isLiteralArrayType && !items.length) {
          return true;
        }
        return this.checkItems(items, [], context, options);
      }
      needBrackets() {
        if (this.elements.length === 1) {
          let first = this.elements[0].type();
          first = first.isComputeType && !first.object.isThisType ? first.getComputeType() : first;
          if ((first.isUnionType || first.isKeyofType) && first.elements.length > 1) {
            return true;
          } else if (first.isFunctionType) {
            return true;
          }
        }
        return this.elements.length > 1;
      }
      toString(context = {}, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        let isTupleUnion = this.isTupleUnion;
        let needBrackets = false;
        let hasAnyType = false;
        let elements = this.elements.map((item2) => {
          let type2 = item2.type();
          if (type2 === this) {
            hasAnyType = true;
            return "any";
          }
          if (!needBrackets) {
            if (type2.isGenericType && typeof context.inference === "function") {
              const result2 = context.inference(type2);
              if (result2 && result2.type().isUnionType) {
                needBrackets = result2.type().elements.length > 1;
              }
            }
          }
          return type2.toString(context, options);
        });
        if ((hasAnyType || options.hasAnyType) && this.prefix) {
          elements = ["any"];
        }
        const tupleRest = this.rest && this.target && this.target.isTypeTupleRestDefinition;
        const make = () => {
          if (isTupleUnion) {
            if (needBrackets || this.needBrackets()) {
              return `(${elements.join(" | ")})[]`;
            } else {
              return `${elements.join(" | ")}[]`;
            }
          }
          let rest = tupleRest ? "..." : "";
          let squares = rest ? "" : "[]";
          if (elements.length === 1 && (this.prefix || this.rest)) {
            if (needBrackets || this.needBrackets()) {
              return `${rest}(${elements[0]})${squares}`;
            } else {
              return `${rest}${elements[0]}${squares}`;
            }
          }
          return `${rest}[${elements.join(",")}]`;
        };
        let result = make();
        if (options.showRestSymbol) {
          if (this.rest && !result.startsWith("...")) {
            result = "..." + result;
            if (!result.endsWith("]")) {
              result += "[]";
            }
          }
        }
        return result;
      }
    };
    module.exports = TupleType;
  }
});

// lib/types/UnionType.js
var require_UnionType = __commonJS({
  "lib/types/UnionType.js"(exports, module) {
    var Type = require_Type();
    var UnionType = class extends Type {
      constructor(elements, target) {
        super("$UnionType");
        this.isUnionType = true;
        this.target = target;
        this.elements = elements;
        this.hasGenericType = elements.some((type2) => {
          const _type = type2.type();
          return _type ? _type.hasGenericType : false;
        });
      }
      clone(inference) {
        if (!inference || !this.hasGenericType) {
          return this;
        }
        const elements = this.elements.map((item2) => item2.type().clone(inference));
        return new UnionType(elements, this.target);
      }
      checkItems(items, context = {}, options = {}) {
        return items.every((item2) => {
          return this.elements.some((base) => base.type().check(item2, context, options));
        });
      }
      checkType(acceptType, assignment, context, options) {
        if (acceptType.isLiteralObjectType) {
          return acceptType.constraint(assignment, context, options);
        }
        return acceptType.is(assignment, context, options);
      }
      is(type2, context = {}, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        if (type2.isUnionType) {
          return type2.elements.some((item2) => {
            return this.elements.some((base) => this.checkType(base.type(), item2.type(), context, options));
          });
        }
        return this.elements.some((base) => this.checkType(base.type(), type2, context, options));
      }
      toString(context, options = {}) {
        context = this.pushToStringChain(context, options);
        let need = this.elements.length > 1;
        let str = this.elements.map((item2) => {
          const type2 = item2.type();
          if (type2.isFunctionType && need) {
            return `(${type2.toString(context, Object.create(options))})`;
          }
          return type2.toString(context, options);
        }).join(" | ");
        if (options.hasAnyType) {
          return "any";
        }
        return str;
      }
    };
    module.exports = UnionType;
  }
});

// lib/types/ClassGenericType.js
var require_ClassGenericType = __commonJS({
  "lib/types/ClassGenericType.js"(exports, module) {
    var Namespace2 = require_Namespace();
    var Type = require_Type();
    var ClassGenericType = class extends Type {
      constructor(types, inherit, isClass, target) {
        super("$ClassGenericType", inherit);
        this.isClassGenericType = true;
        this.isClassType = !!isClass;
        this.elements = types;
        this.target = target;
        this.isThisType = !!(target && target.isThisType);
        this._relatedTypes = null;
      }
      get types() {
        const t = this._types;
        if (t)
          return t;
        return this._types = this.elements.map((el) => el.type());
      }
      get hasGenericType() {
        return this.types.some((type2) => {
          return type2 && !!(type2.isGenericType || type2.hasGenericType);
        }) || this.inherit.hasGenericType;
      }
      clone(inference) {
        if (!inference) {
          return this;
        }
        const types = this.types.map((type2) => {
          return type2.clone(inference);
        });
        const result = new ClassGenericType(types, this.inherit, this.isClassType, this.target);
        result._relatedTypes = this._relatedTypes;
        return result;
      }
      getWrapCheckerType(wrapType) {
        if (this.elements.length === 1) {
          const declareGenerics = wrapType.target.genericity;
          const has = declareGenerics ? declareGenerics.elements.some((item2) => item2.type() === wrapType.inherit.type()) : false;
          if (has) {
            return this.elements[0].type();
          }
        }
        return wrapType.inherit.type();
      }
      check(stack2, context, options = {}) {
        if (!stack2)
          return false;
        const inherit = this.inherit.type();
        const isWrap = inherit.isAliasType;
        const type2 = stack2.type();
        if (!type2.isClassGenericType) {
          if (this.isClassType && type2.isInstanceofType)
            return false;
          if (isWrap) {
            return this.getWrapCheckerType(inherit).check(stack2, context, options);
          }
          if (this.hasDynamicAttribute(inherit)) {
            return Namespace2.globals.get("object").is(type2, context, options);
          }
          if (type2.isUnionType || type2.isIntersectionType) {
            return this.is(type2, context, options);
          }
          return this.isClassType ? this.types[0].is(type2, context) : inherit.check(stack2, context, options);
        }
        return this.is(type2, context, options);
      }
      hasDynamicAttribute(object) {
        if (object && object.isModule && (object.isInterface || object.isClass)) {
          return !!object.dynamicAttribute(Namespace2.globals.get("string"));
        }
        return false;
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        } else if (type2.isIntersectionType) {
          return [type2.left, type2.right].some((item2) => this.is(item2.type(), context, options));
        }
        if (this.isClassType && (type2.isInstanceofType || !(type2.isClassType && type2.isClassGenericType) || type2.isInterface)) {
          return false;
        }
        const inherit = this.inherit.type();
        const isWrap = inherit.isAliasType;
        if (!(type2.isClassGenericType || type2.isInstanceofType && !type2.isThisType)) {
          if (this.isClassType && type2.isInstanceofType)
            return false;
          if (isWrap) {
            return this.getWrapCheckerType(inherit).is(type2, context, options);
          }
          if (this.hasDynamicAttribute(inherit)) {
            return Namespace2.globals.get("object").is(type2, context, options);
          }
          return this.isClassType ? this.types[0].is(type2, context, options) : inherit.is(type2, context, options);
        }
        if (!this.isClassType) {
          if (type2.isClassType)
            return false;
          const baseType = type2.inherit.type();
          if (!inherit.is(baseType, context, options))
            return false;
          let accepts = this.types;
          let assigments = type2.isInstanceofType ? type2.generics : type2.types;
          const result = accepts.every((accept, index) => {
            const assign = assigments[index];
            if (assign) {
              return accept.type().is(assign.type(), context, options);
            }
            return false;
          });
          return result;
        } else {
          if (!type2.isClassType)
            return false;
          return this.types.every((base, index) => {
            const assign = type2.types[index];
            return assign ? base.type().is(assign.type(), context, options) : false;
          });
        }
      }
      toString(context = {}, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        const tooptions = options.inbuild ? Object.assign({}, options, { rawcode: false, onlyTypeName: true }) : options;
        const types = this.types.map((type2) => {
          if (type2.isGenericType && type2.hasConstraint && type2.inherit.type() === this) {
            return type2.target ? type2.target.value() : "any";
          }
          return type2.toString(context, tooptions);
        });
        if (this.target) {
          if (this.isClassType) {
            return `${this.target.value()}<${types.join(", ")}>`;
          }
          if (this.inherit.isModule) {
            return `${this.inherit.getName()}<${types.join(", ")}>`;
          } else {
            return `${this.inherit.toString(context, Object.assign({}, options, { onlyTypeName: true }))}<${types.join(", ")}>`;
          }
        }
        return this.extends[0].toString(context, options);
      }
    };
    module.exports = ClassGenericType;
  }
});

// lib/core/MergeType.js
var require_MergeType = __commonJS({
  "lib/core/MergeType.js"(exports, module) {
    var LiteralObjectType = require_LiteralObjectType();
    var TupleType = require_TupleType();
    var Type = require_Type();
    var UnionType = require_UnionType();
    var ClassGenericeType = require_ClassGenericType();
    var Namespace2 = require_Namespace();
    var Utils2 = require_Utils();
    var MergeType = class {
      constructor(originType) {
        this.originType = originType;
        this.dynamicProperties = null;
        this.types = /* @__PURE__ */ new Map();
        this.question = {};
        this.target = null;
        this.dataGroup = null;
        this.hasTuplePrefix = false;
        this.isTupleType = false;
        this.isTupleUnion = true;
        this.keepOriginRefs = false;
        this.classGenericOriginType = null;
        this.isClassGenericType = false;
      }
      createGroup(stack2) {
        const type2 = stack2.type();
        const dataGroup = this.dataGroup || (this.dataGroup = /* @__PURE__ */ new Map());
        const originType = Utils2.getOriginType(type2);
        let dataset = dataGroup.get(originType);
        if (!dataset) {
          dataGroup.set(originType, dataset = new MergeType(originType));
          dataset.keepOriginRefs = this.keepOriginRefs;
          dataset.target = type2.target;
        }
        if (type2.isLiteralObjectType) {
          dataset.dynamicProperties = type2.dynamicProperties;
          let has = dataset.types.size > 0;
          if (has) {
            dataset.types.forEach((value, prop) => {
              if (!type2.properties.has(prop)) {
                dataset.question[prop] = true;
              }
            });
          }
          type2.properties.forEach((value, prop) => {
            let items = dataset.types.get(prop);
            if (!items) {
              dataset.types.set(prop, items = new MergeType());
              items.keepOriginRefs = this.keepOriginRefs;
              if (has) {
                dataset.question[prop] = true;
              }
            }
            if (type2.questionProperties && type2.questionProperties[prop]) {
              dataset.question[prop] = true;
            }
            items.add(value);
          });
        } else if (type2.isLiteralArrayType || type2.isTupleType) {
          dataset.hasTuplePrefix = !!type2.prefix;
          dataset.isTupleType = !!type2.isTupleType;
          dataset.isTupleUnion = this.forceNotTupleUnion ? false : MergeType.isTupleUnion(type2);
          type2.elements.forEach((item2, index) => {
            dataset.add(item2);
          });
        }
        return dataset;
      }
      add(stack2, toLiteralValue = false) {
        const type2 = stack2 && stack2.type();
        if (type2) {
          if (type2.isLiteralValueType) {
            this.types.set(type2.value, type2);
          } else if (toLiteralValue && type2.isLiteralType) {
            this.types.set(type2.toString(null, { toLiteralValue: true }), type2);
          } else if (type2.isLiteralArrayType || type2.isTupleType) {
            const originType = Utils2.getOriginType(type2);
            this.types.set(originType, this.createGroup(stack2));
          } else if (type2.isLiteralObjectType) {
            if (!this.keepOriginRefs) {
              const originType = Utils2.getOriginType(type2);
              this.types.set(originType, this.createGroup(stack2));
            } else {
              this.types.set(type2.toString({}, { toUniKeyValue: true }), stack2);
            }
          } else if (type2.isUnionType) {
            type2.elements.forEach((item2) => {
              const type3 = item2.type();
              const key = type3.toString();
              if (!this.types.has(key)) {
                if (!this.keepOriginRefs) {
                  this.types.set(key, type3);
                } else {
                  this.types.set(key, item2);
                }
              }
            });
          } else if (type2.isClassGenericType) {
            const key = type2.inherit.type();
            let group = this.types.get(key);
            if (!group) {
              group = new MergeType();
              group.classGenericOriginType = key;
              group.isClassGenericType = type2.isClassType;
              group.target = type2.target;
              this.types.set(key, group);
            }
            type2.types.forEach((item2, index) => {
              index = String(index);
              let merge = group.types.get(index);
              if (!merge) {
                merge = new MergeType();
                group.types.set(index, merge);
              }
              merge.add(item2);
            });
          } else if (type2.isModule && type2.isType) {
            this.types.set(type2, type2);
          } else if (type2.isInstanceofType) {
            this.types.set(type2.inherit, type2);
          } else if (type2.isGenericType) {
            this.types.set(type2, stack2);
          } else {
            let key = type2.toString();
            if (!this.types.has(key)) {
              if (!this.keepOriginRefs) {
                this.types.set(key, type2);
              } else {
                this.types.set(key, stack2);
              }
            }
          }
        }
      }
      type() {
        const origArrayType = Namespace2.globals.get("Array");
        const origObjectType = Namespace2.globals.get("Object");
        if (this.originType === origArrayType) {
          const elements = [];
          this.types.forEach((type2) => {
            if (type2 instanceof MergeType) {
              elements.push(type2.type());
            } else {
              elements.push(type2);
            }
          });
          if (!elements.length) {
            elements.push(Namespace2.globals.get("any"));
          }
          return new TupleType(origArrayType, elements, this.target, false, this.isTupleUnion, !!this.hasTuplePrefix);
        } else if (this.originType === origObjectType) {
          const properties = /* @__PURE__ */ new Map();
          this.types.forEach((property, propName) => {
            if (property instanceof MergeType) {
              properties.set(propName, property.type());
            } else {
              properties.set(propName, property);
            }
          });
          return new LiteralObjectType(origObjectType, this.target, properties, this.dynamicProperties, this.question);
        }
        const items = Array.from(this.types.values()).map((item2) => item2.type());
        if (this.classGenericOriginType) {
          return new ClassGenericeType(items, this.classGenericOriginType, this.isClassGenericType, this.target);
        }
        if (!(items.length > 0) || items.some((type2) => {
          type2 = type2.type();
          return type2.isAnyType && !type2.isUnknownType;
        })) {
          return Namespace2.globals.get("any");
        }
        if (items.length > 1) {
          let i = 0;
          let first = null;
          while (i < items.length && items.length > 1) {
            const item2 = items[i];
            if (item2.isLiteralObjectType) {
              if (first === null) {
                first = !this.keepOriginRefs ? item2.clone(null, true) : item2;
                i++;
              } else {
                const dynamics = item2.dynamicProperties;
                if (dynamics) {
                  if (!first.dynamicProperties) {
                    first.dynamicProperties = dynamics;
                  } else {
                    dynamics.forEach((item3, key) => {
                      if (!first.dynamicProperties.has(key)) {
                        first.dynamicProperties.set(key, item3);
                      }
                    });
                  }
                }
                if (!(item2.properties.size > 0)) {
                  items.splice(i, 1);
                } else {
                  i++;
                }
              }
            } else {
              i++;
            }
          }
        }
        if (items.length > 1) {
          let typeNumber = null;
          let typeBoolean = null;
          let isNumber = items.every((item2) => {
            const name = item2.toString();
            if (name === "number")
              typeNumber = item2;
            if (name === "boolean")
              typeBoolean = item2;
            if (name === "int" || name === "uint" || name === "float" || name === "double" || name === "number") {
              return true;
            }
            return false;
          });
          if (isNumber && typeNumber) {
            return typeNumber;
          }
          if (typeBoolean) {
            if (items.every((item2) => {
              const name = item2.toString();
              return name === "false" || name === "true";
            })) {
              return typeBoolean;
            }
          }
          return new UnionType(items, this.target);
        }
        return items[0];
      }
      static forOfItem(type2, keepOriginRefs = true) {
        if (!type2)
          return type2;
        if (type2.isLiteralArrayType || type2.isTupleType || type2.isLiteralObjectType || type2.isClassGenericType) {
          var mergeType = new MergeType();
          mergeType.keepOriginRefs = keepOriginRefs;
          if (type2.isClassGenericType) {
            type2.types.forEach((item2) => {
              mergeType.types.set(item2.type(), item2.type());
            });
          } else if (type2.isLiteralArrayType || type2.isTupleType) {
            type2.elements.forEach((item2) => {
              mergeType.add(item2.type());
            });
          } else {
            type2.properties.forEach((item2) => {
              mergeType.add(item2.type());
            });
          }
          return mergeType.type();
        }
        return type2;
      }
      static isTupleUnion(type2) {
        if (type2 && type2.isTupleType && type2.target && type2.target.isTypeTupleDefinition && !type2.prefix && !type2.isTupleUnion) {
          return false;
        }
        return true;
      }
      static isNeedMergeType(type2) {
        if (type2 && type2.isTupleType && type2.target && type2.target.isTypeTupleDefinition && !type2.prefix && !type2.isTupleUnion) {
          return false;
        }
        return true;
      }
      static to(stack2, arrayToUnion = false, keepOriginRefs = false, toLiteralValue = false) {
        const type2 = stack2 && stack2.type();
        if (type2) {
          if (type2.isLiteralArrayType || type2.isTupleType) {
            const origArrayType = Namespace2.globals.get("Array");
            var mergeType = new MergeType(arrayToUnion ? null : origArrayType);
            mergeType.keepOriginRefs = keepOriginRefs;
            mergeType.hasTuplePrefix = !!type2.prefix;
            mergeType.isTupleType = !!type2.isTupleType;
            mergeType.isTupleUnion = MergeType.isTupleUnion(type2);
            mergeType.target = type2.target;
            type2.elements.forEach((item2) => {
              mergeType.add(item2, toLiteralValue);
            });
            return mergeType.type();
          } else if (type2.isLiteralObjectType) {
            if (keepOriginRefs) {
              return stack2;
            }
            const origObjectType = Namespace2.globals.get("Object");
            var mergeType = new MergeType(arrayToUnion ? null : origObjectType);
            mergeType.keepOriginRefs = keepOriginRefs;
            mergeType.dynamicProperties = type2.dynamicProperties;
            mergeType.target = type2.target;
            type2.properties.forEach((value, prop) => {
              mergeType.types.set(prop, MergeType.to(value, false, keepOriginRefs));
            });
            return mergeType.type();
          } else if (type2.isUnionType) {
            var mergeType = new MergeType();
            mergeType.keepOriginRefs = keepOriginRefs;
            mergeType.target = type2.target;
            type2.elements.forEach((item2) => {
              mergeType.add(item2);
            });
            return mergeType.type();
          } else {
            if (keepOriginRefs) {
              return stack2;
            } else {
              return type2;
            }
          }
        }
        return Namespace2.globals.get("any");
      }
      static arrayToTuple(items, isTupleUnion = true, prefix = true, target = null) {
        const mergeType = new MergeType(Namespace2.globals.get("Array"));
        mergeType.hasTuplePrefix = prefix;
        mergeType.isTupleType = true;
        mergeType.isTupleUnion = isTupleUnion;
        mergeType.target = target;
        items.forEach((item2) => {
          mergeType.add(item2);
        });
        return mergeType.type();
      }
      static arrayToUnion(items, target = null) {
        const mergeType = new MergeType();
        mergeType.target = target;
        items.forEach((item2) => {
          mergeType.add(item2);
        });
        return mergeType.type();
      }
    };
    module.exports = MergeType;
  }
});

// lib/types/UnknownType.js
var require_UnknownType = __commonJS({
  "lib/types/UnknownType.js"(exports, module) {
    var Type = require_Type();
    var UnknownType = class extends Type {
      constructor() {
        super("$UnknownType");
        this.isAnyType = true;
        this.isUnknownType = true;
      }
      check() {
        return true;
      }
      is() {
        return true;
      }
      toString() {
        return "unknown";
      }
    };
    module.exports = UnknownType;
  }
});

// lib/core/Context.js
var require_Context = __commonJS({
  "lib/core/Context.js"(exports, module) {
    var Namespace2 = require_Namespace();
    var UnknownType = require_UnknownType();
    var Utils2 = require_Utils();
    var MergeType = require_MergeType();
    var UKType = new UnknownType();
    var privateKey = Symbol("privateKey");
    var defaultInferType = null;
    var Context = class {
      static setDefaultInferType(type2) {
        if (type2 && type2.isType) {
          defaultInferType = type2;
        } else {
          defaultInferType = null;
        }
      }
      constructor(stack2) {
        this.stack = stack2;
        this.children = [];
        this.parent = null;
        this.dataset = /* @__PURE__ */ new Map();
        this._declareGenerics = null;
        this.makeDoneCache = /* @__PURE__ */ new WeakSet();
        this.applyResult = /* @__PURE__ */ new Map();
        this.isContext = true;
        this.onSetValue = null;
        this._applyContext = {};
      }
      createChild(stack2) {
        const old = stack2[privateKey];
        if (old)
          return old;
        const ctx2 = new Context(stack2);
        stack2[privateKey] = ctx2;
        ctx2.parent = this;
        this.children.push(ctx2);
        return ctx2;
      }
      hasDeclareGenerics() {
        if (this.stack.isFunctionExpression || this.stack.isClassDeclaration || this.stack.isDeclaratorDeclaration || this.stack.isInterfaceDeclaration) {
          return !!this.stack.genericity;
        } else if (this.stack.isCallExpression || this.stack.isNewExpression) {
          let desc2 = this.stack.description();
          if (desc2) {
            if (desc2.isMethodDefinition) {
              desc2 = desc2.expression;
            }
            if (desc2.isFunctionExpression) {
              return !!desc2.genericity;
            }
            desc2 = desc2.isDeclarator ? desc2.type() : desc2;
            if (Utils2.isTypeModule(desc2)) {
              const stackModule = desc2.moduleStack;
              return !!(stackModule && stackModule.genericity);
            }
          }
        }
        return !!this.stack.isTypeGenericDefinition;
      }
      declareGenerics(declare) {
      }
      setValue(type2, value) {
        if (type2 && value) {
          if (type2.isGenericType) {
            if (value.isGenericType) {
              const res = this.getValue(value, true);
              if (res)
                value = res;
            }
            this.dataset.set(type2.getUniKey(), value);
          } else {
            throw new Error(`Assigment type is not generic-type`);
          }
        }
      }
      getValue(type2, flag) {
        if (!type2 || !type2.isGenericType)
          return null;
        let result = this.dataset.get(type2.getUniKey()) || null;
        if (type2 === result) {
          result = null;
        }
        if (flag && !result) {
          if (this.parent) {
            return this.parent.getValue(type2, flag);
          }
        }
        return result;
      }
      batch(declares, assignments) {
        if (declares && declares.length > 0 && assignments && assignments.length > 0) {
          declares.forEach((declare, index) => {
            const value = assignments[index];
            if (value) {
              this.setValue(declare, value);
            }
          });
        }
      }
      merge(context) {
        if (context instanceof Context) {
          context.dataset.forEach((value, key) => {
            const old = this.dataset.get(key);
            if (old && old !== UKType)
              return;
            this.dataset.set(key, value);
          });
        } else {
          throw new Error(`Argument context is not Context instanced.`);
        }
      }
      assignment(type2, callback) {
        if (!type2 || type2.isGenericType)
          return;
        if (type2.isAliasType) {
          if (type2.target && type2.target.isDeclaratorTypeAlias) {
            this.merge(type2.target.getContext());
          }
          const inherit = type2.inherit;
          if (inherit && type2 !== inherit) {
            this.assignment(inherit.type(), callback);
          }
          return;
        }
        const setValue = (assignments) => {
          if (declareGenerics) {
            declareGenerics.forEach((decl, index) => {
              let value = assignments[index];
              if (value) {
                decl = decl.type();
                if (decl === value.type()) {
                  value = decl.assignType;
                  if (!value)
                    return;
                }
                if (callback) {
                  callback(decl, value);
                } else {
                  this.setValue(decl, value);
                }
              }
            });
          }
        };
        let originType = Utils2.getOriginType(type2);
        let [stack2, declareGenerics] = this.getDeclareGenerics(type2, originType);
        if (originType && originType.isModule) {
          if (stack2)
            this.merge(stack2.getContext());
          originType.getStacks().forEach((item2) => {
            if (stack2 !== item2) {
              this.merge(item2.getContext());
            }
          });
        }
        if (type2.isTupleType || type2.isLiteralArrayType) {
          if (type2.isTupleType) {
            type2.elements.forEach((item2) => {
              this.assignment(item2.type(), callback);
            });
          }
          setValue([MergeType.to(type2, true, true)]);
        } else if (type2.isInstanceofType && type2.generics && type2.generics.length > 0) {
          setValue(type2.generics);
        } else if (type2.isClassGenericType) {
          if (!type2.isClassType) {
            const wrap = type2.inherit.type();
            if (wrap.target && wrap.target.isDeclaratorTypeAlias && wrap.target.genericity) {
              declareGenerics = wrap.target.genericity.elements;
            }
          }
          type2.types.forEach((assign) => {
            this.assignment(assign, callback);
          });
          setValue(type2.types);
        }
      }
      getDeclareGenerics(type2, originType) {
        if (type2.isClassGenericType && type2.target && type2.target.isTypeGenericDefinition) {
          return type2.target.getDeclareGenerics();
        }
        originType = originType || Utils2.getOriginType(type2);
        if (originType && originType.isModule) {
          return originType.getModuleDeclareGenerics(true);
        }
        return [];
      }
      make(type2) {
        if (!type2 || type2.isGenericType)
          return false;
        if (this.makeDoneCache.has(type2))
          return true;
        this.makeDoneCache.add(type2);
        if (type2.isIntersectionType) {
          this.make(type2.left.type());
          this.make(type2.right.type());
        } else if (type2.isUnionType) {
          const dataset = /* @__PURE__ */ new Map();
          type2.elements.forEach((item2) => {
            this.assignment(item2.type(), (key, value) => {
              let target = dataset.get(key);
              if (!target) {
                dataset.set(key, target = [value]);
              } else {
                target.push(value);
              }
            });
          });
          dataset.forEach((items, key) => {
            if (items.length > 1) {
              const mergeType = new MergeType();
              items.forEach((type3) => mergeType.add(type3));
              this.setValue(key, mergeType.type());
            } else {
              this.setValue(key, items[0]);
            }
          });
        } else {
          this.assignment(type2);
        }
        return true;
      }
      __fetch(type2, flag = false, prev = null) {
        if (!type2)
          return null;
        if (!type2.isGenericType)
          return type2;
        let result = this.getValue(type2);
        let value = result ? result.type() : null;
        if (value && value.isGenericType && value !== type2) {
          return this.__fetch(value, flag, prev);
        } else if ((!result || value === UKType) && this.parent) {
          if (value)
            prev = value;
          return this.parent.__fetch(type2, flag, prev || value);
        }
        if (!value) {
          value = type2.assignType;
        }
        if (!value && prev) {
          value = prev;
        }
        return flag && !value ? type2 : value;
      }
      fetch(type2, flag = false) {
        let result = this.__fetch(type2, flag);
        if (!result || result === UKType) {
          if (defaultInferType) {
            result = defaultInferType;
          }
        }
        return result;
      }
      inferValue(type2, flag = false) {
        if (!type2 || !type2.isGenericType)
          return type2;
        let result = this.fetch(type2);
        if (!result || type2.assignType === result || result === UKType) {
          result = type2.hasConstraint ? type2.inherit : result;
        }
        if (result) {
          return result.type();
        } else if (flag) {
          return UKType;
        }
        return null;
      }
      get inference() {
        return (type2) => {
          if (!type2 || !type2.isGenericType)
            return type2;
          let result = this.fetch(type2);
          if (!result || type2.assignType === result || result === UKType) {
            this._applyContext.mismatch = true;
            result = type2.hasConstraint ? type2.inherit : result;
          }
          if (result) {
            return result.type();
          }
          return type2;
        };
      }
      apply(type2, context = {}) {
        if (type2 && type2.hasGenericType) {
          this._applyContext = context;
          if (type2.isGenericType) {
            return this.fetch(type2) || (this._applyContext.mismatch = true, type2.hasConstraint ? type2.inherit.type() : UKType);
          }
          if (this.applyResult.has(type2)) {
            return this.applyResult.get(type2);
          }
          let result = type2.clone(this.inference);
          if (type2.isComputeType) {
            result = result.getComputeType();
          }
          this.applyResult.set(type2, result);
          return result;
        }
        return type2;
      }
      isObjectType(type2) {
        if (!type2)
          return false;
        return type2.isLiteralObjectType || type2.isInstanceofType || type2.isEnumType || type2.isEnum && type2.isModule;
      }
      extracts(declareParams, assignments, declareGenerics, parserFlag = false) {
        const cache = /* @__PURE__ */ new Map();
        const onSetValue = (decl, assignValue, context = []) => {
          const old = cache.get(decl);
          if (old) {
            if (old[0] === "via") {
              return false;
            }
            if (context.length === 2 && context[0] === "wrap") {
              if (old.length > 2 && old[0] === "wrap") {
                return false;
              }
            }
          }
          cache.set(decl, context);
          return true;
        };
        let declareParamsLen = declareParams.length;
        for (let index = 0; index < declareParamsLen; index++) {
          let declared = declareParams[index];
          let argument = assignments[index];
          if (!argument)
            return;
          if (parserFlag) {
            argument.parser();
            argument.setRefBeUsed();
          }
          if (argument.isSpreadElement) {
            const type2 = argument.type();
            let elements = [];
            let defaultValue = null;
            if (type2.isTupleType && !type2.prefix || type2.isLiteralArrayType) {
              elements = type2.elements;
            } else if (type2.isTupleType && type2.prefix) {
              defaultValue = type2.elements[0];
            }
            for (let s = 0; s < elements.length && s + index < declareParamsLen; s++) {
              declared = declareParams[s + index];
              let value = elements[s] || defaultValue;
              if (declared && value) {
                this.extract(declared, value, declareGenerics, onSetValue);
              } else {
                break;
              }
            }
          }
          if (declared.isRestElement) {
            return this.extract(declared, MergeType.arrayToTuple(assignments.slice(index)), declareGenerics, onSetValue);
          }
          this.extract(declared, argument, declareGenerics, onSetValue);
        }
      }
      extract(declared, argument, declareGenerics, onSetValue) {
        if (!declared || !argument)
          return null;
        const isInScope = (declType2) => {
          if (!declareGenerics || !Array.isArray(declareGenerics))
            return true;
          if (declType2 && declType2.target && declType2.target.isGenericTypeDeclaration) {
            if (declType2.target.parentStack.parentStack.isDeclaratorTypeAlias) {
              return true;
            }
          }
          return declareGenerics.some((item2) => item2.type() === declType2);
        };
        if (declared.isObjectPattern) {
          const argumentType = argument.type();
          if (!this.isObjectType(argumentType)) {
            return;
          }
          return declared.properties.forEach((property) => {
            const declType2 = property.type();
            if (!declType2.hasGenericType)
              return;
            const matchResult = this.stack.getObjectDescriptor(argumentType, property.key.value(), false, true);
            if (declType2.isGenericType) {
              this.extractive(declType2, matchResult, isInScope, onSetValue);
            } else {
              this.extract(declType2, matchResult, declareGenerics, onSetValue);
            }
          });
        } else if (declared.isArrayPattern) {
          const argumentType = argument.type();
          if (!(argumentType.isLiteralArrayType || argumentType.isTupleType)) {
            return;
          }
          return declared.elements.forEach((item2, index) => {
            const declType2 = item2.type();
            if (!declType2.hasGenericType)
              return;
            const matchResult = this.stack.getObjectDescriptor(argumentType, index, false, true);
            if (declType2.isGenericType) {
              this.extractive(declType2, matchResult, isInScope, onSetValue);
            } else {
              this.extract(declType2, matchResult, declareGenerics, onSetValue);
            }
          });
        }
        let declType = declared.type();
        if (declType) {
          if (declType.hasGenericType || declType.isFunctionType || declType.isClassGenericType) {
            this.extractive(declType, argument, isInScope, onSetValue);
          }
          if (declType.isGenericType) {
            if (declType.hasConstraint) {
              let constraint = declType.inherit.type();
              if (constraint && !constraint.check(argument, this)) {
                const str1 = this.stack.isLiteralValueConstraint(constraint, this) ? this.stack.getTypeLiteralValueString(declType, this) : this.stack.getTypeDisplayName(declType, this);
                const str2 = this.stack.getTypeDisplayName(constraint, this);
                argument.error(1003, str1, str2);
              }
            }
          }
        }
      }
      extractive(declareType, assignValue, checkScope, onSetValue) {
        if (!declareType || !assignValue)
          return;
        let checkFlag = true;
        const context = [];
        const setValue = (decl, assignValue2, callback) => {
          if (!checkFlag || !checkScope || checkScope(decl, this, assignValue2)) {
            if (onSetValue && onSetValue(decl, assignValue2, context) === false) {
              return false;
            }
            if (callback) {
              return callback(decl, assignValue2);
            } else {
              if (assignValue2.isLiteralArrayType) {
                assignValue2 = this.arrayToUnionType(decl, assignValue2, true);
              }
              this.setValue(decl, assignValue2);
              return true;
            }
          }
          return false;
        };
        const forEach = (items, callback, flag) => {
          for (let i = 0; i < items.length; i++) {
            if (callback(flag ? items[i] : items[i].type(), i)) {
              return true;
            }
          }
          return false;
        };
        const every = (declareType2, assignType, callback) => {
          if (declareType2.isGenericType) {
            context.push("via");
            return setValue(declareType2, assignType, callback);
          } else if (declareType2.isTupleType && (assignType.isLiteralArrayType || assignType.isTupleType)) {
            const isRest = !!declareType2.rest;
            context.push("array");
            return forEach(declareType2.elements, (decl, index) => {
              if (decl.isGenericType) {
                let assignValue2 = assignType;
                if (!isRest) {
                  if (!declareType2.prefix) {
                    if (assignType.isTupleType) {
                      if (assignType.elements.length === 1) {
                        assignValue2 = assignType.elements[0];
                      } else {
                        assignValue2 = assignType.elements[index] || Namespace2.globals.get("any");
                      }
                    } else if (assignType.isLiteralArrayType) {
                      assignValue2 = assignType.elements[index] || Namespace2.globals.get("any");
                    }
                  } else {
                    if (assignType.isTupleType && assignType.prefix && assignType.elements.length === 1) {
                      assignValue2 = assignType.elements[0];
                    }
                  }
                } else if (assignValue2.isTupleType) {
                  assignValue2 = this.arrayToUnionType(decl, assignValue2);
                }
                return setValue(decl, assignValue2, (decl2, assignType2) => {
                  return this.setValue(decl2, this.arrayToUnionType(decl2, assignType2, isRest));
                });
              } else {
                let assign = null;
                if (decl.isTupleType) {
                  if (assignType.isLiteralArrayType) {
                    const origin = Namespace2.globals.get("Array");
                    const mergeType = new MergeType(origin);
                    mergeType.keepOriginRefs = true;
                    mergeType.hasTuplePrefix = !!decl.prefix;
                    mergeType.isTupleType = true;
                    mergeType.isTupleUnion = !!decl.isTupleUnion;
                    mergeType.forceNotTupleUnion = !decl.prefix;
                    mergeType.target = assignType.target;
                    assignType.elements.forEach((item2) => {
                      mergeType.add(item2);
                    });
                    assign = mergeType.type();
                  } else if (assignType.isTupleType) {
                    assign = assignType;
                  }
                  if (assign.elements[index]) {
                    if (decl.prefix && !assign.prefix) {
                      assign = MergeType.to(assign.elements[index], true);
                    } else if (assign.prefix === decl.prefix) {
                      assign = assign.elements[index];
                      if (assign.isTupleType && !decl.prefix && decl.elements.length < assign.elements.length) {
                        assign = Namespace2.globals.get("any");
                      }
                    }
                  } else {
                    assign = Namespace2.globals.get("any");
                  }
                } else {
                  assign = assignType.elements[index];
                }
                if (assign) {
                  return every(decl, assign, (decl2, assignType2) => {
                    return this.setValue(decl2, assignType2);
                  });
                }
              }
            });
          } else if (declareType2.isUnionType) {
            context.push("union");
            return forEach(declareType2.elements, (decl) => {
              return every(decl, assignType, callback);
            });
          } else if (declareType2.isLiteralObjectType) {
            context.push("object");
            return forEach(Array.from(declareType2.properties.values()), (property) => {
              let decl = property.type();
              if (decl.hasGenericType) {
                const value = this.stack.getObjectDescriptor(assignType, property.key.value());
                if (value) {
                  return every(decl, value.type(), callback);
                }
              }
            }, true);
          } else if (declareType2.isClassGenericType) {
            context.push("wrap");
            const inherit = declareType2.inherit.type();
            if (assignType.isClassGenericType) {
              if (inherit.is(assignType.inherit.type())) {
                const [, declareGenerics = []] = this.getDeclareGenerics(declareType2);
                forEach(declareType2.types, (value, index) => {
                  let _decl = declareGenerics[index];
                  if (_decl) {
                    _decl = _decl.type();
                    this.setValue(_decl, value);
                  }
                  if (assignType.types[index]) {
                    let _old = checkFlag;
                    checkFlag = false;
                    every(value, assignType.types[index].type());
                    checkFlag = _old;
                  }
                });
                return true;
              }
            } else if (!declareType2.isClassType && inherit.isAliasType) {
              const [, declareGenerics = []] = this.getDeclareGenerics(declareType2);
              forEach(declareType2.types, (value, index) => {
                let _decl = declareGenerics[index];
                if (_decl) {
                  _decl = _decl.type();
                  this.setValue(_decl, value);
                }
              });
              return every(inherit.inherit.type(), assignType, (decl, assignValue2) => {
                let setFlag = false;
                assignValue2 = this.arrayToUnionType(decl, assignValue2);
                forEach(declareType2.types, (value, index) => {
                  let _decl = declareGenerics[index];
                  if (_decl) {
                    _decl = _decl.type();
                    this.setValue(_decl, value);
                    if (!setFlag) {
                      setFlag = every(value, assignValue2, callback);
                    }
                  }
                });
                return true;
              });
            } else {
              const [, declareGenerics = []] = this.getDeclareGenerics(declareType2);
              let setFlag = false;
              forEach(declareType2.types, (value, index) => {
                let _decl = declareGenerics[index];
                if (_decl) {
                  _decl = _decl.type();
                  this.setValue(_decl, value);
                }
                if (!setFlag) {
                  setFlag = every(value, assignType, callback);
                }
              });
              return true;
            }
          } else if (declareType2.isIntersectionType) {
            context.push("intersect");
            return forEach([declareType2.left.type(), declareType2.right.type()], (decl) => {
              return every(decl, assignType, callback);
            });
          } else if (declareType2.isAliasType) {
            return every(declareType2.inherit.type(), assignType, callback);
          } else if (declareType2.isFunctionType && assignType.isFunctionType) {
            context.push("function");
            const voidType = Namespace2.globals.get("void");
            let assignValue2 = assignType.getInferReturnType();
            let decl = declareType2.returnType;
            if (decl && assignValue2) {
              decl = decl.type();
              if (voidType !== decl) {
                return every(decl, assignValue2, callback);
              }
            }
          }
          return false;
        };
        every(declareType, assignValue.type());
      }
      arrayToUnionType(declareType, assignType, isRest = false) {
        if (!declareType || !assignType || !declareType.isGenericType)
          return assignType;
        const inherit = declareType.inherit;
        const isKeyof = inherit && inherit.isKeyofType;
        if (assignType.isLiteralArrayType || assignType.isTupleType) {
          return MergeType.to(assignType, !isRest, true, isKeyof);
        }
        return assignType;
      }
    };
    module.exports = Context;
  }
});

// lib/core/Specifier.js
var require_Specifier = __commonJS({
  "lib/core/Specifier.js"(exports, module) {
    var Specifier = class {
      constructor(stack2, context) {
        this.stack = stack2;
        this.context = context;
        this.type = null;
      }
      getContext() {
        let ctx2 = this.context;
        if (ctx2)
          return ctx2;
        return this.context = stack.getContext();
      }
      setType(value) {
        if (value) {
          this.type = value;
        }
      }
      getType() {
        let type2 = this.type;
        if (type2)
          return type2;
        type2 = this.stack.type();
        return this.type = type2;
      }
    };
    module.exports = Specifier;
  }
});

// lib/core/Typer.js
var require_Typer = __commonJS({
  "lib/core/Typer.js"(exports, module) {
    var Namespace2 = require_Namespace();
    var TyperFlag = Symbol("TyperInstanceof");
    var Typer = class {
      static is(type2) {
        return type2 ? type2[TyperFlag] : false;
      }
      [TyperFlag] = true;
      constructor(type2, stack2, context = null) {
        this.type = type2;
        this.stack = stack2;
        this.context = context;
        this.isType = true;
      }
      getContext() {
        return this.context || this.stack.getContext();
      }
      get origin() {
        return this.type;
      }
      type() {
        let type2 = this.origin;
        let ctx2 = this.getContext();
        if (type2.isComputeType) {
          const object = ctx2.fetch(this.object.type(), true);
          const property = ctx2.fetch(this.property.type(), true);
          if (object && property && !(object.isGenericType || property.isGenericType)) {
            type2 = type2.getComputeValue(object, property);
            if (type2)
              return type2;
          }
          return Namespace2.globals.get("any");
        }
        return ctx2.fetch(type2, true);
      }
      check(type2, context, options = {}, whenErrorCallback = null) {
        if (!type2)
          return false;
        return this.type().check(type2.type(), context, options);
      }
      is(type2, context, options = {}) {
        if (!type2)
          return false;
        return this.type().is(type2.type(), context, options);
      }
    };
    module.exports = Typer;
  }
});

// lib/core/Stack.js
var require_Stack = __commonJS({
  "lib/core/Stack.js"(exports, module) {
    var Utils2 = require_Utils();
    var EventDispatcher = require_EventDispatcher();
    var MergeType = require_MergeType();
    var Module = require_Module();
    var Type = require_Type();
    var Context = require_Context();
    var Namespace2 = require_Namespace();
    var Specifier = require_Specifier();
    var Typer = require_Typer();
    var keySymbol = Symbol("key");
    var emptyOnlyreadArray = [];
    var NOT_ASSING_GENERICS = 1;
    var MISSING_ASSING_GENERICS = 1 << 1;
    var FAILED_ASSING_GENERICS = 1 << 2;
    var DESCRIPTOR_TYPE_UNMATCH = 1 << 3;
    var Stack = class extends EventDispatcher {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super();
        this.compilation = compilation;
        this.mtime = compilation.mtime;
        this.compiler = compilation.compiler;
        this.isStack = true;
        this.node = node;
        this.scope = scope;
        this.parentNode = parentNode;
        this.parentStack = parentStack;
        this.childrenStack = [];
        this.namespace = compilation.namespace;
        this.module = null;
        this.isFragment = false;
        this.file = compilation.file;
        this.childIndexAt = 0;
        this[keySymbol] = {
          context: null,
          comments: null,
          attributes: /* @__PURE__ */ Object.create(null),
          specifier: null
        };
        this._useRefItems = null;
        if (parentStack) {
          this.childIndexAt = parentStack.childrenStack.length;
          parentStack.childrenStack.push(this);
          this.isFragment = parentStack.isFragment;
          this.namespace = parentStack.namespace;
          this.module = parentStack.module;
        }
        if (node) {
          if (compilation.compiler.options.enableStackMap) {
            if (!(parentStack && parentStack.isFragment)) {
              this.compilation.addStack(this);
            }
          }
        }
      }
      get comments() {
        const comments = this[keySymbol].comments;
        if (comments)
          return comments;
        const type2 = this.node.type;
        switch (type2) {
          case "DeclaratorTypeAlias":
          case "DeclaratorFunction":
          case "DeclaratorVariable":
          case "PackageDeclaration":
          case "ClassDeclaration":
          case "DeclaratorDeclaration":
          case "InterfaceDeclaration":
          case "EnumDeclaration":
          case "StructTableDeclaration":
          case "MethodDefinition":
          case "PropertyDefinition":
            return this[keySymbol].comments = this.findComments() || [];
        }
      }
      findComments(latter = false) {
        let stack2 = this;
        let prev = stack2;
        let parent = stack2.parentStack;
        let index = -1;
        if (parent) {
          const testSkipAnnotation = (index2) => {
            if (latter) {
              if (index2 < parent.childrenStack.length) {
                const node = parent.childrenStack[index2 + 1];
                if (node.isAnnotationDeclaration) {
                  return testSkipAnnotation(index2 + 1);
                }
              }
            } else {
              if (index2 > 0) {
                const node = parent.childrenStack[index2 - 1];
                if (node.isAnnotationDeclaration) {
                  return testSkipAnnotation(index2 - 1);
                }
              }
            }
            return index2;
          };
          let restrict = latter ? parent.node.end : parent.node.start;
          index = parent.childrenStack.indexOf(prev);
          if (index >= 0) {
            index = testSkipAnnotation(index);
            if (latter) {
              if (index < parent.childrenStack.length) {
                restrict = parent.childrenStack[index + 1].node.start;
              }
            } else if (index > 0) {
              restrict = parent.childrenStack[index - 1].node.end;
            }
            return this.compilation.emitComments.filter((comment) => {
              if (latter) {
                return stack2.node.end < comment.start && comment.end < restrict;
              } else {
                return restrict < comment.start && comment.end < stack2.node.start;
              }
            });
          }
        }
        return null;
      }
      addUseRef(stack2) {
        if (stack2 && stack2.isStack) {
          if (stack2.compilation) {
            stack2.compilation.addReferenceStack(this);
          }
          this.useRefItems.add(stack2);
        }
      }
      get useRefItems() {
        if (!this._useRefItems) {
          return this._useRefItems = /* @__PURE__ */ new Set();
        }
        return this._useRefItems;
      }
      isSameSource(stack2) {
        return stack2 && stack2.compilation === this.compilation && stack2.mtime === this.mtime;
      }
      hasAttribute(name) {
        const data = this[keySymbol].attributes;
        return Object.prototype.hasOwnProperty.call(data, name);
      }
      getAttribute(name, initCallback = null) {
        const data = this[keySymbol].attributes;
        if (initCallback) {
          if (!Object.prototype.hasOwnProperty.call(data, name)) {
            const value = initCallback();
            if (value !== void 0) {
              data[name] = value;
            }
          }
        }
        return data[name];
      }
      setAttribute(name, value) {
        const data = this[keySymbol].attributes;
        return data[name] = value;
      }
      createTokenStack(compilation, node, scope, parentNode, parentStack) {
        return Stack.create(compilation, node, scope, parentNode, parentStack);
      }
      async createCompleted() {
      }
      getGlobalTypeById(id) {
        const value = this.compilation.getGlobalTypeById(id);
        if (!value) {
          this.error(1083, id);
        }
        return value;
      }
      getTypeById(id, context) {
        context = context || this.module || this.namespace;
        return this.compilation.getModuleById(id, context);
      }
      getModuleById(id, context) {
        context = context || this.module || this.namespace;
        return this.compilation.getModuleById(id, context);
      }
      hasModuleById(id, context) {
        context = context || this.module || this.namespace;
        return this.compilation.hasModuleById(id, context);
      }
      checkNeedToLoadTypeById(id, context) {
        let type2 = this.scope.define(id);
        if (type2) {
          if ((this.isTypeDefinition || this.isTypeGenericDefinition) && !(type2 instanceof Type)) {
            if (type2.isGenericTypeDeclaration || type2.isGenericTypeAssignmentDeclaration || type2.isTypeStatement || type2.isEnumDeclaration && type2.isExpressionDeclare) {
              return false;
            }
          } else {
            return false;
          }
        }
        context = context || this.module || this.namespace;
        return this.compilation.checkNeedToLoadTypeById(id, context);
      }
      async loadTypeAsync(id, context) {
        context = context || this.module || this.namespace;
        return await this.compilation.loadTypeAsync(id, context, !!this.isImportDeclaration);
      }
      getLocation() {
        return this.node.loc || null;
      }
      getContext() {
        let ctx2 = this[keySymbol].context;
        if (ctx2)
          return ctx2;
        let parent = null;
        if (this.isTypeDefinitionStack(this)) {
          if (this.parentStack.isFunctionExpression && this.parentStack.parentStack.isMethodDefinition) {
            parent = this.parentStack;
          } else if (this.parentStack.isDeclaratorVariable && this.parentStack.parentStack.isPropertyDefinition) {
            parent = this.parentStack.parentStack;
          } else if (this.isTypeDefinitionStack(this.parentStack)) {
            ctx2 = this.parentStack.getContext();
          }
        } else if (this.isFunctionExpression || this.isArrayExpression || this.isObjectExpression) {
          let stack2 = this.parentStack;
          if (stack2.isMethodDefinition) {
            const module2 = this.parentStack.module;
            if (module2) {
              parent = module2.moduleStack;
            }
          } else {
            while (stack2 && (stack2.isProperty || stack2.isObjectExpression || stack2.isArrayExpression)) {
              stack2 = stack2.parentStack;
            }
            if (stack2.isCallExpression || stack2.isNewExpression || stack2.isVariableDeclarator || stack2.isAssignmentExpression) {
              parent = stack2;
            }
          }
        } else if (this.isPropertyDefinition) {
          const module2 = this.module;
          if (module2) {
            parent = module2.moduleStack;
          }
        } else if (this.isCallExpression || this.isNewExpression) {
          if (this.callee.isParenthesizedExpression) {
            parent = this.callee.expression;
          } else {
            parent = this.callee;
          }
        } else if (this.isMemberExpression) {
          parent = this.object;
        } else if (this.parentStack && this.parentStack.isMemberExpression && this === this.parentStack.property) {
          ctx2 = this.parentStack.getContext();
        } else if (this.parentStack && (this.parentStack.isArrayExpression || this.parentStack.isObjectExpression)) {
          ctx2 = this.parentStack.getContext();
        }
        if (!ctx2) {
          if (parent && parent !== this) {
            ctx2 = parent.getContext();
          }
          if (ctx2) {
            ctx2 = ctx2.createChild(this);
          } else {
            ctx2 = new Context(this);
          }
        }
        this[keySymbol].context = ctx2;
        return ctx2;
      }
      newContext() {
        return new Context(this);
      }
      createSpecifier(stack2, context) {
        if (stack2 && !(stack2 instanceof Stack)) {
          throw new Error("Stack.createSpecifier stack param invalid.");
        } else {
          stack2 = this;
        }
        let spe = stack2[keySymbol].specifier;
        if (spe) {
          return spe;
        }
        const specifier = new Specifier(stack2, context);
        stack2[keySymbol].specifier = specifier;
        return specifier;
      }
      getParentStack(callback, flag = false) {
        let parent = flag ? this : this.parentStack;
        while (parent && !callback(parent) && parent.parentStack) {
          parent = parent.parentStack;
        }
        return parent || this;
      }
      definition(context) {
        if (this.parentStack) {
          return this.parentStack.definition(context);
        }
        return null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [];
      }
      description() {
        return this;
      }
      type() {
        return null;
      }
      getLocalReferenceType(id) {
        return this.getAttribute("getLocalReferenceType:" + id, () => {
          let type2 = this.scope.define(id);
          if (type2 && !(type2 instanceof Type)) {
            if (type2.isGenericTypeDeclaration || type2.isGenericTypeAssignmentDeclaration || type2.isTypeStatement || type2.isEnumDeclaration && type2.isExpressionDeclare) {
              return type2;
            }
            type2 = null;
          }
          if (!type2) {
            type2 = this.getModuleById(id);
          }
          return type2 || void 0;
        });
      }
      hasLocalReferenceType(id) {
        return this.getAttribute("hasLocalReferenceType:" + id, () => {
          let type2 = this.scope.define(id);
          if (type2 && !(type2 instanceof Type)) {
            if (type2.isGenericTypeDeclaration || type2.isGenericTypeAssignmentDeclaration || type2.isTypeStatement || type2.isEnumDeclaration && type2.isExpressionDeclare) {
              return true;
            }
            type2 = null;
          }
          if (!type2) {
            type2 = this.hasModuleById(id);
          }
          return !!type2;
        });
      }
      getTypeDisplayName(type2, ctx2, options = {}) {
        if (!type2)
          return "unknown";
        ctx2 = ctx2 || this.getContext();
        if (Array.isArray(type2)) {
          if (type2.length > 1) {
            return type2.map((item2) => item2.type().toString(ctx2, options)).join(" | ");
          } else {
            type2 = type2[0].type();
          }
        }
        return MergeType.to(Utils2.inferTypeValue(type2, ctx2.inference)).toString(ctx2, options);
      }
      getTypeLiteralValueString(type2, ctx2) {
        if (!type2)
          return "unknown";
        ctx2 = ctx2 || this.getContext();
        type2 = ctx2.fetch(type2, true);
        if (type2.isLiteralType) {
          return type2.toString(ctx2, { toLiteralValue: true });
        }
        return type2.toString(ctx2);
      }
      isLiteralValueConstraint(type2, ctx2) {
        ctx2 = ctx2 || this.getContext();
        const check = (type3, flag) => {
          if (type3) {
            type3 = ctx2.fetch(type3, true);
            if (type3.isLiteralType && (flag || type3.isLiteralValueType)) {
              return true;
            } else if (type3.isKeyofType) {
              return true;
            } else if (type3.isUnionType) {
              return type3.elements.every((item2) => {
                return check(item2.type(), true);
              });
            }
          }
          return false;
        };
        return check(type2);
      }
      checkGenericConstraint(genericType, argumentStack, context) {
        var checkResult = true;
        if (genericType.isGenericType && genericType.hasConstraint) {
          const acceptType = genericType.inherit;
          const assignType = context.fetch(genericType);
          if (assignType && !assignType.isGenericType && !acceptType.check(assignType, context)) {
            checkResult = false;
            argumentStack.error(
              1003,
              this.getTypeDisplayName(assignType, context, { toLiteralValue: acceptType.isKeyofType }),
              this.getTypeDisplayName(acceptType, context)
            );
          }
        }
        return checkResult;
      }
      isGenericsRelationValue(acceptType, declareGenerics, assigments) {
        if (!acceptType)
          return false;
        acceptType = acceptType.type();
        if (!acceptType.hasGenericType) {
          return false;
        }
        if (acceptType.isGenericType) {
          if (declareGenerics.length > 0) {
            const index = declareGenerics.findIndex((item2) => item2.type() === acceptType);
            if (index >= 0 && !(assigments && assigments[index])) {
              return true;
            }
          }
          return false;
        } else if (acceptType.isUnionType) {
          return acceptType.elements.some((item2) => this.isGenericsRelationValue(item2, declareGenerics, assigments));
        } else if (acceptType.isIntersectionType) {
          return this.isGenericsRelationValue(acceptType.left, declareGenerics, assigments) || this.isGenericsRelationValue(acceptType.right, declareGenerics, assigments);
        }
        return false;
      }
      checkExpressionType(acceptType, expression, curStack = null, ctx2 = null) {
        let checkResult = true;
        if (acceptType && expression) {
          acceptType = acceptType.type();
          if (!ctx2) {
            ctx2 = expression.isStack && expression.node && expression.compilation ? expression.getContext() : this.getContext();
          }
          if (expression.isArrayExpression || expression.isObjectExpression || expression.isSpreadElement && expression.argument.isArrayExpression) {
            ctx2.errorHandler = (result, acceptType2, assignmentStack, assignmentType) => {
              if (!result && assignmentStack && assignmentStack.isStack) {
                if (assignmentStack.isProperty && assignmentStack.init) {
                  assignmentStack = assignmentStack.init;
                }
                assignmentType = assignmentType || assignmentStack.type();
                assignmentStack.error(1009, this.getTypeDisplayName(assignmentType, ctx2), this.getTypeDisplayName(acceptType2, ctx2));
                checkResult = false;
                return true;
              }
              return result;
            };
          }
          if (acceptType && !acceptType.check(expression, ctx2)) {
            let target = curStack || expression;
            if (!(target && target.isStack))
              target = this;
            target.error(1009, this.getTypeDisplayName(expression.type(), ctx2), this.getTypeDisplayName(acceptType, ctx2));
            checkResult = false;
          }
          ctx2.errorHandler = null;
        }
        return checkResult;
      }
      checkArgumentItemType(argumentStack, declareParam, acceptType, context, whenErrorStack) {
        var checkResult = true;
        if (declareParam.isObjectPattern) {
          const argumentType = argumentStack.type();
          let isModule = argumentType.isEnum && argumentType.isModule || argumentType.isInterface && argumentType.isModule;
          if (argumentType.isLiteralObjectType || argumentType.isInstanceofType || argumentType.isEnumType || isModule) {
            declareParam.properties.forEach((property) => {
              let propertyStack = isModule ? argumentType.getMember(property.key.value(), "get") : argumentType.attribute(property.key.value(), "get");
              let throwErrorStack = argumentStack.isObjectExpression && propertyStack && propertyStack.isStack && propertyStack.init ? propertyStack.init : argumentStack;
              if (propertyStack && propertyStack.isStack) {
                checkResult = this.checkArgumentItemType(propertyStack, property, property.type(), context, throwErrorStack);
              } else if (argumentStack.isObjectExpression) {
                checkResult = false;
                (whenErrorStack || argumentStack).error(1152, property.key.value());
              }
            });
          } else if (!argumentType.isAnyType && acceptType) {
            if (!acceptType.is(argumentType, context)) {
              checkResult = false;
              (whenErrorStack || argumentStack).error(1002, this.getTypeDisplayName(argumentType, context), this.getTypeDisplayName(acceptType, context));
            }
          }
        } else if (declareParam.isArrayPattern) {
          const argumentType = argumentStack.type();
          if (argumentType.isLiteralArrayType) {
            declareParam.elements.forEach((property, index) => {
              let propertyStack = argumentType.attribute(index);
              let throwErrorStack = argumentStack.isArrayExpression && propertyStack && propertyStack.isStack ? propertyStack : argumentStack;
              if (propertyStack) {
                return this.checkArgumentItemType(propertyStack, property, property.type(), context, throwErrorStack);
              } else if (argumentStack.isArrayExpression) {
                checkResult = false;
                (whenErrorStack || argumentStack).error(1152, `index-property-${index}`);
              }
            });
          } else {
            const iteratorType = this.getGlobalTypeById("Iterator");
            if (!argumentType.is(iteratorType, context)) {
              checkResult = false;
              (whenErrorStack || argumentStack).error(1002, this.getTypeDisplayName(argumentType, context), this.getTypeDisplayName(iteratorType, context), context);
            }
          }
        } else if (acceptType) {
          const orgType = acceptType;
          const checkConstraint = (acceptType2, argumentStack2, context2) => {
            if (!this.checkGenericConstraint(acceptType2, argumentStack2, context2)) {
              checkResult = false;
            }
          };
          if (acceptType.isGenericType) {
            checkConstraint(acceptType, argumentStack, context);
          } else if (acceptType.hasGenericType) {
            if (acceptType.isTupleType || acceptType.isUnionType || acceptType.isLiteralArrayType) {
              acceptType.elements.forEach((elem) => checkConstraint(elem.type(), argumentStack, context));
            } else if (acceptType.isLiteralObjectType) {
              acceptType.properties.forEach((elem) => checkConstraint(elem.type(), argumentStack, context));
              acceptType.dynamicProperties && acceptType.dynamicProperties.forEach((elem) => checkConstraint(elem.type(), argumentStack, context));
            }
          }
          if (acceptType) {
            if (argumentStack.isArrayExpression || argumentStack.isObjectExpression || argumentStack.isSpreadElement && argumentStack.argument.isArrayExpression) {
              context.errorHandler = (result, acceptType2, checkStack) => {
                if (!result && checkStack && checkStack.isStack) {
                  if (checkStack.isProperty && checkStack.init) {
                    checkStack = checkStack.init;
                  } else if (checkStack.parentStack.isProperty) {
                    checkStack = checkStack.parentStack;
                  }
                  if (acceptType2) {
                    checkStack.error(1002, this.getTypeDisplayName(checkStack.type(), context), this.getTypeDisplayName(acceptType2, context));
                  } else {
                    checkStack.error(1009, this.getTypeDisplayName(checkStack.type(), context), "unknown");
                  }
                  return true;
                }
                return result;
              };
            }
            if (!acceptType.type().check(argumentStack, context)) {
              checkResult = false;
              if (orgType.hasConstraint) {
                (whenErrorStack || argumentStack).error(1003, this.getTypeDisplayName(argumentStack.type(), context), this.getTypeDisplayName(orgType.inherit, context));
              } else {
                (whenErrorStack || argumentStack).error(1002, this.getTypeDisplayName(argumentStack.type(), context), this.getTypeDisplayName(acceptType, context));
              }
            }
            context.errorHandler = null;
            return checkResult;
          }
        }
        return checkResult;
      }
      checkMatchType(argumentStack, declareParam, acceptType, context) {
        const argumentType = argumentStack.type();
        if (!argumentType) {
          return false;
        }
        if (argumentType.isGenericType) {
          return true;
        }
        if (declareParam && declareParam.isObjectPattern) {
          if (argumentType.isLiteralObjectType || argumentType.isInstanceofType || argumentType.isEnumType || argumentType.isEnum && argumentType.isModule) {
            return true;
          } else {
            const objectType = this.getGlobalTypeById("object");
            return objectType.is(argumentType, context);
          }
        } else if (declareParam && declareParam.isArrayPattern) {
          const arrayType = this.getGlobalTypeById("array");
          return arrayType.is(argumentType);
        } else if (acceptType) {
          if (acceptType.isGenericType && context && context.isContext && context instanceof Context) {
            acceptType = context.fetch(acceptType, true);
          }
          if (acceptType.isGenericType) {
            return true;
          } else if (acceptType.isFunctionType) {
            return argumentType.isFunctionType;
          } else if (acceptType.isLiteralObjectType) {
            return acceptType.constraint(argumentType, context);
          } else if (acceptType.isLiteralArrayType) {
            const arrayType = this.getGlobalTypeById("array");
            return arrayType.is(argumentType);
          }
          if (!acceptType.is(argumentType, context)) {
            return false;
          }
        }
        return true;
      }
      getMatchDescriptor(property, classModule, isStatic = false, onlyAccessProperty = false) {
        if (!property || !classModule || !(classModule.isModule || classModule.isNamespace))
          return null;
        if (classModule.isClassGenericType && classModule.isClassType) {
          return this.getMatchDescriptor(property, type.types[0], true);
        }
        let args = null;
        let assigments = null;
        let pStack = this;
        let isCall = !!this.isCallExpression;
        let isNew = this.isNewExpression;
        let isSet = this.isAssignmentExpression || this.parentStack.isAssignmentExpression && this.parentStack.left === this;
        if (!isCall && this.parentStack.isCallExpression && this.parentStack.callee === this) {
          isCall = true;
          pStack = this.parentStack;
        }
        if (onlyAccessProperty) {
          isCall = false;
          isNew = false;
          isSet = false;
        }
        if (isCall || isNew) {
          isCall = true;
          args = pStack.arguments || emptyOnlyreadArray;
          assigments = pStack.genericity || emptyOnlyreadArray;
        }
        let incompleteFlag = 0;
        let matchResult = false;
        const checkMatchFun = (params, declareGenerics, desc2) => {
          incompleteFlag = 0;
          matchResult = false;
          if (params.length === args.length && args.length === 0) {
            return matchResult = true;
          } else if (params.length >= args.length) {
            if (assigments.length > 0) {
              if (declareGenerics.length < assigments.length)
                incompleteFlag = FAILED_ASSING_GENERICS;
              if (declareGenerics.length > assigments.length)
                incompleteFlag = MISSING_ASSING_GENERICS;
            } else if (declareGenerics.length > 0) {
              incompleteFlag = NOT_ASSING_GENERICS;
            }
            if (!isNew && desc2.isConstructor) {
              incompleteFlag |= DESCRIPTOR_TYPE_UNMATCH;
            }
            matchResult = params.every((declare, index) => {
              const argument = args[index];
              const optional = !!(declare.question || declare.isAssignmentPattern || declare.isRestElement);
              if (argument) {
                let acceptType = declare.type();
                if (declareGenerics && assigments && acceptType && acceptType.isGenericType) {
                  for (let i = 0; i < declareGenerics.length; i++) {
                    if (acceptType === declareGenerics[i].type()) {
                      if (assigments[i]) {
                        acceptType = assigments[i].type();
                      }
                      break;
                    }
                  }
                }
                let ctx2 = {};
                if (acceptType && acceptType.isClassGenericType) {
                  ctx2 = new Context(this);
                  ctx2.assignment(acceptType);
                }
                return this.checkMatchType(argument, declare, acceptType, ctx2);
              }
              return optional;
            });
            return matchResult && incompleteFlag === 0;
          }
          return false;
        };
        let target = null;
        let fullmatched = false;
        const records = [];
        const update = (desc2, params, generics) => {
          records[0] = desc2;
          records[1] = params;
          records[2] = generics;
          records[3] = matchResult;
          records[4] = incompleteFlag;
          return records;
        };
        const calcScore = (result2, params, generics, incompleteFlag2, desc2) => {
          let score = result2 ? 500 : 0;
          if (assigments && assigments.length > 0) {
            score += generics.length;
          }
          if ((NOT_ASSING_GENERICS & incompleteFlag2) === NOT_ASSING_GENERICS) {
            score -= generics.length;
            for (let i = 0; i < generics.length; i++) {
              const decl = generics[i].type();
              if (decl.assignType) {
                score += generics.length - i;
                break;
              }
            }
          }
          if ((MISSING_ASSING_GENERICS & incompleteFlag2) === MISSING_ASSING_GENERICS) {
            score -= generics.length - assigments.length;
          }
          if ((FAILED_ASSING_GENERICS & incompleteFlag2) === FAILED_ASSING_GENERICS) {
            score -= 500;
            score -= assigments.length - generics.length;
          }
          if ((DESCRIPTOR_TYPE_UNMATCH & incompleteFlag2) === DESCRIPTOR_TYPE_UNMATCH) {
            score -= 1;
          }
          if (args.length > params.length) {
            score -= args.length - params.length;
          } else if (args.length < params.length) {
            score -= params.length - args.length;
          }
          return score;
        };
        const choose = (prev, desc2, params, generics) => {
          if (!prev) {
            records.push(desc2, params, generics, matchResult, incompleteFlag);
            return records;
          }
          let pScore = calcScore(prev[3], prev[1], prev[2], prev[4], prev[0]);
          let cScore = calcScore(matchResult, params, generics, incompleteFlag, desc2);
          let pResult = (FAILED_ASSING_GENERICS & prev[4]) !== FAILED_ASSING_GENERICS && prev[3];
          let cResult = (FAILED_ASSING_GENERICS & incompleteFlag) !== FAILED_ASSING_GENERICS && matchResult;
          if (pResult && cResult && pScore === cScore && desc2.toString() === prev.toString()) {
            if (desc2.isDeclaratorFunction || desc2.isDeclaratorVariable) {
              const cAnnots = desc2.annotations.length + desc2.imports.length;
              const pAnnots = prev.annotations.length + prev.imports.length;
              if (cAnnots > pAnnots) {
                return update(desc2, params, generics);
              } else if (cAnnots < pAnnots) {
                return prev;
              }
            }
          }
          if (cResult) {
            if (pResult && pScore > cScore)
              return prev;
            return update(desc2, params, generics);
          }
          if (!pResult && cScore >= pScore) {
            return update(desc2, params, generics);
          } else {
            return prev;
          }
        };
        const filter = (desc2, prev, index, descriptors, extendsContext) => {
          const isStaticDesc = desc2.callableStatic || Utils2.isStaticDescriptor(desc2);
          if (isStatic) {
            if (!isStaticDesc) {
              if (!extendsContext || !extendsContext.callableStatic)
                return false;
            }
          } else if (isStaticDesc) {
            return false;
          }
          if (isCall) {
            if (desc2.isEnumProperty || desc2.isMethodSetterDefinition)
              return false;
            let params = emptyOnlyreadArray;
            let generics = emptyOnlyreadArray;
            if (desc2.isMethodDefinition && !desc2.isMethodGetterDefinition || desc2.isDeclaratorFunction || isNew && desc2.isNewDefinition || !isNew && desc2.isCallDefinition) {
              generics = desc2.genericity ? desc2.genericity.elements : emptyOnlyreadArray;
              params = desc2.params || emptyOnlyreadArray;
              if (isNew) {
                if (!(desc2.isConstructor || desc2.isNewDefinition))
                  return false;
                if (generics === emptyOnlyreadArray && !desc2.isNewDefinition) {
                  generics = desc2.module.getModuleDeclareGenerics(false, true);
                }
              }
              if (checkMatchFun(params, generics, desc2)) {
                return fullmatched = true;
              }
            } else if (desc2.isPropertyDefinition || desc2.isMethodGetterDefinition || desc2.isDeclaratorVariable) {
              if (desc2.isDeclaratorVariable && descriptors && descriptors.length === 1) {
                return fullmatched = true;
              }
              let type2 = desc2.type();
              if (type2) {
                if (!isNew && desc2.isDeclaratorVariable) {
                  const origin = Utils2.getOriginType(type2);
                  if (Utils2.isTypeModule(origin)) {
                    let _result = origin.getDescriptor(`#${origin.id}`, filter, { isNew: false, isCall });
                    if (_result) {
                      target = _result;
                      return fullmatched;
                    }
                  }
                }
                if (isNew) {
                  if (type2.isClassGenericType && type2.isClassType) {
                    return fullmatched = true;
                  }
                } else if (type2.isFunctionType) {
                  generics = type2.generics;
                  params = type2.params || emptyOnlyreadArray;
                  if (checkMatchFun(params, generics, desc2)) {
                    return fullmatched = true;
                  }
                }
              }
            }
            return choose(prev, desc2, params, generics);
          } else if (isSet) {
            if (desc2.isEnumProperty)
              return false;
            if (desc2.isMethodSetterDefinition) {
              return fullmatched = true;
            } else if (desc2.isPropertyDefinition) {
              if (!desc2.isReadonly) {
                return fullmatched = true;
              }
            }
          } else {
            if (desc2.isMethodGetterDefinition || desc2.isPropertyDefinition || desc2.isEnumProperty) {
              return fullmatched = true;
            }
          }
          return prev || desc2;
        };
        const result = classModule.getDescriptor(property, filter, { isNew: false, isCall });
        return result === records ? result[0] : target || result;
      }
      getObjectDescriptor(object, property, isStatic = false, prevObject = null, context = null) {
        if (!object)
          return null;
        if (!(object instanceof Type)) {
          throw new Error("Argument object is not type");
        }
        const ctx2 = context || this.getContext();
        object = ctx2.fetch(object.type(), true);
        if (object === prevObject) {
          return Namespace2.globals.get("any");
        }
        if (object.isComputeType) {
          object = object.getResult();
        }
        if (object.isAnyType)
          return Namespace2.globals.get("any");
        if (object.isAliasType) {
          return this.getObjectDescriptor(object.inherit.type(), property, isStatic, object, context);
        }
        if (object.isClassGenericType) {
          if (object.isClassType) {
            return this.getObjectDescriptor(object.types[0].type(), property, true, object, context);
          } else {
            const wrap = object.inherit.type();
            if (wrap.target && wrap.target.isDeclaratorTypeAlias && wrap.target.genericity) {
              const declareGenerics = wrap.target.genericity.elements;
              if (object.elements.length === 1 && declareGenerics.length === 1) {
                const has = declareGenerics[0].type() === wrap.inherit.type();
                if (has) {
                  return this.getObjectDescriptor(object.elements[0].type(), property, false, object, context);
                }
              }
              const ctx3 = new Context(this);
              ctx3.make(object);
              return this.getObjectDescriptor(wrap.inherit.type(), property, false, object, ctx3);
            }
          }
        }
        if (object.isIntersectionType) {
          return this.getObjectDescriptor(object.left.type(), property, isStatic, object, context) || this.getObjectDescriptor(object.right.type(), property, isStatic, object, context);
        }
        let dynamicAttribute = false;
        let result = null;
        if (object.isUnionType) {
          const properties = [];
          const elems = object.elements;
          const checkCall = (stack2) => {
            if (!stack2)
              return false;
            return (stack2.isCallExpression || stack2.isNewExpression) && stack2.callee === this;
          };
          const isCall = checkCall(this) || checkCall(this.parentStack);
          const isTypeDefinition = (stack2) => {
            return stack2.isTypeObjectPropertyDefinition || stack2.isPropertyDefinition || stack2.isMethodGetterDefinition;
          };
          for (let i = 0; i < elems.length; i++) {
            const item2 = elems[i];
            const result2 = this.getObjectDescriptor(item2.type(), property, isStatic, object, context);
            if (result2) {
              if (isCall) {
                if (result2.isMethodDefinition && !result2.isAccessor || result2.isFunctionExpression) {
                  return result2;
                } else if (result2.isPropertyDefinition || result2.isMethodGetterDefinition) {
                  const type2 = result2.type();
                  if (type2.isFunctionType) {
                    return result2;
                  }
                }
              } else {
                if (isTypeDefinition(result2)) {
                  return result2;
                }
                properties.push(result2);
              }
            }
          }
          if (properties.length > 0) {
            if (properties.length === 1) {
              return properties[0];
            } else {
              const mergeType = new MergeType();
              properties.forEach((item2) => {
                mergeType.add(item2);
              });
              return mergeType.type();
            }
          }
          return null;
        } else if (this.isLiteralObject(object)) {
          dynamicAttribute = true;
          let desc2 = object.attribute(property);
          if (desc2) {
            return desc2;
          }
        }
        const origin = Utils2.getOriginType(object);
        result = this.getMatchDescriptor(property, origin, isStatic);
        if (!result) {
          result = this.getObjectDynamicDescriptor(dynamicAttribute ? object : origin, object.isLiteralArrayType || object.isTupleType ? "number" : "string");
        }
        if (!result && object.isLiteralObjectType && object.target && object.target.isObjectExpression) {
          if (!this.compiler.options.literalObjectStrict) {
            result = Namespace2.globals.get("any");
          }
        }
        return result || null;
      }
      getObjectDescriptorForAuxiliary(object, property, isStatic = false, prevObject = null, context = null) {
        if (!object)
          return null;
        if (!(object instanceof Type)) {
          throw new Error("Argument object is not type");
        }
        const ctx2 = context || this.getContext();
        object = ctx2.fetch(object.type(), true);
        if (object === prevObject) {
          return null;
        }
        if (object.isComputeType) {
          object = object.getResult();
        }
        if (object.isAnyType)
          return null;
        if (object.isAliasType) {
          return this.getObjectDescriptorForAuxiliary(object.inherit.type(), property, isStatic, object, context);
        }
        if (object.isClassGenericType) {
          if (object.isClassType) {
            return this.getObjectDescriptorForAuxiliary(object.types[0].type(), property, true, object, context);
          } else {
            const wrap = object.inherit.type();
            if (wrap.target && wrap.target.isDeclaratorTypeAlias && wrap.target.genericity) {
              const declareGenerics = wrap.target.genericity.elements;
              if (object.elements.length === 1 && declareGenerics.length === 1) {
                const has = declareGenerics[0].type() === wrap.inherit.type();
                if (has) {
                  return this.getObjectDescriptorForAuxiliary(object.elements[0].type(), property, false, object, context);
                }
              }
              const ctx3 = new Context(this);
              ctx3.make(object);
              return this.getObjectDescriptorForAuxiliary(wrap.inherit.type(), property, false, object, ctx3);
            }
          }
        }
        if (object.isIntersectionType) {
          return this.getObjectDescriptorForAuxiliary(object.left.type(), property, isStatic, object, context) || this.getObjectDescriptorForAuxiliary(object.right.type(), property, isStatic, object, context);
        }
        let dynamicAttribute = false;
        let result = null;
        if (object.isUnionType) {
          const elems = object.elements;
          for (let i = 0; i < elems.length; i++) {
            const item2 = elems[i];
            const result2 = this.getObjectDescriptorForAuxiliary(item2.type(), property, isStatic, object, context);
            if (result2) {
              return result2;
            }
          }
          return null;
        } else if (this.isLiteralObject(object)) {
          dynamicAttribute = true;
          let desc2 = object.attribute(property);
          if (desc2) {
            return desc2;
          }
        }
        const origin = Utils2.getOriginType(object);
        if (origin.isModule) {
          if (isStatic) {
            result = origin.getMethod(property);
          } else {
            result = origin.getMember(property);
          }
        }
        if (!result) {
          result = this.getObjectDynamicDescriptor(dynamicAttribute ? object : origin, object.isLiteralArrayType || object.isTupleType ? "number" : "string");
        }
        return result;
      }
      isLiteralObject(object) {
        if (!object)
          return false;
        if (object.isLiteralArrayType || object.isTupleType || object.isLiteralObjectType || object.isGenericType && object.hasConstraint || object.isEnumType) {
          return true;
        }
        return false;
      }
      getObjectDynamicDescriptor(object, propertyType) {
        if (this.isLiteralObject(object) || Utils2.isTypeModule(object)) {
          const type2 = Namespace2.globals.get(propertyType);
          if (object.isGenericType) {
            object = object.inherit.type();
          }
          return object.dynamicAttribute(type2);
        }
        return null;
      }
      isTypeInContextType(type2, contextType) {
        if (!contextType || !type2)
          return false;
        if (type2 === contextType) {
          return true;
        } else if (contextType.isClassGenericType) {
          return contextType.types.some((item2) => this.isTypeInContextType(type2, item2.type()));
        } else if (contextType.isFunctionType) {
          const declReturnType = contextType.returnType;
          if (declReturnType && this.isTypeInContextType(type2, declReturnType.type()))
            return true;
          if (contextType.params.some((item2) => this.isTypeInContextType(type2, item2.type())))
            return true;
        } else if (contextType.isTupleType || contextType.isLiteralArrayType || contextType.isUnionType) {
          return contextType.elements.some((item2) => this.isTypeInContextType(type2, item2.type()));
        } else if (contextType.isLiteralObjectType) {
          if (contextType.properties.some((item2) => this.isTypeInContextType(type2, item2.type())))
            return true;
          if (type2.dynamicProperties) {
            const properties = Array.from(type2.dynamicProperties.values());
            if (properties.some((item2) => this.isTypeInContextType(type2, item2.type())))
              return true;
          }
        } else if (type2.isIntersectionType) {
          if (this.isTypeInContextType(type2, type2.left.type()))
            return true;
          if (this.isTypeInContextType(type2, type2.right.type()))
            return true;
        } else if (type2.isAliasType) {
          if (this.isTypeInContextType(type2, type2.inherit.type()))
            return true;
        }
        return false;
      }
      isTypeDefinitionStack(stack2) {
        if (!stack2)
          return false;
        return stack2.isTypeDefinition || stack2.isTypeTupleRestDefinition || stack2.isTypeTupleDefinition || stack2.isTypeGenericDefinition || stack2.isTypeObjectDefinition || stack2.isTypeObjectPropertyDefinition || stack2.isTypeFunctionDefinition || stack2.isTypeComputeDefinition || stack2.isTypeIntersectionDefinition || stack2.isTypeKeyofDefinition || stack2.isTypeTypeofDefinition || stack2.isTypeUnionDefinition;
      }
      isModuleForWebComponent(module2) {
        if (!(module2 && module2.isModule && module2.isClass)) {
          return false;
        }
        return module2.isWebComponent();
      }
      isModuleForSkinComponent(module2) {
        if (!(module2 && module2.isModule && module2.isClass)) {
          return false;
        }
        return module2.isSkinComponent();
      }
      isJSXForContext(stack2) {
        stack2 = stack2 || this.parentStack;
        if (stack2.isSequenceExpression)
          stack2 = stack2.parentStack;
        if (stack2.isParenthesizedExpression)
          stack2 = stack2.parentStack;
        if (stack2.isLiteral || stack2.isJSXExpressionContainer)
          stack2 = stack2.parentStack;
        if (stack2.isJSXAttribute)
          stack2 = stack2.jsxElement;
        if (stack2.isMemberExpression)
          return this.isJSXForContext(stack2.parentStack);
        return !!(stack2.jsxElement && stack2.scope.isForContext);
      }
      isJSXForRef(stack2) {
        stack2 = stack2 || this.parentStack;
        if (stack2.isLiteral || stack2.isJSXExpressionContainer)
          stack2 = stack2.parentStack;
        if (stack2.isJSXAttribute)
          stack2 = stack2.jsxElement;
        if (stack2.isMemberExpression)
          return this.isJSXForRef(stack2.parentStack);
        return !!(stack2.jsxElement && stack2.scope.isForContext);
      }
      getAnnotationArgumentItem(name, args, indexes = null) {
        name = String(name).toLowerCase();
        let index = args.findIndex((item2) => {
          const key = String(item2.key).toLowerCase();
          return key === name;
        });
        if (index < 0 && indexes && Array.isArray(indexes)) {
          index = indexes.indexOf(name);
          if (index >= 0) {
            const arg = args[index];
            return arg && !arg.assigned ? arg : null;
          }
        }
        return args[index];
      }
      findAnnotation(stack2, filter, inheritFlag = true) {
        if (arguments.length === 1) {
          filter = stack2;
          stack2 = this;
        } else if (arguments.length === 2 && typeof filter === "boolean") {
          inheritFlag = filter;
          filter = stack2;
          stack2 = this;
        }
        if (stack2 && stack2.isModule && stack2 instanceof Module) {
          const items = stack2.getStacks();
          for (let i = 0; i < items.length; i++) {
            const result2 = this.findAnnotation(items[i], filter);
            if (result2) {
              return result2;
            }
          }
          return null;
        }
        if (!stack2 || !stack2.isStack) {
          return null;
        }
        const each = (list, invoke) => {
          if (!list)
            return null;
          let len = list.length;
          let i = 0;
          for (; i < len; i++) {
            const result2 = invoke(list[i]);
            if (result2) {
              return result2;
            }
          }
          return null;
        };
        let result = each(stack2.annotations, (annotation) => {
          const result2 = filter(annotation, stack2);
          if (result2) {
            return [result2, stack2];
          }
        });
        if (result) {
          return result;
        }
        if (inheritFlag === false) {
          return null;
        }
        if (stack2.isClassDeclaration || stack2.isDeclaratorDeclaration || stack2.isInterfaceDeclaration || stack2.isEnumDeclaration) {
          const module2 = stack2.module;
          const impls = module2.extends.concat(module2.implements || []);
          return each(impls, (module3) => {
            const result2 = this.findAnnotation(module3, filter, inheritFlag);
            if (result2) {
              return result2;
            }
          });
        } else if ((stack2.isMethodDefinition || stack2.isPropertyDefinition) && !stack2.static) {
          const module2 = stack2.module;
          const name = stack2.value();
          const impls = module2.extends.concat(module2.implements || []);
          const token = stack2.toString();
          const isStatic = !!stack2.static;
          return each(impls, (module3) => {
            const descriptors = module3.descriptors.get(name);
            if (descriptors) {
              for (let i = 0; i < descriptors.length; i++) {
                const stack3 = descriptors[i];
                if (stack3 && token === stack3.toString() && isStatic === !!stack3.static) {
                  const result2 = this.findAnnotation(stack3, filter, inheritFlag);
                  if (result2) {
                    return result2;
                  }
                }
              }
            }
          });
        }
        return null;
      }
      getFunType() {
        return null;
      }
      value() {
        return this.node.name || this.node.value;
      }
      raw() {
        if (this.compilation && this.compilation.source) {
          return this.compilation.source.substr(this.node.start, this.node.end - this.node.start);
        }
        return this.node.raw || this.node.name;
      }
      checker() {
        if (this.__checked)
          return false;
        return this.__checked = true;
      }
      parser() {
        if (this.__parsered)
          return false;
        return this.__parsered = true;
      }
      parserDescriptor(desc2) {
        if (!desc2)
          return;
        if (desc2.isStack && desc2.module === this.module) {
          if (desc2.isMethodDefinition || desc2.isPropertyDefinition || desc2.isFunctionExpression) {
            desc2.parser();
          }
        }
      }
      setRefBeUsed(description) {
        const desc2 = description || this.description();
        if (desc2 && desc2 instanceof Stack && desc2 !== this) {
          desc2.addUseRef(this);
        } else if (desc2 && Utils2.isTypeModule(desc2)) {
          const classStack = this.compilation.getStackByModule(desc2);
          if (classStack && classStack !== this) {
            classStack.addUseRef(this);
          }
          if (!(this.parentStack.isTypeDefinition || this.parentStack.isTypeGenericDefinition || this.parentStack.isVariableDeclarator)) {
            this.compilation.addDependency(desc2, this.module);
          }
        }
      }
      interceptAnnotation(stack2) {
        if (!(stack2 && stack2.isAnnotationDeclaration)) {
          return stack2;
        }
        const aName = stack2.name.toLowerCase();
        if (aName === "hostcomponent" && this.isJSXScript) {
          this.hostComponentAnnotation = stack2;
          return null;
        } else if (aName === "require") {
          return null;
        } else if (aName === "reference") {
          if (!(stack2.parentStack && (stack2.parentStack.isProgram || stack2.parentStack.isPackageDeclaration))) {
            stack2.error(1105, this.name);
          }
          return null;
        }
        return stack2;
      }
      freeze(target) {
        Object.freeze(target || this);
      }
      error(code, ...args) {
        this.compilation.error(this.node, code, ...args);
      }
      warn(code, ...args) {
        this.compilation.warn(this.node, code, ...args);
      }
      deprecated(code, ...args) {
        this.compilation.deprecated(this.node, code, ...args);
      }
      unnecessary(code, ...args) {
        this.compilation.unnecessary(this.node, code, ...args);
      }
      toString() {
        return "Stack";
      }
      async allSettled(items, asyncMethod, fetchResult = false) {
        if (!items)
          return;
        if (!Array.isArray(items)) {
          console.error("Stack.allSettled items invalid.");
          return false;
        }
        try {
          const results = await Promise.allSettled(items.map((item2, index) => asyncMethod(item2, index, items)));
          if (fetchResult) {
            return results.map((promise) => {
              if (promise.status === "rejected") {
                console.error(promise.reason);
              }
              return promise.status === "fulfilled" ? promise.value : null;
            });
          }
        } catch (e) {
          return false;
        }
      }
      async callParser(callback, nowInvokeFlag = false) {
        if (this.__parsered && !nowInvokeFlag)
          return false;
        try {
          this.__parsered = true;
          await callback();
        } catch (e) {
          console.error(e);
        }
        return true;
      }
    };
    module.exports = Stack;
  }
});

// lib/stacks/Declarator.js
var require_Declarator = __commonJS({
  "lib/stacks/Declarator.js"(exports, module) {
    var Namespace2 = require_Namespace();
    var Stack = require_Stack();
    var Utils2 = require_Utils();
    var Declarator = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isDeclarator = true;
        if (!(parentStack && (parentStack.isArrayPattern || parentStack.isProperty && parentStack.parentStack.isObjectPattern))) {
          this._acceptType = this.createTokenStack(compilation, node.acceptType, scope, node, this);
        }
        let p = parentStack && parentStack.isProperty && parentStack.parentStack && parentStack.parentStack.isObjectPattern ? parentStack.parentStack : parentStack;
        p = p && (p.isArrayPattern || p.isObjectPattern) && p.parentStack ? p.parentStack : parentStack;
        if (p && (p.isFunctionExpression || p.isTypeFunctionDefinition || p.isTryStatement)) {
          this.question = !!node.question;
          this.isParamDeclarator = true;
        }
        this.assignValue = null;
        this.assignFirstValue = null;
        this.assignItems = /* @__PURE__ */ new Set();
        this._kind = "var";
      }
      get acceptType() {
        const parent = this.parentStack;
        let _acceptType = this._acceptType;
        if (!_acceptType && parent) {
          if (parent.isArrayPattern) {
            if (parent.acceptType && parent.acceptType.isTypeTupleDefinition) {
              const index = parent.elements.indexOf(this);
              _acceptType = parent.acceptType.elements[index] || null;
            }
          } else if (parent.isProperty && parent.parentStack.isObjectPattern) {
            _acceptType = parent.acceptType;
          }
        }
        return _acceptType;
      }
      freeze(target) {
        super.freeze(target);
        super.freeze(this.assignItems);
        super.freeze(this.useRefItems);
        this.acceptType && this.acceptType.freeze();
      }
      definition(context) {
        context = context || this.getAttribute("Declarator.getRelateParamDescriptionCtx") || this.getContext();
        const type2 = this.type().toString(context);
        if (this.isParamDeclarator) {
          const identifier = this.value();
          let relate = this.getAttribute("Declarator.getRelateParamDescriptionParamItem");
          let comments = this.comments;
          let location = this.getLocation();
          let file = this.compilation.file;
          if (context.stack === this) {
            if (relate && relate.isStack) {
              comments = relate.comments;
              location = relate.getLocation();
              file = relate.compilation.file;
            }
          }
          return {
            comments,
            expre: `(parameter) ${identifier}:${type2}`,
            location,
            file
          };
        } else if (this.parentStack.isArrayPattern || this.parentStack.isProperty && this.parentStack.parentStack.isObjectPattern) {
          const identifier = this.value();
          const expre = `(local ${this.kind}) ${identifier}:${type2}`;
          return {
            comments: this.comments,
            expre,
            location: this.getLocation(),
            file: this.compilation.file
          };
        }
        return null;
      }
      set kind(value) {
        this._kind = value;
      }
      get kind() {
        let p = this.parentStack;
        let flag = false;
        if (p && p.isArrayPattern) {
          flag = true;
          p = p.parentStack;
        } else if (p && p.isProperty && p.parentStack.isObjectPattern) {
          flag = true;
          p = p.parentStack.parentStack;
        }
        if (flag && p && p.isVariableDeclarator) {
          return p.kind;
        }
        return this._kind;
      }
      reference(called) {
        if (Utils2.isFunction(this.assignValue)) {
          return this.assignValue;
        }
        if (this.assignValue && this.assignValue.isStack) {
          return this.assignValue.reference(called) || this.assignValue;
        }
        return this;
      }
      referenceItems(called) {
        let items = [];
        this.assignItems.forEach((item2) => {
          if (!called && Utils2.isFunction(item2)) {
            items.push(item2);
          } else {
            items = items.concat(item2.referenceItems(called) || item2);
          }
        });
        return items.length > 0 ? items : [this];
      }
      description() {
        return this;
      }
      getRelateParamDescription(stack2, argument, index, propertyStack = []) {
        if (!stack2)
          return null;
        if (stack2.isObjectExpression) {
          return this.getRelateParamDescription(stack2.parentStack, stack2, index, propertyStack.concat(argument));
        } else if (stack2.isProperty) {
          return this.getRelateParamDescription(stack2.parentStack, stack2, index, propertyStack);
        } else if (stack2.isArrayExpression) {
          return this.getRelateParamDescription(stack2.parentStack, stack2, index, propertyStack.concat(argument));
        }
        const fetchObjectType = (object, property) => {
          if (property.isProperty) {
            object = stack2.getObjectDescriptorForAuxiliary(object, property.value());
            if (object) {
              return object.type();
            }
          } else if (object.isTupleType && property.parentStack.isArrayExpression) {
            const index2 = property.parentStack.elements.indexOf(property);
            const type2 = object.prefix || object.rest ? object.elements[0] : object.elements[index2];
            if (type2) {
              return type2.type();
            }
          }
          return null;
        };
        const fetchType = (declareParam) => {
          if (!declareParam)
            return null;
          let type2 = declareParam.type();
          if (type2.isTupleType && type2.rest) {
            type2 = type2.elements[0];
          }
          while (type2.isAliasType) {
            type2 = type2.inherit.type();
          }
          if (argument.isArrayExpression || argument.isObjectExpression) {
            let desc3 = type2.type();
            while (desc3 && propertyStack.length > 0) {
              desc3 = fetchObjectType(desc3, propertyStack.pop());
            }
            return desc3;
          }
          return declareParam;
        };
        const getDescription = (declareParams2, pos) => {
          if (declareParams2 && declareParams2.length > 0) {
            if (pos >= 0 && pos < declareParams2.length) {
              return fetchType(declareParams2[pos]);
            }
          }
        };
        if (stack2.isVariableDeclarator) {
          const acceptType = stack2._acceptType;
          if (!acceptType)
            return [];
          return [
            fetchType(acceptType.type()),
            stack2
          ];
        }
        if (stack2.isAssignmentExpression) {
          return [
            fetchType(stack2.left.type()),
            stack2
          ];
        }
        if (!(stack2.isCallExpression || stack2.isNewExpression)) {
          return null;
        }
        let desc2 = stack2.description();
        let funType = stack2.isCallExpression ? stack2.getDeclareFunctionType(desc2) : desc2;
        let declareParams = stack2.getFunDeclareParams(funType);
        return [
          getDescription(declareParams, stack2.arguments.indexOf(argument)),
          stack2
        ];
      }
      getRelateParamType() {
        return this.getAttribute("Declarator.getRelateParamType", () => {
          if (!this.parentStack.isFunctionExpression) {
            return null;
          }
          const stack2 = this.parentStack.parentStack;
          if (stack2.isVariableDeclarator && stack2.init === this.parentStack) {
            return null;
          }
          const index = this.parentStack.params.indexOf(this);
          if (!(index >= 0))
            return null;
          const [description, _stack] = this.getRelateParamDescription(stack2, this.parentStack, index) || [];
          if (!description || this === description)
            return null;
          this.setAttribute("Declarator.getRelateParamDescription", description);
          const ctx2 = _stack.getContext();
          this.setAttribute("Declarator.getRelateParamDescriptionCtx", ctx2);
          const getType = (type2) => {
            const result = Utils2.extractFunTypeFromType(type2);
            if (!result)
              return null;
            const [declareFunction, _ctx] = result;
            let value = null;
            if (declareFunction.isFunctionType && declareFunction.params && declareFunction.params.length > 0) {
              if (declareFunction.target && declareFunction.target === this.parentStack) {
                return null;
              }
              const param = declareFunction.params[index];
              if (param) {
                this.setAttribute("Declarator.getRelateParamDescriptionParamItem", param);
                if (param.isRestElement) {
                  value = param.getItemType();
                } else {
                  value = param.type();
                }
              } else {
                const restMaybe = declareFunction.params[declareFunction.params.length - 1];
                if (restMaybe && restMaybe.isRestElement) {
                  this.setAttribute("Declarator.getRelateParamDescriptionParamItem", restMaybe);
                  value = restMaybe.getItemType();
                }
              }
            }
            return value;
          };
          const items = [];
          const paramType = description.type();
          if (paramType.isUnionType) {
            items.push(...paramType.elements);
          } else if (paramType.isIntersectionType) {
            items.push(paramType.left);
            items.push(paramType.right);
          } else {
            return getType(paramType);
          }
          for (let item2 of items) {
            const result = getType(item2.type());
            if (result)
              return result;
          }
          return null;
        });
      }
      getAssignType() {
        return this.getAttribute("getAssignType", () => {
          let acceptType = this.acceptType;
          if (acceptType) {
            acceptType = acceptType.type();
          } else if (this.inheritInterfaceAcceptType) {
            acceptType = this.inheritInterfaceAcceptType.type();
          }
          if (!acceptType) {
            acceptType = this.getRelateParamType();
          }
          return acceptType;
        });
      }
      type() {
        let acceptType = this.getAssignType();
        if (acceptType) {
          return acceptType;
        }
        if (this.parentStack.isProperty && this.parentStack.parentStack.isObjectPattern) {
          return this.parentStack.type();
        }
        if (this.parentStack.isTryStatement) {
          return Namespace2.globals.get("Error");
        }
        let init = this.getDefaultInit();
        if (init && !this.checkNullType(init)) {
          const isSelf = init.isStack && init.description() === this;
          if (!isSelf) {
            return init.type();
          }
        }
        return Namespace2.globals.get("any");
      }
      getDefaultInit(flag) {
        let init = null;
        if (this.parentStack.isArrayPattern && this.parentStack.parentStack.isVariableDeclarator) {
          if (this.isAssignmentPattern) {
            init = this.right;
          } else {
          }
        } else if (this.isVariableDeclarator) {
          init = this.init;
        } else if (this.isAssignmentPattern) {
          init = this.right;
        } else if (this.dynamic && this.parentStack.isPropertyDefinition && this.init && this.init.isTypeDefinition) {
          init = this.init;
        }
        if (flag)
          return init;
        return init || this.assignFirstValue;
      }
      getContext() {
        return this.getAttribute("Declarator.getContext", () => {
          let ctx2 = null;
          if (this.parentStack.isFunctionExpression) {
            let stack2 = this.parentStack.parentStack;
            while (stack2 && (stack2.isProperty || stack2.isObjectExpression || stack2.isArrayExpression)) {
              stack2 = stack2.parentStack;
            }
            if (stack2 && (stack2.isCallExpression || stack2.isNewExpression)) {
              ctx2 = stack2.getContext().createChild(this);
            }
          }
          if (!ctx2 && !this.isAssignmentPattern) {
            const init = this.getDefaultInit(true);
            if (init && init instanceof Stack && init !== this) {
              if (!(init.isFunctionExpression || init.isArrayExpression || init.isObjectExpression)) {
                ctx2 = init.getContext();
              }
            }
          }
          if (!ctx2) {
            ctx2 = super.getContext();
          }
          ctx2.make(this.getAssignType());
          return ctx2;
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.acceptType) {
          this.acceptType.parser();
          const type2 = this.acceptType.type();
          const origin = Utils2.getOriginType(type2);
          const module2 = this.module;
          const isGlobal = module2 && module2.compilation.pluginScopes.scope === "global";
          if (origin && origin.isModule && Utils2.isTypeModule(origin) && origin.compilation.pluginScopes.scope !== "global" && !isGlobal) {
            this.compilation.addDependency(origin, this.module);
          }
        }
        if (this.module && this.module.id === this.value()) {
          this.error(1008, this.value());
        }
      }
      checkNullType(type2) {
        if (type2) {
          type2 = type2.type();
          if (type2 && type2.isNullableType) {
            return true;
          }
        }
        return false;
      }
      assignment(value, stack2 = null) {
        if (this.assignValue !== value && value) {
          if (this.checkNullType(value))
            return;
          let assignDesc = null;
          if (value && value.isStack) {
            assignDesc = value.description();
          }
          if (assignDesc) {
            if (assignDesc === this || assignDesc.isStack && assignDesc.description() === this) {
              return;
            }
          }
          let acceptType = this.acceptType || this.inheritInterfaceAcceptType;
          let isNullable = false;
          if (!acceptType) {
            let init = this.getDefaultInit();
            if (init) {
              isNullable = this.checkNullType(init);
              if (!isNullable) {
                acceptType = init.type();
              }
            }
          }
          if (acceptType) {
            const errorStack = stack2 && stack2.isStack ? stack2 : null;
            if (this.checkExpressionType(acceptType, value, errorStack)) {
              this.assignItems.add(value);
              this.assignValue = value;
            }
          }
          if (!this.assignFirstValue && !this.checkNullType(value)) {
            this.assignFirstValue = value;
          }
        }
      }
    };
    module.exports = Declarator;
  }
});

// lib/stacks/AnnotationDeclaration.js
var require_AnnotationDeclaration = __commonJS({
  "lib/stacks/AnnotationDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var Utils2 = require_Utils();
    var path = __require("path");
    var Constant = require_Constant();
    var Declarator = require_Declarator();
    var Namespace2 = require_Namespace();
    var AnnotationDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isAnnotationDeclaration = true;
        this.body = (node.body || []).map((item2) => {
          const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          if (item2.acceptType) {
            stack2.acceptType = this.createTokenStack(compilation, item2.acceptType, scope, node, this);
          }
          return stack2;
        });
        this._additional = null;
        const allowed = this.compiler.options.annotations;
        if (!(allowed.includes(this.name) || allowed.includes(Utils2.firstToUpper(this.name)))) {
          this.error(1140, this.name);
        }
      }
      get name() {
        return this.node.name;
      }
      set additional(stack2) {
        this._additional = stack2;
        const scope = this.scope;
        const args = this.getArguments();
        const name = this.name.toLowerCase();
        if ((name === "import" || name === "require") && args.length === 2 && args[0].isObjectPattern) {
          const source = args[1].value;
          args[0].extract.forEach((prop) => {
            var desc2 = Namespace2.globals.get(source) || Namespace2.fetch(source);
            if (desc2) {
              if ((desc2.isAliasType || desc2.isLiteralObjectType) && !desc2.isModule) {
                if (desc2.isAliasType)
                  desc2 = desc2.inherit;
                if (desc2.isLiteralObjectType) {
                  desc2 = desc2.attribute(prop.key);
                } else {
                  desc2 = null;
                }
              } else if (desc2.isModule) {
                desc2 = desc2.getMethod(prop.key);
              } else if (desc2.isNamespace) {
                desc2 = desc2.get(prop.key);
              } else {
                desc2 = null;
              }
            }
            if (desc2) {
              scope.define(prop.key, desc2);
            } else {
              scope.define(prop.key, new Declarator(this.compilation, prop.stack.key, prop.stack.scope, prop.stack.parentNode, prop.stack.parentStack));
            }
          });
        } else if (name === "import" || name === "require") {
          args.forEach((item2) => {
            if (item2.assigned) {
              if (scope.isDefine(item2.key)) {
                this.error(1007, item2.key);
              } else {
                var desc2 = Namespace2.globals.get(item2.value);
                if (desc2) {
                  scope.define(item2.key, desc2);
                } else {
                  scope.define(item2.key, new Declarator(this.compilation, item2.stack.left, item2.stack.scope, item2.stack.parentNode, item2.stack.parentStack));
                }
              }
            }
          });
        } else if ("embed") {
          if (stack2 && stack2.module && (stack2.isClassDeclaration || stack2.isInterfaceDeclaration || stack2.isEnumDeclaration && !stack2.isExpressionDeclare || stack2.isDeclaratorDeclaration)) {
            args.forEach((item2) => {
              if (item2.assigned) {
                if (scope.isDefine(item2.key)) {
                  this.error(1007, item2.key);
                } else {
                  scope.define(item2.key, new Declarator(this.compilation, item2.stack.left, item2.stack.scope, item2.stack.parentNode, item2.stack.parentStack));
                }
              }
            });
          }
        }
      }
      get additional() {
        return this._additional;
      }
      getReferenceFiles() {
        return this.getAttribute("getReferenceFiles", () => {
          const files = [];
          const describePattern = this.compiler.options.describePattern;
          this.getArguments().forEach((item2) => {
            const deep = (file, context, isRoot = false) => {
              file = this.compiler.getFileAbsolute(file, context, false);
              if (!file)
                return;
              if (Utils2.existsSync(file)) {
                const stat = Utils2.getFileStatSync(file);
                if (stat.isDirectory()) {
                  const list = Utils2.readdir(file);
                  if (list) {
                    list.forEach((filename) => deep(filename, file));
                  }
                } else if (stat.isFile() && (isRoot || describePattern.test(file))) {
                  files.push(file);
                }
              } else {
                item2.stack.error(1132, file);
              }
            };
            deep(item2.value, this.file, true);
          });
          return files;
        });
      }
      async createCompleted() {
        const aName = this.name.toLowerCase();
        if (aName !== "reference")
          return;
        if (this.compilation.import === "manifest")
          return null;
        const files = this.getReferenceFiles();
        const compilations = files.map((file) => this.compilation.createChildCompilation(file, null, file, true));
        const results = await Promise.allSettled(compilations);
        const items = results.map((result) => result.value).filter((v) => !!v);
        items.forEach((compilation) => {
          if (!compilation.import) {
            compilation.import = "reference";
          }
        });
        this.setAttribute("referenceCompilations", items);
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.body);
        super.freeze(this.scope);
        this.body.forEach((stack2) => stack2.freeze());
      }
      definition(context) {
        const enterStack = context && context.stack;
        if (!enterStack)
          return false;
        const name = this.name.toLowerCase();
        if (!["import", "embed", "require"].includes(name)) {
          return null;
        }
        if (name === "embed") {
          const item2 = this.getArguments().find((item3) => {
            return item3.stack === enterStack || item3.stack.left === enterStack;
          });
          const file = item2.resolveFile ? this.compiler.normalizePath(item2.resolveFile) : item2.value;
          return {
            expre: `Embed("${file}")`,
            location: item2.stack.getLocation(),
            range: item2.stack.getLocation(),
            file: this.compilation.file
          };
        } else {
          const find = (item3) => {
            if (item3.assigned) {
              return item3.stack.right === enterStack || item3.stack.left === enterStack;
            } else if (item3.isObjectPattern) {
              return item3.extract.find(find);
            } else if (item3.isProperty) {
              if (item3.stack.init.isAssignmentPattern) {
                return item3.stack.init.right === enterStack || item3.stack.init.left === enterStack;
              } else {
                return item3.stack.init === enterStack;
              }
            }
            return false;
          };
          let item2 = this.getArguments().find(find);
          if (item2) {
            if (item2.isObjectPattern) {
              item2 = item2.extract.find(find);
            }
            const scope = this.additional.scope || this.scope;
            const desc2 = scope.define(item2.key);
            const file = item2.resolveFile ? this.compiler.normalizePath(item2.resolveFile) : item2.value;
            if (desc2) {
              return {
                expre: `(refs) ${item2.key}:${desc2.type().toString()}`,
                location: desc2.isStack ? desc2.getLocation() : null,
                file: desc2.isStack ? desc2.file : null
              };
            }
            if (item2.assigned) {
              return {
                expre: `${Utils2.firstToUpper(name)}(${item2.key} = "${file}")`
              };
            } else {
              return {
                expre: this.raw()
              };
            }
          }
        }
      }
      description() {
        return this;
      }
      getArguments() {
        if (this._args) {
          return this._args;
        }
        const target = this._args = [];
        this.body.map((item2, index) => {
          if (item2.isAssignmentPattern) {
            const key = item2.left.value();
            const value = item2.right.value();
            const assigned = true;
            target.push({ key, value, assigned, stack: item2 });
          } else if (item2.isObjectPattern) {
            const properties = item2.properties.map((node) => {
              const value = node.key.value();
              const key = node.init.isAssignmentPattern ? node.init.right.value() : node.init.value();
              return { key, value, isProperty: true, stack: node };
            });
            target.push({ isObjectPattern: true, extract: properties, stack: item2 });
          } else if (item2.isArrayPattern) {
          } else {
            const key = index;
            const value = item2.value();
            const assigned = false;
            target.push({ key, value, assigned, stack: item2 });
          }
        });
        return target;
      }
      checkImportParams(args) {
        if (!args.length || args.length > 3 || args[0].isObjectPattern && args.length < 2) {
          this.error(1001, 2, args.length);
        } else if (args[0].isObjectPattern && !(args[1] && (!args[1].assigned || typeof args[1].value !== "string"))) {
          args[1].stack.error(1135, this.name);
        } else if (args[2] && !(args[2].value === false || args[2].value === true)) {
          args[2].stack.error(1135, this.name);
        }
        const fileItem = args[0].isObjectPattern ? args[1] : args[0];
        let resolve = null;
        if (fileItem.value && !(args.length > 1 && args[args.length - 1].value === true)) {
          resolve = this.compiler.resolve(fileItem.value, this.file);
          if (!resolve) {
            resolve = fileItem.value;
          } else {
            resolve = this.compiler.normalizePath(resolve);
          }
        }
        fileItem.resolveFile = resolve;
        if (args[0].isObjectPattern) {
          const extract = args[0].extract;
          return [fileItem, extract];
        } else {
          if (fileItem.assigned) {
            return [fileItem];
          } else {
            fileItem.key = path.basename(fileItem.value, path.extname(fileItem.value));
            return [fileItem];
          }
        }
      }
      createRequireModule(args) {
        let [file, extract] = args;
        if (!extract) {
          extract = [file];
        }
        extract.forEach((item2) => {
          const topScope = this.compilation.scope;
          const name = item2.isProperty ? item2.value : item2.key;
          const module2 = this.compilation.createModule(this.namespace, name);
          if (topScope.define(name) === module2) {
          } else {
            topScope.define(name, module2);
            module2.isClass = true;
            module2.required = true;
            module2.isAnnotationCreated = true;
            this.compilation.addModuleStack(module2, this);
            if (!module2.addRequire(item2.key, name, file.value, file.resolveFile, !!item2.isProperty, item2.stack)) {
            }
          }
        });
      }
      extractDependenceRefs(args) {
        let [file, extract] = args;
        if (!extract) {
          extract = [file];
        }
        const target = this.additional && this.additional.module || this.compilation;
        extract.forEach((item2) => {
          const name = item2.isProperty ? item2.value : item2.key;
          if (!target.addRequire(item2.key, name, file.value, file.resolveFile, !!item2.isProperty, item2.stack)) {
          }
        });
      }
      async parserAsync() {
        const _name = this.name.toLowerCase();
        if (_name === "reference") {
          if (!(this.parentStack.isProgram || this.parentStack.isPackageDeclaration)) {
            this.error(1103, this.name);
          }
          if (this.compilation.import === "manifest")
            return null;
          const compilations = this.getAttribute("referenceCompilations");
          if (Array.isArray(compilations)) {
            await this.allSettled(compilations, async (compilation) => await compilation.parserAsync());
          }
        }
      }
      parser() {
        if (super.parser() === false)
          return false;
        const args = this.getArguments();
        const _name = this.name.toLowerCase();
        const ownerModule = this.additional && this.additional.module;
        switch (_name) {
          case "dynamic":
            if (!this.additional || !(this.additional.isClassDeclaration || this.additional.isInterfaceDeclaration || this.additional.isDeclaratorDeclaration || this.additional.isEnumDeclaration && !this.additional.isExpressionDeclare)) {
              this.error(1105, this.name);
            }
            break;
          case "require":
            if (!(this.parentStack && (this.parentStack.isProgram || this.parentStack.isPackageDeclaration))) {
              this.error(1105, this.name);
            }
            this.createRequireModule(this.checkImportParams(args));
            break;
          case "import":
            if (!(this.parentStack && (this.parentStack.isProgram || this.parentStack.isPackageDeclaration))) {
              this.error(1105, this.name);
            }
            this.extractDependenceRefs(this.checkImportParams(args));
            break;
          case "deprecated":
            if (!this.additional || !(this.additional.isMethodDefinition || this.additional.isPropertyDefinition || this.additional.isDeclaratorDeclaration || this.additional.isClassDeclaration)) {
              this.error(1104, this.name);
            }
            break;
          case "hostcomponent":
            if (!args.length || args.length > 1) {
              this.error(1001, 1, args.length);
            }
            const classModule = this.getModuleById(args[0].value);
            if (!classModule) {
              this.error(1083, args[0].value);
            }
            break;
          case "post":
          case "get":
          case "del":
          case "put":
          case "option":
          case "router":
            if (!this.additional || !(this.additional.module.isClass || this.additional.isMethodDefinition)) {
              this.error(1105, this.name);
            }
            break;
          case "callable":
          case "override":
            if (!this.additional || !this.additional.isMethodDefinition) {
              this.error(1104, this.name);
            }
            break;
          case "syntax":
            if (!this.additional || !(this.additional.isPackageDeclaration || this.additional.isProgram || this.additional.isInterfaceDeclaration || this.additional.isDeclaratorDeclaration || this.additional.isDeclaratorTypeAlias || this.additional.isDeclaratorFunction || this.additional.isEnumDeclaration && !this.additional.isExpressionDeclare || this.additional.isClassDeclaration)) {
              if (!this.parentStack.isProgram) {
                this.error(1103, this.name);
              }
            }
            break;
          case "runtime":
            if (!this.additional || !(this.additional.isPackageDeclaration || this.additional.isProgram || this.additional.isInterfaceDeclaration || this.additional.isDeclaratorDeclaration || this.additional.isDeclaratorFunction || this.additional.isEnumDeclaration && !this.additional.isExpressionDeclare || this.additional.isClassDeclaration)) {
              if (!this.parentStack.isProgram) {
                this.error(1103, this.name);
              }
            }
            const value = (args[0].value || "").toLowerCase();
            if (value === "server") {
              this.compilation.setPolicy(Constant.POLICY_SERVER, ownerModule);
            } else if (value === "client") {
              this.compilation.setPolicy(Constant.POLICY_CLIENT, ownerModule);
            } else if (value === "all") {
              this.compilation.setPolicy(Constant.POLICY_ALL, ownerModule);
            } else {
              item.error(1092);
            }
            break;
          case "embed":
            if (this.additional && this.additional.module && !(this.additional.isClassDeclaration || this.additional.isDeclaratorDeclaration || this.additional.isPropertyDefinition)) {
              this.error(1102);
            }
            if (!args.length) {
              this.error(1101);
            }
            args.forEach((item2) => {
              let file = this.compiler.resolve(item2.value, this.file ? path.dirname(this.file) : null);
              var assign = item2.assigned ? item2.key : null;
              var additional = this.additional;
              if (additional && additional.isPropertyDefinition) {
                var top = additional.module && additional.module.methodConstructor ? additional.module.methodConstructor : this.compilation.getStackByModule(additional.module) || additional.compilation;
                assign = top.scope.generateVarName(additional.id.value());
              }
              if (!file) {
                file = this.compiler.normalizePath(item2.value);
                item2.resolveFile = file;
              } else {
                item2.resolveFile = this.compiler.normalizePath(file);
              }
              if (file) {
                const target = additional && additional.module || this.compilation;
                if (!target.addAsset(item2.resolveFile, item2.value, null, path.extname(file), assign, null, this)) {
                  if (target.file === this.compilation.file) {
                    this.error(1106, item2.value);
                  }
                }
              }
            });
            break;
          case "main":
            if (this.additional) {
              const modifier = this.additional.modifier ? this.additional.modifier.value() : "public";
              if (!(modifier === "public" && this.additional.static && this.additional.isMethodDefinition)) {
                this.error(1138, this.name);
              }
            }
            break;
        }
      }
    };
    module.exports = AnnotationDeclaration;
  }
});

// lib/stacks/AnnotationExpression.js
var require_AnnotationExpression = __commonJS({
  "lib/stacks/AnnotationExpression.js"(exports, module) {
    var MergeType = require_MergeType();
    var Stack = require_Stack();
    var Utils2 = require_Utils();
    var ClassGenericType = require_ClassGenericType();
    var path = __require("path");
    var AnnotationExpression = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isAnnotationExpression = true;
        this.body = (node.body || []).map((item2) => {
          const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          if (item2.acceptType) {
            stack2.acceptType = this.createTokenStack(compilation, item2.acceptType, scope, node, this);
          }
          return stack2;
        });
        const name = this.name.toLowerCase();
        const isServer = ["provider", "http", "router"].includes(name);
        if (isServer) {
          const args = this.getArguments();
          const item2 = this.getAnnotationArgumentItem("classname", args, ["classname"]);
          if (item2) {
            this.compilation.hookAsync("compilation.create.after", async () => {
              const desc2 = await this.loadTypeAsync(item2.value);
              if (desc2 && desc2.isModule) {
                this.compilation.addDependency(desc2, this.module);
              }
            });
          }
          const response = this.getAnnotationArgumentItem("response", args);
          if (response) {
            this.compilation.hookAsync("compilation.create.after", async () => {
              const desc2 = await this.loadTypeAsync(response.value);
              if (desc2 && desc2.isModule) {
                this.compilation.addDependency(desc2, this.module);
              }
            });
          }
        }
      }
      get name() {
        return this.node.name;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.body);
        super.freeze(this.scope);
        this.body.forEach((stack2) => stack2.freeze());
      }
      definition(context) {
        if (context) {
          let current = context.stack;
          if (current) {
            if (current.parentStack.isAssignmentPattern) {
              current = current.parentStack;
            }
            const index = this.body.indexOf(current);
            if (index >= 0) {
              const name = this.name.toLowerCase();
              const args = this.getArguments();
              const itemArg = args[index];
              if (name === "http" || name === "router") {
                if (index === 0) {
                  const provideModule = args[0] ? this.getModuleById(args[0].value) : null;
                  if (provideModule && provideModule.isModule) {
                    return provideModule.definition(context);
                  }
                } else if (index === 1) {
                  const provideModule = args[0] ? this.getModuleById(args[0].value) : null;
                  if (provideModule && itemArg && this.isModuleForWebComponent(provideModule)) {
                    let stack2 = itemArg.stack;
                    if (stack2.isAssignmentPattern)
                      stack2 = stack2.right;
                    const desc2 = stack2.description();
                    if (desc2 && desc2.isStack) {
                      return desc2.definition(context);
                    }
                  } else {
                    const result = this.getProviderDescriptor(args);
                    if (result) {
                      const [desc2] = result;
                      if (desc2) {
                        return desc2.definition(context);
                      }
                    }
                  }
                } else if (index > 1 && itemArg) {
                  let stack2 = itemArg.stack;
                  if (stack2.isAssignmentPattern)
                    stack2 = stack2.right;
                  const desc2 = stack2.description();
                  if (desc2 && desc2.isStack) {
                    return desc2.definition(context);
                  }
                }
              }
            }
          }
          return null;
        }
        return {
          expre: `(Annotation) ${this.name}`,
          file: this.compilation.file
        };
      }
      description() {
        return this;
      }
      getArguments() {
        if (this._args) {
          return this._args;
        }
        const target = this._args = [];
        this.body.map((item2, index) => {
          if (item2.isAssignmentPattern) {
            const key = item2.left.value();
            const value = item2.right.value();
            const assigned = true;
            target.push({ key, value, assigned, stack: item2 });
          } else if (item2.isObjectPattern) {
            item2.error(1176, item2.raw());
          } else if (item2.isArrayPattern) {
            item2.error(1176, item2.raw());
          } else if (item2.isIdentifier || item2.isLiteral || item2.isCallExpression || item2.isNewExpression || item2.isConditionalExpression || item2.isMemberExpression || item2.isArrayExpression || item2.isObjectExpression) {
            const key = index;
            const value = item2.isIdentifier || item2.isLiteral || item2.isMemberExpression ? item2.value() : "";
            const assigned = false;
            target.push({ key, value, assigned, stack: item2 });
          } else {
            item2.error(1176, item2.raw());
          }
        });
        return target;
      }
      getProviderDescriptor(args) {
        const classNameArg = args.find((item2) => String(item2.key).toLowerCase() === "classname") || args[0];
        const actionArg = args.find((item2) => String(item2.key).toLowerCase() === "action") || args[1];
        const provideModule = classNameArg ? this.getModuleById(classNameArg.value) : null;
        if (provideModule && provideModule.isModule && actionArg) {
          const flag = provideModule.compilation.parserDoneFlag;
          const desc2 = provideModule.getMember(actionArg.value);
          if (desc2 && desc2.isMethodDefinition && !desc2.isAccessor && Utils2.isModifierPublic(desc2)) {
            return [desc2, flag, provideModule];
          }
        }
        return null;
      }
      type() {
        switch (this.name.toLowerCase()) {
          case "env": {
            const args2 = this.getArguments();
            if (args2.length > 1) {
              return this.getGlobalTypeById("boolean");
            } else if (args2.length > 0) {
              return this.getGlobalTypeById("string");
            }
            return this.getGlobalTypeById("nullable");
          }
          case "url":
          case "provider":
            return this.getGlobalTypeById("string");
          case "router":
            return this.getGlobalTypeById("annotation.IRouter");
          case "http":
            if (this._type)
              return this._type;
            const args = this.getArguments();
            const response = args.find((arg) => String(arg.key).toLowerCase() === "response");
            const HttpResponse = this.getGlobalTypeById("net.HttpResponse");
            const responseField = this.compiler.options.metadata.http.responseField;
            let typeValue = null;
            let flag = true;
            const ctx2 = this.getContext();
            const getResponseType = () => {
              const [desc2, _flag] = this.getProviderDescriptor(args) || [];
              if (desc2) {
                flag = _flag;
                let value = desc2.inferReturnType();
                if (value) {
                  value = MergeType.to(value.type());
                  if (value.isClassGenericType && value.types[0]) {
                    value = value.types[0].type();
                  }
                  if (value) {
                    value = ctx2.apply(value);
                  }
                  if (value && !value.isGenericType) {
                    return value;
                  }
                }
              }
              return this.getGlobalTypeById("any");
            };
            if (response || responseField) {
              const type2 = response && (this.scope.define(response.value) || this.getModuleById(response.value));
              if (type2 && (type2.isTypeStatement || type2.isModule)) {
                return this._type = type2.type();
              } else {
                const desc2 = HttpResponse.getMember(response ? response.value : responseField, "get");
                const declareGenerics = HttpResponse.getModuleGenerics();
                if (desc2) {
                  typeValue = desc2.type();
                  if (declareGenerics && declareGenerics.length > 0) {
                    const index = declareGenerics.indexOf(typeValue);
                    if (index === 0) {
                      typeValue = getResponseType();
                    }
                  }
                }
                if (!typeValue) {
                  typeValue = this.getGlobalTypeById("any");
                }
              }
            } else {
              typeValue = new ClassGenericType(
                [getResponseType()],
                HttpResponse,
                false,
                HttpResponse.moduleStack
              );
            }
            const Promise2 = this.getGlobalTypeById("Promise");
            const _type = new ClassGenericType(
              [typeValue],
              Promise2,
              false,
              Promise2.moduleStack
            );
            if (!flag)
              return _type;
            return this._type = _type;
          default:
            break;
        }
        return this.getGlobalTypeById("any");
      }
      parser() {
        if (super.parser() === false)
          return false;
        const args = this.getArguments();
        const item2 = this.getAnnotationArgumentItem("classname", args, ["classname"]);
        const name = this.name.toLowerCase();
        const isServer = ["provider", "http", "router"].includes(name);
        if (name === "http" || name === "router") {
          args.forEach((item3) => {
            let key = String(item3.key).toLowerCase();
            if (name === "http") {
              const indexes = ["classname", "action", "param", "data", "method", "config"];
              if (item3.key >= 2 && !item3.assigned && indexes[item3.key]) {
                key = indexes[item3.key];
              }
            } else if (name === "router") {
              const indexes = ["classname", "action", "param"];
              if (item3.key >= 2 && !item3.assigned && indexes[item3.key]) {
                key = indexes[item3.key];
              }
            }
            if (key === "data" || key === "param" || key === "params" || key === "config") {
              let stack2 = item3.stack;
              if (stack2.isAssignmentPattern) {
                stack2 = item3.stack.right;
              }
              if (stack2.isCallExpression || stack2.isNewExpression) {
                stack2 = stack2.callee;
              }
              while (stack2.isMemberExpression)
                stack2 = stack2.object;
              if (stack2.isIdentifier) {
                stack2.setRefBeUsed();
              }
            }
          });
        }
        if (isServer) {
          if (!item2) {
            this.error(1001, 1, 0);
          } else {
            const moduleClass = this.getModuleById(item2.value);
            if (!moduleClass) {
              item2.stack.error(1027, item2.value);
            } else {
              this.compilation.addDependency(moduleClass, this.module);
              if (name === "http") {
                const response = this.getAnnotationArgumentItem("response", args);
                if (response) {
                  const HttpResponse = this.getGlobalTypeById("net.HttpResponse");
                  let type2 = HttpResponse.getMember(response.value, "get");
                  if (!type2) {
                    type2 = this.scope.define(response.value) || this.getModuleById(response.value);
                  }
                  if (!type2 || !(type2.isTypeStatement || type2.isType)) {
                    response.stack.error(1175, response.value);
                  }
                }
              }
            }
          }
        } else if (name === "url") {
          if (args.length != 1) {
            this.error(1001, 1, args.length);
          } else {
            args.forEach((item3) => {
              let flag = item3.value.charCodeAt(0) === 64;
              let file = flag ? item3.value.substr(1) : this.compiler.resolve(item3.value, this.file ? path.dirname(this.file) : null);
              if (!file) {
                file = this.compiler.normalizePath(item3.value);
                item3.resolveFile = file;
              } else {
                item3.resolveFile = this.compiler.normalizePath(file);
              }
              if (file) {
                const top = this.module ? this.compilation.getStackByModule(this.module) : this.compilation;
                const name2 = path.basename(item3.resolveFile) || file;
                const assign = top.scope.generateVarName(name2.replace(/(\W)+/g, "_"));
                const target = this.module || this.compilation;
                target.addAsset(item3.resolveFile, item3.value, null, path.extname(file), assign, null, this);
              }
            });
          }
        } else if (name === "env") {
        }
      }
    };
    module.exports = AnnotationExpression;
  }
});

// lib/stacks/Expression.js
var require_Expression = __commonJS({
  "lib/stacks/Expression.js"(exports, module) {
    var Stack = require_Stack();
    var Expression = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isExpression = true;
      }
      reference() {
        const description = this.description();
        if (description !== this && description instanceof Stack) {
          return description.reference();
        }
        return description;
      }
      referenceItems() {
        const description = this.description();
        if (description !== this && description instanceof Stack) {
          return description.referenceItems();
        }
        return [description];
      }
    };
    module.exports = Expression;
  }
});

// lib/types/LiteralArrayType.js
var require_LiteralArrayType = __commonJS({
  "lib/types/LiteralArrayType.js"(exports, module) {
    var Type = require_Type();
    var LiteralArrayType = class extends Type {
      constructor(inherit, target, elements = null) {
        super("$LiteralArrayType", inherit);
        this.isLiteralArrayType = true;
        this.target = target;
        this.elements = elements || target.elements;
        this._hasGenericType = void 0;
      }
      get hasGenericType() {
        if (this._hasGenericType === void 0) {
          this._hasGenericType = this.elements.some((type2) => type2.type().isGenericType);
        }
        return this._hasGenericType;
      }
      attribute(index) {
        if (this.target && !this.target.isTypeTupleDefinition) {
          return this.target.attribute(index);
        }
        return null;
      }
      dynamicAttribute(type2) {
        if (this.target && !this.target.isTypeTupleDefinition) {
          return this.target && this.target.isArrayExpression ? this.target.dynamicAttribute(type2) : null;
        }
        return null;
      }
      clone(inference, flag = false) {
        if (!flag && (!inference || !this.hasGenericType)) {
          return this;
        }
        const elements = inference ? this.elements.map((item2) => item2.type().clone(inference)) : this.elements.slice(0);
        return new LiteralArrayType(this.inherit, this.target, elements);
      }
      getElementTypes() {
        if (this._elementTypes) {
          return this._elementTypes;
        }
        const items = /* @__PURE__ */ new Set();
        this.elements.forEach((item2) => {
          items.add(item2.type());
        });
        return this._elementTypes = Array.from(items.values());
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        } else if (type2.isIntersectionType) {
          return [type2.left, type2.right].some((item2) => this.is(item2.type(), context, options));
        }
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        if (type2.isLiteralArrayType || type2.isTupleType) {
          const errorHandler = context && context.errorHandler || ((result) => result);
          let bases = this.getElementTypes().map((item2) => item2.type());
          if (bases.length === 0)
            return true;
          return type2.elements.every((el) => {
            const elType = el.type();
            return errorHandler(bases.some((acceptType) => acceptType.is(elType, context, options)), bases, el);
          });
        }
        return this.inherit.is(type2, context, options);
      }
      toString(context, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        const elements = this.elements.map((item2) => {
          const type2 = item2.type();
          if (type2 === this)
            return "any";
          return type2.toString(context, options);
        }).join(", ");
        return `[${elements}]`;
      }
    };
    module.exports = LiteralArrayType;
  }
});

// lib/stacks/ArrayExpression.js
var require_ArrayExpression = __commonJS({
  "lib/stacks/ArrayExpression.js"(exports, module) {
    var Expression = require_Expression();
    var LiteralArrayType = require_LiteralArrayType();
    var keySymbol = Symbol("key");
    var ArrayExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isArrayExpression = true;
        this.elements = [];
        this.spreadElement = [];
        node.elements.map((item2) => {
          const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          if (stack2) {
            this.elements.push(stack2);
          }
        });
        this[keySymbol] = {};
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.elements);
        this.elements.forEach((stack2) => stack2.freeze());
      }
      definition() {
        return null;
      }
      attribute(index) {
        if (typeof index === "number") {
          return this.elements[index] || null;
        }
        return null;
      }
      dynamicAttribute(type2) {
        const arrClass = this.getGlobalTypeById("Array");
        if (type2 && arrClass) {
          return arrClass.dynamicAttribute(type2);
        }
        return null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      description() {
        return this;
      }
      type() {
        return this[keySymbol]._type || (this[keySymbol]._type = new LiteralArrayType(this.getGlobalTypeById("array"), this));
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.elements.forEach((item2) => {
          item2.parser();
          item2.setRefBeUsed();
        });
      }
      value() {
        return `[${this.elements.map((elem) => elem.value()).join(",")}]`;
      }
    };
    module.exports = ArrayExpression;
  }
});

// lib/stacks/ArrayPattern.js
var require_ArrayPattern = __commonJS({
  "lib/stacks/ArrayPattern.js"(exports, module) {
    var Stack = require_Stack();
    var Declarator = require_Declarator();
    var ArrayPattern = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isArrayPattern = true;
        this.elements = node.elements.map((item2) => {
          let stack2 = null;
          if (item2.type === "Identifier") {
            if (this.parentStack.isVariableDeclarator || this.parentStack.isFunctionExpression) {
              stack2 = new Declarator(compilation, item2, scope, node, this);
              const context = parentStack.parentStack.kind === "var" ? "function" : "block";
              const name = stack2.value();
              if (scope.isDefine(name, context)) {
                this.error(1007, name);
              }
              scope.define(name, stack2);
            } else {
              stack2 = this.createTokenStack(compilation, item2, scope, node, this);
            }
          } else {
            stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          }
          return stack2;
        });
        if (node.acceptType) {
          this._acceptType = this.createTokenStack(compilation, node.acceptType, scope, node, this);
        }
      }
      get acceptType() {
        if (this.parentStack.isVariableDeclarator) {
          return this.parentStack._acceptType;
        }
        return this._acceptType;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.elements);
        this.elements.forEach((stack2) => stack2.freeze());
      }
      definition() {
        return null;
      }
      setKind(value) {
        this.elements.forEach((item2) => {
          item2.kind = value;
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        const init = this.parentStack.init;
        const is = init && init.isArrayExpression;
        const refs = init && init.type();
        const arrayType = this.getGlobalTypeById("array");
        const iteratorType = this.getGlobalTypeById("Iterator");
        if (init)
          init.parser();
        if (init && !(arrayType.check(refs) || iteratorType.check(refs))) {
          init.error(1012, init.raw(), refs.toString());
        }
        this.elements.forEach((item2, index) => {
          item2.parser();
          const desc2 = item2.description();
          const defaultValue = item2.isAssignmentPattern ? true : false;
          if (desc2) {
            if (item2.isRestElement) {
              if (refs) {
                desc2.assignment(refs, item2);
              }
              return;
            }
            if (is) {
              const value = init.attribute(index);
              if (!defaultValue && !value) {
                item2.error(1014, init.raw(), index);
              }
              if (value) {
                desc2.assignment(value, item2);
              } else if (item2.right) {
                desc2.assignment(item2.right, item2);
              }
            } else {
              let value = refs && (refs.isLiteralArrayType || refs.isTupleType) ? refs.attribute(index) : null;
              if (value) {
                desc2.assignment(value, item2);
              } else if (item2.right) {
                desc2.assignment(item2.right, item2);
              } else if (refs && (refs.isTupleType && !refs.prefix || refs.isLiteralArrayType) && refs.elements.length > 0) {
                item2.error(1014, init.raw(), index);
              }
            }
          }
        });
      }
      value() {
        return this.elements.map((item2) => {
          return item2.value();
        }).join(",");
      }
    };
    module.exports = ArrayPattern;
  }
});

// lib/scope/FunctionScope.js
var require_FunctionScope = __commonJS({
  "lib/scope/FunctionScope.js"(exports, module) {
    var Scope = require_Scope();
    module.exports = class FunctionScope extends Scope {
      constructor(parentScope) {
        super(parentScope);
        this.arguments = [];
        this.returnType = null;
        this.returnItems = [];
        this.key = null;
        this.isArrow = false;
        this.isExpression = false;
      }
      type(name) {
        return name === "function";
      }
    };
  }
});

// lib/types/FunctionType.js
var require_FunctionType = __commonJS({
  "lib/types/FunctionType.js"(exports, module) {
    var Namespace2 = require_Namespace();
    var Type = require_Type();
    var FunctionType = class extends Type {
      constructor(inherit, target, params, returnType, generics) {
        super("$FunctionType", [inherit]);
        this.params = params ? params : target.params || [];
        this._returnType = returnType;
        this.isFunctionType = true;
        this.target = target;
        this.generics = generics || target.genericity && target.genericity.elements || [];
      }
      get returnType() {
        return this.inferReturnType();
      }
      inferReturnType() {
        const r = this._returnType;
        if (!r && this.target && (this.target.isFunctionExpression || this.target.isTypeFunctionDefinition)) {
          return this.target.getReturnedType();
        }
        return r;
      }
      getInferReturnType() {
        const r = this._returnType;
        if (!r && this.target) {
          if (this.target.isFunctionExpression) {
            return this.target.inferReturnType();
          } else {
            return this.target.getReturnedType();
          }
        }
        return r;
      }
      type(context) {
        if (context && context.called) {
          if (this.target && this.target.isFunctionExpression) {
            if (this._returnType) {
              return context.apply(this._returnType);
            } else {
              return this.target.type(context);
            }
          }
          return context.apply(this.returnType);
        }
        return this;
      }
      get hasGenericType() {
        return false;
      }
      checkHasGeneric() {
        if (this._hasGenericType === void 0) {
          this._hasGenericType = this.params.concat(this.returnType, this.generics).some((item2) => {
            const type2 = item2 && item2.type();
            if (type2) {
              if (type2.isFunctionType) {
                return type2.checkHasGeneric();
              }
              return !!type2.hasGenericType;
            }
          });
        }
        return this._hasGenericType;
      }
      clone(inference) {
        return this;
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        if (Namespace2.globals.get("Function") === type2) {
          return true;
        }
        if (!type2.isFunctionType)
          return false;
        const inWrapContext = type2.target && type2.target.parentStack && (type2.target.parentStack.isProperty || type2.target.parentStack.isCallExpression || type2.target.parentStack.isNewExpression);
        if (type2.params.length > 0) {
          const params = this.params;
          const last = params && params[params.length - 1];
          const hasRest = last && last.isRestElement;
          if (!hasRest && this.params.length < type2.params.length) {
            return false;
          }
          const result = type2.params.every((item2, index) => {
            if (inWrapContext && item2.isStack && item2.isDeclarator) {
              if (!item2.acceptType) {
                return true;
              }
            }
            const acceptType = params[index];
            if (!acceptType || last === acceptType) {
              if (hasRest) {
                return last.getItemType().is(item2.type(), context, options);
              }
            }
            let itemType = item2.isObjectPattern ? Namespace2.globals.get("Object") : item2.type();
            return acceptType && acceptType.type().is(itemType, context, options);
          });
          if (!result) {
            return false;
          }
        }
        if (inWrapContext && type2.target.isStack && !type2.target_returnType) {
          return true;
        }
        let left = this.inferReturnType(context);
        let right = type2.inferReturnType(context);
        let res = true;
        if (left) {
          res = right && left.type().is(right.type(), context, options);
        }
        return res;
      }
      definition(context) {
        let location = null;
        let comments = "";
        if (this.target && (this.target.isFunctionExpression || this.target.isTypeFunctionDefinition)) {
          location = (this.target.key || this.target).getLocation();
          comments = this.target.comments || "";
        }
        let expre = this.toString(context);
        return {
          location,
          comments,
          expre: `(type) ${expre}`
        };
      }
      toString(context = {}, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        let complete = !!options.complete;
        let rawcode = options.rawcode;
        options.rawcode = false;
        if (options.complete === void 0 && !options.inferTypeValueFlag && !(context.stack && (context.stack.isCallExpression || context.stack.isNewExpression))) {
          context = {};
          complete = true;
        }
        const params = this.target.params.map((item2, index) => {
          if (item2.isObjectPattern) {
            const properties = item2.properties.map((property) => {
              const name = property.key.value();
              const acceptType = property.type();
              const init = property.init;
              if (init && init.isAssignmentPattern) {
                return `${init.left.value()}:${acceptType.toString(context, options)} = ${init.right.raw()}`;
              }
              return `${name}:${acceptType.toString(context, options)}`;
            });
            return `{${properties.join(",")}}`;
          } else if (item2.isArrayPattern) {
            const properties = item2.elements.map((property) => {
              if (property.isAssignmentPattern) {
                const acceptType2 = property.type();
                return `${property.left.value()}:${acceptType2.toString(context, options)} = ${property.right.raw()}`;
              }
              const name = property.value();
              const acceptType = property.type();
              return `${name}:${acceptType.toString(context, options)}`;
            });
            return `[${properties.join(",")}]`;
          } else {
            const type2 = this.params[index].type();
            const name = item2.value();
            const rest = item2.isRestElement ? "..." : "";
            const question = item2.question ? "?" : "";
            if (item2.isAssignmentPattern && item2.right) {
              const initial = item2.right.value();
              return `${rest}${name}${question}: ${type2.toString(context, options)}=${initial}`;
            }
            return `${rest}${name}${question}: ${type2.toString(context, options)}`;
          }
        });
        const returnType = this.inferReturnType();
        const genOptions = Object.create(options);
        genOptions.complete = complete;
        genOptions.rawcode = rawcode;
        if (options.inbuild) {
          genOptions.rawcode = true;
        }
        const genericity = this.generics.length > 0 ? "<" + this.generics.map((item2) => item2.type().toString(context, genOptions)).join(", ") + ">" : "";
        return `${genericity}(${params.join(", ")})=>${returnType.toString(context)}`;
      }
    };
    module.exports = FunctionType;
  }
});

// lib/types/InstanceofType.js
var require_InstanceofType = __commonJS({
  "lib/types/InstanceofType.js"(exports, module) {
    var Type = require_Type();
    var InstanceofType = class extends Type {
      constructor(inherit, target, generics = [], isThis = false, newModuleType = null) {
        super("$InstanceofType", inherit);
        this.target = target;
        this.isInstanceofType = true;
        this.isThisType = !!isThis;
        if (!generics && !isThis && inherit) {
          const baseType = inherit;
          const declares = baseType.isModule && baseType.getModuleGenerics() || [];
          generics = declares.map((item2) => {
            return item2.type();
          });
        }
        this.newModuleType = newModuleType;
        this.generics = generics || [];
        this.hasGenericType = this.inherit.type().hasGenericType || this.generics.some((type2) => !!(type2 && type2.hasGenericType));
      }
      clone(inference) {
        if (!inference || !this.hasGenericType) {
          return this;
        }
        return new InstanceofType(this.inherit.type().clone(inference), this.target, this.generics.map((type2) => type2.clone(inference)), this.isThisType);
      }
      getTypeKeys() {
        let inherit = this.inherit.type();
        if (inherit.isClassGenericType && inherit.isClassType && this.target.isNewExpression) {
          inherit = inherit.elements[0].type();
        }
        return inherit.getTypeKeys();
      }
      attribute(property, kind = "get") {
        let inherit = this.inherit.type();
        if (inherit.isClassGenericType && inherit.isClassType && this.target.isNewExpression) {
          inherit = inherit.elements[0].type();
        }
        return inherit.getMember(property, kind);
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        } else if (type2.isIntersectionType) {
          return [type2.left, type2.right].some((item2) => this.is(item2.type(), context, options));
        }
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        if (this.isThisType && type2.isInstanceofType && type2.isThisType) {
          return true;
        }
        if (this.target && this.target.isNewExpression && this.target.genericity) {
          const lGenerics = this.target.genericity;
          const tGenerics = type2.isInstanceofType && type2.target.isNewExpression ? type2.target.genericity : null;
          if (!tGenerics || lGenerics.length != tGenerics.length) {
            return false;
          }
          if (!lGenerics.every((item2, index) => item2.type().is(tGenerics[index].type(), context, options))) {
            return false;
          }
        }
        type2 = type2.isInstanceofType ? type2.inherit : type2;
        if (this.inherit.type().is(type2, context, options)) {
          return true;
        }
        if (this.isThisType && type2) {
          return type2.is(this.inherit, context, options);
        }
        return false;
      }
      toString(context, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        if (this.isThisType) {
          return "this";
        }
        let inherit = this.inherit.type();
        if (inherit.isModule && this.generics.length > 0) {
          return `${inherit.getName()}<${this.generics.map((type2) => type2.toString(context, options)).join(", ")}>`;
        }
        if (inherit.isClassGenericType && inherit.isClassType && this.target.isNewExpression) {
          return inherit.elements[0].type().toString(context, options);
        }
        return inherit.toString(context, options);
      }
    };
    module.exports = InstanceofType;
  }
});

// lib/stacks/FunctionExpression.js
var require_FunctionExpression = __commonJS({
  "lib/stacks/FunctionExpression.js"(exports, module) {
    var Utils2 = require_Utils();
    var Declarator = require_Declarator();
    var FunctionScope = require_FunctionScope();
    var Expression = require_Expression();
    var FunctionType = require_FunctionType();
    var MergeType = require_MergeType();
    var InstanceofType = require_InstanceofType();
    var keySymbol = Symbol("key");
    var Namespace2 = require_Namespace();
    var FunctionExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        scope = new FunctionScope(scope);
        super(compilation, node, scope, parentNode, parentStack);
        if (parentStack && parentStack.isMethodDefinition) {
          scope.isMethod = true;
          if (parentStack.isConstructor) {
            scope.isConstructor = true;
            this.isConstructor = true;
          }
        }
        this.isFunctionExpression = true;
        this.genericity = this.createTokenStack(compilation, node.genericity, scope, node, this);
        this._returnType = this.createTokenStack(compilation, node.returnType, scope, node, this);
        this.hasReturnType = !!node.returnType;
        let assignment = null;
        let hasRest = null;
        this.params = node.params.map((item2) => {
          if (item2.type == "Identifier") {
            const stack2 = new Declarator(compilation, item2, scope, node, this);
            if (assignment && !stack2.question) {
              assignment.error(1050, assignment.value());
            }
            scope.define(stack2.value(), stack2);
            return stack2;
          } else {
            const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
            if (stack2.isRestElement) {
              hasRest = stack2;
            }
            assignment = stack2;
            return stack2;
          }
        });
        if (hasRest && this.params[this.params.length - 1] !== hasRest) {
          hasRest.error(1051, hasRest.value());
        }
        this.awaitCount = 0;
        this.async = scope.async = !!node.async;
        if (this.async) {
          scope.asyncParentScopeOf = scope;
        }
        if (!parentStack.isMethod) {
          this.callable = true;
        }
        this.body = this.createTokenStack(compilation, node.body, scope, node, this);
        this[keySymbol] = {};
        if (this.body) {
          this.compilation.hookAsync("compilation.create.after", async () => {
            this.scope.define("arguments", Namespace2.globals.get("IArguments"));
            if (!(this.parentStack.isMethodDefinition || this.isArrowFunctionExpression)) {
              this.scope.define("this", Namespace2.globals.get("Record"));
            }
          });
        }
      }
      freeze() {
        super.freeze();
        super.freeze(this.params);
        this.genericity && this.genericity.freeze();
        this._returnType && this._returnType.freeze();
        this.body && this.body.freeze();
        this.params.forEach((stack2) => stack2.freeze());
      }
      definition(ctx2) {
        let complete = false;
        if (!ctx2 || ctx2.stack && (ctx2.stack === this.key || ctx2.stack === this || ctx2.stack.isMemberExpression)) {
          complete = true;
          ctx2 = this.getContext().parent;
          if (ctx2 && (ctx2.stack.isCallExpression || ctx2.stack.isNewExpression)) {
          } else {
            ctx2 = {};
          }
        }
        const token = this.parentStack.isProperty || this.parentStack.isMethodDefinition ? this.parentStack.key : this.key;
        const type2 = this.getReturnedType();
        const params = this.params.map((item2) => {
          if (item2.isObjectPattern) {
            const properties = item2.properties.map((property) => {
              const name = property.key.value();
              const acceptType = property.type().toString(ctx2);
              const init = property.init;
              if (init && init.isAssignmentPattern) {
                return `${init.left.value()}:${acceptType} = ${init.right.raw()}`;
              }
              return `${name}:${acceptType}`;
            });
            return `{${properties.join(",")}}`;
          } else if (item2.isArrayPattern) {
            const properties = item2.elements.map((property) => {
              const acceptType = property.type().toString(ctx2);
              if (property.isAssignmentPattern) {
                return `${property.left.value()}:${acceptType} = ${property.right.raw()}`;
              }
              const name = property.value();
              return `${name}:${acceptType.toString(ctx2)}`;
            });
            return `[${properties.join(",")}]`;
          } else {
            const name = item2.value();
            const type3 = item2.type().toString(ctx2);
            const rest = item2.isRestElement ? "..." : "";
            const question = item2.question ? "?" : "";
            if (item2.isAssignmentPattern && item2.right) {
              const initial = item2.right.value();
              return `${rest}${name}${question}: ${type3}=${initial}`;
            }
            return `${rest}${name}${question}: ${type3}`;
          }
        });
        const generics = (this.genericity ? this.genericity.elements : []).map((item2) => {
          return item2.type().toString(ctx2, { complete });
        });
        const strGenerics = generics.length > 0 ? `<${generics.join(", ")}>` : "";
        const returnType = type2 ? type2.toString(ctx2) : "void";
        let kind = "function";
        let key = token ? token.value() : "anonymous";
        let loc = null;
        if (this.isNewDefinition) {
          key = this.module.getName();
          kind = "constructor";
          loc = this.getLocation();
        } else if (this.isCallDefinition || this.parentStack.isMethodDefinition) {
          kind = "method";
        }
        if (this.isArrowFunctionExpression || this.isCallDefinition) {
          return {
            comments: this.comments,
            expre: `(${kind}) ${strGenerics}(${params.join(", ")})=>${returnType}`,
            location: this.getLocation(),
            file: this.compilation.file
          };
        }
        return {
          comments: this.comments,
          expre: `(${kind}) ${key}${strGenerics}(${params.join(", ")}): ${returnType}`,
          location: loc || (token ? token.getLocation() : null),
          file: this.compilation.file
        };
      }
      reference(called) {
        if (called) {
          const stack2 = this.scope.returnItems[this.scope.returnItems.length - 1];
          return stack2 ? stack2.reference() : null;
        }
        return this;
      }
      referenceItems(called) {
        if (called) {
          let items = [];
          this.scope.returnItems.forEach((item2) => {
            items = items.concat(item2.referenceItems(called));
          });
          return items;
        } else {
          return [this];
        }
      }
      description() {
        return this;
      }
      getRelateRuturnType(stack2, argument, propertyStack = []) {
        if (stack2.isObjectExpression) {
          return this.getRelateRuturnType(stack2.parentStack, stack2, propertyStack.concat(argument));
        } else if (stack2.isProperty) {
          return this.getRelateRuturnType(stack2.parentStack, stack2, propertyStack);
        } else if (stack2.isArrayExpression) {
          return this.getRelateRuturnType(stack2.parentStack, stack2, propertyStack.concat(argument));
        }
        if (stack2.isVariableDeclarator && (stack2.init === this || !stack2._acceptType)) {
          return null;
        }
        const fetchObjectType = (object, property) => {
          if (property.isProperty) {
            object = stack2.getObjectDescriptorForAuxiliary(object, property.value());
            if (object) {
              return object.type();
            }
          } else if (object.isTupleType && property.parentStack.isArrayExpression) {
            const index2 = property.parentStack.elements.indexOf(property);
            const type2 = object.prefix || object.rest ? object.elements[0] : object.elements[index2];
            if (type2) {
              return type2.type();
            }
          }
          return null;
        };
        const fetchType = (declareParam) => {
          if (!declareParam)
            return null;
          let type2 = declareParam.type();
          if (type2.isTupleType && type2.rest) {
            type2 = type2.elements[0];
          }
          while (type2.isAliasType) {
            type2 = type2.inherit.type();
          }
          if (argument.isArrayExpression || argument.isObjectExpression) {
            let desc3 = type2.type();
            while (desc3 && propertyStack.length > 0) {
              desc3 = fetchObjectType(desc3, propertyStack.pop());
            }
            return desc3;
          }
          return declareParam;
        };
        if (stack2.isAssignmentExpression || stack2.isVariableDeclarator) {
          let result = fetchType(stack2.isVariableDeclarator ? stack2.type() : stack2.left.type());
          if (result) {
            let type2 = result.type();
            if (type2 && type2.isFunctionType && type2.target && type2.target !== this) {
              type2 = type2.target.isFunctionExpression || type2.target.isTypeFunctionDefinition ? type2.target.returnType : null;
              if (type2) {
                return type2.type();
              }
            }
          }
          return null;
        }
        if (!(stack2.isCallExpression || stack2.isNewExpression)) {
          return null;
        }
        let index = stack2.arguments.indexOf(argument);
        let desc2 = stack2.description();
        let funType = stack2.isCallExpression ? stack2.getDeclareFunctionType(desc2) : desc2;
        let declareParams = stack2.getFunDeclareParams(funType);
        if (funType && declareParams) {
          const declare = fetchType(declareParams[index]);
          if (declare) {
            const result = Utils2.extractFunTypeFromType(declare.type());
            if (result) {
              const [funType2, ctx2] = result;
              if (funType2 && funType2.isFunctionType && funType2.target && funType2.target !== this) {
                let returnType = funType2.returnType;
                if (returnType) {
                  returnType = returnType.type();
                  if (ctx2) {
                    returnType = ctx2.fetch(returnType, true);
                  }
                  if (!returnType.isVoidType) {
                    return returnType;
                  }
                }
              }
            }
          }
        }
        return null;
      }
      get returnType() {
        return this.getAttribute("FunctionExpression.returnType", () => {
          let returnResult = null;
          if (this._returnType) {
            returnResult = this._returnType;
          } else {
            if (this.parentStack.isMethodDefinition) {
              const module2 = this.parentStack.module;
              const name = this.parentStack.value();
              const kind = this.parentStack.isMethodGetterDefinition ? "get" : this.parentStack.isMethodSetterDefinition ? "set" : null;
              const getImpModule = (imps) => {
                if (!imps)
                  return null;
                for (var impModule of imps) {
                  if (impModule && impModule !== module2) {
                    const result2 = impModule.getMember(name, kind) || getImpModule(impModule.implements) || getImpModule(impModule.extends);
                    if (result2 && result2.returnType) {
                      return result2;
                    }
                  }
                }
                return null;
              };
              const result = getImpModule(module2.implements) || getImpModule(module2.extends);
              if (result) {
                returnResult = result.returnType;
              }
            } else {
              returnResult = this.getRelateRuturnType(this.parentStack, this);
            }
          }
          if (returnResult) {
            this.getContext().make(returnResult.type());
          }
          return returnResult;
        });
      }
      inferReturnType() {
        if (this.isArrowFunctionExpression && this.scope.isExpression) {
          return this.body.type();
        }
        return this.getAttribute("inferReturnType", () => {
          const returnItems = this.scope.returnItems;
          if (!returnItems || !returnItems.length) {
            return this.getGlobalTypeById("void");
          }
          if (returnItems.length > 1) {
            const mergeType = new MergeType();
            mergeType.keepOriginRefs = false;
            let breakContext = null;
            for (let item2 of returnItems) {
              const desc2 = item2.description();
              if (desc2 && (desc2 === this || desc2.expression === this)) {
                continue;
              }
              const ips = item2.parentStack;
              if (ips.isBlockStatement && ips.parentStack.isIfStatement) {
                if (ips.parentStack.alternate === ips) {
                  if (ips.parentStack.parentStack && ips.parentStack.parentStack.parentStack === this) {
                    breakContext = ips.parentStack.parentStack;
                  }
                }
                mergeType.add(item2.type());
              } else if (ips.isSwitchCase) {
                mergeType.add(item2.type());
              } else {
                if (breakContext === ips && ips.parentStack === this) {
                  break;
                }
                mergeType.add(item2.type());
              }
            }
            return mergeType.type();
          }
          return MergeType.to(returnItems[0].type());
        });
      }
      normalization(type2) {
        if (type2 && type2.isUnionType) {
          if (type2.elements.some((type3) => {
            type3 = type3.type();
            return type3 && type3.isAnyType;
          })) {
            return this.getGlobalTypeById("any");
          }
        }
        return type2;
      }
      getReturnedType() {
        return this.getAttribute("getReturnedType", () => {
          let type2 = this.returnType;
          let value = null;
          if (type2) {
            value = this.normalization(type2.type());
          } else if (this.async) {
            value = new InstanceofType(Namespace2.globals.get("Promise"), null, [this.inferReturnType()]);
          } else {
            value = this.inferReturnType();
          }
          return value;
        });
      }
      type() {
        return this.getFunType();
      }
      getFunType() {
        return this.getAttribute("getFunType", () => {
          return new FunctionType(Namespace2.globals.get("Function"), this);
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.genericity) {
          this.genericity.parser();
        }
        this.params.forEach((item2) => {
          item2.parser();
        });
        if (this._returnType) {
          this._returnType.parser();
          this._returnType.setRefBeUsed();
        }
        if (this.isNewDefinition || this.isCallDefinition) {
          return;
        }
        if (this.body) {
          this.body.parser();
        }
        if (this.parentStack && this.parentStack.parentStack && this.parentStack.parentStack.isUseExtendStatement) {
          return true;
        }
        if (!this.isDeclaratorFunction) {
          const isInterface = this.module && (this.module.isDeclaratorModule || this.module.isInterface);
          if (this.isConstructor && this.module && !isInterface && !this.module.callable) {
            if (this.scope.returnItems.length > 0) {
              const last = this.scope.returnItems[this.scope.returnItems.length - 1];
              last.error(1052);
            }
            if (this.module.extends[0] && this.scope.firstSuperIndex != 1) {
              (this.body.childrenStack[0] || this.key).error(1053);
            }
          } else if (!isInterface) {
            let acceptType = this.returnType;
            if (acceptType) {
              acceptType = acceptType.type();
              const hasVoidType = (type2) => {
                if (!type2)
                  return false;
                if (type2.isVoidType)
                  return true;
                return type2.isUnionType ? type2.elements.some((el) => hasVoidType(el.type())) : false;
              };
              if (!hasVoidType(acceptType)) {
                if (this.async) {
                  const promiseType = Namespace2.globals.get("Promise");
                  if (promiseType && !promiseType.is(acceptType.type())) {
                    (this._returnType || this).error(1055, promiseType.toString());
                  }
                } else if (!this.scope.returnItems.length) {
                  if (!(this.scope.isArrow && this.scope.isExpression)) {
                    const target = this.parentStack.isMethodDefinition ? this.parentStack.key : this.key;
                    const body = this.body;
                    const has = (body && body.isBlockStatement && body.body).some((item2) => {
                      return !!(item2 && item2.isThrowStatement);
                    });
                    if (!has) {
                      (target || this).error(1133);
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
    module.exports = FunctionExpression;
  }
});

// lib/stacks/ArrowFunctionExpression.js
var require_ArrowFunctionExpression = __commonJS({
  "lib/stacks/ArrowFunctionExpression.js"(exports, module) {
    var FunctionExpression = require_FunctionExpression();
    var ArrowFunctionExpression = class extends FunctionExpression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isArrowFunctionExpression = true;
        this.scope.isArrow = true;
        this.scope.isExpression = !!node.expression;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.scope.isExpression) {
          let acceptType = this.returnType;
          if (acceptType) {
            acceptType = acceptType.type();
            if (acceptType && !acceptType.isGenericType && !acceptType.check(this.body)) {
              this.body.error(1002, this.body.type().toString(), acceptType.toString());
            }
          }
        }
      }
      reference() {
        if (this.scope.isExpression) {
          return this.body;
        }
        return super.reference();
      }
      referenceItems() {
        if (this.scope.isExpression) {
          return [this.body];
        }
        return super.referenceItems();
      }
    };
    module.exports = ArrowFunctionExpression;
  }
});

// lib/stacks/AssignmentExpression.js
var require_AssignmentExpression = __commonJS({
  "lib/stacks/AssignmentExpression.js"(exports, module) {
    var Expression = require_Expression();
    var AssignmentExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isAssignmentExpression = true;
        this.left = this.createTokenStack(compilation, node.left, scope, node, this);
        this.right = this.createTokenStack(compilation, node.right, scope, node, this);
        this.left.accessor = "set";
        this.operator = node.operator;
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
      }
      definition(context) {
        return this.left.definition(context);
      }
      description() {
        const desc2 = this.left.description();
        if (desc2 && desc2.isPropertyDefinition) {
          return desc2.description();
        }
        return desc2;
      }
      getContext() {
        const desc2 = this.description();
        if (desc2 && desc2.isStack) {
          return desc2.getContext();
        }
        return super.getContext();
      }
      type(ctx2) {
        return this.right.type(ctx2);
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.left.parser();
        this.right.parser();
        this.left.setRefBeUsed();
        this.right.setRefBeUsed();
        let desc2 = this.description();
        if (desc2 && desc2.isComputeType) {
          desc2 = this.left.type();
          this.checkExpressionType(desc2, this.right);
        } else if (desc2 && !desc2.isAnyType) {
          let identi = this.left;
          if (identi.isMemberExpression) {
            identi = identi.property;
          }
          if (this.left.isArrayPattern || this.left.isObjectPattern) {
          } else {
            if (desc2.kind === "const" || !desc2.assignment) {
              if (desc2.isTypeObjectPropertyDefinition) {
                this.checkExpressionType(desc2, this.right, identi);
              } else {
                if (!this.left.isMemberExpression) {
                  this.error(1015, this.left.value());
                }
              }
            } else {
              desc2.assignment(this.right, identi);
            }
          }
        }
      }
      value() {
        return this.left.value();
      }
      raw() {
        return this.left.raw();
      }
    };
    module.exports = AssignmentExpression;
  }
});

// lib/stacks/AssignmentPattern.js
var require_AssignmentPattern = __commonJS({
  "lib/stacks/AssignmentPattern.js"(exports, module) {
    var Declarator = require_Declarator();
    var AssignmentPattern = class extends Declarator {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isAssignmentPattern = true;
        this.left = this.createTokenStack(compilation, node.left, scope, node, this);
        this.right = this.createTokenStack(compilation, node.right, scope, node, this);
        if (!(parentStack && (parentStack.isArrayPattern || parentStack.isProperty))) {
          this._acceptType = this.createTokenStack(compilation, node.left.acceptType, scope, node, this);
        }
        const isAssignment = this.parentStack.isArrayPattern && this.parentStack.parentStack.isAssignmentExpression;
        if (!(isAssignment || this.parentStack.isAnnotationDeclaration || this.parentStack.isAnnotationExpression)) {
          const stack2 = this.getParentStack((stack3) => !!(stack3.isVariableDeclaration || stack3.isBlockStatement));
          const name = this.left.value();
          let context = void 0;
          if (stack2 && stack2.isVariableDeclaration) {
            context = stack2.kind === "var" ? "function" : "block";
          }
          if (scope.isDefine(name, context)) {
            this.error(1007, name);
          }
          scope.define(name, this);
          this.assignValue = this.right;
          this.assignFirstValue = this.right;
          this.assignItems.add(this.right);
        }
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
      }
      type() {
        if (this.parentStack && this.parentStack.isAnnotationDeclaration && this.parentStack.name.toLowerCase() === "embed") {
          const item2 = this.parentStack.getArguments()[0];
          if (item2.assigned && /\.(css|less|scss|sass)$/i.test(item2.value)) {
            return this.getGlobalTypeById("object");
          }
        }
        if (this.acceptType) {
          return this.acceptType.type();
        }
        if (this.inheritInterfaceAcceptType) {
          return this.inheritInterfaceAcceptType.type();
        }
        if (this.parentStack.isTryStatement) {
          return this.getGlobalTypeById("Error");
        }
        const desc2 = this.description();
        if (desc2 && desc2 !== this) {
          return this.getContext().apply(desc2.type());
        }
        return super.type();
      }
      description() {
        const p = this.parentStack;
        var desc2 = null;
        if (p.isProperty && p.parentStack.isObjectPattern && p.parentStack.parentStack.isVariableDeclarator) {
          const init = p.parentStack.parentStack.init;
          if (init) {
            const type2 = init.type();
            const isStatic = type2.isClassGenericType && type2.isClassType || p.parentStack.parentStack.init.description() === type2;
            desc2 = this.getObjectDescriptor(init.type(), this.left.value(), isStatic);
            if (desc2 && (desc2.isAnyType || desc2.isGenericType || desc2.isNullableType || desc2.isNeverType)) {
              desc2 = null;
            }
          }
        } else if (p.isArrayPattern && p.parentStack.isAssignmentExpression) {
          return this.left.description();
        }
        if (desc2) {
          return desc2;
        }
        return super.description();
      }
      definition(context) {
        const type2 = this.type().toString();
        const identifier = this.value();
        if (this.parentStack.isFunctionExpression) {
          return super.definition(context);
        }
        if (this.parentStack.isAnnotationDeclaration || this.parentStack.isAnnotationExpression) {
          return this.parentStack.definition(context);
        } else if (this.isParamDeclarator) {
          return super.definition(context);
        } else if (this.parentStack.isProperty) {
          return this.parentStack.definition(context);
        }
        return {
          kind: this.kind,
          identifier,
          expre: `${this.kind} ${identifier}:${type2}`,
          location: this.left.getLocation(),
          file: this.compilation.file,
          context: this
        };
      }
      value() {
        return this.left.value();
      }
      error(code, ...args) {
        this.left.error(code, ...args);
      }
      warn(code, ...args) {
        this.left.warn(code, ...args);
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.acceptType) {
          this.acceptType.parser();
        }
        this.right.parser();
        if (this.module && this.module.id === this.left.value()) {
          this.left.error(1008, this.left.value());
        }
        const isStatement = this.parentStack.isFunctionExpression;
        const isNullable = isStatement && this.right.isLiteral && this.right.value() === null;
        if (!isNullable) {
          this.checkExpressionType(this.acceptType, this.right);
        }
        const lDesc = this.left.description();
        const rDesc = this.right.description();
        if (lDesc === rDesc) {
          this.error(1010, this.right.value());
        }
      }
    };
    module.exports = AssignmentPattern;
  }
});

// lib/stacks/AwaitExpression.js
var require_AwaitExpression = __commonJS({
  "lib/stacks/AwaitExpression.js"(exports, module) {
    var Utils2 = require_Utils();
    var Expression = require_Expression();
    var AwaitExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        node.name = "await";
        super(compilation, node, scope, parentNode, parentStack);
        this.isAwaitExpression = true;
        this.argument = this.createTokenStack(compilation, node.argument, scope, node, this);
        if (parentStack) {
          parentStack.isAwaitExpression = true;
        }
        let parent = parentStack;
        while (parent && !parent.isFunctionExpression) {
          parent.scope.hasChildAwait = true;
          parent.hasAwait = true;
          parent = parent.parentStack;
        }
        if (parent.isFunctionExpression) {
          parent.hasAwait = true;
        }
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
      }
      definition() {
        return null;
      }
      description() {
        return this.argument.description();
      }
      getContext() {
        return this.argument.getContext();
      }
      type() {
        const type2 = this.argument.type();
        const origin = Utils2.getOriginType(type2);
        const PromiseType = this.getGlobalTypeById("Promise");
        if (origin && PromiseType && PromiseType.is(origin)) {
          if (type2.isInstanceofType && type2.generics[0]) {
            return type2.generics[0].type();
          } else if (type2.isClassGenericType) {
            return type2.types[0].type();
          }
        }
        return type2;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.argument.parser();
        const stack2 = this.getParentStack((stack3) => !!stack3.isFunctionExpression);
        if (!stack2 && !stack2.async) {
          this.error(1017);
        }
        const type2 = this.argument.type();
        const PromiseType = this.getGlobalTypeById("Promise");
        if (!(type2 && PromiseType && PromiseType.is(type2))) {
          this.error(1018);
        }
      }
    };
    module.exports = AwaitExpression;
  }
});

// lib/stacks/BinaryExpression.js
var require_BinaryExpression = __commonJS({
  "lib/stacks/BinaryExpression.js"(exports, module) {
    var Utils2 = require_Utils();
    var Expression = require_Expression();
    var BinaryExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isBinaryExpression = true;
        this.left = this.createTokenStack(compilation, node.left, scope, node, this);
        this.right = this.createTokenStack(compilation, node.right, scope, node, this);
        this.operator = this.node.operator;
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
      }
      definition() {
        return null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      description() {
        return this;
      }
      type(ctx2) {
        const operator = this.operator;
        if (operator === "instanceof" || operator === "is") {
          return this.getGlobalTypeById("boolean");
        } else {
          const code = operator.charCodeAt(0);
          if (code === 33 || code === 60 || code === 61 || code === 62) {
            return this.getGlobalTypeById("boolean");
          } else if (code === 43) {
            const stringType = this.getGlobalTypeById("string");
            if (stringType.check(this.left, ctx2) || stringType.check(this.right, ctx2)) {
              return stringType;
            }
          }
          return this.getGlobalTypeById("number");
        }
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.left.parser();
        this.left.setRefBeUsed();
        this.right.parser();
        this.right.setRefBeUsed();
        const operator = this.node.operator;
        if (operator === "instanceof" || operator === "is") {
          const lDesc = this.left.description();
          const lType = this.left.type();
          if (lType) {
            if (lDesc && Utils2.isTypeModule(lDesc) || lType.isLiteralType || lType.isClassType || lType.isClassGenericType) {
              this.left.error(1019, this.left.value());
            }
          }
          const rightType = this.right.description();
          if (!Utils2.isTypeModule(rightType)) {
            if (!rightType || !rightType.isAnyType) {
              this.right.error(1021, operator);
            }
          } else {
            this.compilation.addDependency(rightType, this.module);
          }
        }
      }
    };
    module.exports = BinaryExpression;
  }
});

// lib/scope/BlockScope.js
var require_BlockScope = __commonJS({
  "lib/scope/BlockScope.js"(exports, module) {
    var Scope = require_Scope();
    module.exports = class BlockScope extends Scope {
      constructor(parentScope) {
        super(parentScope);
      }
      type(name) {
        return name === "block";
      }
    };
  }
});

// lib/stacks/BlockStatement.js
var require_BlockStatement = __commonJS({
  "lib/stacks/BlockStatement.js"(exports, module) {
    var Stack = require_Stack();
    var BlockScope = require_BlockScope();
    var BlockStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        if (parentStack && !(parentStack.isFunctionDeclaration || parentStack.isFunctionExpression || parentStack.isArrowFunctionExpression || parentStack.isForOfStatement || parentStack.isForInStatement || parentStack.isForStatement || parentStack.isWhenStatement)) {
          scope = new BlockScope(scope);
        }
        super(compilation, node, scope, parentNode, parentStack);
        this.isBlockStatement = true;
        this.body = [];
        for (const item2 of node.body) {
          const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          if (stack2) {
            this.body.push(stack2);
          }
        }
        ;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.scope);
        super.freeze(this.body);
        this.body.forEach((stack2) => stack2.freeze());
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        let fristReturnAt = -1;
        this.body.forEach((item2, index) => {
          item2.parser();
          if (fristReturnAt === -1) {
            if (item2.hasReturnStatement || item2.hasThrowStatement) {
              if (index + 1 < this.body.length) {
                fristReturnAt = index;
              }
            }
          }
        });
        if (fristReturnAt >= 0) {
          const start = this.body[fristReturnAt + 1];
          const end = this.body[this.body.length - 1];
          if (start && end) {
            const startRange = this.compilation.getRangeByNode(start.node);
            const endRange = this.compilation.getRangeByNode(end.node);
            const range = {
              loc: {
                start: startRange.start,
                end: endRange.end
              }
            };
            this.compilation.unnecessary(range, 1184);
          }
        }
      }
    };
    module.exports = BlockStatement;
  }
});

// lib/stacks/BreakStatement.js
var require_BreakStatement = __commonJS({
  "lib/stacks/BreakStatement.js"(exports, module) {
    var Stack = require_Stack();
    var BreakStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isBreakStatement = true;
        this.label = this.createTokenStack(compilation, node.label, scope, node, this);
        let parent = parentStack;
        while (parent && !parent.isFunctionExpression) {
          if (parent.isSwitchCase || parent.isSwitchStatement || parent.isWhileStatement || parent.isDoWhileStatement || parent.isBlockStatement) {
            parent.hasBreak = true;
            break;
          }
          parent = parent.parentStack;
        }
      }
      freeze() {
        super.freeze(this);
        this.label.freeze();
      }
      getLabelStackByName(name) {
        let labelStack = this.getParentStack((stack2) => !!(stack2.isLabeledStatement || stack2.isFunctionExpression));
        while (labelStack && labelStack.isLabeledStatement) {
          if (labelStack.label.value() === name) {
            return labelStack;
          }
          labelStack = labelStack.labelParent;
        }
        return null;
      }
      definition(context) {
        if (this.label) {
          const labelStack = this.getLabelStackByName(this.label.value());
          if (labelStack) {
            return labelStack.definition(context);
          }
        }
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.label) {
          const labelStack = this.getLabelStackByName(this.label.value());
          if (!labelStack || !labelStack.isLabeledStatement) {
            this.label.error(1022);
          }
        }
        let parent = this.parentStack;
        while (parent) {
          if (parent.isSwitchCase || parent.isDoWhileStatement || parent.isWhileStatement || parent.isForStatement || parent.isForOfStatement || parent.isForInStatement) {
            return true;
          } else if (parent.isFunctionExpression) {
            break;
          } else {
            parent = parent.parentStack;
          }
        }
        this.error(1023);
      }
    };
    module.exports = BreakStatement;
  }
});

// lib/stacks/CallDefinition.js
var require_CallDefinition = __commonJS({
  "lib/stacks/CallDefinition.js"(exports, module) {
    var FunctionExpression = require_FunctionExpression();
    var CallDefinition = class extends FunctionExpression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isCallDefinition = true;
        this.module.addDescriptor("#" + this.module.id, this);
        this.callable = true;
      }
    };
    module.exports = CallDefinition;
  }
});

// lib/stacks/CallExpression.js
var require_CallExpression = __commonJS({
  "lib/stacks/CallExpression.js"(exports, module) {
    var Utils2 = require_Utils();
    var Expression = require_Expression();
    var Stack = require_Stack();
    var Namespace2 = require_Namespace();
    var keySymbol = Symbol("key");
    var CallExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isCallExpression = true;
        this.callee = this.createTokenStack(compilation, node.callee, scope, node, this);
        this.arguments = node.arguments.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
        this.genericity = null;
        if (node.genericity) {
          this.genericity = node.genericity.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
        }
        this[keySymbol] = {};
      }
      freeze() {
        super.freeze(this);
        this.callee.freeze();
        super.freeze(this.genericity);
        (this.genericity || []).forEach((stack2) => stack2.freeze());
      }
      definition() {
        const identifier = this.callee.value();
        let description = this.description();
        if (!description && this.parentStack.isWhenStatement) {
          const type2 = "boolean";
          const params = this.arguments.map((item2) => item2.value());
          return {
            comments: this.comments,
            expre: `(method) ${identifier}(${params.join(",")}):${type2}`,
            location: this.callee.getLocation(),
            file: this.compilation.file
          };
        }
        if (!description)
          return null;
        if (description && (description.isType && description.isAnyType)) {
          return {
            expre: `any`
          };
        }
        const context = this.getContext();
        if (description.isDeclaratorVariable) {
          const desc2 = this.getDeclareFunctionType(description);
          const def = desc2.definition(context);
          if (def && def.expre.startsWith("(method)")) {
            def.expre = `(alias ${description.id})${def.expre.slice(8)}`;
          }
          return def;
        } else if (Utils2.isTypeModule(description) && description !== Namespace2.globals.get("Function")) {
          description = this.getDeclareFunctionType(description);
        }
        return description.definition(context);
      }
      reference() {
        let description = this.description();
        if (description) {
          if (description instanceof Stack) {
            return description.reference(true);
          } else if (description.isFunctionType) {
            return description.type();
          }
        }
        return null;
      }
      referenceItems() {
        let description = this.description();
        if (description) {
          if (description instanceof Stack) {
            return description.referenceItems(true);
          } else if (description.isFunctionType) {
            return [].concat(description.type());
          }
        }
        return [];
      }
      description() {
        let desc2 = this.callee.description();
        if (!desc2)
          return this.getGlobalTypeById("any");
        return desc2;
      }
      value() {
        return this.callee.value();
      }
      doGetDeclareFunctionType(description) {
        if (!description)
          return null;
        if (description.isTypeObjectPropertyDefinition) {
          description = description.type();
        } else if (description.isPropertyDefinition) {
          description = description.type();
        } else if (description.isTypeObjectPropertyDefinition) {
          description = description.type();
        } else if (description.isProperty && !description.hasAssignmentPattern) {
          description = description.type();
        } else if (description.isDeclarator) {
          description = description.type();
        }
        if (description) {
          if (description.isAliasType) {
            description = this.getDeclareFunctionType(description.inherit.type());
          }
          if (description.isDeclaratorVariable) {
            const type2 = description.declarations[0].type();
            if (type2.isClassGenericType) {
              this.getContext().make(type2);
            }
            const origin = Utils2.getOriginType(type2);
            if (origin === Namespace2.globals.get("Function")) {
              return origin;
            }
            if (Utils2.isTypeModule(origin)) {
              return this.getMatchDescriptor(`#${origin.id}`, origin);
            }
          } else if (Utils2.isTypeModule(description) && description !== Namespace2.globals.get("Function")) {
            return this.getMatchDescriptor(`#${description.id}`, description);
          }
        }
        return description;
      }
      getDeclareFunctionType(type2) {
        if (!type2)
          return null;
        return this.getAttribute("CallExpression.getDeclareFunctionType", () => this.doGetDeclareFunctionType(type2));
      }
      getFunDeclareParams(description) {
        if (!description)
          return [];
        const declareParams = description.isFunctionType && description.target ? description.target.params : description.params;
        return declareParams || [];
      }
      getDeclareGenerics(description) {
        const genericity = description.isFunctionType && description.target ? description.target.genericity : description.genericity;
        const classModule = description.isFunctionType && description.target ? description.target.module : description.module;
        const classGenerics = Utils2.isTypeModule(classModule) ? classModule.moduleStack.genericity : null;
        return [genericity ? genericity.elements : [], classGenerics];
      }
      getRawType() {
        const type2 = this.type();
        return this.getAttribute("CallExpression.getRawType") || type2;
      }
      type() {
        return this.getAttribute("CallExpression.type", () => {
          let description = this.description();
          if (!description) {
            return Namespace2.globals.get("any");
          }
          let type2 = null;
          description = this.getDeclareFunctionType(description);
          if (description.isMethodDefinition || description.isFunctionExpression) {
            const result = description.getReturnedType();
            if (result) {
              type2 = result.type();
            }
          } else {
            let result = description.type();
            if (result.isInstanceofType && result.isThisType) {
              const refs = this.callee;
              if (refs && refs.isMemberExpression) {
                result = refs.object.type();
              } else {
                result = refs.type();
              }
            }
            if (result && result.isFunctionType) {
              result = result.returnType;
              if (result) {
                type2 = result.type();
              }
            }
          }
          if (!type2) {
            return Namespace2.globals.get("any");
          }
          if (type2.isInstanceofType && type2.isThisType && this.callee.isMemberExpression) {
            return this.callee.object.type();
          }
          const context = this.getContext();
          let final = context.apply(type2);
          if (final.isInstanceofType && final.target && final.target.isNewExpression) {
            const inherit = final.inherit.type();
            if (inherit.isClassGenericType && inherit.isClassType) {
              final = inherit.elements[0].type();
              this.setAttribute("CallExpression.getRawType", final);
            }
          }
          context.make(final);
          return final;
        });
      }
      parserArguments() {
        this.arguments.forEach((item2) => {
          item2.parser();
          item2.setRefBeUsed();
        });
      }
      isCallableDesc(desc2) {
        if (!(desc2.callable || desc2.isAnyType || desc2.isFunctionType || this.callee.isSuperExpression)) {
          if (desc2.isUnionType && Array.isArray(desc2.elements)) {
            return desc2.elements.some((item2) => this.isCallableDesc(item2.type()));
          }
          return false;
        }
        return true;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.callee.parser();
        this.callee.setRefBeUsed();
        let description = this.getDeclareFunctionType(this.description());
        if (!description || description.isAnyType || description === Namespace2.globals.get("Function")) {
          this.parserArguments();
          return true;
        }
        const whenThrow = this.callee.isMemberExpression ? this.callee.property : this.callee;
        if (!this.isCallableDesc(description)) {
          whenThrow.error(1006, this.value());
          this.parserArguments();
          return true;
        }
        if (description.isMethodDefinition || description.isFunctionExpression && !description.isDeclaratorFunction) {
          if (description.isNoop) {
            whenThrow.unnecessary(1185);
          } else {
            let fnStatement = description.isMethodDefinition ? description.expression : description;
            if (fnStatement && fnStatement.body && fnStatement.body.isBlockStatement) {
              if (fnStatement.body.body.length === 0) {
                whenThrow.unnecessary(1185);
              }
            }
          }
        }
        const context = this.getContext();
        const [declareGenerics, classGenerics] = this.getDeclareGenerics(description);
        const declareParams = this.getFunDeclareParams(description);
        const declareTypeParams = declareParams;
        const length = declareParams.length;
        const args = this.arguments;
        if (this.genericity) {
          const last = this.genericity[this.genericity.length - 1];
          if (declareGenerics.length < 1) {
            last.error(1004, 0, this.genericity.length);
          } else {
            const requires = declareGenerics.filter((item2) => !item2.isGenericTypeAssignmentDeclaration);
            if (requires.length > this.genericity.length) {
              if (requires.length === declareGenerics.length) {
                last.error(1004, requires.length, this.genericity.length);
              } else {
                last.error(1005, requires.length, declareGenerics.length, this.genericity.length);
              }
            }
            this.genericity.forEach((item2, index) => {
              item2.parser();
              const declareType = declareGenerics[index] && declareGenerics[index].type();
              if (declareType) {
                context.setValue(declareType, item2);
                if (declareType.hasConstraint) {
                  const constraint = declareType.inherit.type();
                  if (!constraint.check(item2, context)) {
                    item2.error(1003, item2.type().toString(context), constraint.toString(context));
                  }
                }
              }
            });
          }
          this.parserArguments();
        } else {
          context.extracts(declareParams, args, declareGenerics, true);
        }
        const requireParams = declareParams.filter((item2) => !(item2.question || item2.isAssignmentPattern || item2.isRestElement));
        const requireCount = requireParams.length;
        const argsLength = args.length;
        let hasRest = false;
        if (length > 0) {
          const checkArguments = (index, args2, declareParams2, declareTypes, top = false) => {
            let checkResult = true;
            for (; index < args2.length; index++) {
              const argument = args2[index];
              const argumentType = argument.type();
              const declareParamType = declareTypes[index];
              const declareParamItem = declareParams2[index];
              if (!(declareParamType && declareParamItem))
                continue;
              let _ctx = context;
              let acceptType = declareParamType.type();
              if (this.isGenericsRelationValue(acceptType, declareGenerics, this.genericity)) {
                continue;
              }
              if (acceptType && acceptType.isGenericType) {
                acceptType = context.fetch(acceptType, true);
              }
              if (acceptType && acceptType.isClassGenericType) {
                _ctx = context.createChild(argument);
                _ctx.assignment(acceptType);
              }
              if (argument.isSpreadElement) {
                if (top)
                  hasRest = true;
                if (!argumentType.isAnyType) {
                  if (!(argumentType.isTupleType || argumentType.isLiteralArrayType || Namespace2.globals.get("array").is(argumentType))) {
                    argument.error(1154);
                    return false;
                  } else {
                    if (declareParamItem.isRestElement) {
                      checkResult = this.checkArgumentItemType(argument, declareParamItem, acceptType, _ctx);
                    } else {
                      return checkArguments(index, argumentType.elements, declareParams2, declareTypes);
                    }
                  }
                }
              } else {
                const isRest = acceptType && acceptType.target && acceptType.target.isTypeTupleRestDefinition;
                if (isRest || declareParamItem.isRestElement) {
                  if (top)
                    hasRest = true;
                  let restParamType = acceptType;
                  let result = true;
                  for (; index < args2.length; index++) {
                    let argument2 = args2[index];
                    const res = restParamType.elements.some((declare) => {
                      const acceptType2 = declare.type();
                      if (acceptType2.isTupleType && argument2.isArrayExpression || argument2.isObjectExpression) {
                        return this.checkArgumentItemType(argument2, declare, acceptType2, _ctx);
                      } else {
                        return acceptType2.check(argument2, _ctx);
                      }
                    });
                    if (!res) {
                      argument2.error(1002, argument2.type().toString(_ctx), restParamType.toString(_ctx));
                      result = false;
                    }
                  }
                  return result;
                } else {
                  if (!this.checkArgumentItemType(argument, declareParamItem, acceptType, _ctx)) {
                    checkResult = false;
                  }
                }
              }
            }
            return checkResult;
          };
          checkArguments(0, args, declareParams, declareTypeParams, true);
        }
        if (!hasRest) {
          if (requireCount > 0 && argsLength < requireCount || length < argsLength) {
            whenThrow.error(1e3, requireCount, argsLength);
          }
        }
      }
      value() {
        return this.callee.value();
      }
      raw() {
        return this.callee.raw();
      }
    };
    module.exports = CallExpression;
  }
});

// lib/scope/ClassScope.js
var require_ClassScope = __commonJS({
  "lib/scope/ClassScope.js"(exports, module) {
    var Scope = require_Scope();
    module.exports = class ClassScope extends Scope {
      constructor(parentScope, isStatic) {
        super(parentScope);
        this.isStatic = isStatic;
        this.level = parentScope ? parentScope.level + 1 : 1;
      }
      type(name) {
        return name === "class";
      }
    };
  }
});

// lib/stacks/ClassDeclaration.js
var require_ClassDeclaration = __commonJS({
  "lib/stacks/ClassDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var Utils2 = require_Utils();
    var ClassScope = require_ClassScope();
    var ClassDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        scope = scope && scope.type("class") ? scope : new ClassScope(scope);
        super(compilation, node, scope, parentNode, parentStack);
        this.isClassDeclaration = true;
        this._metatypes = [];
        this._annotations = [];
        this._imports = [];
        this.usings = [];
        this.body = [];
        this.id = this.createTokenStack(compilation, node.id, scope, node, this);
        this.modifier = this.createTokenStack(compilation, node.modifier, scope, node, this);
        const module2 = this.module = compilation.createModule(this.namespace, this.id.value(), this.modifier ? this.modifier.value() === "internal" : false);
        this.id.module = module2;
        this.abstract = this.createTokenStack(compilation, node.abstract, scope, node, this);
        this.inherit = this.createTokenStack(compilation, node.superClass, scope, node, this);
        if (node.superClass && node.superClass.genericity) {
          this.inherit.assignGenerics = node.superClass.genericity.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
        }
        this.isFinal = module2.isFinal = !!node.final;
        this.static = this.createTokenStack(compilation, node.static, scope, node, this);
        this.implements = (node.implements || []).map((item2) => {
          const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          if (item2.genericity) {
            stack2.assignGenerics = item2.genericity.map((item3) => this.createTokenStack(compilation, item3, scope, node, this));
          }
          return stack2;
        });
        scope.define(module2.id, module2);
        this.genericity = this.createTokenStack(compilation, node.genericity, scope, node, this);
        this.dynamic = false;
        module2.abstract = !!this.abstract;
        module2.isValid = true;
        module2.isClass = true;
        module2.dynamic = false;
        module2.static = !!this.static;
        module2.genericity = this.genericity;
        module2.comments = this.comments;
        compilation.addModuleStack(module2, this);
      }
      set metatypes(value) {
        value.forEach((item2) => {
          item2.additional = this;
        });
        this._metatypes = value;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value) {
        value.forEach((annotation) => {
          annotation.additional = this;
        });
        this._annotations = value;
        this.dynamic = value.some((annotation) => {
          return annotation.name.toLowerCase() === "dynamic";
        });
        this.module.dynamic = this.dynamic;
      }
      get annotations() {
        return this._annotations;
      }
      set imports(items) {
        if (Array.isArray(items)) {
          items.forEach((item2) => {
            if (item2.isImportDeclaration) {
              item2.additional = this;
            }
          });
          this._imports = items;
        }
      }
      get imports() {
        return this._imports;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.id);
        super.freeze(this.scope);
        super.freeze(this.inherit);
        super.freeze(this.abstract);
        super.freeze(this.metatypes);
        super.freeze(this.annotations);
        super.freeze(this.implements);
        super.freeze(this.imports);
        super.freeze(this.modifier);
        super.freeze(this.genericity);
        super.freeze(this.module);
        super.freeze(this.body);
        this.body.forEach((stack2) => stack2.freeze());
      }
      async createCompleted() {
        if (this._createCompletedFlag)
          return;
        this._createCompletedFlag = true;
        const metatypes = [];
        const annotations = [];
        const compilation = this.compilation;
        const scope = this.scope;
        const node = this.node;
        await this.allSettled(this.imports, async (stack2) => await stack2.addImport(this.module, this.parentStack.scope));
        if (this.inherit) {
          const inheritModule = await this.loadTypeAsync(this.inherit.value());
          if (inheritModule) {
            if (Utils2.checkDepend(this.module, inheritModule)) {
              this.inherit.error(1024, this.inherit.value(), this.module.getName(), inheritModule.getName());
            } else {
              this.module.extends = inheritModule;
              inheritModule.used = true;
              inheritModule.children.push(compilation.module);
              this.compilation.addDependency(inheritModule, this.module);
            }
          } else {
            this.inherit.error(1027, this.inherit.value());
          }
        }
        const impls = this.module.implements = [];
        await this.allSettled(this.implements, async (stack2) => {
          const module2 = await this.loadTypeAsync(stack2.value());
          if (module2) {
            if (!module2.isInterface) {
              stack2.error(1028, stack2.value());
            } else {
              module2.used = true;
              this.compilation.addDependency(module2, this.module);
              impls.push(module2);
            }
          } else {
            stack2.error(1029, stack2.value());
          }
        });
        (node.body.body || []).forEach((item2) => {
          const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          if (stack2.isUseExtendStatement) {
            this.usings.push(stack2);
          } else if (stack2.isMetatypeDeclaration) {
            metatypes.push(stack2);
          } else if (stack2.isAnnotationDeclaration) {
            annotations.push(stack2);
          } else {
            stack2.metatypes = metatypes.splice(0, metatypes.length);
            stack2.annotations = annotations.splice(0, annotations.length);
            this.body.push(stack2);
          }
        });
        if (this.usings.length > 0) {
          await this.allSettled(this.usings.map((stack2) => stack2.createCompleted()));
        }
      }
      mergeModuleGenerics(module2, assignGenerics) {
        if (!module2 || !module2.isModule)
          return false;
        if (module2.inherit) {
          this.mergeModuleGenerics(module2.inherit, assignGenerics);
        }
        const declares = module2.getModuleDeclareGenerics();
        if (declares) {
          const ctx2 = this.getContext();
          module2.getStacks().forEach((item2) => {
            ctx2.merge(item2.getContext());
          });
          ctx2.batch(declares, assignGenerics);
          if (module2.implements && module2.implements.length > 0) {
            module2.implements.forEach((imp) => {
              this.mergeModuleGenerics(imp, assignGenerics);
            });
          }
        }
      }
      genericsCheck(typeModule, assignGenerics, atStack) {
        if (!typeModule)
          return;
        if (assignGenerics && assignGenerics.length > 0) {
          assignGenerics.forEach((item2) => {
            item2.parser();
          });
        }
        const _compilation = typeModule.compilation;
        if (_compilation && _compilation.stack) {
        }
        const stackModule = typeModule.moduleStack;
        if (stackModule) {
          stackModule.addUseRef(atStack);
          const declareGenerics = stackModule.genericity ? stackModule.genericity.elements : [];
          const requires = declareGenerics.filter((item2) => !item2.isGenericTypeAssignmentDeclaration);
          if (!assignGenerics || !assignGenerics.length) {
            if (declareGenerics.length > 0) {
              atStack.error(1030, typeModule.toString(), declareGenerics.length);
            }
          } else {
            const lastStack = assignGenerics[assignGenerics.length - 1];
            if (requires.length > assignGenerics.length || assignGenerics.length > declareGenerics.length) {
              if (requires.length === declareGenerics.length) {
                lastStack.error(1030, typeModule.toString(), requires.length);
              } else {
                lastStack.error(1031, typeModule.toString(), requires.length, declareGenerics.length);
              }
            }
            if (declareGenerics.length > 0) {
              assignGenerics.forEach((item2, index) => {
                const declareType = declareGenerics[index] && declareGenerics[index].type();
                if (declareType && declareType.hasConstraint && !declareType.check(item2)) {
                  item2.error(1003, item2.type().toString(), declareType.toString(true));
                }
              });
            }
          }
        }
        this.mergeModuleGenerics(typeModule, assignGenerics);
      }
      implementCheck(interfaceModule) {
        const check = (left, right) => {
          if (!left)
            return;
          if (left.modifier && left.modifier.value() === "private")
            return;
          const type2 = left.isAccessor ? left.kind == "set" ? "setter" : "getter" : left.isPropertyDefinition ? "property" : "method";
          if (!right) {
            if (left.question) {
              return;
            }
            const impStack = this.implements.find((stack2) => {
              return interfaceModule === this.getModuleById(stack2.value());
            });
            return impStack.error(1032, left.value(), type2, interfaceModule.getName(), this.module.getName());
          }
          if (left.isMethodDefinition) {
            if (!right.isMethodDefinition) {
              right.error(1034, left.value(), type2, interfaceModule.getName());
            } else {
              let lType = left.expression._returnType;
              let rType = right.expression._returnType;
              if (!lType && !rType) {
                lType = this.getGlobalTypeById("void");
                rType = right.inferReturnType();
              }
              if (lType && rType && !Utils2.checkTypeForBoth(lType.type(), rType.type(), false)) {
                right.error(1033, right.value(), lType.type().toString({ scopeGenerics: true }));
              }
            }
            const paramLen = left.params.length;
            if (paramLen && paramLen != right.params.length) {
              const requires = left.params.filter((item2) => !item2.question);
              if (requires.length > right.params.length) {
                right.error(1090, left.value(), interfaceModule.getName());
              }
            } else if (paramLen > 0) {
              const lP = left.params[paramLen - 1];
              const rP = right.params[paramLen - 1];
              if (rP) {
                const lT = !!lP.isRestElement;
                const rT = !!rP.isRestElement;
                if (lT !== rT) {
                  right.error(1090, left.value(), interfaceModule.getName());
                }
              }
            }
            const result = left.params.every((item2, index) => {
              if (right.params[index] && !right.params[index].acceptType) {
                right.params[index].inheritInterfaceAcceptType = item2;
                return true;
              }
              const rType = right.params[index] && right.params[index].type();
              if (!rType && item2.question)
                return true;
              return rType ? Utils2.checkTypeForBoth(item2.type(), rType, false) : false;
            });
            if (!result) {
              right.error(1036, left.value(), type2, interfaceModule.getName());
            }
            const lGens = left.genericity ? left.genericity.elements.length : 0;
            const rGens = right.genericity ? right.genericity.elements.length : 0;
            if (lGens > 0 && lGens !== rGens) {
              right.error(1037, left.value(), type2, interfaceModule.getName());
            }
            if (lGens > 0) {
              const result2 = left.genericity.elements.every((leftGeneric, index) => {
                const rightGeneric = right.genericity.elements[index];
                if (rightGeneric) {
                  const left2 = leftGeneric.type();
                  const right2 = rightGeneric.type();
                  if (left2.hasConstraint || right2.hasConstraint) {
                    return left2.check(rightGeneric, true);
                  }
                  return true;
                }
                return false;
              });
              if (!result2) {
                right.error(1038, left.value(), type2, interfaceModule.getName());
              }
            }
          } else {
            if (!right.isPropertyDefinition) {
              right.error(1034, left.value(), type2, interfaceModule.getName());
            } else {
              const lType = left.declarations[0].acceptType;
              const rType = right.declarations[0].acceptType;
              if (lType && rType && !Utils2.checkTypeForBoth(lType.type(), rType.type(), false)) {
                right.error(1033, right.value(), lType.type().toString({ scopeGenerics: true }));
              }
            }
          }
          if (right.modifier && right.modifier.value() !== "public") {
            right.error(1039, right.value(), type2, interfaceModule.getName());
          }
        };
        if (Utils2.isInterface(interfaceModule) && !interfaceModule.isStructTable && interfaceModule !== this.module) {
          const members = interfaceModule.members || {};
          for (var name in members) {
            const left = members[name];
            if (left.isAccessor) {
              check(left.get, this.module.getMember(name, "get", true));
              check(left.set, this.module.getMember(name, "set", true));
            } else {
              check(left, this.module.getMember(name, null, true));
            }
          }
          if (interfaceModule.dynamicProperties) {
            interfaceModule.dynamicProperties.forEach((value, key) => {
              this.module.dynamic = true;
              if (!this.module.dynamicProperties.has(key)) {
                this.module.dynamicProperties.set(key, value);
              }
            });
          }
        }
        if (Utils2.isInterface(interfaceModule)) {
          interfaceModule.extends.forEach((item2) => {
            if (!item2.isStructTable) {
              this.implementCheck(item2);
            }
          });
        }
        (interfaceModule && interfaceModule.implements || []).forEach((item2) => {
          if (!item2.isStructTable) {
            this.implementCheck(item2);
          }
        });
      }
      definition(context) {
        const module2 = this.module;
        context = context || {};
        context.scopeGenerics = true;
        let location = (this.id || this).getLocation();
        if (this.compilation.JSX) {
          const program = this.compilation.stack;
          if (program && program.body[0]) {
            location = program.body[0].getLocation();
          }
        }
        return {
          kind: "class",
          comments: this.comments,
          expre: `(class) ${module2.toString(context)}`,
          location,
          file: this.file
        };
      }
      value() {
        return this.id.value();
      }
      type() {
        return this.module;
      }
      description() {
        return this;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.imports.forEach((stack2) => {
          stack2.parser();
        });
        this.usings.forEach((stack2) => {
          stack2.parser();
        });
        if (this.genericity) {
          this.genericity.parser();
          this.genericity.setRefBeUsed();
        }
        if (this.inherit) {
          const inherit = this.module.extends[0];
          if (inherit) {
            this.parserDescriptor(inherit);
            this.module.policy = inherit.policy;
            this.genericsCheck(inherit, this.inherit.assignGenerics, this.inherit);
            if (inherit.isFinal) {
              this.inherit.error(1147, this.module.getName(), inherit.getName());
            }
          }
        }
        this.metatypes.forEach((stack2) => {
          stack2.parser();
        });
        this.annotations.forEach((stack2) => {
          stack2.parser();
        });
        this.implements.forEach((stack2) => {
          const impModule = this.getModuleById(stack2.value());
          if (impModule) {
            this.parserDescriptor(impModule);
            this.genericsCheck(impModule, stack2.assignGenerics, stack2);
          }
        });
        this.implementCheck(this.module);
        this.module.ckeckAllDescriptors();
        this.body.forEach((stack2) => {
          stack2.parser();
        });
      }
    };
    module.exports = ClassDeclaration;
  }
});

// lib/stacks/ConditionalExpression.js
var require_ConditionalExpression = __commonJS({
  "lib/stacks/ConditionalExpression.js"(exports, module) {
    var Expression = require_Expression();
    var MergeType = require_MergeType();
    var ConditionalExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isConditionalExpression = true;
        this.test = this.createTokenStack(compilation, node.test, scope, node, this);
        this.consequent = this.createTokenStack(compilation, node.consequent, scope, node, this);
        this.alternate = this.createTokenStack(compilation, node.alternate, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.consequent.freeze();
        this.alternate.freeze();
      }
      definition() {
        return null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return this.consequent.referenceItems().concat(this.alternate.referenceItems());
      }
      description() {
        return this;
      }
      type() {
        return this.getAttribute("ConditionalExpression.type", () => {
          const mergeType = new MergeType();
          mergeType.add(this.consequent.type());
          mergeType.add(this.alternate.type());
          return mergeType.type();
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.test.parser();
        this.test.setRefBeUsed();
        this.consequent.parser();
        this.consequent.setRefBeUsed();
        this.alternate.parser();
        this.alternate.setRefBeUsed();
      }
    };
    module.exports = ConditionalExpression;
  }
});

// lib/stacks/ContinueStatement.js
var require_ContinueStatement = __commonJS({
  "lib/stacks/ContinueStatement.js"(exports, module) {
    var Stack = require_Stack();
    var ContinueStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isBreakStatement = true;
        this.label = this.createTokenStack(compilation, node.label, scope, node, this);
      }
      freeze() {
        super.freeze(this);
        this.label && this.label.freeze();
      }
      getLabelStackByName(name) {
        let labelStack = this.getParentStack((stack2) => !!(stack2.isLabeledStatement || stack2.isFunctionExpression));
        while (labelStack && labelStack.isLabeledStatement) {
          if (labelStack.label.value() === name) {
            return labelStack;
          }
          labelStack = labelStack.labelParent;
        }
        return null;
      }
      definition(context) {
        if (this.label) {
          const labelStack = this.getLabelStackByName(this.label.value());
          if (labelStack) {
            return labelStack.definition(context);
          }
        }
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.label) {
          const labelStack = this.getLabelStackByName(this.label.value());
          if (!labelStack || !labelStack.isLabeledStatement) {
            this.label.error(1022);
          }
        }
        let parent = this.parentStack;
        while (parent) {
          if (parent.isSwitchCase || parent.isDoWhileStatement || parent.isWhileStatement || parent.isForStatement || parent.isForOfStatement || parent.isForInStatement) {
            return true;
          } else if (parent.isFunctionExpression) {
            break;
          } else {
            parent = parent.parentStack;
          }
        }
        this.error(1022);
      }
    };
    module.exports = ContinueStatement;
  }
});

// lib/stacks/DeclaratorDeclaration.js
var require_DeclaratorDeclaration = __commonJS({
  "lib/stacks/DeclaratorDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var Utils2 = require_Utils();
    var ClassScope = require_ClassScope();
    var DeclaratorDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        scope = new ClassScope(scope);
        super(compilation, node, scope, parentNode, parentStack);
        this._metatypes = [];
        this._annotations = [];
        this.usings = [];
        this.body = [];
        this._imports = [];
        this.isDeclaratorDeclaration = true;
        this.id = this.createTokenStack(compilation, node.id, scope, node, this);
        this.modifier = this.createTokenStack(compilation, node.modifier, scope, node, this);
        const module2 = this.module = compilation.createModule(this.namespace, this.id.value(), this.modifier ? this.modifier.value() === "internal" : false);
        this.id.module = module2;
        this.inherit = null;
        this.isFinal = module2.isFinal = !!node.final;
        this.static = this.createTokenStack(compilation, node.static, scope, node, this);
        if (node.extends) {
          this.inherit = this.createTokenStack(compilation, node.extends, scope, node, this);
          if (node.extends.genericity) {
            this.inherit.assignGenerics = node.extends.genericity.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
          }
        }
        this.implements = (node.implements || []).map((item2) => {
          const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          if (item2.genericity) {
            stack2.assignGenerics = item2.genericity.map((item3) => this.createTokenStack(compilation, item3, scope, node, this));
          }
          return stack2;
        });
        scope.define(module2.id, module2);
        this.genericity = this.createTokenStack(compilation, node.genericity, scope, node, this);
        this.dynamic = false;
        module2.dynamic = false;
        module2.isValid = true;
        module2.static = !!this.static;
        module2.comments = this.comments;
        module2.isDeclaratorModule = true;
        switch (node.kind) {
          case "class":
            module2.isClass = true;
            break;
          case "interface":
            module2.isInterface = true;
            break;
        }
        compilation.addModuleStack(module2, this);
      }
      set metatypes(value) {
        value.some((item2) => {
          item2.additional = this;
        });
        this._metatypes = value;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value) {
        value.forEach((annotation) => {
          annotation.additional = this;
        });
        this._annotations = value;
        this.dynamic = value.some((annotation) => {
          return annotation.name.toLowerCase() === "dynamic";
        });
        this.module.dynamic = this.dynamic;
      }
      get annotations() {
        return this._annotations;
      }
      set imports(items) {
        if (Array.isArray(items)) {
          items.forEach((item2) => {
            if (item2.isImportDeclaration) {
              item2.additional = this;
            }
          });
          this._imports = items;
        }
      }
      get imports() {
        return this._imports;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.id);
        super.freeze(this.inherit);
        super.freeze(this.implements);
        super.freeze(this.imports);
        super.freeze(this.modifier);
        super.freeze(this.genericity);
        super.freeze(this.module);
        super.freeze(this.body);
        (this.body || []).forEach((stack2) => stack2.freeze());
      }
      definition(context) {
        const module2 = this.module;
        const kind = module2.isInterface ? "interface" : module2.isEnum ? "enum" : "class";
        context = context || {};
        context.scopeGenerics = true;
        let location = (this.id || this).getLocation();
        if (this.compilation.JSX) {
          const program = this.compilation.stack;
          if (program && program.body[0]) {
            location = program.body[0].getLocation();
          }
        }
        return {
          kind,
          comments: this.comments,
          expre: `(${kind}) ${module2.toString(context)}`,
          location,
          file: this.file
        };
      }
      async createCompleted() {
        const compilation = this.compilation;
        const metatypes = [];
        const annotations = [];
        await this.allSettled(this.imports, async (stack2) => await stack2.addImport(this.module, this.parentStack.scope));
        if (this.inherit) {
          const inheritModule = await this.loadTypeAsync(this.inherit.value());
          if (!inheritModule) {
            this.inherit.error(1027, this.inherit.value());
          } else {
            if (Utils2.checkDepend(this.module, inheritModule)) {
              this.inherit.error(1024, this.inherit.value(), this.module.getName(), inheritModule.getName());
            } else {
              this.module.extends = inheritModule;
              this.compilation.addDependency(inheritModule, this.module);
              if (this.static) {
                Object.assign(this.module.methods, inheritModule.methods);
              }
            }
          }
        }
        await this.allSettled(this.implements, async (stack2) => {
          const module2 = await this.loadTypeAsync(stack2.value());
          if (module2) {
            this.module.implements.push(module2);
            if (!(module2.isInterface || module2.isDeclarator)) {
              stack2.error(1028, stack2.value());
            } else {
              this.compilation.addDependency(module2, this.module);
            }
            if (this.static) {
              Object.assign(this.module.methods, module2.methods);
              Object.assign(this.module.methods, module2.members);
            }
          } else {
            stack2.error(1029, stack2.value());
          }
        });
        (this.node.body || []).map((item2) => {
          const stack2 = this.createTokenStack(compilation, item2, this.scope, this.node, this);
          if (stack2.isUseExtendStatement) {
            this.usings.push(stack2);
          } else if (stack2.isMetatypeDeclaration) {
            metatypes.push(stack2);
          } else if (stack2.isAnnotationDeclaration) {
            annotations.push(stack2);
          } else {
            stack2.metatypes = metatypes.splice(0, metatypes.length);
            stack2.annotations = annotations.splice(0, annotations.length);
            this.body.push(stack2);
          }
        });
        if (this.usings.length > 0) {
          await this.allSettled(this.usings.map((stack2) => stack2.createCompleted()));
        }
      }
      mergeModuleGenerics(module2, assignGenerics) {
        if (!module2 || !module2.isModule)
          return false;
        if (module2.inherit) {
          this.mergeModuleGenerics(module2.inherit, assignGenerics);
        }
        const declares = module2.getModuleDeclareGenerics();
        if (declares) {
          const ctx2 = this.getContext();
          const moduleStack = module2.moduleStack;
          if (moduleStack) {
            ctx2.merge(module2.moduleStack.getContext());
          }
          ctx2.batch(declares, assignGenerics);
          if (module2.implements && module2.implements.length > 0) {
            module2.implements.forEach((imp) => {
              this.mergeModuleGenerics(imp, assignGenerics);
            });
          }
        }
      }
      genericsCheck(typeModule, assignGenerics, aStack) {
        if (!typeModule)
          return;
        if (assignGenerics && assignGenerics.length > 0) {
          assignGenerics.forEach((item2) => {
            item2.parser();
          });
        }
        const stackModule = typeModule.moduleStack;
        const _compilation = typeModule.compilation;
        if (_compilation && _compilation.stack) {
        }
        if (stackModule) {
          stackModule.addUseRef(aStack);
          assignGenerics = assignGenerics || [];
          const declareGenerics = stackModule.genericity ? stackModule.genericity.elements : [];
          const requires = declareGenerics.filter((item2) => !item2.isGenericTypeAssignmentDeclaration);
          let lastStack = assignGenerics[assignGenerics.length - 1] || aStack || this.id;
          if (requires.length > assignGenerics.length || assignGenerics.length > declareGenerics.length) {
            if (requires.length === declareGenerics.length) {
              lastStack.error(1030, typeModule.toString(), requires.length);
            } else {
              lastStack.error(1031, typeModule.toString(), requires.length, declareGenerics.length);
            }
          }
          if (declareGenerics.length > 0) {
            assignGenerics.forEach((item2, index) => {
              const declareType = declareGenerics[index] && declareGenerics[index].type();
              if (declareType && declareType.hasConstraint && !declareType.check(item2)) {
                item2.error(1003, item2.type().toString(), declareType.toString());
              }
            });
          }
        }
        this.mergeModuleGenerics(typeModule, assignGenerics);
      }
      value() {
        return this.id.value();
      }
      type() {
        return this.module;
      }
      description() {
        return this;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.imports.forEach((stack2) => {
          stack2.parser();
        });
        this.usings.forEach((stack2) => {
          stack2.parser();
        });
        if (this.genericity) {
          this.genericity.parser();
          this.genericity.setRefBeUsed();
        }
        this.metatypes.forEach((stack2) => {
          stack2.parser();
        });
        this.annotations.forEach((stack2) => {
          stack2.parser();
        });
        if (this.inherit) {
          this.parserDescriptor(this.module.extends[0]);
          this.genericsCheck(this.module.extends[0], this.inherit.assignGenerics, this.inherit);
          if (this.module.extends[0] && this.module.extends[0].isFinal) {
            this.inherit.error(1147, this.module.getName(), this.module.extends[0].getName());
          }
        }
        this.implements.forEach((stack2) => {
          const impModule = this.getModuleById(stack2.value());
          if (impModule) {
            this.parserDescriptor(impModule);
            this.genericsCheck(impModule, stack2.assignGenerics, stack2);
          }
        });
        this.module.ckeckAllDescriptors();
        this.body.forEach((item2) => item2.parser());
      }
    };
    module.exports = DeclaratorDeclaration;
  }
});

// lib/stacks/DeclaratorFunction.js
var require_DeclaratorFunction = __commonJS({
  "lib/stacks/DeclaratorFunction.js"(exports, module) {
    var FunctionExpression = require_FunctionExpression();
    var DeclaratorFunction = class extends FunctionExpression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isDeclaratorFunction = true;
        this.key = this.createTokenStack(compilation, node.id, scope, node, this);
        this.modifier = this.createTokenStack(compilation, node.modifier, scope, node, this);
        this.namespace.set(this.key.value(), this);
        this._annotations = [];
      }
      set imports(items) {
        if (Array.isArray(items)) {
          items.forEach((item2) => {
            if (item2.isImportDeclaration) {
              item2.additional = this;
            }
          });
          this._imports = items;
        }
      }
      get imports() {
        return this._imports;
      }
      set metatypes(value) {
        this._metatypes = value;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value) {
        this._annotations = value;
        value.forEach((annotation) => {
          annotation.additional = this;
        });
      }
      get annotations() {
        return this._annotations;
      }
      freeze() {
        super.freeze();
        this.key.freeze();
      }
      parser() {
        if (super.parser() === false)
          return false;
        const name = this.key.value();
        if (!this.namespace.checkDescriptors(name, this)) {
          this.key.error(1096, name);
        }
      }
    };
    module.exports = DeclaratorFunction;
  }
});

// lib/types/AnyType.js
var require_AnyType = __commonJS({
  "lib/types/AnyType.js"(exports, module) {
    var Type = require_Type();
    var AnyType = class extends Type {
      constructor() {
        super("$AnyType");
        this.isAnyType = true;
      }
      check() {
        return true;
      }
      definition() {
        return {
          expre: `(type) any`
        };
      }
      is() {
        return true;
      }
      toString(context, options = {}) {
        options.hasAnyType = true;
        return "any";
      }
    };
    module.exports = AnyType;
  }
});

// lib/types/VoidType.js
var require_VoidType = __commonJS({
  "lib/types/VoidType.js"(exports, module) {
    var Namespace2 = require_Namespace();
    var Type = require_Type();
    var VoidType = class extends Type {
      constructor() {
        super("$VoidType");
        this.isVoidType = true;
      }
      is(type2) {
        if (!type2 || type2 === this)
          return true;
        type2 = this.getWrapAssignType(type2);
        if (type2.isInstanceofType && type2.generics && type2.generics.length === 1) {
          const PromiseModule = Namespace2.globals.get("Promise");
          const inheritModule = type2.inherit;
          if (PromiseModule && inheritModule && PromiseModule.is(inheritModule.type())) {
            type2 = type2.generics[0].type();
          }
        }
        return !!type2.isVoidType;
      }
      toString() {
        return "void";
      }
    };
    module.exports = VoidType;
  }
});

// lib/types/AliasType.js
var require_AliasType = __commonJS({
  "lib/types/AliasType.js"(exports, module) {
    var Utils2 = require_Utils();
    var Type = require_Type();
    var AliasType = class extends Type {
      constructor(inherit, target) {
        if (inherit && inherit.isAliasType) {
          inherit = inherit.inherit;
        }
        super("$AliasType", inherit);
        this.isAliasType = true;
        this.target = target;
        if (typeof target === "string") {
          this.typeName = target;
          this.fullName = target;
        } else if (target && target.isStack) {
          this.typeName = target.value();
          this.fullName = this.typeName;
          if (target.namespace && target.namespace.isNamespace) {
            this.fullName = target.namespace.getChain().concat(this.typeName).join(".");
          }
        }
      }
      get id() {
        return this.toString();
      }
      get hasGenericType() {
        return this.inherit.hasGenericType;
      }
      definition(ctx2) {
        if (this.target && this.target.isStack) {
          return this.target.definition(ctx2);
        }
        return super.definition();
      }
      clone(inference) {
        if (inference) {
          return new AliasType(inference(this.inherit), this.target);
        }
        return this;
      }
      check(stack2, context = {}, options = {}) {
        const type2 = stack2 && stack2.type();
        if (!type2)
          return false;
        if (!this.isNeedCheckType(type2))
          return true;
        return this.inherit.type().check(stack2, context, options);
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        if (this.toString() === "object") {
          return !Utils2.isScalar(type2) && this.inherit.type().is(type2, context, options);
        }
        return this.inherit.type().is(type2, context, options);
      }
      toString(context, options = {}) {
        let key = this.typeName || this.target.value();
        if (options.inbuild && this.fullName) {
          key = this.fullName;
        }
        if (!options.onlyTypeName && this.target && this.target.genericity && this.target.genericity.isGenericDeclaration) {
          const declareGgenerics = this.target.genericity;
          if (declareGgenerics && declareGgenerics.elements.length > 0) {
            const types = declareGgenerics.elements.map((item2) => {
              let decltype = item2.type();
              if (options.fetchDeclareGenericsDefaultValue) {
                if (decltype.assignType) {
                  decltype = decltype.assignType.type();
                } else {
                  return "any";
                }
              }
              return decltype.toString(context, options);
            });
            return `${key}<${types.join(", ")}>`;
          }
        }
        return key;
      }
    };
    module.exports = AliasType;
  }
});

// lib/types/ScalarType.js
var require_ScalarType = __commonJS({
  "lib/types/ScalarType.js"(exports, module) {
    var Type = require_Type();
    var ScalarType = class extends Type {
      constructor(inherit, target) {
        super("$ScalarType", inherit);
        this.isScalarType = true;
        this.target = target;
      }
      get id() {
        return this.toString();
      }
      get hasGenericType() {
        return false;
      }
      clone() {
        return this;
      }
      // check( stack, context={},options={}){
      //     const type = stack && stack.type();
      //     if( !type )return false;
      //     if( !this.isNeedCheckType(type) )return true;
      //     return this.inherit.type().check( stack, context, options);
      // }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = type2.isLiteralType ? type2.inherit.type() : type2;
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        if (this.toString() === "object") {
          return !type2.isScalarType && this.inherit.type().is(type2, context, options);
        }
        type2 = type2.isScalarType ? type2.inherit.type() : type2;
        return this.inherit.type().is(type2, context, options);
      }
      toString() {
        return this.target.value();
      }
    };
    module.exports = ScalarType;
  }
});

// lib/types/NullableType.js
var require_NullableType = __commonJS({
  "lib/types/NullableType.js"(exports, module) {
    var Namespace2 = require_Namespace();
    var Type = require_Type();
    var NullableType = class extends Type {
      constructor(inherit) {
        super("$NullableType", inherit);
        this.isNullableType = true;
      }
      is(type2, context, options) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        if (type2.isInstanceofType && type2.generics && type2.generics.length === 1) {
          const PromiseModule = Namespace2.globals.get("Promise");
          const inheritModule = type2.inherit;
          if (PromiseModule && inheritModule && PromiseModule.is(inheritModule.type(), context, options)) {
            return this.is(type2.generics[0].type(), context, options);
          }
        }
        return !!type2.isNullableType;
      }
      toString() {
        return "null";
      }
    };
    module.exports = NullableType;
  }
});

// lib/types/NeverType.js
var require_NeverType = __commonJS({
  "lib/types/NeverType.js"(exports, module) {
    var Type = require_Type();
    var NeverType = class extends Type {
      constructor() {
        super("$NeverType");
        this.isNeverType = true;
      }
      definition() {
        return {
          expre: `(type) never`
        };
      }
      is(type2, context = {}, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        return type2 === this;
      }
      toString() {
        return "never";
      }
    };
    module.exports = NeverType;
  }
});

// lib/stacks/DeclaratorTypeAlias.js
var require_DeclaratorTypeAlias = __commonJS({
  "lib/stacks/DeclaratorTypeAlias.js"(exports, module) {
    var Stack = require_Stack();
    var AnyType = require_AnyType();
    var VoidType = require_VoidType();
    var AliasType = require_AliasType();
    var ScalarType = require_ScalarType();
    var NullableType = require_NullableType();
    var NeverType = require_NeverType();
    var BlockScope = require_BlockScope();
    var Utils2 = require_Utils();
    var DeclaratorTypeAlias = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        scope = new BlockScope(scope);
        super(compilation, node, scope, parentNode, parentStack);
        this.isDeclaratorTypeAlias = true;
        this.left = this.createTokenStack(compilation, node.left, scope, node, this);
        this.right = this.createTokenStack(compilation, node.right, scope, node, this);
        this.genericity = this.createTokenStack(compilation, node.genericity, scope, node, this);
        this.modifier = this.createTokenStack(compilation, node.modifier, scope, node, this);
        this.namespace.set(this.left.value(), this);
      }
      set imports(items) {
        if (Array.isArray(items)) {
          items.forEach((item2) => {
            if (item2.isImportDeclaration) {
              item2.additional = this;
            }
          });
          this._imports = items;
        }
      }
      get imports() {
        return this._imports;
      }
      freeze() {
        super.freeze(this);
        this.left.freeze();
        this.right.freeze();
      }
      definition(ctx2) {
        let complete = ctx2 ? false : true;
        if (ctx2 && ctx2.stack) {
          if (ctx2.stack === this.left) {
            complete = true;
          }
        }
        const declareGenerics = this.genericity ? this.genericity.elements : [];
        const generics = declareGenerics.length > 0 ? "<" + declareGenerics.map((decl) => decl.type().toString(ctx2, { complete })).join(", ") + ">" : "";
        return {
          comments: this.comments,
          expre: `(type) ${this.left.value()}${generics}`,
          location: this.left.getLocation(),
          file: this.file
        };
      }
      set metatypes(value) {
        this._metatypes = value;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value) {
        this._annotations = value;
      }
      get annotations() {
        return this._annotations;
      }
      get id() {
        return this.left.value();
      }
      reference() {
        return this.right.reference();
      }
      referenceItems() {
        return this.right.referenceItems();
      }
      description() {
        return this.right.description();
      }
      type() {
        return this.getAttribute("type", () => {
          const value = this.right.value();
          switch (value) {
            case "any":
              return this._type = new AnyType(value);
            case "nullable":
              return this._type = new NullableType(value);
            case "void":
              return this._type = new VoidType(value);
            case "never":
              return this._type = new NeverType(value);
          }
          return new AliasType(this.right.type(), this);
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.genericity) {
          this.genericity.parser();
        }
        this.right.parser();
        if (!this.namespace.checkDescriptors(this.left.value(), this)) {
          this.left.error(1078, this.left.value());
        }
      }
      error(code, ...args) {
        this.left.error(code, ...args);
      }
      warn(code, ...args) {
        this.left.warn(code, ...args);
      }
      value() {
        return this.left.value();
      }
      raw() {
        return this.left.raw();
      }
    };
    module.exports = DeclaratorTypeAlias;
  }
});

// lib/stacks/DeclaratorVariable.js
var require_DeclaratorVariable = __commonJS({
  "lib/stacks/DeclaratorVariable.js"(exports, module) {
    var Stack = require_Stack();
    var InstanceofType = require_InstanceofType();
    var DeclaratorVariable = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isDeclaratorVariable = true;
        this.modifier = this.createTokenStack(compilation, node.modifier, scope, node, this);
        this.declarations = node.expression.declarations.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
        this.declarations.forEach((item2) => {
          this.namespace.set(item2.id.value(), this);
        });
        this._annotations = [];
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.declarations.forEach((item2) => {
          item2.parser();
          if (!this.namespace.checkDescriptors(item2.id.value(), this)) {
            item2.id.error(1097, item2.id.value());
          }
        });
      }
      set imports(items) {
        if (Array.isArray(items)) {
          items.forEach((item2) => {
            if (item2.isImportDeclaration) {
              item2.additional = this;
            }
          });
          this._imports = items;
        }
      }
      get imports() {
        return this._imports;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.declarations);
        this.declarations.forEach((stack2) => stack2.freeze());
      }
      definition(context) {
        const kind = this.declarations[0].kind;
        const type2 = this.declarations[0].type().toString(context);
        const id = this.declarations[0].id;
        const token = id.value();
        return {
          comments: this.comments,
          expre: `(global ${kind}) ${token}:${type2}`,
          location: id.getLocation(),
          file: id.compilation.file
        };
      }
      set metatypes(value) {
        this._metatypes = value;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value) {
        this._annotations = value;
        value.forEach((annotation) => {
          annotation.additional = this;
        });
      }
      get annotations() {
        return this._annotations;
      }
      get kind() {
        return this.declarations[0].kind;
      }
      get init() {
        return this.declarations[0].init;
      }
      get id() {
        return this.declarations[0].value();
      }
      get acceptType() {
        return this.declarations[0].acceptType;
      }
      get assignItems() {
        return this.declarations[0].assignItems;
      }
      reference() {
        return this.declarations[0].reference();
      }
      referenceItems() {
        return this.declarations[0].referenceItems();
      }
      description() {
        return this;
      }
      type() {
        return this._type || (this._type = new InstanceofType(this.declarations[0].type(), this));
      }
      error(code, ...args) {
        this.declarations[0].error(code, ...args);
      }
      warn(code, ...args) {
        this.declarations[0].warn(code, ...args);
      }
      value() {
        return this.declarations[0].value();
      }
      raw() {
        return this.declarations[0].raw();
      }
    };
    module.exports = DeclaratorVariable;
  }
});

// lib/stacks/DoWhileStatement.js
var require_DoWhileStatement = __commonJS({
  "lib/stacks/DoWhileStatement.js"(exports, module) {
    var Stack = require_Stack();
    var DoWhileStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isDoWhileStatement = true;
        this.condition = this.createTokenStack(compilation, node.test, scope, node, this);
        this.body = this.createTokenStack(compilation, node.body, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.condition.freeze();
        this.body.freeze();
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (!this.condition) {
          this.error(1041);
        } else {
          this.condition.parser();
          this.condition.setRefBeUsed();
          this.body.parser();
          const desc2 = this.condition.description();
          if (desc2.isLiteral) {
            const has = this.body.body.some((item2) => item2.isReturnStatement || item2.isBreakStatement);
            if (!has) {
              this.condition.warn(1042);
            }
          }
        }
      }
    };
    module.exports = DoWhileStatement;
  }
});

// lib/stacks/EmptyStatement.js
var require_EmptyStatement = __commonJS({
  "lib/stacks/EmptyStatement.js"(exports, module) {
    var Stack = require_Stack();
    var EmptyStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isEmptyStatement = true;
      }
    };
    module.exports = EmptyStatement;
  }
});

// lib/types/EnumType.js
var require_EnumType = __commonJS({
  "lib/types/EnumType.js"(exports, module) {
    var Type = require_Type();
    var EnumType = class extends Type {
      constructor(inherit, target, owner = null) {
        super("$EnumType", inherit);
        this.target = target;
        this.isEnumType = true;
        this.owner = owner;
        this.acceptProperties = [];
      }
      accept(property) {
        this.acceptProperties.push(property);
      }
      attribute(property) {
        return this.target.attribute(property);
      }
      get attributes() {
        return this.target.attributes;
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        if (this.owner) {
          return this.inherit.type().is(type2, context, options);
        }
        return type2.isEnumType && type2.owner === this;
      }
      toString(context, options = {}) {
        if (this.owner) {
          if (this.owner.isEnumType) {
            return `${this.owner.target.key.value()}`;
          } else {
            return `${this.owner.id}.${this.target.value()}`;
          }
        }
        let properties = [];
        const inherit = this.inherit;
        if (inherit && inherit.isModule && inherit.isEnum) {
          properties = Object.keys(inherit.methods);
        } else {
          properties = this.target.properties.map((item2) => item2.value());
        }
        return `enum {${properties.join(",")}}`;
      }
    };
    module.exports = EnumType;
  }
});

// lib/stacks/EnumDeclaration.js
var require_EnumDeclaration = __commonJS({
  "lib/stacks/EnumDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var EnumType = require_EnumType();
    var EnumDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isEnumDeclaration = true;
        this.isDeclarator = true;
        this.key = this.createTokenStack(compilation, node.key, scope, node, this);
        this.inherit = this.createTokenStack(compilation, node.extends, scope, node, this);
        this.increment = 0;
        this.mapProperties = /* @__PURE__ */ new Map();
        this.imports = [];
        this._metatypes = [];
        this._annotations = [];
        this.isExpressionDeclare = !(parentStack.isPackageDeclaration || parentStack.isProgram);
        if (!this.isExpressionDeclare) {
          this.modifier = this.createTokenStack(compilation, node.modifier, scope, node);
          const module2 = this.module = compilation.createModule(this.namespace, this.key.value());
          this.key.module = module2;
          scope.define(module2.id, module2);
          module2.comments = this.comments;
          module2.isEnum = true;
          module2.isLocalModule = true;
          module2.increment = this.increment;
          compilation.addModuleStack(module2, this);
        } else {
          this.properties = node.properties.map((item2, index) => {
            const stack2 = this.createTokenStack(compilation, item2, scope, item2, this);
            const lastValue = stack2.init && stack2.init.value();
            if (!stack2.key.isIdentifier) {
              stack2.error(1043, stack2.raw());
            }
            if (lastValue) {
              if (typeof lastValue === "number") {
                this.increment = lastValue + 1;
              } else if (typeof lastValue === "string") {
                this.increment = lastValue;
              } else {
                stack2.error(1044, stack2.raw());
              }
            }
            if (this.mapProperties.has(stack2.value())) {
              stack2.error(1045, stack2.raw());
            }
            this.mapProperties.set(stack2.value(), stack2);
            return stack2;
          });
          scope.define(this.value(), this);
        }
      }
      set metatypes(value) {
        value.some((item2) => {
          item2.additional = this;
        });
        this._metatypes = value;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value) {
        value.forEach((annotation) => {
          annotation.additional = this;
        });
        this._annotations = value;
        this.dynamic = value.some((annotation) => {
          return annotation.name.toLowerCase() === "dynamic";
        });
        this.module.isFinal = value.some((annotation) => {
          return annotation.name.toLowerCase() === "final";
        });
      }
      get annotations() {
        return this._annotations;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.properties);
        super.freeze(this.mapProperties);
        if (this.parentStack.isPackageDeclaration) {
          super.freeze(this.id);
          super.freeze(this.module);
          (this.properties || []).forEach((stack2) => stack2.freeze());
        }
      }
      async createCompleted() {
        if (this.isExpressionDeclare) {
          return;
        }
        const compilation = this.compilation;
        const module2 = this.module;
        await this.allSettled(this.imports, async (stack2) => await stack2.addImport(this.module, this.parentStack.scope));
        if (this.inherit) {
          const inheritModule = await this.loadTypeAsync(this.inherit.value());
          if (!inheritModule) {
            this.inherit.error(1027, this.inherit.value());
          } else {
            if (Utils.checkDepend(this.module, inheritModule)) {
              this.inherit.error(1024, this.inherit.value(), this.module.getName(), inheritModule.getName());
            } else {
              const stackModule = this.compilation.getStackByModule(inheritModule);
              stackModule.addUseRef(this.inherit);
            }
          }
          module2.extends = inheritModule;
          this.increment = inheritModule.increment;
        }
        this.properties = this.node.properties.map((item2, index) => {
          const stack2 = this.createTokenStack(compilation, item2, this.scope, item2, this);
          const lastValue = stack2.init && stack2.init.value();
          if (!stack2.key.isIdentifier) {
            stack2.error(1043, stack2.raw());
          }
          if (lastValue) {
            if (typeof lastValue === "number") {
              this.increment = lastValue + 1;
            } else if (typeof lastValue === "string") {
              this.increment = lastValue;
            } else {
              stack2.error(1044, stack2.raw());
            }
          }
          if (this.mapProperties.has(stack2.value())) {
            stack2.error(1045, stack2.raw());
          }
          this.mapProperties.set(stack2.value(), stack2);
          module2.addMember(stack2.value(), stack2, true);
          return stack2;
        });
        module2.increment = this.increment;
      }
      assignment(value, stack2 = null) {
        (stack2 || this).error(1015, this.raw());
      }
      definition() {
        const expre = `enum ${this.value()}`;
        return {
          kind: "enum",
          comments: this.comments,
          expre,
          location: this.key.getLocation(),
          file: this.file
        };
      }
      get attributes() {
        return this.mapProperties;
      }
      attribute(name) {
        return this.mapProperties.get(name) || null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      description() {
        return this;
      }
      type() {
        if (this.parentStack.isPackageDeclaration && this.module.isEnum) {
          return this.module;
        }
        return this._type || (this._type = new EnumType(this.getGlobalTypeById("object"), this));
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.imports.forEach((stack2) => {
          stack2.parser();
        });
        this.metatypes.forEach((stack2) => {
          stack2.parser();
        });
        this.annotations.forEach((stack2) => {
          stack2.parser();
        });
        this.inherit && this.inherit.parser();
        if (this.module) {
          this.parserDescriptor(this.module.inherit);
        }
        this.properties && this.properties.forEach((stack2) => {
          stack2.parser();
        });
      }
      value() {
        return this.key.value();
      }
    };
    module.exports = EnumDeclaration;
  }
});

// lib/stacks/EnumProperty.js
var require_EnumProperty = __commonJS({
  "lib/stacks/EnumProperty.js"(exports, module) {
    var Stack = require_Stack();
    var EnumType = require_EnumType();
    var EnumProperty = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isEnumProperty = true;
        this.key = this.createTokenStack(compilation, node.key, scope, node, this);
        let init = node.init;
        if (!init) {
          if (typeof parentStack.increment === "string") {
            this.key.error(1153, this.key.value());
          } else {
            init = Object.assign({}, node);
            init.type = "Literal";
            init.value = parentStack.increment++;
            init.raw = `${init.value}`;
          }
        }
        this.init = this.createTokenStack(compilation, init, scope, node, this);
        this.callableStatic = true;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.init);
        super.freeze(this.key);
      }
      definition() {
        const expre = `(enum member) ${this.parentStack.value()}.${this.value()}=${this.init.value()}`;
        return {
          kind: "enum",
          comments: this.comments,
          identifier: this.value(),
          expre,
          location: this.getLocation(),
          file: this.compilation.file,
          context: this
        };
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      description() {
        return this;
      }
      type() {
        return this._type || (this._type = new EnumType(typeof this.init.value() === "string" ? this.getGlobalTypeById("String") : this.getGlobalTypeById("Number"), this, this.parentStack.type()));
      }
      raw() {
        return this.key.raw();
      }
      value() {
        return this.key.value();
      }
    };
    module.exports = EnumProperty;
  }
});

// lib/stacks/ExportAllDeclaration.js
var require_ExportAllDeclaration = __commonJS({
  "lib/stacks/ExportAllDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var ExportAllDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isExportAllDeclaration = true;
        this.source = this.createTokenStack(compilation, node.source, scope, node, this);
        this.exported = this.createTokenStack(compilation, node.exported, scope, node, this);
        if (parentStack && !(parentStack.isProgram || parentStack.isPackageDeclaration || parentStack.isModuleDeclaration)) {
          this.error(1159);
        }
      }
      definition(ctx2) {
        const resolveCompilation = this.getResolveCompilation();
        if (resolveCompilation) {
          if (!ctx2 || ctx2.stack === this.source) {
            return {
              expre: `module "${resolveCompilation.file}"`,
              location: resolveCompilation.stack.getLocation(),
              file: resolveCompilation.file,
              range: this.source.getLocation()
            };
          } else if (!ctx2 || this.exported === ctx2.stack) {
            return {
              expre: `import ${this.exported.value()}`,
              location: resolveCompilation.stack.getLocation(),
              file: resolveCompilation.file,
              range: this.exported.getLocation()
            };
          }
        }
        return null;
      }
      type() {
        return this.getGlobalTypeById("any");
      }
      getResolveFile() {
        if (this.source && this.source.isLiteral) {
          if (this.resolve !== void 0)
            return this.resolve;
          const resolve = this.resolve = this.compiler.resolve(this.source.value(), this.compilation.file);
          if (!resolve) {
            this.source.error(1122, this.source.value());
          }
          return resolve;
        }
      }
      getResolveCompilation() {
        return this._resolveCompilation;
      }
      async getResolveCompilationAsync() {
        if (this._resolveCompilation !== void 0) {
          return this._resolveCompilation;
        }
        this._resolveCompilation = null;
        if (this.compiler.options.suffix === this.getFileExt()) {
          const compilation = this._resolveCompilation = await this.compilation.createChildCompilation(this.getResolveFile(), this.compilation.file);
          if (!compilation) {
            this.source.error(1132, this.source.value());
          } else {
            compilation.import = "importSpecifier";
          }
          return compilation;
        }
        return null;
      }
      async createCompleted() {
        await this.getResolveCompilationAsync();
      }
      getFileExt() {
        const resolve = this.getResolveFile();
        if (resolve) {
          const pos = resolve.lastIndexOf(".");
          if (pos > 0) {
            return resolve.substring(pos);
          }
        }
        return null;
      }
      value() {
        return this.exported ? this.exported.value() : "*";
      }
      raw() {
        return this.exported ? this.exported.raw() : "*";
      }
      parser() {
        if (super.parser() === false)
          return false;
        const resolve = this.getResolveFile();
        if (resolve) {
          const compilation = this.getResolveCompilation();
          if (compilation) {
            if (!(compilation.stack && compilation.stack.exports.length > 0)) {
              this.source.error(1162, this.source.value());
            }
          }
        }
      }
    };
    module.exports = ExportAllDeclaration;
  }
});

// lib/stacks/ExportDefaultDeclaration.js
var require_ExportDefaultDeclaration = __commonJS({
  "lib/stacks/ExportDefaultDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var ExportDefaultDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isExportDefaultDeclaration = true;
        this.declaration = this.createTokenStack(compilation, node.declaration, scope, node, this);
        if (parentStack && !(parentStack.isProgram || parentStack.isPackageDeclaration || parentStack.isModuleDeclaration)) {
          this.error(1159);
        }
      }
      freeze() {
        this.declaration.freeze();
      }
      reference() {
        return this.description().reference();
      }
      referenceItems() {
        return this.description().referenceItems();
      }
      definition() {
        return this.description().definition();
      }
      description() {
        if (this.declaration.isClassDeclaration) {
          return this.declaration.module;
        }
        return this.declaration.description();
      }
      value() {
        return this.declaration.value();
      }
      raw() {
        return this.declaration.raw();
      }
      type() {
        return this.description().type();
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.compilation.stack.exports.length > 0) {
          const result = this.compilation.stack.exports.filter((item2) => item2.isExportDefaultDeclaration);
          if (result.length > 1) {
            this.error(1163);
          }
        }
        if (this.declaration) {
          this.declaration.parser();
          if (this.declaration.isIdentifier || this.declaration.isMemberExpression) {
            this.declaration.setRefBeUsed();
          }
        }
      }
    };
    module.exports = ExportDefaultDeclaration;
  }
});

// lib/stacks/ExportNamedDeclaration.js
var require_ExportNamedDeclaration = __commonJS({
  "lib/stacks/ExportNamedDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var ExportNamedDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isExportNamedDeclaration = true;
        this.declaration = this.createTokenStack(compilation, node.declaration, scope, node, this);
        this.source = this.createTokenStack(compilation, node.source, scope, node, this);
        this.specifiers = node.specifiers ? node.specifiers.map((item2) => this.createTokenStack(compilation, item2, scope, node, this)) : [];
        if (parentStack && !(parentStack.isProgram || parentStack.isPackageDeclaration || parentStack.isModuleDeclaration)) {
          this.error(1159);
        }
      }
      definition(ctx2) {
        if (this.source && this.source.isLiteral) {
          const resolveCompilation = this.getResolveCompilation();
          if (resolveCompilation) {
            if (!ctx2 || ctx2.stack === this.source) {
              return {
                expre: `module "${resolveCompilation.file}"`,
                location: resolveCompilation.stack.getLocation(),
                file: resolveCompilation.file,
                range: this.source.getLocation()
              };
            }
          }
        } else if (this.declaration) {
          return this.declaration.definition(ctx2);
        }
        return null;
      }
      freeze() {
        super.freeze();
        this.declaration && this.declaration.freeze();
        this.source && this.source.freeze();
        this.specifiers.forEach((item2) => item2.freeze());
      }
      getKeyName() {
        if (this.declaration) {
          if (this.declaration.isClassDeclaration) {
            return this.declaration.module.id;
          } else if (this.declaration.isFunctionDeclaration) {
            return local === item.declaration.key.value() ? item.declaration : null;
          } else if (this.declaration.isAssignmentExpression) {
            return local === item.declaration.left.value() ? item.declaration : null;
          } else if (this.declaration.isIdentifier) {
            return local === item.declaration.value() ? item.declaration : null;
          } else if (this.declaration.isVariableDeclaration) {
            const result = item.declaration.declarations.find((decl) => decl.id.value() === local);
            return result ? result : null;
          }
        }
      }
      getDescByName(name) {
        if (this.declaration) {
          const decl = this.declaration;
          if (decl.isClassDeclaration) {
            return decl.module.id === name ? decl.module : null;
          } else if (decl.isFunctionDeclaration) {
            return name === decl.key.value() ? decl : null;
          } else if (decl.isAssignmentExpression) {
            return name === decl.left.value() ? decl : null;
          } else if (decl.isIdentifier) {
            return name === decl.value() ? decl : null;
          } else if (decl.isVariableDeclaration) {
            const result = decl.declarations.find((de) => de.id.value() === name);
            return result ? result : null;
          }
        } else if (this.specifiers && this.specifiers.length > 0) {
          const result = this.specifiers.find((specifier) => {
            return specifier.exported.value() === name;
          });
          if (result) {
            return result.description();
          }
        }
      }
      getResolveFile() {
        if (this.source && this.source.isLiteral) {
          if (this.resolve !== void 0)
            return this.resolve;
          const resolve = this.resolve = this.compiler.resolve(this.source.value(), this.compilation.file);
          if (!resolve) {
            this.source.error(1122, this.source.value());
          }
          return resolve;
        }
      }
      getResolveCompilation() {
        return this._resolveCompilation;
      }
      async getResolveCompilationAsync() {
        if (this._resolveCompilation !== void 0)
          return this._resolveCompilation;
        this._resolveCompilation = null;
        if (this.compiler.options.suffix === this.getFileExt()) {
          const compilation = this._resolveCompilation = await this.compilation.createChildCompilation(this.getResolveFile(), this.compilation.file);
          if (!compilation) {
            this.source.error(1132, this.source.value());
          } else {
            compilation.import = "importSpecifier";
          }
          return compilation;
        }
        return null;
      }
      async createCompleted() {
        await this.getResolveCompilationAsync();
      }
      getFileExt() {
        const resolve = this.getResolveFile();
        if (resolve) {
          const pos = resolve.lastIndexOf(".");
          if (pos > 0) {
            return resolve.substring(pos);
          }
        }
        return null;
      }
      type() {
        return this.getGlobalTypeById("any");
      }
      parser() {
        if (super.parser() === false)
          return false;
        const resolve = this.getResolveFile();
        if (resolve) {
          const compilation = this.getResolveCompilation();
          if (compilation) {
            if (!(compilation.stack.exports.length > 0)) {
              this.source.error(1162, this.source.value());
            }
          }
        }
        if (this.declaration) {
          this.declaration.parser();
          if (this.declaration.isIdentifier || this.declaration.isMemberExpression) {
            this.declaration.setRefBeUsed();
          }
        }
        this.specifiers.forEach((item2) => item2.parser());
      }
    };
    module.exports = ExportNamedDeclaration;
  }
});

// lib/stacks/ExportSpecifier.js
var require_ExportSpecifier = __commonJS({
  "lib/stacks/ExportSpecifier.js"(exports, module) {
    var Stack = require_Stack();
    var ExportSpecifier = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isExportSpecifier = true;
        this.local = this.createTokenStack(compilation, node.local, scope, node, this);
        this.exported = this.createTokenStack(compilation, node.exported, scope, node, this);
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.exported);
      }
      definition(ctx2) {
        const desc2 = this.description();
        if (desc2) {
          if (desc2.isExportAllDeclaration) {
            const compilation = desc2.getResolveCompilation();
            return {
              expre: `import ${desc2.exported.value()}`,
              location: compilation.stack.getLocation(),
              file: compilation.file
            };
          }
          return desc2.definition(ctx2);
        }
      }
      reference() {
        const desc2 = this.description();
        if (desc2 && !desc2.isExportAllDeclaration) {
          return desc2.reference();
        }
        return null;
      }
      referenceItems() {
        const desc2 = this.description();
        if (desc2 && !desc2.isExportAllDeclaration) {
          return desc2.referenceItems();
        }
        return [];
      }
      description() {
        if (this.parentStack.source) {
          const compilation = this.parentStack.getResolveCompilation();
          if (compilation && compilation.stack && compilation.stack.exports.length > 0) {
            const local2 = this.local.value();
            const exports2 = compilation.stack.exports;
            for (var i = 0; exports2.length > i; i++) {
              const item2 = exports2[i];
              if (item2.isExportAllDeclaration && item2.exported && item2.exported.value() === local2) {
                return item2;
              } else if (item2.isExportNamedDeclaration) {
                const desc2 = item2.getDescByName(local2);
                if (desc2)
                  return desc2;
              }
            }
          }
          return null;
        }
        return this.local.description();
      }
      type() {
        const desc2 = this.description();
        if (desc2)
          return desc2.type();
        return this.getGlobalTypeById("any");
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (!this.parentStack.source) {
          this.local.parser();
          this.local.setRefBeUsed();
        }
      }
    };
    module.exports = ExportSpecifier;
  }
});

// lib/stacks/ExpressionStatement.js
var require_ExpressionStatement = __commonJS({
  "lib/stacks/ExpressionStatement.js"(exports, module) {
    var Stack = require_Stack();
    var ExpressionStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isExpressionStatement = true;
        this.expression = this.createTokenStack(compilation, node.expression, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.expression.freeze();
      }
      definition() {
        return null;
      }
      error(code, ...args) {
        this.expression.error(code, ...args);
      }
      warn(code, ...args) {
        this.expression.warn(code, ...args);
      }
      reference() {
        return this.expression.reference();
      }
      referenceItems() {
        return this.expression.referenceItems();
      }
      description() {
        return this.expression.description();
      }
      type(ctx2) {
        return this.expression.type(ctx2);
      }
      parser() {
        this.expression.parser();
      }
      value() {
        return this.expression.value();
      }
      raw() {
        return this.expression.raw();
      }
    };
    module.exports = ExpressionStatement;
  }
});

// lib/stacks/ForInStatement.js
var require_ForInStatement = __commonJS({
  "lib/stacks/ForInStatement.js"(exports, module) {
    var Stack = require_Stack();
    var BlockScope = require_BlockScope();
    var ForInStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        scope = new BlockScope(scope);
        super(compilation, node, scope, parentNode, parentStack);
        this.isForInStatement = true;
        this.left = this.createTokenStack(compilation, node.left, scope, node, this);
        this.right = this.createTokenStack(compilation, node.right, scope, node, this);
        this.body = this.createTokenStack(compilation, node.body, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
        this.body.freeze();
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.left.parser();
        this.left.setRefBeUsed();
        this.right.parser();
        this.right.setRefBeUsed();
        if (this.body) {
          this.body.parser();
        }
        const desc2 = this.right.description();
        const type2 = desc2.type();
        const iterator = this.getGlobalTypeById("Iterator");
        const objectType = this.getGlobalTypeById("Object");
        if (!type2.isAnyType) {
          if (iterator.check(type2) || objectType.check(type2))
            return;
          this.right.error(1046, this.right.raw());
        }
        if (this.left.isVariableDeclaration) {
          if (this.left.declarations.length > 1) {
            this.left.declarations[1].error(1047, "for-in");
          }
          if (this.left.declarations[0].init) {
            this.left.declarations[0].init.error(1048, "for-in");
          }
        }
        const checkItems = /* @__PURE__ */ new Set();
        const getCheckItems = (desc3) => {
          if (!desc3)
            return [];
          let items = [];
          if (desc3.isDeclarator || desc3.isPropertyDefinition) {
            if (desc3.acceptType && !desc3.acceptType.type().isAnyType) {
              checkItems.add(desc3.acceptType.type());
            } else {
              items = Array.from(desc3.assignItems);
            }
          } else if (desc3.isMethodDefinition || desc3.isFunctionDeclaration) {
            if (desc3.returnType && !desc3.returnType.type().isAnyType) {
              checkItems.add(desc3.returnType.type());
            } else {
              items = desc3.scope.returnItems.map((item2) => item2.argument);
              if (desc3.isMethodGetterDefinition) {
                const name = desc3.key.value();
                const setter = this.module.getMember(name, "set");
                if (setter) {
                  items = items.concat(Array.from(setter.assignItems));
                }
              }
            }
          } else {
            items.push(desc3);
          }
          items.forEach((item2) => {
            if (item2.isArrayExpression || item2.isLiteral || item2.isObjectExpression || item2.isModule) {
              if (item2.isModule) {
                checkItems.add(item2);
              } else {
                checkItems.add(item2.type());
              }
            } else if (item2.isStack) {
              const desc4 = item2.description();
              if (item2 !== desc4) {
                getCheckItems(desc4);
              }
            }
          });
        };
        getCheckItems(desc2);
        const result = Array.from(checkItems).every((type3) => {
          return type3.is(iterator) || type3.is(objectType);
        });
        if (!result) {
          this.right.warn(1049, this.right.raw());
        }
      }
    };
    module.exports = ForInStatement;
  }
});

// lib/stacks/ForOfStatement.js
var require_ForOfStatement = __commonJS({
  "lib/stacks/ForOfStatement.js"(exports, module) {
    var Context = require_Context();
    var MergeType = require_MergeType();
    var Stack = require_Stack();
    var Utils2 = require_Utils();
    var BlockScope = require_BlockScope();
    var ForOfStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        scope = new BlockScope(scope);
        super(compilation, node, scope, parentNode, parentStack);
        this.isForOfStatement = true;
        this.left = this.createTokenStack(compilation, node.left, scope, node, this);
        this.right = this.createTokenStack(compilation, node.right, scope, node, this);
        this.body = this.createTokenStack(compilation, node.body, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
        this.body.freeze();
      }
      definition() {
        return null;
      }
      forOfType() {
        const t = this.getAttribute("forOfType");
        if (t)
          return t;
        const ctx2 = this.right.getContext();
        let rightType = this.right.type();
        ctx2.make(rightType);
        let valueType = this.getGlobalTypeById("any");
        if (rightType && !rightType.isAnyType) {
          if (rightType.isLiteralArrayType || rightType.isUnionType || rightType.isLiteralObjectType) {
            valueType = MergeType.to(rightType, !!(rightType.isLiteralArrayType || rightType.isLiteralObjectType));
          } else if (rightType.isTupleType) {
            if (rightType.elements.length == 1) {
              valueType = rightType.elements[0].type();
            } else {
              valueType = MergeType.to(rightType, true);
            }
          } else if (rightType.isLiteralType) {
            valueType = this.getGlobalTypeById("string");
          } else {
            const iterator = this.getGlobalTypeById("Iterator");
            const originType = Utils2.getOriginType(rightType);
            const IteratorReturnResult = this.getGlobalTypeById("IteratorReturnResult");
            if (originType.isModule && originType.is(iterator)) {
              let result = null;
              let declareGenerics = iterator.getModuleGenerics();
              if (declareGenerics) {
                const res = ctx2.fetch(declareGenerics[0]);
                if (res && !res.isUnknownType) {
                  result = res.type();
                }
              }
              if (!result) {
                const desc2 = originType.getDescriptor("next", (desc3, prev) => {
                  if (desc3.isMethodDefinition) {
                    const result2 = desc3.inferReturnType();
                    if (result2) {
                      if (IteratorReturnResult.is(result2.type(), ctx2)) {
                        return true;
                      }
                    }
                  }
                  return null;
                });
                if (desc2) {
                  const resultCtx = new Context(this.right);
                  const returnType = desc2._returnType;
                  if (returnType) {
                    resultCtx.make(returnType.type());
                  } else {
                    let inferType = desc2.inferReturnType();
                    if (inferType) {
                      resultCtx.extractive(IteratorReturnResult, inferType.type());
                    }
                  }
                  declareGenerics = IteratorReturnResult.getModuleGenerics();
                  if (declareGenerics) {
                    const res = resultCtx.fetch(declareGenerics[0]);
                    if (res && !res.isUnknownType) {
                      result = res.type();
                    }
                  }
                }
              }
              if (result) {
                valueType = result;
              }
            }
          }
        }
        return this.setAttribute("forOfType", valueType);
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.left.parser();
        this.left.setRefBeUsed();
        this.right.parser();
        this.right.setRefBeUsed();
        if (this.body) {
          this.body.parser();
        }
        const iterator = this.getGlobalTypeById("Iterator");
        const type2 = Utils2.getOriginType(this.right.type());
        if (this.left.isVariableDeclaration) {
          if (this.left.declarations.length > 1) {
            this.left.declarations[1].error(1047, "for-of");
          }
          if (this.left.declarations[0].init) {
            this.left.declarations[0].init.error(1048, "for-of");
          }
        }
        if (type2 && !type2.isAnyType && !type2.is(iterator)) {
          this.right.error(1049, this.right.raw());
        }
      }
    };
    module.exports = ForOfStatement;
  }
});

// lib/stacks/ForStatement.js
var require_ForStatement = __commonJS({
  "lib/stacks/ForStatement.js"(exports, module) {
    var Stack = require_Stack();
    var BlockScope = require_BlockScope();
    var ForStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        scope = new BlockScope(scope);
        super(compilation, node, scope, parentNode, parentStack);
        this.isForStatement = true;
        this.init = this.createTokenStack(compilation, node.init, scope, node, this);
        this.condition = this.createTokenStack(compilation, node.test, scope, node, this);
        this.update = this.createTokenStack(compilation, node.update, scope, node, this);
        this.body = this.createTokenStack(compilation, node.body, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.init && this.init.freeze();
        this.condition && this.condition.freeze();
        this.update && this.update.freeze();
        this.body.freeze();
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.init) {
          this.init.parser();
          this.init.setRefBeUsed();
        }
        if (this.condition) {
          this.condition.parser();
          this.condition.setRefBeUsed();
        }
        if (this.update) {
          this.update.parser();
          this.update.setRefBeUsed();
        }
        if (this.body) {
          this.body.parser();
        }
      }
    };
    module.exports = ForStatement;
  }
});

// lib/stacks/FunctionDeclaration.js
var require_FunctionDeclaration = __commonJS({
  "lib/stacks/FunctionDeclaration.js"(exports, module) {
    var FunctionExpression = require_FunctionExpression();
    var FunctionDeclaration = class extends FunctionExpression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isFunctionDeclaration = true;
        this.key = this.createTokenStack(compilation, node.id, scope, node, this);
        scope.define(this.key.value(), this);
      }
      freeze() {
        super.freeze();
        this.key.freeze();
        Object.freeze(this.useRefItems);
      }
    };
    module.exports = FunctionDeclaration;
  }
});

// lib/stacks/GenericDeclaration.js
var require_GenericDeclaration = __commonJS({
  "lib/stacks/GenericDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var GenericDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isGenericDeclaration = true;
        this.elements = node.elements.map((item2) => {
          const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          const fnScope = scope.getScopeByType("function");
          const name = stack2.value();
          if (scope.isDefine(name) && scope.define(name).scope.getScopeByType("function") === fnScope) {
            stack2.error(1056, name);
          } else if (this.getTypeById(name)) {
            stack2.error(1057, name);
          } else {
            scope.define(name, stack2);
          }
          return stack2;
        });
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.elements);
      }
      description() {
        return this;
      }
      definition() {
        return null;
      }
      type() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        let isAssignLast = false;
        this.elements.forEach((item2) => {
          item2.parser();
          const isAssign = item2.isGenericTypeAssignmentDeclaration;
          if (isAssignLast && !isAssign) {
            item2.error(1058);
          }
          isAssignLast = item2.isGenericTypeAssignmentDeclaration;
        });
      }
      value() {
        const elements = this.elements.map((item2) => {
          return item2.value();
        });
        return `<${elements.join(",")}>`;
      }
      raw() {
        const elements = this.elements.map((item2) => {
          return item2.raw();
        });
        return `<${elements.join(",")}>`;
      }
    };
    module.exports = GenericDeclaration;
  }
});

// lib/types/GenericType.js
var require_GenericType = __commonJS({
  "lib/types/GenericType.js"(exports, module) {
    var Type = require_Type();
    var GenericType = class extends Type {
      constructor(target, inherit = null, assignType = null, isFunGeneric = false) {
        super("$GenericType", inherit);
        this.target = target;
        this.isGenericType = true;
        this.assignType = assignType;
        this.isFunGeneric = isFunGeneric;
        this.hasGenericType = true;
        this.unikey = null;
      }
      getUniKey() {
        const unikey = this.unikey;
        if (unikey)
          return unikey;
        const target = this.target;
        const parent = target.parentStack.parentStack;
        const index = target.parentStack.elements.indexOf(target);
        const namespace = target.namespace.toString();
        let classId = null;
        let methodId = null;
        let hash = `${String(target.parentStack.elements.length)}`;
        if (parent.isClassDeclaration || parent.isInterfaceDeclaration || parent.isDeclaratorDeclaration) {
          classId = parent.id.value();
        } else if (parent.isFunctionExpression) {
          if (parent.key) {
            hash += `-${parent.params.length}`;
            if (parent.parentStack.isMethodDefinition) {
              classId = parent.parentStack.module.id;
            } else if (parent.module) {
              classId = parent.module.id;
            }
            if (parent.isDeclaratorFunction) {
              classId = parent.key.value();
            } else {
              methodId = parent.key.value();
            }
          } else if (parent.parentStack.isProperty) {
            const mStack = parent.parentStack.getParentStack((parent2) => {
              if (parent2.isMethodDefinition) {
                return true;
              }
            });
            if (parent.parentStack.module) {
              classId = parent.module.id;
            }
            if (mStack && mStack.isMethodDefinition) {
              methodId = `${mStack.key.value()}:${parent.parentStack.key.value()}`;
            } else {
              methodId = parent.parentStack.key.value();
            }
          }
        } else if (parent.isDeclaratorTypeAlias) {
          classId = parent.id;
        }
        const name = namespace ? `${namespace}.${classId}` : classId;
        const iden = methodId ? `${methodId}:${hash}-${index}` : `${hash}-${index}`;
        return this.unikey = `${name}::${iden}`;
      }
      get _extends() {
        if (this.target.extends) {
          return [this.target.extends.type()];
        }
        return null;
      }
      set _extends(value) {
      }
      get hasConstraint() {
        return !!this.target.extends;
      }
      attribute(property) {
        const inherit = this.inherit;
        if (!inherit) {
          return null;
        }
        if (inherit.isLiteralObjectType) {
          return inherit.attribute(property);
        } else if (inherit.isModule) {
          return inherit.getMember(property, "get");
        }
        return null;
      }
      clone(inference) {
        if (inference) {
          const result = inference(this);
          if (result && result !== this) {
            return result.clone(inference);
          }
        }
        return this;
      }
      check(stack2, context = {}, options = {}) {
        if (!stack2)
          return false;
        const inference = context && context.inference;
        if (inference) {
          let target = inference(this);
          if (target !== this) {
            let inherit = this.inherit;
            if (inherit && inherit.type().isKeyofType) {
              options.toLiteralValue = true;
            }
            return target.check(stack2, context, options);
          }
        }
        return this.is(stack2.type(), context, options);
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        if (!this.isNeedCheckType(type2))
          return true;
        let inherit = this.inherit;
        if (inherit && inherit.type().isKeyofType) {
          options.toLiteralValue = true;
        }
        let target = this.inferType(this, context);
        if (target !== this) {
          if (options.toLiteralValue) {
            if (target.isLiteralArrayType || target.isTupleType) {
              return target.elements.some((base) => {
                return base.type().is(type2, context, options);
              });
            }
          }
          return target.is(type2, context, options);
        }
        if (type2.isInstanceofType) {
          type2 = type2.inherit;
        }
        if (inherit) {
          if (inherit && inherit.isLiteralObjectType) {
            return inherit.constraint(type2, context, options);
          } else {
            if (type2.isGenericType && type2.hasConstraint) {
              type2 = type2.inherit;
            }
            return inherit.type().is(type2, context, options);
          }
        }
        return false;
      }
      toString(context = {}, options = {}) {
        let inherit = this.inherit;
        if (inherit && inherit.type().isKeyofType) {
          options.toLiteralValue = true;
        }
        if (!options.rawcode) {
          if (options.onlyTypeName) {
            return this.target.value();
          }
          if (!options.complete) {
            const type2 = this.inferType(this, context);
            if (type2 !== this) {
              return type2.toString(context, options);
            }
            if (options.toUniKeyValue) {
              return this.getUniKey();
            }
            return this.target.value();
          }
        }
        const parts = [];
        parts.push(this.target.value());
        if (inherit) {
          parts.push(` extends ${inherit.toString(context, options)}`);
        } else if (this.assignType) {
          parts.push(" = " + this.assignType.toString(context, options));
        }
        return parts.join("");
      }
    };
    module.exports = GenericType;
  }
});

// lib/stacks/GenericTypeAssignmentDeclaration.js
var require_GenericTypeAssignmentDeclaration = __commonJS({
  "lib/stacks/GenericTypeAssignmentDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var GenericType = require_GenericType();
    var GenericTypeAssignmentDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isGenericTypeAssignmentDeclaration = true;
        this.left = this.createTokenStack(compilation, node.left, scope, node, this);
        this.right = this.createTokenStack(compilation, node.right, scope, node, this);
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.left);
        super.freeze(this.right);
      }
      definition() {
        const type2 = this.type();
        if (type2.isModule) {
          return type2.definition();
        }
        const identifier = this.left.value();
        return {
          kind: this.kind,
          comments: this.comments,
          identifier,
          expre: `(Type) ${type2.toString()}`,
          location: this.left.getLocation(),
          file: this.compilation.file,
          context: this
        };
      }
      error(code, ...args) {
        this.left.error(code, ...args);
      }
      warn(code, ...args) {
        this.left.warn(code, ...args);
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type() {
        if (!this._type) {
          const isFunGeneric = !!(this.parentStack && this.parentStack.parentStack && this.parentStack.parentStack.isFunctionExpression);
          this._type = new GenericType(this, null, this.right.type(), isFunGeneric);
        }
        return this._type;
      }
      parser() {
        return this.right.parser();
      }
      value() {
        return this.left.value();
      }
    };
    module.exports = GenericTypeAssignmentDeclaration;
  }
});

// lib/stacks/GenericTypeDeclaration.js
var require_GenericTypeDeclaration = __commonJS({
  "lib/stacks/GenericTypeDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var GenericType = require_GenericType();
    var GenericTypeDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isGenericTypeDeclaration = true;
        this.valueType = this.createTokenStack(compilation, node.value, scope, node, this);
        this.extends = this.createTokenStack(compilation, node.extends, scope, node, this);
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.valueType);
        super.freeze(this.extends);
      }
      definition(context) {
        const type2 = this.type();
        const identifier = this.valueType.value();
        const owner = this.parentStack.parentStack;
        let ns = owner.module ? owner.module.toString(context) : owner.isDeclaratorTypeAlias ? owner.left.value() : "";
        let desc2 = owner.isFunctionExpression ? owner.type().toString() : ns;
        let name = owner.isFunctionExpression && owner.parentStack && owner.parentStack.key ? ns + "." + owner.parentStack.key.value() : "";
        return {
          kind: this.kind,
          comments: this.comments,
          identifier,
          expre: `(type parameter) ${type2.toString()} in ${name}${desc2}`,
          location: this.valueType.getLocation(),
          file: this.compilation.file,
          context: this
        };
      }
      error(code, ...args) {
        this.valueType.error(code, ...args);
      }
      warn(code, ...args) {
        this.valueType.warn(code, ...args);
      }
      description() {
        return this;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type() {
        if (!this._type) {
          if (this.extends && this.scope.define(this.extends.value()) === this) {
            this._type = this.getGlobalTypeById("never");
          } else {
            const isFunGeneric = !!(this.parentStack && this.parentStack.parentStack && this.parentStack.parentStack.isFunctionExpression);
            this._type = new GenericType(this, null, null, isFunGeneric);
          }
        }
        return this._type;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.extends) {
          if (this.scope.define(this.extends.value()) === this) {
            this.extends.error(1141, this.extends.value());
          } else {
            this.extends.parser();
          }
        }
      }
      value() {
        return this.valueType.value();
      }
      raw() {
        return this.valueType.raw();
      }
    };
    module.exports = GenericTypeDeclaration;
  }
});

// lib/stacks/Identifier.js
var require_Identifier = __commonJS({
  "lib/stacks/Identifier.js"(exports, module) {
    var Namespace2 = require_Namespace();
    var Stack = require_Stack();
    var Utils2 = require_Utils();
    var keySymbol = Symbol("key");
    var Identifier = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isIdentifier = true;
        this[keySymbol] = {};
        this.addHook();
      }
      addHook() {
        if (!this.isJSXForContext()) {
          const id = this.value();
          const maybe = this.parentStack.isCallExpression || this.parentStack.isNewExpression || this.parentStack.isAssignmentPattern && this.parentStack.node.right === this.node || this.parentStack.isAssignmentExpression && this.parentStack.node.right === this.node || this.parentStack.isVariableDeclarator && this.parentStack.node.init === this.node || this.parentStack.isMemberExpression && this.parentStack.node.object === this.node || this.parentStack.isProperty && this.parentStack.node.value === this.node;
          if (maybe) {
            if (this.parentStack.isMemberExpression) {
              const p = this.getParentStack((item2) => !item2.isMemberExpression);
              if (p && p.isImportDeclaration) {
                return;
              }
            }
            if (this.checkNeedToLoadTypeById(id)) {
              this.compilation.hookAsync("compilation.create.after", async () => {
                const desc2 = await this.loadTypeAsync(id);
                if (desc2 && desc2.isModule) {
                  this.compilation.addDependency(desc2, this.module);
                }
              });
            } else {
              const desc2 = this.scope.define(id);
              if (desc2 && desc2.isModule) {
                this.compilation.addDependency(desc2, this.module);
              }
            }
          }
        }
      }
      definition(context) {
        const pStack = this.parentStack;
        if (pStack) {
          if (this.isTypeDefinitionStack(pStack)) {
            return pStack.definition(context);
          }
          if (pStack.isMethodDefinition || pStack.isFunctionDeclaration || pStack.isProperty) {
            if (pStack.key === this) {
              return pStack.definition(context);
            } else if (pStack.isProperty && pStack.parentStack.isObjectPattern && pStack.init === this) {
              return pStack.definition(context);
            }
          } else if (pStack.isVariableDeclarator) {
            if (pStack.parentStack.isDeclaratorVariable) {
              return pStack.parentStack.definition(context);
            } else if (pStack.id === this) {
              return pStack.definition(context);
            }
          } else if (pStack.isClassDeclaration || pStack.isDeclaratorDeclaration || pStack.isInterfaceDeclaration || pStack.isEnumDeclaration && !pStack.isExpressionDeclare) {
            if (!context) {
              context = pStack.getContext();
            }
          } else if (pStack.isDeclaratorTypeAlias || pStack.isDeclaratorVariable || pStack.isDeclaratorFunction) {
            return pStack.definition(context);
          } else if (pStack.isAnnotationExpression) {
            const name = pStack.name.toLowerCase();
            if (name === "http" || name === "router") {
              const index = pStack.body.indexOf(this);
              if (index >= 0) {
                const args = pStack.getArguments();
                const itemArg = args[index];
                if (index < 2 || itemArg && String(itemArg.key).toLowerCase() === "action") {
                  return pStack.definition(context || super.getContext());
                }
              }
            }
          }
        }
        const desc2 = this.description();
        if (this.value() === "arguments") {
          const expre = `(local const) arguments: ${desc2.type().toString()}`;
          return {
            expre
          };
        }
        context = context || this.getContext();
        if (desc2 && desc2 !== this) {
          const pStack2 = this.parentStack;
          if ((pStack2.isCallExpression || pStack2.isNewExpression) && pStack2.callee === this) {
            return pStack2.definition(context);
          } else if (pStack2.isMemberExpression) {
            if (pStack2.parentStack.isImportDeclaration || pStack2.property === this) {
              return pStack2.definition(context);
            }
          } else if (pStack2.isTypeObjectPropertyDefinition || pStack2.isTypeTupleRestDefinition) {
            return this.parentStack.definition(context);
          }
          if (desc2.isModule) {
            return desc2.definition(context);
          } else if (desc2.isType && !desc2.isStack) {
            const def = desc2.target && desc2.target.isStack ? desc2.target.definition(context) : desc2.definition(context);
            if (def)
              return def;
          } else if (desc2.isStack) {
            const def = desc2.definition(context);
            if (def)
              return def;
          }
        }
        if (this.parentStack) {
          if (this.parentStack.isStructTableDeclaration || this.parentStack.isAssignmentExpression) {
            return null;
          }
          return this.parentStack.definition(context);
        }
        return null;
      }
      reference(called) {
        const value = this.value();
        const description = this.scope.define(value);
        if (description && description !== this && description instanceof Stack) {
          return description.reference(called);
        }
        return this;
      }
      referenceItems(called) {
        const value = this.value();
        const description = this.scope.define(value);
        if (description && description !== this && description instanceof Stack) {
          return description.referenceItems(called);
        }
        return [this];
      }
      getContext() {
        const desc2 = this.description();
        if (desc2 && desc2 !== this && desc2.isStack && (desc2.isDeclarator || desc2.isProperty)) {
          return this.getAttribute("Idenfifier.getContext", () => {
            return desc2.getContext().createChild(this);
          });
        }
        return super.getContext();
      }
      findDescription() {
        return this.getAttribute("Idenfifier.findDescription.result", () => {
          if (this.parentStack.isMemberExpression && !this.parentStack.computed && this.parentStack.object !== this) {
            return false;
          }
          const value = this.value();
          const module2 = this.module;
          let isAnnot = false;
          let p = this.parentStack;
          if (p) {
            if (p.isVariableDeclarator && p.id === this) {
              return false;
            }
            if (p.isAssignmentPattern && p.left === this && !(p.parentStack.isArrayPattern && p.parentStack.parentStack.isAssignmentExpression)) {
              return false;
            }
            if (p.isProperty && p.key === this && p.hasInit) {
              return false;
            }
            p = p.parentStack;
            isAnnot = p.isAnnotationDeclaration || p.isAnnotationExpression;
          }
          var desc2 = this.scope.define(value);
          var global = false;
          if (module2 && desc2 === module2) {
            return { desc: desc2, global };
          }
          if (desc2 && desc2.isImportSpecifier && desc2.parentStack && desc2.parentStack.isImportDeclaration) {
            const object = Namespace2.fetch(desc2.parentStack.source.value());
            if (object) {
              const _desc = this.getMatchDescriptor(desc2.imported.value(), object);
              if (_desc)
                desc2 = _desc;
            }
          }
          if (desc2) {
            if (desc2.isVariableDeclarator && desc2.init === this)
              return false;
            if (desc2.isDeclarator)
              return { desc: desc2, global };
          } else {
            global = !this.isJSXForContext();
            if (global) {
              if (this.parentStack.isCallExpression && this.parentStack.callee === this) {
                desc2 = this.parentStack.getMatchDescriptor(value, Namespace2.dataset);
              }
            }
          }
          const scopeCtx = { removed: false };
          desc2 = this.checkScope(desc2, scopeCtx);
          if (!desc2 && module2 && !isAnnot) {
            const scope = this.scope.getScopeByType("function");
            const isRef = !this.parentStack.isMemberExpression || this.parentStack.object === this;
            if (isRef && !this.parentStack.isTypeDefinition) {
              const isStatic = !!(module2.static || (scope && scope.isMethod ? scope.isStatic : false));
              desc2 = this.getMatchDescriptor(value, module2, isStatic);
            }
          }
          return { desc: desc2, global, scopeCtx };
        });
      }
      description() {
        return this.getAttribute("Idenfifier.description", () => {
          const value = this.value();
          if (this.parentStack.isImportDeclaration) {
            return this.getModuleById(value);
          } else if (this.parentStack.isMemberExpression && this.parentStack.object === this) {
            const pStack = this.getParentStack((stack2) => !stack2.isMemberExpression);
            if (pStack && pStack.isImportDeclaration) {
              return Namespace2.fetch(this.value(), null, true);
            }
          }
          let { desc: desc2, scopeCtx, global } = this.findDescription();
          if (desc2 === false)
            return null;
          if (!desc2 && global) {
            desc2 = this.getModuleById(value);
          }
          if (scopeCtx && desc2) {
            desc2 = this.checkScope(desc2, scopeCtx);
          }
          if (!desc2 && scopeCtx && scopeCtx.removed) {
            this.error(1178, this.raw());
          }
          if (desc2 && desc2.isDeclaratorVariable && desc2.init === this) {
            return null;
          } else if (desc2 === this) {
            return null;
          }
          return desc2;
        });
      }
      checkScope(desc2, ctx2) {
        if (this.compilation.isDescriptionType)
          return desc2;
        if (this.parentStack.isMemberExpression && this.parentStack.object !== this) {
          return desc2;
        }
        if (desc2 && (desc2.isModule || desc2.isStack) && !this.isTypeDefinitionStack(this.parentStack)) {
          if (!this.compiler.checkContenxtDescriptor(desc2, this.module || this.compilation)) {
            ctx2.removed = true;
            return null;
          }
        }
        return desc2;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.isJSXForContext()) {
          return true;
        }
        const description = this.description();
        if (description) {
          if (description.isModule && !this.isTypeDefinitionStack(this.parentStack)) {
            this.compilation.addDependency(description, this.module);
          }
          this.parserDescriptor(description);
        }
        if (!description) {
          this.error(1013, this.value());
        } else if ((description.isAliasType || description.isGenericTypeDeclaration || description.isTypeStatement) && !this.scope.isDirective) {
          const parent = this.parentStack;
          if (!parent.isTypeTransformExpression && !(this.isTypeDefinitionStack(parent) || parent.isGenericTypeDeclaration || parent.isGenericDeclaration)) {
            this.error(1059, this.value());
          }
        }
      }
      type() {
        return this.getAttribute("Identifier.type", () => {
          var type2 = null;
          const description = this.description();
          if (description && description.isDeclaratorVariable && (this.parentStack.isNewExpression || this.parentStack.isCallExpression)) {
            type2 = description.declarations[0].type();
            const origin = Utils2.getOriginType(type2);
            if (Utils2.isTypeModule(origin)) {
              this.compilation.addDependency(origin, this.module);
            }
            return type2;
          }
          if (description && description.isNamespace) {
            type2 = description;
          } else if (description && (description.isStack || description.isType) && description !== this) {
            type2 = description.type();
            if (type2.isGenericType && description.isStack && description instanceof Stack) {
              type2 = description.getContext().fetch(type2, true);
            }
          } else {
            type2 = this.getGlobalTypeById("any");
          }
          return type2;
        });
      }
      value() {
        return this.node.name;
      }
      raw() {
        return this.node.name;
      }
    };
    module.exports = Identifier;
  }
});

// lib/stacks/IfStatement.js
var require_IfStatement = __commonJS({
  "lib/stacks/IfStatement.js"(exports, module) {
    var Stack = require_Stack();
    var IfStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isIfStatement = true;
        this.condition = this.createTokenStack(compilation, node.test, scope, node, this);
        this.consequent = this.createTokenStack(compilation, node.consequent, scope, node, this);
        this.alternate = this.createTokenStack(compilation, node.alternate, scope, node, this);
        this.hasReturnStatement = false;
        if (this.alternate && this.consequent) {
          let alternate = !!(this.alternate.hasReturnStatement || this.alternate.hasThrowStatement);
          let consequent = !!(this.consequent.hasReturnStatement || this.consequent.hasThrowStatement);
          if (!alternate && this.alternate.isBlockStatement) {
            alternate = this.alternate.body.some((item2) => !!(item2.hasReturnStatement || item2.hasThrowStatement));
          }
          if (alternate && !consequent && this.consequent.isBlockStatement) {
            consequent = this.consequent.body.some((item2) => !!(item2.hasReturnStatement || item2.hasThrowStatement));
          }
          this.hasReturnStatement = alternate && consequent;
        }
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.condition);
        super.freeze(this.consequent);
        super.freeze(this.alternate);
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (!this.condition) {
          this.error(1041);
        } else {
          this.condition.parser();
          this.condition.setRefBeUsed();
        }
        if (this.consequent) {
          this.consequent.parser();
        }
        if (this.alternate) {
          this.alternate.parser();
        }
      }
    };
    module.exports = IfStatement;
  }
});

// lib/stacks/ImportDeclaration.js
var require_ImportDeclaration = __commonJS({
  "lib/stacks/ImportDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var ImportDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isImportDeclaration = true;
        this.source = this.createTokenStack(compilation, node.source, scope, node, this);
        this.specifiers = node.specifiers.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
        this.alias = this.createTokenStack(compilation, node.alias, scope, node, this);
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.alias);
        super.freeze(this.source);
        this.specifiers.forEach((item2) => item2.freeze());
      }
      set additional(stack2) {
        this._additional = stack2;
      }
      get additional() {
        return this._additional;
      }
      definition(ctx2) {
        if (ctx2 && (ctx2.stack === this.source || ctx2 === this.source)) {
          const compilation = this.getResolveCompilation();
          if (compilation) {
            return {
              expre: `(import) "${compilation.file}"`,
              location: compilation.stack.getLocation(),
              range: this.source.getLocation(),
              file: compilation.file
            };
          } else {
            return {
              expre: `(import) "${this.source.value()}"`,
              location: this.source.getLocation(),
              range: this.source.getLocation()
            };
          }
        }
        return null;
      }
      description() {
        if (this.source.isLiteral) {
          const compilation = this._resolveCompilation;
          if (compilation && compilation.modules.size > 0) {
            return compilation.mainModule;
          }
          return null;
        } else {
          return this.getModuleById(this.source.value()) || null;
        }
      }
      async addImport(owner, scope) {
        if (this.source.isLiteral) {
          await this.getResolveCompilationAsync();
        } else {
          await this.loadTypeAsync(this.source.value());
        }
        const desc2 = this.description();
        if (desc2) {
          scope = scope || this.scope;
          const nameId = this.alias ? this.alias.value() : desc2.isType ? desc2.id : this.source.isMemberExpression ? this.source.property.value() : this.source.value();
          if (desc2.isModule) {
            const add = (key, module2, stack2) => {
              if (owner && !owner.addImport(key, module2, module2.id != key, scope)) {
                if (owner.file === this.compilation.file) {
                  stack2.error(1025, key);
                }
              }
              scope.define(key, module2);
              const moduleStack = this.compilation.getStackByModule(module2);
              if (moduleStack) {
                moduleStack.addUseRef(stack2);
                if (stack2 === this && this.alias) {
                  moduleStack.addUseRef(this.alias);
                }
              }
            };
            if (this.source.isLiteral) {
              const compilation = this.getResolveCompilation();
              const isAll = this.specifiers.some((item2) => item2.isImportNamespaceSpecifier);
              if (isAll) {
                compilation.modules.forEach((module2, index) => {
                  add(index === 0 ? nameId : module2.id, module2, this);
                });
              } else {
                this.specifiers.forEach((item2) => {
                  if (item2.isImportDefaultSpecifier) {
                    add(item2.local.value(), desc2, item2);
                  } else {
                    const module2 = compilation.modules.get(item2.imported.value());
                    if (module2) {
                      add(item2.value(), module2, item2);
                    }
                  }
                });
              }
            } else {
              add(nameId, desc2, this);
            }
          } else {
            scope.define(nameId, desc2);
          }
        } else if (!this.source.isLiteral) {
          this.error(1026, this.source.value());
        } else {
          this.specifiers.forEach((item2) => {
            item2.localBinding();
          });
        }
        return desc2;
      }
      getResolveFile() {
        if (this.resolve !== void 0)
          return this.resolve;
        const resolve = this.resolve = this.compiler.resolve(
          this.source.isLiteral ? this.source.value() : this.source.value().replace(".", "/"),
          this.compilation.file
        );
        if (!resolve) {
          return this.source.value();
        }
        return resolve;
      }
      checkFileExists() {
        this.getResolveFile();
        if (!this.resolve) {
          this.source.error(1122, this.source.value());
          return false;
        }
        return true;
      }
      getResolveCompilation() {
        return this._resolveCompilation;
      }
      async getResolveCompilationAsync() {
        if (this._resolveCompilation !== void 0) {
          return this._resolveCompilation;
        }
        this._resolveCompilation = null;
        if (this.compiler.options.suffix === this.getFileExt()) {
          const compilation = this._resolveCompilation = await this.compilation.createChildCompilation(this.getResolveFile(), this.compilation.file);
          if (!compilation) {
            this.source.error(1132, this.source.value());
          } else {
            compilation.import = "importSpecifier";
          }
          return compilation;
        }
        return null;
      }
      getFileExt() {
        const resolve = this.getResolveFile();
        if (resolve) {
          const pos = resolve.lastIndexOf(".");
          if (pos > 0) {
            return resolve.substring(pos);
          }
        }
        return null;
      }
      getDescByName(desc2, key) {
        if (!desc2 || desc2.isAnyType)
          return null;
        if ((desc2.isAliasType || desc2.isLiteralObjectType) && !desc2.isModule) {
          if (desc2.isAliasType)
            desc2 = desc2.inherit;
          if (desc2.isLiteralObjectType) {
            return desc2.attribute(key);
          }
        } else if (desc2.isNamespace) {
          return desc2.get(key);
        }
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.source.isLiteral) {
          const resolveCompilation = this.getResolveCompilation();
          this.specifiers.forEach((item2) => item2.parser());
          if (resolveCompilation) {
            const desc2 = this.description();
            if (!(resolveCompilation.stack && resolveCompilation.stack.exports.length > 0) && !desc2) {
              this.source.error(1162, this.source.value());
            }
          }
        } else {
          const desc2 = this.description();
          if (!desc2) {
            this.error(1026, this.source.value());
          }
        }
      }
      type() {
        return this.description() || this.getGlobalTypeById("any");
      }
      value() {
        return this.source.value();
      }
      raw() {
        return this.source.raw();
      }
    };
    module.exports = ImportDeclaration;
  }
});

// lib/stacks/ImportDefaultSpecifier.js
var require_ImportDefaultSpecifier = __commonJS({
  "lib/stacks/ImportDefaultSpecifier.js"(exports, module) {
    var Declarator = require_Declarator();
    var Namespace2 = require_Namespace();
    var ImportDefaultSpecifier = class extends Declarator {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node.local, scope, parentNode, parentStack);
        this.isImportDefaultSpecifier = true;
        this._kind = "const";
      }
      freeze() {
        super.freeze(this);
      }
      definition(ctx2) {
        const desc2 = this.description();
        if (desc2) {
          const def = desc2.definition(ctx2);
          if (def) {
            return {
              comments: def.comments,
              expre: `(import refs) ${this.value()}:${desc2.type().toString(ctx2)}`,
              location: def.location,
              file: def.file
            };
          }
        }
        return {
          expre: `(import refs) ${this.value()}:any`
        };
      }
      description() {
        if (this.parentStack.source.isLiteral) {
          const compilation = this.parentStack.getResolveCompilation();
          if (compilation && compilation.stack && compilation.stack.exports.length > 0) {
            const result = compilation.stack.exports.find((item2) => item2.isExportDefaultDeclaration);
            if (result) {
              return result.description();
            }
          } else if (!compilation) {
            const source = this.parentStack.source.value();
            const desc2 = Namespace2.globals.get(source);
            if (desc2) {
              if (desc2.isModule && desc2.isDeclaratorModule) {
                return desc2;
              } else if (desc2.isAliasType) {
                return desc2;
              } else if (desc2.isStack) {
                return desc2;
              }
            }
          }
        }
        return null;
      }
      type() {
        const desc2 = this.description();
        if (desc2)
          return desc2.type();
        return this.getGlobalTypeById("any");
      }
      localBinding() {
        const name = this.value();
        const additional = this.parentStack.additional;
        if (additional) {
          const binding = additional.isDeclaratorVariable || additional.isDeclaratorFunction || additional.isDeclaratorTypeAlias;
          if (binding) {
            return true;
          }
        }
        if (this.scope.isDefine(name)) {
          const old = this.scope.define(name);
          if (old.compilation === this.compilation && !this.compilation.isDescriptorDocument()) {
            this.error(1025, name);
          }
        }
        this.scope.define(name, this);
      }
    };
    module.exports = ImportDefaultSpecifier;
  }
});

// lib/stacks/ImportExpression.js
var require_ImportExpression = __commonJS({
  "lib/stacks/ImportExpression.js"(exports, module) {
    var Stack = require_Stack();
    var ImportExpression = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isImportExpression = true;
        this.source = this.createTokenStack(compilation, node.source, scope, node, this);
        this.compilation.hookAsync("compilation.create.after", async () => {
          if (this.source.isLiteral) {
            await this.getResolveCompilationAsync();
          } else {
            const desc2 = await this.loadTypeAsync(this.source.value());
            if (desc2 && desc2.isModule) {
              this.compilation.addDependency(desc2, this.module);
            }
          }
        });
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.source);
      }
      definition(ctx2) {
        const context = this.description();
        if (context && context.isType && context.isModule && (context.isClass || context.isDeclarator || context.isInterface)) {
          return context.definition(ctx2);
        }
      }
      description() {
        if (this.source) {
          if (this.source.isLiteral) {
            const compilation = this._resolveCompilation;
            if (compilation && compilation.modules.size > 0) {
              return compilation.mainModule;
            }
          } else {
            return this.getModuleById(this.source.value());
          }
        }
        return null;
      }
      getResolveFile() {
        if (this.resolve !== void 0)
          return this.resolve;
        const resolve = this.resolve = this.compiler.resolve(
          this.source.isLiteral ? this.source.value() : this.source.value().replace(".", "/"),
          this.compilation.file
        );
        if (!resolve) {
          this.source.error(1122, this.source.value());
        }
        return resolve;
      }
      getResolveCompilation() {
        return this._resolveCompilation;
      }
      async getResolveCompilationAsync() {
        if (this._resolveCompilation !== void 0)
          return this._resolveCompilation;
        this._resolveCompilation = null;
        if (this.compiler.options.suffix === this.getFileExt()) {
          const compilation = this._resolveCompilation = await this.compilation.createChildCompilation(this.getResolveFile(), this.compilation.file);
          if (!compilation) {
            this.source.error(1132, this.source.value());
          } else {
            if (compilation.mainModule) {
              this.compilation.addDependency(compilation.mainModule, this.module);
            } else {
              this.compilation.addDependency(compilation);
            }
            compilation.import = "importSpecifier";
          }
          return compilation;
        }
        return null;
      }
      getFileExt() {
        const resolve = this.getResolveFile();
        if (resolve) {
          const pos = resolve.lastIndexOf(".");
          if (pos > 0) {
            return resolve.substring(pos);
          }
        }
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.source) {
          const module2 = this.description();
          if (!module2) {
            if (this.compiler.options.suffix === this.getFileExt()) {
              const file = this.source.value();
              if (file) {
                this.source.error(1026, this.source.value());
              } else {
                this.source.error(1060, this.source.value());
              }
            }
          } else {
            module2.used = true;
            this.compilation.addDependency(module2, this.module);
          }
        } else {
          this.error(1e3, 1, 0);
        }
      }
      type() {
        return this.description() || this.getGlobalTypeById("any");
      }
      value() {
        return this.source.value();
      }
      raw() {
        return this.source.raw();
      }
    };
    module.exports = ImportExpression;
  }
});

// lib/stacks/ImportNamespaceSpecifier.js
var require_ImportNamespaceSpecifier = __commonJS({
  "lib/stacks/ImportNamespaceSpecifier.js"(exports, module) {
    var Declarator = require_Declarator();
    var Namespace2 = require_Namespace();
    var ImportNamespaceSpecifier = class extends Declarator {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node.local, scope, parentNode, parentStack);
        this.isImportNamespaceSpecifier = true;
        this._kind = "const";
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.local);
      }
      definition(ctx2) {
        const compilation = this.parentStack.getResolveCompilation();
        if (compilation) {
          if (compilation.modules.size > 0) {
            const module2 = Array.from(compilation.modules.values())[0];
            return module2.definition(ctx2);
          }
          return {
            expre: `(import refs) ${this.value()}:${this.type().toString()}`,
            location: compilation.stack.getLocation(),
            file: compilation.file
          };
        } else {
          const desc2 = this.description();
          if (desc2) {
            if (desc2.isModule) {
              const def = desc2.definition(ctx2);
              if (def) {
                return {
                  comments: def.comments,
                  expre: `(import refs) ${this.value()}:${desc2.type().toString()}`,
                  location: def.location,
                  file: def.file
                };
              }
              return null;
            } else if (desc2.isNamespace) {
              return {
                expre: `(namespace) ${this.value()} as ${desc2.toString()}`
              };
            }
            return {
              expre: `(import refs) ${this.value()}:${desc2.type().toString()}`,
              location: desc2.isStack ? desc2.getLocation() : this.getLocation(),
              file: desc2.isStack ? desc2.file : this.file
            };
          }
        }
        return {
          expre: `(import refs) ${this.value()}:any`
        };
      }
      description() {
        if (this.__desc !== void 0)
          return this.__desc;
        this.__desc = null;
        if (this.parentStack.source.isLiteral) {
          const compilation = this.parentStack.getResolveCompilation();
          if (compilation && compilation.stack && compilation.stack.exports.length > 0) {
            const result = compilation.stack.exports.find((item2) => item2.isExportDefaultDeclaration);
            if (result) {
              return this.__desc = result.description();
            }
          } else if (!compilation) {
            const source = this.parentStack.source.value();
            const desc2 = Namespace2.globals.get(source) || Namespace2.fetch(source);
            if (desc2) {
              if (desc2.isModule && desc2.isDeclaratorModule) {
                return this.__desc = desc2;
              } else if (desc2.isAliasType || desc2.isStack) {
                return this.__desc = desc2;
              } else if (desc2.isNamespace) {
                return this.__desc = desc2;
              }
            }
          }
        }
        return null;
      }
      type() {
        const desc2 = this.description();
        if (desc2) {
          if (desc2.isNamespace)
            return desc2;
          return desc2.type();
        }
        return this.getGlobalTypeById("any");
      }
      localBinding() {
        if (this.node.type === "Identifier") {
          const additional = this.parentStack.additional;
          if (additional) {
            const binding = additional.isDeclaratorVariable || additional.isDeclaratorFunction || additional.isDeclaratorTypeAlias;
            if (binding) {
              return true;
            }
          }
          const name = this.value();
          if (this.scope.isDefine(name)) {
            const old = this.scope.define(name);
            if (old.compilation === this.compilation && !this.compilation.isDescriptorDocument()) {
              this.error(1025, name);
            }
          }
          this.scope.define(name, this);
        }
      }
    };
    module.exports = ImportNamespaceSpecifier;
  }
});

// lib/stacks/ImportSpecifier.js
var require_ImportSpecifier = __commonJS({
  "lib/stacks/ImportSpecifier.js"(exports, module) {
    var Declarator = require_Declarator();
    var Namespace2 = require_Namespace();
    var ImportSpecifier = class extends Declarator {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node.local, scope, parentNode, parentStack);
        this.isImportSpecifier = true;
        this.imported = this.createTokenStack(compilation, node.imported, scope, node, this);
        this._kind = "const";
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.imported);
      }
      get useRefItems() {
        const dataset = this.fetchUseRefItems();
        return dataset || super.useRefItems;
      }
      fetchUseRefItems() {
        if (!this.parentStack.source.isLiteral)
          return null;
        const compilation = this.parentStack.getResolveCompilation();
        if (compilation)
          return null;
        const source = this.parentStack.source.value();
        const desc2 = Namespace2.fetch(source, null, true);
        if (desc2 && desc2.isNamespace && desc2.descriptors.has(this.imported.value())) {
          const dataset = super.useRefItems;
          desc2.getDescriptor(this.imported.value(), (desc3) => {
            if (desc3.isStack && desc3.useRefItems) {
              desc3.useRefItems.forEach((value) => {
                if (value.compilation === this.compilation) {
                  dataset.add(value);
                }
              });
            }
          });
          return dataset;
        }
        return null;
      }
      definition(ctx2) {
        const desc2 = this.description();
        if (desc2) {
          if (desc2.isExportAllDeclaration) {
            const compilation = desc2.getResolveCompilation();
            return {
              comments: compilation.stack.comments,
              expre: `(import refs) ${this.value()}:${this.type().toString(ctx2)}`,
              location: compilation.stack.getLocation(),
              file: compilation.file
            };
          }
          const def = desc2.definition(ctx2);
          if (def) {
            return {
              comments: def.comments,
              expre: `(import refs) ${this.value()}:${desc2.type().toString(ctx2)}`,
              location: def.location,
              file: def.file
            };
          }
        }
        return {
          expre: `(import refs) ${this.value()}:any`
        };
      }
      description() {
        if (this.parentStack.source.isLiteral) {
          const compilation = this.parentStack.getResolveCompilation();
          if (compilation && compilation.stack && compilation.stack.exports.length > 0) {
            const imported = this.imported.value();
            const exports2 = compilation.stack.exports;
            for (var i = 0; exports2.length > i; i++) {
              const item2 = exports2[i];
              if (item2.isExportAllDeclaration && item2.exported && item2.exported.value() === imported) {
                return item2;
              } else if (item2.isExportNamedDeclaration) {
                const desc2 = item2.getDescByName(imported);
                if (desc2)
                  return desc2;
              }
            }
          } else if (!compilation) {
            const source = this.parentStack.source.value();
            const desc2 = Namespace2.fetch(source);
            if (desc2) {
              const imports = desc2.imports;
              if (Array.isArray(imports) && imports.some((imp) => imp === this.parentStack)) {
                return null;
              }
              return this.parentStack.getDescByName(desc2, this.imported.value());
            }
          }
        }
        return null;
      }
      type() {
        const desc2 = this.description();
        if (desc2)
          return desc2.type();
        return this.getGlobalTypeById("any");
      }
      localBinding() {
        const name = this.value();
        const additional = this.parentStack.additional;
        if (additional) {
          const binding = additional.isDeclaratorVariable || additional.isDeclaratorFunction || additional.isDeclaratorTypeAlias;
          if (binding) {
            return true;
          }
        }
        if (this.scope.isDefine(name)) {
          const old = this.scope.define(name);
          if (old.compilation === this.compilation && !this.compilation.isDescriptorDocument()) {
            this.error(1025, name);
          }
        }
        this.scope.define(name, this);
      }
      parser() {
        if (super.parser() === false)
          return false;
        const desc2 = this.description();
        if (!desc2) {
          const compilation = this.parentStack.getResolveCompilation();
          if (compilation) {
            this.error(1164, this.parentStack.source.value(), this.imported.value());
          }
        }
      }
    };
    module.exports = ImportSpecifier;
  }
});

// lib/stacks/InterfaceDeclaration.js
var require_InterfaceDeclaration = __commonJS({
  "lib/stacks/InterfaceDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var ClassScope = require_ClassScope();
    var InterfaceDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        scope = new ClassScope(scope);
        super(compilation, node, scope, parentNode, parentStack);
        this.isInterfaceDeclaration = true;
        this._metatypes = [];
        this._annotations = [];
        this.body = [];
        this.usings = [];
        this._imports = [];
        this.id = this.createTokenStack(compilation, node.id, scope, node, this);
        const module2 = this.module = compilation.createModule(this.namespace, this.id.value());
        this.id.module = module2;
        this.inherit = this.createTokenStack(compilation, node.extends, scope, node, this);
        if (node.extends && node.extends.genericity) {
          this.inherit.assignGenerics = node.extends.genericity.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
        }
        this.implements = (node.implements || []).map((item2) => {
          const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          if (item2.genericity) {
            stack2.assignGenerics = item2.genericity.map((item3) => this.createTokenStack(compilation, item3, scope, node, this));
          }
          return stack2;
        });
        scope.define(module2.id, module2);
        this.modifier = this.createTokenStack(compilation, node.modifier, scope, node);
        this.genericity = this.createTokenStack(compilation, node.genericity, scope, node, this);
        module2.comments = this.comments;
        module2.isInterface = true;
        compilation.addModuleStack(module2, this);
      }
      set metatypes(value) {
        value.forEach((item2) => {
          item2.additional = this;
        });
        if (value.length > 0) {
          this._metatypes = value;
        }
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value) {
        value.forEach((annotation) => {
          annotation.additional = this;
        });
        if (value.length > 0) {
          this._annotations = value;
        }
      }
      get annotations() {
        return this._annotations;
      }
      set imports(items) {
        if (Array.isArray(items)) {
          items.forEach((item2) => {
            if (item2.isImportDeclaration) {
              item2.additional = this;
            }
          });
          this._imports = items;
        }
      }
      get imports() {
        return this._imports;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.id);
        super.freeze(this.scope);
        super.freeze(this.inherit);
        super.freeze(this.implements);
        super.freeze(this.imports);
        super.freeze(this.modifier);
        super.freeze(this.genericity);
        super.freeze(this.module);
        super.freeze(this.body);
        (this.body || []).forEach((stack2) => stack2.freeze());
      }
      definition(context) {
        const module2 = this.module;
        context = context || {};
        context.scopeGenerics = true;
        let location = (this.id || this).getLocation();
        return {
          kind: "interface",
          comments: this.comments,
          expre: `(interface) ${module2.toString(context)}`,
          location,
          file: this.file
        };
      }
      async createCompleted() {
        const compilation = this.compilation;
        await this.allSettled(this.imports, async (stack2) => {
          const module2 = await stack2.addImport(this.module, this.parentStack.scope);
          if (module2 && module2.isType) {
            if (this.checkDepend(this.module, module2)) {
              stack2.error(1024, stack2.value());
            }
          }
        });
        if (this.inherit) {
          const inheritModule = await this.loadTypeAsync(this.inherit.value());
          if (inheritModule) {
            inheritModule.used = true;
            this.module.extends = inheritModule;
            this.compilation.addDependency(inheritModule, this.module);
          } else {
            this.inherit.error(1027, this.inherit.value());
          }
        }
        await this.allSettled(this.implements, async (stack2) => {
          const module2 = await this.loadTypeAsync(stack2.value());
          if (module2) {
            if (!(module2.isInterface || module2.isDeclarator)) {
              stack2.error(1028, stack2.value());
            }
            this.module.implements.push(module2);
            this.compilation.addDependency(module2, this.module);
          } else {
            stack2.error(1029, stack2.value());
          }
        });
        const metatypes = [];
        const annotations = [];
        (this.node.body || []).map((item2) => {
          const stack2 = this.createTokenStack(compilation, item2, this.scope, this.node, this);
          if (stack2.isUseStatement) {
            this.usings.push(stack2);
          } else if (stack2.isMetatypeDeclaration) {
            metatypes.push(stack2);
          } else if (stack2.isAnnotationDeclaration) {
            annotations.push(stack2);
          } else {
            stack2.metatypes = metatypes.splice(0, metatypes.length);
            stack2.annotations = annotations.splice(0, annotations.length);
            this.body.push(stack2);
          }
        });
      }
      mergeModuleGenerics(module2, assignGenerics) {
        if (!module2 || !module2.isModule)
          return false;
        if (module2.inherit) {
          this.mergeModuleGenerics(module2.inherit, assignGenerics);
        }
        const declares = module2.getModuleDeclareGenerics();
        if (declares) {
          const ctx2 = this.getContext();
          const moduleStack = module2.moduleStack;
          if (moduleStack) {
            ctx2.merge(module2.moduleStack.getContext());
          }
          ctx2.batch(declares, assignGenerics);
          if (module2.implements && module2.implements.length > 0) {
            module2.implements.forEach((imp) => {
              this.mergeModuleGenerics(imp, assignGenerics);
            });
          }
        }
      }
      genericsCheck(typeModule, assignGenerics, aStack) {
        if (!typeModule)
          return;
        if (assignGenerics && assignGenerics.length > 0) {
          assignGenerics.forEach((item2) => {
            item2.parser();
          });
        }
        const stackModule = typeModule.moduleStack;
        const _compilation = typeModule.compilation;
        if (_compilation && _compilation.stack) {
        }
        if (stackModule) {
          stackModule.addUseRef(aStack);
          assignGenerics = assignGenerics || [];
          const declareGenerics = stackModule.genericity ? stackModule.genericity.elements : [];
          const requires = declareGenerics.filter((item2) => !item2.isGenericTypeAssignmentDeclaration);
          const lastStack = assignGenerics[assignGenerics.length - 1] || aStack || this.id;
          if (requires.length > assignGenerics.length || assignGenerics.length > declareGenerics.length) {
            if (requires.length === declareGenerics.length) {
              lastStack.error(1030, typeModule.toString(), requires.length);
            } else {
              lastStack.error(1031, typeModule.toString(), requires.length, declareGenerics.length);
            }
          }
          if (declareGenerics.length > 0) {
            assignGenerics.forEach((item2, index) => {
              const declareType = declareGenerics[index] && declareGenerics[index].type();
              if (declareType && declareType.hasConstraint && !declareType.check(item2)) {
                item2.error(1003, item2.type().toString(), declareType.toString());
              }
            });
          }
        }
        this.mergeModuleGenerics(typeModule, assignGenerics);
      }
      type() {
        return this.module;
      }
      description() {
        return this;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.imports.forEach((item2) => item2.parser());
        this.usings.forEach((item2) => item2.parser());
        if (this.genericity) {
          this.genericity.parser();
          this.genericity.setRefBeUsed();
        }
        this.metatypes.forEach((item2) => item2.parser());
        this.annotations.forEach((item2) => item2.parser());
        if (this.inherit) {
          this.parserDescriptor(this.module.extends[0]);
          this.genericsCheck(this.module.extends[0], this.inherit.assignGenerics, this.inherit);
        }
        this.implements.forEach((stack2) => {
          const impModule = this.getModuleById(stack2.value());
          if (impModule) {
            this.parserDescriptor(impModule);
            this.genericsCheck(impModule, stack2.assignGenerics, stack2);
          }
        });
        this.body.forEach((item2) => item2.parser());
        this.module.ckeckAllDescriptors();
      }
      value() {
        return this.id.value();
      }
      raw() {
        return this.node.name;
      }
    };
    module.exports = InterfaceDeclaration;
  }
});

// lib/stacks/JSXAttribute.js
var require_JSXAttribute = __commonJS({
  "lib/stacks/JSXAttribute.js"(exports, module) {
    var BlockScope = require_BlockScope();
    var Stack = require_Stack();
    var MergeType = require_MergeType();
    var Utils2 = require_Utils();
    var { Parser } = require_Parser();
    var JSXAttribute = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isJSXAttribute = true;
        this.jsxElement = parentStack.jsxElement;
        this.name = this.createTokenStack(compilation, node.name, this.scope, node, this);
        this.value = this.createTokenStack(compilation, node.value, this.scope, node, this);
        this.hasNamespaced = !!this.name.isJSXNamespacedName;
        this.isAttributeXmlns = this.hasNamespaced ? this.name.namespace.value().toLowerCase() === "xmlns" : false;
        this.isAttributeDirective = false;
        this.isMemberProperty = false;
        if (this.isAttributeXmlns && parentStack && parentStack.parentStack.isJSXElement) {
          parentStack.parentStack.xmlns.push(this);
        }
        if (this.isAttributeXmlns && this.jsxElement.jsxRootElement !== this.jsxElement) {
          this.name.error(1117);
        }
        if (this.hasNamespaced && !this.isAttributeXmlns) {
          const xmlns = this.name.getXmlNamespace();
          const jsxConfig = this.compiler.options.jsx || {};
          let ns = null;
          if (xmlns && xmlns.value) {
            ns = xmlns.value.value();
          } else {
            const nsStack = this.getNamespaceStack();
            ns = jsxConfig.xmlns && jsxConfig.xmlns.default[nsStack.namespace.value().toLowerCase()] || ns;
          }
          if (ns) {
            let custom = "";
            if (ns.includes("::")) {
              const [_ns, _custom] = ns.split("::", 2);
              ns = _ns;
              custom = _custom;
            }
            if (ns === "@directives") {
              const sections = jsxConfig.xmlns && jsxConfig.xmlns.sections;
              const directives = sections[ns];
              if (this.value && this.jsxElement.jsxRootElement === this.jsxElement) {
                this.value.error(1115);
              }
              if (directives) {
                let dName = custom ? custom.toLowerCase() : this.name.value();
                if (!(directives.includes(dName) || directives.includes("*"))) {
                  this.name.error(1125, directives.join(","));
                } else {
                  this.isAttributeDirective = true;
                }
                const newContext = jsxConfig.xmlns.context || [];
                if (newContext.includes(dName)) {
                  this.scope = new BlockScope(this.scope);
                  this.scope.isDirective = true;
                  this.scope.isForContext = true;
                  this.parentStack.scope = this.scope;
                  this.parentStack.parentStack.scope = this.scope;
                }
              }
            } else if (ns === "@slots") {
              this.isAttributeSlot = true;
              this.jsxElement.hasAttributeSlot = true;
              if (this.value) {
                this.scope = new BlockScope(this.scope);
                this.scope.isAttributeSlotScope = true;
                this.parentStack.scope = this.scope;
                this.parentStack.parentStack.scope = this.scope;
              }
            } else if (ns === "@events" || ns === "@natives") {
              this.isAttributeEvent = true;
            } else if (ns === "@binding") {
              this.isAttributeBinding = true;
            }
          }
        }
        this.addHook();
      }
      addHook() {
        if (this.isAttributeXmlns) {
          let namespace = this.value && this.value.value();
          if (namespace) {
            if (namespace.includes("::")) {
              const [_ns, defineClass] = namespace.split("::", 2);
              if (_ns === "@events") {
                this.compilation.hookAsync("compilation.create.after", async () => {
                  await this.loadTypeAsync(defineClass);
                });
              }
            }
          }
        }
      }
      freeze() {
        super.freeze();
        this.name.freeze();
        this.value.freeze();
      }
      definition(context) {
        if (this.isAttributeXmlns) {
          const str = [this.name.name.value(), this.value && this.value.value()].filter((value) => !!value).join(": ");
          return {
            kind: "namespace",
            comments: null,
            identifier: this.name.name.value(),
            expre: `(xmlns) ${str}`,
            location: this.value ? this.value.getLocation() : this.name.name.getLocation(),
            file: this.compilation.file,
            range: this.name.node.loc
          };
        } else if (this.isAttributeDirective) {
          return null;
        }
        if (this.hasNamespaced) {
          var xmlns = this.getXmlNamespace();
          var namespace = xmlns && xmlns.value ? xmlns.value.value() : null;
          if (namespace && namespace.includes("::")) {
            const [namespace2, defineClass] = namespace2.split("::", 2);
            if (namespace2 === "@events") {
              const defineClassModule = this.getModuleById(defineClass);
              if (defineClassModule) {
                const desc3 = this.getAttributeDescription(defineClassModule, "get");
                if (desc3) {
                  const def = desc3.definition(context);
                  if (def) {
                    def.range = this.name.name.getLocation();
                    return def;
                  }
                }
              }
            }
          }
        }
        if (this.isAttributeSlot && this.value) {
          return {
            expre: `(local var) ${this.value.value()}: ${this.type().toString()}`,
            location: this.value.getLocation(),
            file: this.file
          };
        } else if (this.jsxElement.isSlot) {
          const isLocal = context ? context.stack !== this.name : false;
          if (this.jsxElement.isSlotDeclared) {
            if (this.value) {
              const desc3 = this.value.description();
              return {
                expre: `(refs) ${this.name.value()}: ${this.value.type().toString()}`,
                location: desc3 && desc3.isStack ? desc3.getLocation() : this.value.getLocation(),
                file: desc3 && desc3.isStack ? desc3.file : this.value.file
              };
            } else {
              return {
                expre: `(refs) ${this.name.value()}: any`,
                location: this.name.getLocation(),
                file: this.name.file
              };
            }
          } else {
            const el = this.jsxElement;
            const slotName = el.openingElement.name.value();
            const desc3 = el.getSlotDescription(slotName);
            const key = this.value ? this.value : this.name;
            let type2 = this.getGlobalTypeById("any");
            let stack2 = key;
            if (desc3) {
              if (desc3.isJSXElement) {
                const attributes = desc3.openingElement ? desc3.openingElement.attributes : [];
                const _key = this.name.value();
                const attr = attributes.length === 1 ? attributes[0] : attributes.find((attr2) => attr2.name.value() === _key);
                if (attr && attr.isJSXAttribute && attr.value) {
                  stack2 = attr.name;
                  type2 = attr.value.type();
                }
              } else if (desc3.isAnnotation && desc3.args && desc3.args.length > 0) {
                const _key = this.name.value();
                const argument = desc3.args.length === 1 ? desc3.args[0] : desc3.args.find((arg) => arg.name === _key);
                if (argument) {
                  if (argument.stack)
                    stack2 = argument.stack;
                  if (argument.type)
                    type2 = argument.type;
                }
              }
            }
            if (isLocal) {
              return {
                expre: `(local var) ${key.value()}: ${type2.toString()}`,
                location: key.getLocation(),
                file: key.file
              };
            } else {
              return {
                expre: `(refs) ${key.value()}: ${type2.toString()}`,
                location: stack2.getLocation(),
                file: stack2.file
              };
            }
          }
        }
        const desc2 = this.description();
        if (desc2) {
          const def = desc2.definition(context);
          return def;
        }
        const elem = this.parentStack.parentStack;
        if (elem && elem.isJSXStyle && elem.absoluteFile) {
          return {
            kind: "attr",
            comments: null,
            identifier: this.name.value(),
            expre: `(attr) ${this.name.value()}: ${elem.absoluteFile.replace(/\\/g, "/")}`,
            location: {
              start: { column: 0, line: 1 },
              end: { column: 0, line: 1 }
            },
            range: (context.stack || this.value).getLocation(),
            file: elem.absoluteFile
          };
        }
        return null;
      }
      reference() {
        return null;
      }
      referenceItems() {
        return [];
      }
      getNamespaceStack() {
        if (this.name.isJSXNamespacedName) {
          return this.name;
        } else if (this.name.isJSXMemberExpression && this.name.object.isJSXNamespacedName) {
          return this.name.object;
        }
        return null;
      }
      getXmlNamespace(ns) {
        if (this.parentStack.isJSXOpeningElement) {
          const stack2 = this.getNamespaceStack();
          return this.parentStack.getXmlNamespace(ns || stack2.namespace.value());
        }
        return null;
      }
      getAttributeDescription(desc2, kind = "set") {
        if (desc2 && desc2.isModule) {
          const argument = this.value ? this.value : this.getGlobalTypeById("boolean");
          const name = this.name.isJSXNamespacedName ? this.name.name.value() : this.name.value();
          return desc2.getDescriptor(name, (desc3, prev, index) => {
            if (desc3.isMethodSetterDefinition) {
              const params = desc3.params || [];
              if (params[0] && this.checkMatchType(argument, params[0], argument.type())) {
                return true;
              }
              return desc3;
            } else if (desc3.isPropertyDefinition && !desc3.isReadonly) {
              if (this.checkMatchType(argument, desc3, argument.type())) {
                return true;
              }
              return desc3;
            }
            return false;
          });
        }
        return null;
      }
      description() {
        if (this.isAttributeDirective || this.jsxElement.isDirective) {
          return this._directiveDesc;
        } else if (!this.isAttributeXmlns) {
          const value = this.value;
          if (this.jsxElement.isSlot) {
            if (this.jsxElement.isSlotDeclared) {
              return value ? value.description() : null;
            } else {
              const el = this.jsxElement;
              const slotName = el.openingElement.name.value();
              const desc2 = el.getSlotDescription(slotName);
              if (desc2) {
                if (desc2.isJSXElement) {
                  const attributes = desc2.openingElement ? desc2.openingElement.attributes : [];
                  const key = this.name.value();
                  const attr = attributes.length === 1 ? attributes[0] : attributes.find((attr2) => attr2.name.value() === key);
                  if (attr && attr.isJSXAttribute) {
                    return attr.description();
                  }
                } else if (desc2.isAnnotation && desc2.args && desc2.args.length > 0) {
                  const key = this.name.value();
                  const argument = desc2.args.length === 1 ? desc2.args[0] : desc2.args.find((arg) => arg.name === key);
                  if (argument) {
                    return argument.type;
                  }
                }
              }
            }
          } else if (this.isAttributeSlot) {
            return value ? value.description() : null;
          }
          const elem = this.parentStack.parentStack;
          if (elem.isJSXElement && elem.isComponent) {
            return this.getAttributeDescription(elem.description());
          }
        }
        return null;
      }
      type() {
        if (this.jsxElement.isSlot) {
          if (this.jsxElement.isSlotDeclared) {
            if (this.value) {
              return this.value.type();
            }
            return this.getGlobalTypeById("any");
          } else {
            const el = this.jsxElement;
            const slotName = el.openingElement.name.value();
            const desc2 = el.getSlotDescription(slotName);
            if (desc2) {
              if (desc2.isJSXElement) {
                const attributes = desc2.openingElement ? desc2.openingElement.attributes : [];
                const key = this.name.value();
                const attr = attributes.length === 1 ? attributes[0] : attributes.find((attr2) => attr2.name.value() === key);
                if (attr && attr.isJSXAttribute) {
                  const _desc = attr.description();
                  if (_desc) {
                    return _desc.type();
                  }
                }
              } else if (desc2.isAnnotation && desc2.args && desc2.args.length > 0) {
                const key = this.name.value();
                const argument = desc2.args.length === 1 ? desc2.args[0] : desc2.args.find((arg) => arg.name === key);
                if (argument) {
                  return argument.type;
                }
              }
            }
            return this.getGlobalTypeById("any");
          }
        } else if (this.isAttributeSlot && this.value) {
          const desc2 = this.getSlotAttrDescription();
          if (desc2) {
            if (desc2.isJSXElement) {
              const attributes = desc2.openingElement ? desc2.openingElement.attributes : [];
              const key = this.value.value();
              const attr = attributes.length === 1 ? attributes[0] : attributes.find((attr2) => attr2.name.value() === key);
              if (attr && attr.isJSXAttribute) {
                const _desc = attr.description();
                if (_desc) {
                  return _desc.type();
                }
              }
            } else if (desc2.isAnnotation && desc2.args && desc2.args.length > 0) {
              const key = this.value.value();
              const argument = desc2.args.length === 1 ? desc2.args[0] : desc2.args.find((arg) => arg.name === key);
              if (argument) {
                return argument.type;
              }
            }
          }
          return this.getGlobalTypeById("any");
        }
        return this.getGlobalTypeById("void");
      }
      createType(descStack, name, type2) {
        type2 = type2 || descStack.type();
        if (descStack && type2) {
          let _type = MergeType.forOfItem(type2);
          if (_type !== type2) {
            _type.definition = () => {
              return {
                kind: "identifier",
                identifier: name,
                expre: `(local var) ${name}:${_type.toString()}`,
                location: this.value.getLocation(),
                file: this.compilation.file
              };
            };
          }
          return _type;
        }
        return this.getGlobalTypeById("any");
      }
      checkConditionStatementDirective() {
        const index = this.jsxElement.parentStack.childrenStack.indexOf(this.jsxElement);
        const prevStack = this.jsxElement.parentStack.childrenStack[index - 1];
        if (prevStack && prevStack.isJSXElement) {
          if (prevStack.isDirective) {
            const directiveName = prevStack.openingElement.name.value().toLowerCase();
            if (directiveName === "if" || directiveName === "elseif") {
              return true;
            }
          }
          return prevStack.openingElement.attributes.some((item2) => {
            if (item2.isAttributeDirective) {
              const directiveName = item2.name.value().toLowerCase();
              return directiveName === "if" || directiveName === "elseif";
            }
            return false;
          });
        }
        return false;
      }
      parserDirective() {
        if (this._directiveDesc !== void 0) {
          return this._directiveDesc;
        }
        this._directiveDesc = null;
        this.valueArgument = { expression: null, declare: {} };
        const name = this.name.value().toLowerCase();
        const has = (name2) => this.scope.define(name2);
        let desc2 = null;
        if (name === "if" || name === "elseif") {
          if (name === "elseif") {
            if (!this.checkConditionStatementDirective()) {
              this.name.error(1156);
            }
          }
          if (!this.value || this.value.isLiteral && !this.value.value().trim()) {
            this.error(1144, `condition`);
          } else {
            desc2 = this.parserAttributeValueStack();
            this.valueArgument.expression = desc2;
          }
        } else if (name === "each" || name === "for") {
          if (this.value && this.value.isJSXExpressionContainer) {
            this.value.error(1121);
          } else {
            const value = this.value.value();
            const divide = value.match(/\s+(of|in)\s+/i);
            var item2 = null;
            if (divide) {
              const startAt = this.value.node.start + 1;
              item2 = this.parserAttributeValueStack(this.compilation.source.substr(0, startAt + divide.index), startAt);
              desc2 = this.parserAttributeValueStack(this.compilation.source.substr(0, startAt + value.length), startAt + divide.index + divide[0].length);
            } else {
              if (name === "each") {
                this.value.error(1116);
              } else {
                this.value.error(1121);
              }
            }
            if (desc2) {
              this.valueArgument.expression = desc2;
              const descType = desc2.type();
              const originType = Utils2.getOriginType(descType);
              if (originType && !originType.isAnyType) {
                if (name === "each" && !this.getGlobalTypeById("array").is(descType)) {
                  this.value.error(1119, descType.toString());
                } else if (originType.isNullableType || originType.isNeverType || originType.isVoidType || this.getGlobalTypeById("boolean").is(originType)) {
                  this.value.error(1049, descType.toString());
                }
              }
            }
            if (item2) {
              item2.parser();
              if (item2.isParenthesizedExpression) {
                item2 = item2.expression;
              }
              const segments = item2.isSequenceExpression ? item2.expressions : [item2];
              const refType = desc2 && desc2.type();
              const mapTypes = [
                refType ? MergeType.forOfItem(refType) : this.getGlobalTypeById("any"),
                this.getGlobalTypeById("string"),
                this.getGlobalTypeById("number")
              ];
              const mapNames = ["item", "key", "index"];
              if (!(segments.length >= 1 && segments.length <= 3)) {
                this.value.error(1121);
              } else {
                segments.forEach((stack2, index) => {
                  (function(stack3, _type) {
                    stack3.isDeclarator = true;
                    stack3.kind = "const";
                    stack3.type = function type2() {
                      return _type;
                    };
                    stack3.description = function description() {
                      return this;
                    };
                    stack3.definition = function definition(ctx2) {
                      return {
                        expre: `(local var) ${this.value()}:${this.type().toString(ctx2 | this.getContext())}`,
                        location: this.getLocation(),
                        file: this.compilation.file
                      };
                    };
                  })(stack2, mapTypes[index]);
                  const name2 = stack2.value();
                  if (has(name2)) {
                    this.value.error(1045, name2);
                  } else {
                    this.valueArgument.declare[mapNames[index]] = name2;
                    this.jsxElement.scope.define(name2, stack2);
                  }
                });
              }
            }
          }
        } else if (name === "else") {
          if (!this.checkConditionStatementDirective()) {
            this.name.error(1156);
          }
        } else if (name === "custom") {
          if (!this.value) {
            this.name.error(1145, 1, 0);
          } else if (this.value.isJSXExpressionContainer) {
            const expression = this.value.type();
            if (expression && expression.isLiteralObjectType) {
              const result = ["name", "value"].every((name2) => {
                return !!expression.attribute(name2);
              });
              if (!result) {
                this.name.error(1171);
              }
            } else {
              this.name.error(1171);
            }
          } else {
            this.name.error(1171);
          }
        } else {
          desc2 = this.parserAttributeValueStack();
          this.valueArgument.expression = desc2;
        }
        return this._directiveDesc = desc2;
      }
      parserAttributeValueStack(content, startAt = 0, isDeclarator) {
        if (this._attributeValueStack !== void 0 && !content) {
          return this._attributeValueStack;
        }
        const context = this.jsxElement.getSubClassDescription();
        const createStack = (expression, startAt2) => {
          if (!expression || expression.length === startAt2) {
            return null;
          }
          try {
            this.value.module = this.module || context && context.type();
            this.value.isFragment = true;
            let node = Parser.parseExpressionAt(expression, startAt2, this.compilation.compiler.options.parser);
            const stack2 = this.createTokenStack(
              this.compilation,
              node,
              this.scope,
              this.value.node,
              this.value
            );
            if (stack2) {
              stack2.parser();
              if (!isDeclarator) {
                const desc2 = stack2.description();
                if (desc2) {
                  this.setRefBeUsed(desc2);
                }
              }
            }
            return stack2;
          } catch (e) {
            this.value.error(1085, e.message);
          }
        };
        if (content) {
          return createStack(content, startAt);
        } else if (this.value) {
          if (this.value.isJSXExpressionContainer) {
            return this.value;
          } else {
            const startAt2 = this.value.node.start + 1;
            const len = this.value.value().length;
            return this._attributeValueStack = createStack(this.compilation.source.substr(0, startAt2 + len), startAt2);
          }
        }
        return null;
      }
      getAttributeName() {
        if (this.hasNamespaced) {
          const nsStack = this.getNamespaceStack();
          if (nsStack) {
            return nsStack.namespace.value().toLowerCase() + ":" + nsStack.name.value();
          }
        }
        return this.name.value();
      }
      getSlotAttrDescription() {
        if (!this.isAttributeSlot)
          return null;
        const slotDesc = this.__slotDesc;
        if (slotDesc !== void 0)
          return slotDesc;
        const el = this.jsxElement;
        if (el && el.parentStack && el.parentStack.isWebComponent) {
          const slotName = this.name.value();
          return this.__slotDesc = el.parentStack.getSlotDescription(slotName, el.parentStack.description()) || null;
        }
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.value) {
          this.value.parser();
        }
        if (this.jsxElement.isDirective) {
          const direName = this.jsxElement.openingElement.name.value().toLowerCase();
          if (direName !== "custom") {
            const name = this.name.value();
            if (["condition", "name", "item", "key", "index"].includes(name)) {
              const desc2 = this.parserAttributeValueStack();
              this._directiveDesc = desc2;
              return true;
            }
          }
        }
        if (this.jsxElement.isSlot && this.jsxElement.isSlotDeclared) {
          if (!this.value) {
            this.name.error(1170, this.name.value());
          } else {
            this.jsxElement.scope.define(this.name.value(), this);
          }
        }
        if (this.isAttributeSlot) {
          const el = this.jsxElement;
          const slotName = this.name.value();
          if (el && el.parentStack && el.parentStack.isWebComponent) {
            const pSlot = this.getSlotAttrDescription();
            if (!pSlot && slotName !== "default") {
              this.name.warn(1126, slotName);
            }
            if (this.value) {
              const value = this.value.isJSXExpressionContainer ? this.value.expression : this.value;
              if (!(value.isLiteral || value.isIdentifier)) {
                value.error(1169);
              } else {
                const scopeName = value.value();
                this.jsxElement.scope.define(scopeName, this);
              }
            }
          } else {
            this.name.name.error(1157, slotName);
          }
        }
        if (this.isAttributeDirective) {
          this.parserDirective();
        } else if (this.isAttributeBinding) {
          if (this.value && !this.value.isJSXExpressionContainer) {
            this.parserAttributeValueStack();
          }
        } else {
          const nsStack = this.getNamespaceStack();
          const jsxConfig = this.compiler.options.jsx || { xmlns: {} };
          if (this.isAttributeXmlns) {
            let namespace = this.value && this.value.value();
            if (namespace) {
              if (namespace.includes("::")) {
                const [_ns, defineClass] = namespace.split("::", 2);
                if (_ns === "@events") {
                  const defineClassModule = this.getModuleById(defineClass);
                  namespace = _ns;
                  if (!Utils2.isClassType(defineClassModule)) {
                    this.name.error(1027, defineClass);
                  }
                }
              }
            }
          } else if (this.hasNamespaced) {
            const xmlns = this.getXmlNamespace() || jsxConfig.xmlns.default[nsStack.namespace.value().toLowerCase()];
            if (!xmlns) {
              this.error(1098, nsStack.namespace.value());
            } else {
              let namespace = xmlns.value && xmlns.value.value();
              if (namespace && namespace.includes("::")) {
                const [_, defineClass] = namespace.split("::", 2);
                const defineClassModule = this.getModuleById(defineClass);
                const desc2 = defineClassModule && defineClassModule.getMethod(nsStack.name.value(), "get");
                if (!desc2) {
                } else {
                  this.setRefBeUsed(desc2);
                  this.compilation.addDependency(defineClassModule, this.module);
                }
              }
            }
          }
        }
      }
    };
    module.exports = JSXAttribute;
  }
});

// lib/types/LiteralType.js
var require_LiteralType = __commonJS({
  "lib/types/LiteralType.js"(exports, module) {
    var Type = require_Type();
    var LiteralType = class extends Type {
      constructor(inherit, target, value, compareLiteralValue = false) {
        super("$LiteralType", inherit);
        this.isLiteralType = true;
        this.target = target;
        this.value = value;
        this.compareLiteralValue = compareLiteralValue;
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        if (this.isLiteralValueType || options.toLiteralValue) {
          return this.inherit.is(type2, context) && type2.isLiteralType && this.value === type2.value;
        }
        return this.inherit.is(type2, context);
      }
      get isLiteralValueType() {
        return this.target && (this.target.isTypeDefinition || this.target.isTypeKeyofDefinition) || this.compareLiteralValue;
      }
      toString(context, options = {}) {
        if (this.isLiteralValueType || options.toLiteralValue) {
          if (typeof this.value === "string") {
            const str = this.value.replace(/[\'\"]/g, "");
            return `"${str}"`;
          } else if (this.value !== void 0) {
            return this.value;
          }
        }
        return this.inherit && this.inherit.toString(context, options);
      }
    };
    module.exports = LiteralType;
  }
});

// lib/stacks/Literal.js
var require_Literal = __commonJS({
  "lib/stacks/Literal.js"(exports, module) {
    var Stack = require_Stack();
    var LiteralType = require_LiteralType();
    var keySymbol = Symbol("key");
    var Literal = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isLiteral = true;
        this[keySymbol] = {};
      }
      definition(context) {
        if (this.parentStack.isImportDeclaration || this.parentStack.isExportAllDeclaration || this.parentStack.isExportDefaultDeclaration || this.parentStack.isExportNamedDeclaration) {
          return this.parentStack.definition(this.getContext());
        }
        return null;
      }
      reference() {
        return this;
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      getTypeName() {
        const node = this.node;
        let type2 = "string";
        if (node.regex) {
          type2 = "regexp";
        } else if (node.value == node.raw) {
          type2 = "uint";
          if (this.parentStack.isUnaryExpression) {
            type2 = "int";
          } else if (node.raw.includes(".")) {
            type2 = "float";
          }
        } else if (node.raw === "false" || node.raw === "true") {
          type2 = "boolean";
        } else if (node.raw === "null") {
          type2 = "nullable";
        }
        return type2;
      }
      type() {
        return this.getAttribute("type", () => {
          let type2 = this.getTypeName();
          let final = this.getGlobalTypeById(type2);
          if (!(type2 === "regexp" || type2 === "nullable")) {
            return new LiteralType(final, this.parentStack.isTypeDefinition ? this.parentStack : this, this.node.value);
          }
          return final;
        });
      }
      value() {
        return this.node.value;
      }
      raw() {
        return this.node.raw;
      }
    };
    module.exports = Literal;
  }
});

// lib/stacks/JSXCdata.js
var require_JSXCdata = __commonJS({
  "lib/stacks/JSXCdata.js"(exports, module) {
    var Literal = require_Literal();
    var JSXCdata = class extends Literal {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.jsxElement = parentStack.jsxElement;
        this.isJSXCdata = true;
      }
    };
    module.exports = JSXCdata;
  }
});

// lib/stacks/JSXClosingElement.js
var require_JSXClosingElement = __commonJS({
  "lib/stacks/JSXClosingElement.js"(exports, module) {
    var Namespace2 = require_Namespace();
    var Stack = require_Stack();
    var JSXClosingElement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isJSXClosingElement = true;
        this.jsxElement = parentStack.jsxElement;
        this.name = this.createTokenStack(compilation, node.name, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.name && this.name.freeze();
      }
      definition(context) {
        if (this.jsxElement) {
          return this.jsxElement.definition(context);
        }
        const stack2 = context && context.stack;
        if (this.parentStack && this.parentStack.hasNamespaced) {
          if (stack2) {
            const xmlns = this.parentStack.getXmlNamespace();
            const namespace = xmlns && xmlns.value && xmlns.value.value();
            const space = this.parentStack.isProperty ? Namespace2.fetch(namespace, null, true) : Namespace2.create(namespace, true);
            const desc2 = this.name.description(space, stack2);
            return desc2 ? desc2.definition(context) : null;
          } else {
            const desc2 = this.parentStack.description();
            if (desc2) {
              return desc2.definition(context);
            }
          }
        } else if (this.parentStack.isJSXElement) {
          return this.parentStack.definition(context);
        }
        return null;
      }
      reference() {
        return null;
      }
      referenceItems() {
        return [];
      }
      description() {
        return null;
      }
      type() {
        return this.getGlobalTypeById("void");
      }
      value() {
        return this.name.value();
      }
    };
    module.exports = JSXClosingElement;
  }
});

// lib/stacks/JSXClosingFragment.js
var require_JSXClosingFragment = __commonJS({
  "lib/stacks/JSXClosingFragment.js"(exports, module) {
    var Stack = require_Stack();
    var JSXClosingFragment = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isJSXClosingFragment = true;
        this.jsxElement = parentStack.jsxElement;
      }
      definition() {
        return null;
      }
      reference() {
        return null;
      }
      referenceItems() {
        return [];
      }
      description() {
        return null;
      }
      type() {
        return this.getGlobalTypeById("void");
      }
    };
    module.exports = JSXClosingFragment;
  }
});

// lib/stacks/JSXElement.js
var require_JSXElement = __commonJS({
  "lib/stacks/JSXElement.js"(exports, module) {
    var Stack = require_Stack();
    var Namespace2 = require_Namespace();
    var InstanceofType = require_InstanceofType();
    var BlockScope = require_BlockScope();
    var MergeType = require_MergeType();
    var Utils2 = require_Utils();
    var JSXElement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isJSXElement = true;
        this.jsxRootElement = parentStack.jsxRootElement || this;
        this.jsxElement = this;
        this.xmlns = [];
        this.directives = null;
        this.isSlot = false;
        this.isSlotDeclared = false;
        this.isDirective = false;
        this.isWebComponent = false;
        this.isSkinComponent = false;
        this.ownerProperty = null;
        this.newCreatedScope = false;
        this.openingElement = this.createTokenStack(compilation, node.openingElement, this.scope, node, this);
        if (this.hasNamespaced) {
          const nsStack = this.getNamespaceStack();
          const jsxConfig = this.compiler.options.jsx || {};
          const xmlns = this.getXmlNamespace();
          let namespace = xmlns && xmlns.value ? xmlns.value.value() : jsxConfig.xmlns.default[nsStack.namespace.value()];
          if (namespace === "@directives") {
            this.scope = new BlockScope(this.scope);
            this.scope.isDirective = true;
            this.scope.isForContext = true;
            this.isDirective = true;
          } else if (namespace === "@slots") {
            this.scope = new BlockScope(this.scope);
            this.scope.isSlotScope = true;
          }
        }
        this.children = node.children.filter((item2) => {
          return !(item2.type == "JSXText" && !item2.value.trim());
        }).map(
          (item2) => this.createTokenStack(compilation, item2, this.scope, node, this)
        );
        if (this.jsxRootElement === this) {
          this.children.sort((a, b) => {
            return a.isJSXScript || a.isJSXStyle ? -1 : 0;
          });
          this.compilation.jsxElements.push(this);
        }
        this.closingElement = this.createTokenStack(compilation, node.closingElement, this.scope, node, this);
        this.addHook();
      }
      addHook() {
        if (!this.hasNamespaced || this.isSlot || this.isDirective)
          return;
        const id = this.getFullClassName();
        if (id && !this.hasModuleById(id)) {
          this.compilation.hookAsync("compilation.create.after", async () => {
            await this.loadTypeAsync(id);
          });
        }
      }
      getFullClassName() {
        return this.getAttribute("getLoadClassName", () => {
          if (this.hasNamespaced) {
            const stack2 = this.getNamespaceStack();
            const ns = stack2.namespace.value();
            const name = this.openingElement.value();
            const xmlns = this.getXmlNamespace(ns);
            if (xmlns) {
              const jsxConfig = this.compiler.options.jsx || {};
              const sections = jsxConfig.xmlns && jsxConfig.xmlns.sections;
              const namespace = xmlns && xmlns.value ? xmlns.value.value() : jsxConfig.xmlns.default[ns];
              if (namespace && sections[namespace]) {
                return null;
              }
              return namespace && namespace !== "@" ? `${namespace}.${name}` : name;
            } else {
              return `${ns}.${name}`;
            }
          } else {
            return this.openingElement.name.value();
          }
        });
      }
      async createCompleted() {
        if (!this.compilation.JSX || !this.module)
          return;
        if (this.parentStack && this.parentStack.isProgram) {
          const id = this.getFullClassName();
          if (id) {
            const desc2 = await this.loadTypeAsync(id);
            if (desc2 && desc2.isModule && desc2.isClass) {
              if (!this.module.inherit && desc2) {
                this.module.extends = desc2;
              }
            }
          }
          await Promise.all(this.children.filter((stack2) => stack2.isJSXScript).map((stack2) => stack2.createCompleted()));
        }
      }
      get hasNamespaced() {
        return !!this.openingElement.hasNamespaced;
      }
      get nodeName() {
        if (this.hasNamespaced) {
          const stack2 = this.getNamespaceStack();
          const ns = stack2.namespace.value();
          const name = this.openingElement.value();
          const xmlns = this.getXmlNamespace(ns);
          if (xmlns) {
            const namespace = xmlns.value && xmlns.value.value();
            return namespace && namespace !== "@" ? `${namespace}.${name}` : name;
          } else {
            return `${ns}.${name}`;
          }
        } else {
          return this.openingElement.name.value();
        }
      }
      get attributes() {
        if (this.isAttrClone) {
          return this._attributes;
        }
        return this.openingElement.attributes.slice(0);
      }
      get isComponent() {
        const desc2 = this.description();
        return !!(desc2 && desc2.isModule && this.getGlobalTypeById("VNode") !== desc2);
      }
      get isProperty() {
        if (this.parentStack && this.parentStack.isJSXElement) {
          const xmlns = this.getXmlNamespace();
          if (xmlns) {
            if (this.openingElement.name.isJSXMemberExpression) {
              return true;
            } else if (this.openingElement.name.isJSXNamespacedName) {
              let ns = xmlns.value && xmlns.value.value();
              let componentClass = Namespace2.fetch(ns);
              return this.parentStack.description() === componentClass;
            }
          }
        }
        return false;
      }
      freeze() {
        super.freeze();
        this.children.forEach((item2) => item2.freeze());
      }
      definition(context) {
        const stack2 = context && context.stack;
        if (this.isSlot) {
          if (this.isSlotDeclared) {
            return {
              expre: `(slots) ${this.openingElement.name.value()}`,
              location: this.openingElement.name.getLocation(),
              file: this.file
            };
          } else {
            const declareSlot = this.getSlotDescription(this.openingElement.name.value());
            if (declareSlot) {
              if (declareSlot.isJSXElement) {
                return declareSlot.definition(context);
              } else if (declareSlot.isAnnotation && declareSlot.arguments && declareSlot.arguments.length > 0) {
                const slotStack = declareSlot.arguments[0].stack;
                if (slotStack) {
                  return {
                    expre: `(slots) ${declareSlot.name}`,
                    location: slotStack.getLocation(),
                    file: slotStack.file
                  };
                }
              }
            }
          }
        }
        if (stack2) {
          if (this.hasNamespaced) {
            const xmlns = this.getXmlNamespace();
            const namespace = xmlns && xmlns.value && xmlns.value.value();
            const space = this.isProperty ? Namespace2.fetch(namespace, null, true) : Namespace2.create(namespace, true);
            const desc3 = this.openingElement.name.description(space, stack2);
            return desc3 ? desc3.definition(this.getContext()) : null;
          }
        }
        const desc2 = this.description();
        if (desc2 && desc2 !== this.getGlobalTypeById("VNode")) {
          return desc2.definition(context);
        }
        return null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      isFirstUppercase(name) {
        if (name) {
          const code = name.charCodeAt(0);
          return code >= 65 && code <= 90;
        }
        return false;
      }
      description() {
        return this.getAttribute("description", () => {
          const info = this.getElementInfo();
          let desc2 = null;
          if (info) {
            if (info.isDirective) {
              this.isDirective = true;
            } else if (info.isSlot) {
              this.isSlot = true;
            } else {
              if (info.base) {
                desc2 = this.openingElement.name.description(info.base);
              } else if (info.desc) {
                desc2 = info.desc;
              } else if (info.className) {
                desc2 = this.getModuleById(info.className) || this.getGlobalTypeById("VNode");
              }
              if (!desc2 && info.base) {
                const className = info.base.isNamespace ? info.base.getChain().concat(this.openingElement.name.value()).join(".") : this.openingElement.name.value();
                if (this.isProperty) {
                  this.openingElement.name.error(1080, className);
                } else {
                  this.openingElement.name.error(1111, className);
                }
              }
              if (desc2 && desc2.isModule) {
                desc2 = desc2.type();
                if (this.isModuleForWebComponent(desc2)) {
                  this.isWebComponent = true;
                } else if (this.isModuleForSkinComponent(desc2)) {
                  this.isSkinComponent = true;
                }
                this.compilation.addDependency(desc2, this.module);
              }
            }
          }
          return desc2;
        });
      }
      getElementInfo() {
        return this.getAttribute("getElementInfo", () => {
          if (this.hasNamespaced) {
            const xmlns = this.getXmlNamespace();
            const jsxConfig = this.compiler.options.jsx || {};
            let sections = jsxConfig.xmlns && jsxConfig.xmlns.sections;
            const nsStack = this.getNamespaceStack();
            let namespace = xmlns && xmlns.value ? xmlns.value.value() : jsxConfig.xmlns.default[nsStack.namespace.value()];
            let load = true;
            if (namespace && sections[namespace]) {
              const sects = sections[namespace];
              const isAll = sects[0] === "*";
              if (isAll || sects.includes(this.openingElement.name.value())) {
                load = false;
                if (namespace === "@slots") {
                  return { isSlot: true };
                } else if (namespace === "@directives") {
                  return { isDirective: true };
                }
              } else {
                this.openingElement.name.error(1125, sects.join(","));
              }
            }
            if (load) {
              const base = this.isProperty ? this.parentStack.getSubClassDescription() : Namespace2.create(namespace, true);
              return { base };
            } else {
              return false;
            }
          } else {
            const className = this.openingElement.name.value();
            const desc2 = this.scope.define(className);
            return { desc: desc2, className };
          }
        });
      }
      type() {
        if (this._type) {
          return this._type;
        }
        const desc2 = this.description();
        return this._type = desc2 ? new InstanceofType(desc2.type(), this) : this.getGlobalTypeById("nullable");
      }
      getNamespaceStack() {
        if (this.openingElement.name.isJSXNamespacedName) {
          return this.openingElement.name;
        } else if (this.openingElement.name.isJSXMemberExpression && this.openingElement.name.object.isJSXNamespacedName) {
          return this.openingElement.name.object;
        }
        return null;
      }
      getXmlNamespace(ns) {
        ns = ns || this.hasNamespaced && this.getNamespaceStack().namespace.value();
        if (!ns)
          return null;
        const target = this.__xmlns || (this.__xmlns = {});
        if (target[ns] !== void 0) {
          return target[ns];
        }
        const xmlns = this.xmlns.find((item2) => {
          return item2.name.name.value() === ns;
        });
        const getParent = () => {
          const parent = this.getParentStack((parent2) => !!parent2.isJSXElement);
          if (parent && parent.isJSXElement) {
            return parent.getXmlNamespace(ns);
          }
          return null;
        };
        return target[ns] = xmlns || (this.parentStack.isJSXElement ? this.parentStack.getXmlNamespace(ns) : getParent());
      }
      getSubClassDescription() {
        const module2 = this.module;
        const desc2 = this.description();
        if (desc2 && module2) {
          const type2 = desc2.type();
          if (type2 && type2.isModule && module2.extends[0] === type2) {
            return module2;
          }
        }
        return desc2;
      }
      filterPropertyChildren() {
        const children = this.children.filter((item2) => {
          if (item2.isJSXText) {
            return !!item2.value().trim();
          }
          return !!item2;
        });
        return children;
      }
      getDescriptionAcceptType(desc2) {
        if (desc2) {
          if (desc2.isMethodSetterDefinition || desc2.isPropertyDefinition) {
            return desc2.params[0] && desc2.params[0].type();
          } else if (desc2.isPropertyDefinition) {
            return desc2.type();
          }
        }
        return null;
      }
      parserPropertyValue() {
        const children = this.children;
        if (children.length !== 1 || !children[0].isJSXExpressionContainer) {
          this.error(1113);
        } else {
          return children[0].description();
        }
      }
      getSlotDescription(slotName, classModule) {
        let parentComponent = classModule || this.parentStack && this.parentStack.description();
        const define = (desc2) => {
          var stackModule = this.compilation.getStackByModule(desc2);
          if (stackModule) {
            const annotation = stackModule.annotations && stackModule.annotations.find((annotation2) => {
              if (annotation2.name.toLowerCase() === "define") {
                const args = annotation2.getArguments();
                if (args && args.length > 1 && args[0].value && args[0].value.toLowerCase() === "slot") {
                  return args.slice(1).some((item2) => {
                    return item2.assigned && item2.key === "name" && item2.value === slotName || !item2.assigned && item2.value === slotName;
                  });
                }
              }
              return false;
            });
            if (annotation) {
              const args = annotation.getArguments();
              const obj = { "name": slotName, args: [], isAnnotation: true, annotation, arguments: args };
              args.slice(1).forEach((item2, index) => {
                const acceptType = item2.stack.acceptType;
                if (acceptType)
                  acceptType.parser();
                if (item2.assigned) {
                  const key = item2.key.toLowerCase();
                  if (key === "scope") {
                    obj.args.push({
                      name: item2.value,
                      stack: item2.stack,
                      type: acceptType ? acceptType.type() : this.getGlobalTypeById("any")
                    });
                  }
                } else if (index > 0) {
                  obj.args.push({
                    name: item2.value,
                    stack: item2.stack,
                    type: acceptType ? acceptType.type() : this.getGlobalTypeById("any")
                  });
                }
              });
              return obj;
            }
          }
        };
        while (parentComponent) {
          const pSlots = parentComponent.jsxDeclaredSlots;
          if (!(pSlots && pSlots.has(slotName))) {
            const result = define(parentComponent);
            if (result) {
              return result;
            }
            parentComponent = parentComponent.inherit;
          } else {
            return pSlots.get(slotName);
          }
        }
        return null;
      }
      checkConditionStatementDirective() {
        const index = this.parentStack.childrenStack.indexOf(this);
        const prevStack = this.parentStack.childrenStack[index - 1];
        if (prevStack && prevStack.isJSXElement && prevStack.isDirective) {
          const directiveName = prevStack.openingElement.name.value().toLowerCase();
          return directiveName === "if" || directiveName === "elseif";
        } else if (prevStack && prevStack.openingElement.attributes.length > 0) {
          return prevStack.openingElement.attributes.some((attr) => {
            if (attr.isAttributeDirective) {
              const directiveName = attr.name.value().toLowerCase();
              return directiveName === "if" || directiveName === "elseif";
            }
            return false;
          });
        }
        return false;
      }
      checkDirective() {
        const directiveName = this.openingElement.name.value().toLowerCase();
        const attrs = this.openingElement.attributes;
        if (directiveName === "elseif" || directiveName === "else") {
          if (!this.checkConditionStatementDirective()) {
            this.error(1156);
          }
        }
        switch (directiveName) {
          case "if":
          case "show":
          case "elseif":
            if (attrs.length !== 1) {
              this.openingElement.name.error(1145, 1, attrs.length);
            } else if (!attrs.every((attr) => attr.name.value() === "condition")) {
              this.openingElement.name.error(1144, `condition`);
            }
            break;
          case "else":
            if (attrs.length > 0) {
              this.openingElement.name.error(1145, 0, attrs.length);
            }
            break;
          case "each":
          case "for": {
            if (attrs.length < 2 || attrs.length > 4) {
              this.openingElement.name.error(1145, 2, attrs.length);
            } else {
              if (!attrs.every((attr) => ["name", "item", "key", "index"].includes(attr.name.value()))) {
                this.openingElement.name.error(1144, ["name", "item", "key", "index"].join(", "));
              } else {
                const resource = attrs.find((attr) => attr.name.value() === "name");
                const description = resource.description();
                const descType = description && description.type();
                const originType = Utils2.getOriginType(descType);
                if (originType && !originType.isAnyType) {
                  if (directiveName === "each" && !this.getGlobalTypeById("array").is(descType)) {
                    resource.value.error(1119, descType.toString());
                  } else if (originType.isNullableType || originType.isNeverType || originType.isVoidType || this.getGlobalTypeById("boolean").is(originType)) {
                    resource.value.error(1049, descType.toString());
                  }
                }
                const mapTypes = {
                  "item": descType ? MergeType.forOfItem(descType) : this.getGlobalTypeById("any"),
                  "key": this.getGlobalTypeById("string"),
                  "index": this.getGlobalTypeById("number")
                };
                attrs.forEach((attr) => {
                  const stack2 = attr.description();
                  if (stack2) {
                    const name = stack2.value();
                    const key = attr.name.value().toLowerCase();
                    if (name && Object.prototype.hasOwnProperty.call(mapTypes, key)) {
                      (function(stack3, _type) {
                        stack3.isDeclarator = true;
                        stack3.kind = "const";
                        stack3.type = function type2() {
                          return _type;
                        };
                        stack3.description = function description2() {
                          return this;
                        };
                        stack3.definition = function definition(ctx2) {
                          return {
                            expre: `(local var) ${this.value()}:${this.type().toString(ctx2 | this.getContext())}`,
                            location: this.getLocation(),
                            file: this.compilation.file
                          };
                        };
                      })(stack2, mapTypes[key]);
                      this.scope.define(name, stack2);
                    }
                  }
                });
              }
            }
            break;
          }
          case "custom": {
            const pros = {
              "name": this.getGlobalTypeById("any"),
              "value": this.getGlobalTypeById("any"),
              "modifier": this.getGlobalTypeById("object"),
              "props": this.getGlobalTypeById("object")
            };
            if (attrs.length < 2 || attrs.length > 3) {
              this.openingElement.name.error(1145, 3, attrs.length);
            } else {
              const required = {};
              const check = (attr) => {
                const name = attr.name.value();
                const type2 = pros[name];
                required[name] = true;
                if (type2) {
                  if (attr.value) {
                    return this.checkExpressionType(type2, attr.value, attr.name);
                  } else {
                    attr.name.error(1172);
                  }
                } else {
                }
                return false;
              };
              attrs.forEach(check);
              if (!(required.name && required.value)) {
                this.openingElement.name.error(1173);
              }
            }
            break;
          }
        }
      }
      getInheritModule() {
        const desc2 = this.description();
        if (this.isComponent && this.jsxRootElement === this) {
          if (this.compilation.JSX && this.parentStack && this.parentStack.isProgram && (this.isModuleForWebComponent(desc2) || this.isModuleForSkinComponent(desc2))) {
            return desc2;
          }
        }
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        const jsxConfig = this.compiler.options.jsx || { xmlns: {} };
        const desc2 = this.description();
        if (desc2 && desc2.isModule && desc2.compilation) {
          const descStack = desc2.compilation.getStackByModule(desc2);
          if (descStack) {
            this.parserDescriptor(descStack);
            descStack.addUseRef(this);
          }
        }
        this.children = this.filterPropertyChildren();
        if (this.parentStack.isJSXElement) {
          this.ownerProperty = this.parentStack.ownerProperty || (this.isProperty ? this : null);
        }
        if (this.hasNamespaced) {
          const xmlns = this.getXmlNamespace() || jsxConfig.xmlns.default[this.getNamespaceStack().namespace.value().toLowerCase()];
          if (!xmlns) {
            this.error(1098, this.getNamespaceStack().namespace.value());
          }
        }
        const isComponent = this.isComponent;
        const subDesc = this.getSubClassDescription();
        if (isComponent && this.jsxRootElement === this) {
          if (this.compilation.JSX && this.parentStack && this.parentStack.isProgram) {
            this.scope.define("this", new InstanceofType(this.module, this));
            if (!(this.isSkinComponent || this.isWebComponent)) {
              this.openingElement.name.error(1179, this.openingElement.name.value());
            }
          } else if (!this.isWebComponent) {
            this.openingElement.name.error(1134, this.openingElement.name.value());
          }
        }
        if (this.isSlot && this.module) {
          const slotName = this.openingElement.name.value();
          const pStack = this.getParentStack((stack2) => !!(stack2.isComponent || !stack2.isJSXElement));
          if (pStack) {
            const isDeclareSlot = !pStack.isComponent || this.compilation.JSX && pStack.jsxRootElement === pStack;
            if (!isDeclareSlot) {
              if (this.parentStack !== pStack) {
                this.openingElement.name.error(1127, slotName);
              } else {
                const pSlot = this.getSlotDescription(slotName);
                if (!pSlot && slotName !== "default") {
                  this.openingElement.name.warn(1126, slotName);
                }
                if (pStack.isComponent) {
                  if (this.openingElement.attributes.length > 0) {
                    const isJsx = pSlot && pSlot.isJSXElement && pSlot.openingElement;
                    const hasDeclareScoped = isJsx && pSlot.openingElement.attributes.length > 0;
                    this.openingElement.attributes.forEach((attr) => {
                      if (isJsx && !hasDeclareScoped) {
                        attr.name.error(1130, attr.name.value());
                      }
                      if (attr.value) {
                        this.scope.define(attr.value.value(), attr);
                      } else {
                        this.scope.define(attr.name.value(), attr);
                      }
                    });
                  }
                  const componentsUseSlots = pStack.componentsUseSlots || (pStack.componentsUseSlots = {});
                  if (componentsUseSlots[slotName] === true) {
                    this.openingElement.name.error(1129, slotName);
                  } else {
                    componentsUseSlots[slotName] = true;
                  }
                }
              }
            } else {
              const declaredSlots = this.module.jsxDeclaredSlots || (this.module.jsxDeclaredSlots = /* @__PURE__ */ new Map());
              this.isSlotDeclared = true;
              if (declaredSlots.has(slotName)) {
                this.openingElement.name.error(1129, slotName);
              } else {
                declaredSlots.set(slotName, this);
              }
            }
          } else {
            this.openingElement.name.error(1127, slotName);
          }
        }
        const attributes = this.openingElement.attributes;
        const cacheAttrs = {};
        attributes.forEach((item2) => {
          item2.parser();
          if (item2.isJSXSpreadAttribute)
            return;
          const name = item2.getAttributeName();
          if (cacheAttrs[name] === true) {
            item2.error(1045, name);
          }
          cacheAttrs[name] = true;
          if (!item2.isAttributeXmlns && !item2.isAttributeDirective && !item2.isAttributeEvent && !item2.isAttributeSlot) {
            if (isComponent) {
              const attrDesc = item2.getAttributeDescription(subDesc);
              if (attrDesc) {
                item2.isMemberProperty = true;
                if (!(attrDesc.isMethodSetterDefinition || attrDesc.isPropertyDefinition)) {
                  item2.name.error(1080, item2.name.value());
                } else if (attrDesc.isPropertyDefinition && attrDesc.isReadonly) {
                  item2.name.error(1142, item2.name.value());
                } else {
                  if (item2.value) {
                    attrDesc.assignment(item2.value, item2.name);
                  }
                }
              }
            } else {
            }
          } else if (item2.isAttributeDirective && this.isDirective) {
            item2.name.error(1143);
          }
        });
        if (this.isProperty) {
          if (desc2) {
            desc2.assignment(this.parserPropertyValue(this.getDescriptionAcceptType(desc2)), this);
          }
        }
        if (!(isComponent || this.isProperty || this.isSlot || this.isDirective) && this.openingElement.name.isJSXMemberExpression) {
          this.warn(1108);
        }
        if (this.isDirective) {
          this.checkDirective();
        } else {
          this.directives = this.openingElement.attributes.filter((attr) => {
            return attr.isAttributeDirective;
          });
        }
        let needCheckSlotDefine = false;
        let pSlots = null;
        let hasDefaultSlot = false;
        if (this.isWebComponent && desc2 && !desc2.isDeclaratorModule) {
          if (!(desc2.isSkinComponent || desc2.isWebComponent) || this.jsxRootElement !== this) {
            needCheckSlotDefine = true;
            pSlots = desc2.jsxDeclaredSlots;
            if (pSlots && pSlots.has("default")) {
              hasDefaultSlot = true;
            } else {
              hasDefaultSlot = !!this.getSlotDescription("default", desc2);
            }
          }
        }
        this.children.forEach((item2) => {
          item2.parser();
          if (!item2.isSlot && needCheckSlotDefine && !hasDefaultSlot) {
            if (desc2.isModule) {
              item2.warn(1131, desc2.getName());
            } else if (desc2.isStack) {
              item2.warn(1131, desc2.value());
            }
          }
        });
      }
      value() {
        return this.openingElement.value();
      }
    };
    module.exports = JSXElement;
  }
});

// lib/stacks/JSXEmptyExpression.js
var require_JSXEmptyExpression = __commonJS({
  "lib/stacks/JSXEmptyExpression.js"(exports, module) {
    var Stack = require_Stack();
    var JSXEmptyExpression = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.jsxElement = parentStack.jsxElement;
        this.isJSXEmptyExpression = true;
      }
    };
    module.exports = JSXEmptyExpression;
  }
});

// lib/stacks/JSXExpressionContainer.js
var require_JSXExpressionContainer = __commonJS({
  "lib/stacks/JSXExpressionContainer.js"(exports, module) {
    var Stack = require_Stack();
    var JSXExpressionContainer = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isJSXExpressionContainer = true;
        this.jsxElement = parentStack.jsxElement;
        this.expression = this.createTokenStack(compilation, node.expression, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.expression.freeze();
      }
      definition(context) {
        const desc2 = this.expression.description();
        if (desc2) {
          const def = desc2.definition(context);
          if (def)
            return def;
        }
        return null;
      }
      reference() {
        return this.expression.reference();
      }
      referenceItems() {
        return this.expression.referenceItems();
      }
      description() {
        return this.expression.description();
      }
      type(ctx2) {
        return this.expression.type(ctx2);
      }
      parser() {
        this.expression.parser();
        this.setRefBeUsed(this.description());
      }
      value() {
        return this.expression.value();
      }
      raw() {
        return this.expression.raw();
      }
    };
    module.exports = JSXExpressionContainer;
  }
});

// lib/stacks/JSXFragment.js
var require_JSXFragment = __commonJS({
  "lib/stacks/JSXFragment.js"(exports, module) {
    var Stack = require_Stack();
    var JSXFragment = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isJSXFragment = true;
        this.jsxRootElement = parentStack.jsxRootElement || this;
        this.children = node.children.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
      }
      freeze() {
        super.freeze();
        this.children.forEach((item2) => item2.freeze());
      }
      definition() {
        return null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      description() {
        return null;
      }
      getXmlNamespace(ns) {
        const xmlns = this.xmlns;
        if (xmlns && ns && xmlns.name.value() === ns) {
          return xmlns;
        }
        return this.parentStack.isJSXElement || this.parentStack.isJSXFragment ? this.parentStack.getXmlNamespace(ns) : null;
      }
      type() {
        return this.getGlobalTypeById("NodeList");
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.children.forEach((item2) => item2.parser());
      }
    };
    module.exports = JSXFragment;
  }
});

// lib/stacks/JSXIdentifier.js
var require_JSXIdentifier = __commonJS({
  "lib/stacks/JSXIdentifier.js"(exports, module) {
    var Identifier = require_Identifier();
    var JSXIdentifier = class extends Identifier {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.jsxElement = parentStack.jsxElement;
        this.isJSXIdentifier = true;
      }
      reference() {
        return null;
      }
      referenceItems() {
        return [];
      }
      description() {
        return null;
      }
      type() {
        return this.getGlobalTypeById("void");
      }
      definition(context) {
        return this.parentStack.definition(context || this.getContext());
      }
      getAttributeDescription(desc2, kind = "set") {
        if (desc2) {
          return this.compilation.getReference(this.value(), desc2, false, kind);
        }
        return null;
      }
    };
    module.exports = JSXIdentifier;
  }
});

// lib/stacks/JSXMemberExpression.js
var require_JSXMemberExpression = __commonJS({
  "lib/stacks/JSXMemberExpression.js"(exports, module) {
    var Stack = require_Stack();
    var Utils2 = require_Utils();
    var JSXMemberExpression = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isJSXMemberExpression = true;
        this.jsxElement = parentStack.jsxElement;
        this.object = this.createTokenStack(compilation, node.object, scope, node, this);
        this.property = this.createTokenStack(compilation, node.property, scope, node, this);
        this.hasNamespaced = !!this.object.isJSXNamespacedName;
      }
      reference(called) {
        return null;
      }
      referenceItems(called) {
        return [];
      }
      definition(context) {
        return this.parentStack.definition(context);
      }
      getFirstMemberStack() {
        if (this.object.isJSXMemberExpression) {
          return this.object.getFirstMemberStack();
        } else {
          return this.object;
        }
      }
      getXmlNamespace(ns) {
        if (this.parentStack.isJSXOpeningElement) {
          return this.parentStack.getXmlNamespace(ns);
        }
        return null;
      }
      description(space, endStack) {
        const property = this.property.value();
        let desc2 = null;
        if (this.object.isJSXMemberExpression) {
          desc2 = this.object.description(space, endStack);
        } else if (space) {
          if (space.isModule) {
            return space.getDescriptor(property, (desc3) => {
              if (desc3.isPropertyDefinition && Utils2.isModifierPublic(desc3) && !desc3.isReadonly) {
                return true;
              } else if (desc3.isMethodSetterDefinition && Utils2.isModifierPublic(desc3)) {
                return true;
              } else {
                return false;
              }
            });
          } else if (space.isNamespace) {
            return this.getModuleById(space.fullName + "." + property, Namespace.dataset);
          }
        }
        if (endStack && endStack !== this.property) {
          return desc2;
        }
        if (desc2) {
          desc2 = desc2.isModule ? desc2 : Utils2.getOriginType(desc2.type());
          return desc2.getDescriptor(property, (desc3) => {
            if (desc3.isPropertyDefinition && Utils2.isModifierPublic(desc3) && !desc3.isReadonly) {
              return true;
            } else if (desc3.isMethodSetterDefinition && Utils2.isModifierPublic(desc3)) {
              return true;
            } else {
              return false;
            }
          });
        }
        return null;
      }
      type() {
        return this.getGlobalTypeById("void");
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.object.parser();
        this.property.parser();
      }
      raw() {
        return `${this.object.raw()}.${this.property.raw()}`;
      }
      value() {
        return `${this.object.value()}.${this.property.value()}`;
      }
    };
    module.exports = JSXMemberExpression;
  }
});

// lib/stacks/JSXNamespacedName.js
var require_JSXNamespacedName = __commonJS({
  "lib/stacks/JSXNamespacedName.js"(exports, module) {
    var Namespace2 = require_Namespace();
    var Stack = require_Stack();
    var Utils2 = require_Utils();
    var JSXNamespacedName = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isJSXNamespacedName = true;
        this.jsxElement = parentStack.jsxElement;
        this.namespace = this.createTokenStack(compilation, node.namespace, scope, node, this);
        this.name = this.createTokenStack(compilation, node.name, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.name && this.name.freeze();
        this.namespace && this.namespace.freeze();
      }
      getXmlNamespace() {
        if (this.parentStack.isJSXOpeningElement || this.parentStack.isJSXAttribute || this.parentStack.isJSXMemberExpression) {
          return this.parentStack.getXmlNamespace(this.namespace.value());
        }
        return null;
      }
      getAttributeDescription(desc2, kind = "set") {
        if (desc2) {
          return this.compilation.getReference(this.name.value(), desc2, false, kind);
        }
        return null;
      }
      definition(context) {
        const stack2 = context && context.stack;
        if (stack2 === this.namespace || this.parentStack.isAttributeDirective) {
          const def = this.getXmlNamespace();
          if (def) {
            let ns = def.value.value();
            if (ns.includes("::")) {
              ns = ns.split("::")[0];
            }
            const expr = this.parentStack.isAttributeDirective ? `${ns}::${this.name.value()}` : def.value.value();
            return {
              text: `(refs) ${expr}`,
              location: def.value.getLocation(),
              file: def.compilation.file,
              range: this.getLocation()
            };
          }
          return null;
        }
        return this.parentStack.definition(context);
      }
      reference() {
        return null;
      }
      referenceItems() {
        return [];
      }
      description(space, endStack) {
        const name = this.name.value();
        if (this.name.isJSXMemberExpression) {
          return this.name.description(space, endStack);
        } else if (space) {
          if (space.isModule) {
            return space.getDescriptor(name, (desc2) => {
              if (desc2.isPropertyDefinition && Utils2.isModifierPublic(desc2)) {
                return true;
              } else if (desc2.isMethodSetterDefinition && Utils2.isModifierPublic(desc2)) {
                return true;
              } else {
                return false;
              }
            });
          } else if (space.isNamespace) {
            return this.getModuleById(space.fullName + "." + name, Namespace2.dataset);
          }
          return null;
        } else {
          return this.getModuleById(name);
        }
      }
      type() {
        return this.getGlobalTypeById("void");
      }
      value() {
        return this.name.value();
      }
    };
    module.exports = JSXNamespacedName;
  }
});

// lib/stacks/JSXOpeningElement.js
var require_JSXOpeningElement = __commonJS({
  "lib/stacks/JSXOpeningElement.js"(exports, module) {
    var Stack = require_Stack();
    var JSXOpeningElement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isJSXOpeningElement = true;
        this.jsxElement = parentStack.jsxElement;
        this.name = this.createTokenStack(compilation, node.name, this.scope, node, this);
        this.attributes = node.attributes.map((item2) => this.createTokenStack(compilation, item2, this.scope, node, this));
        this.selfClosing = !!node.selfClosing;
        this.hasNamespaced = !!(this.name.isJSXNamespacedName || this.name.hasNamespaced);
      }
      freeze() {
        super.freeze();
        this.attributes && this.attributes.forEach((item2) => item2.freeze());
        this.name && this.name.freeze();
      }
      getXmlNamespace(ns) {
        if (this.parentStack.isJSXElement) {
          return this.parentStack.getXmlNamespace(ns);
        }
        return null;
      }
      definition(context) {
        if (this.parentStack.isJSXElement) {
          return this.parentStack.definition(context);
        }
        return null;
      }
      reference() {
        return null;
      }
      referenceItems() {
        return [];
      }
      description() {
        return null;
      }
      type() {
        return this.getGlobalTypeById("void");
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.name.parser();
        this.attributes.forEach((item2) => {
          item2.parser();
        });
      }
      raw() {
        return this.name.raw();
      }
      value() {
        return this.name.value();
      }
    };
    module.exports = JSXOpeningElement;
  }
});

// lib/stacks/JSXOpeningFragment.js
var require_JSXOpeningFragment = __commonJS({
  "lib/stacks/JSXOpeningFragment.js"(exports, module) {
    var Stack = require_Stack();
    var JSXOpeningFragment = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isJSXOpeningFragment = true;
        this.jsxElement = parentStack.jsxElement;
        this.attributes = node.attributes.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
        this.selfClosing = !!node.selfClosing;
      }
      freeze() {
        super.freeze();
        this.attributes && this.attributes.forEach((item2) => item2.freeze());
      }
      definition() {
        return null;
      }
      reference() {
        return null;
      }
      referenceItems() {
        return [];
      }
      description() {
        return null;
      }
      type() {
        return this.getGlobalTypeById("void");
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.attributes.forEach((item2) => {
          item2.parser();
        });
      }
    };
    module.exports = JSXOpeningFragment;
  }
});

// lib/stacks/JSXScript.js
var require_JSXScript = __commonJS({
  "lib/stacks/JSXScript.js"(exports, module) {
    var Stack = require_Stack();
    var Utils2 = require_Utils();
    var JSXScript = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isJSXScript = true;
        this.jsxElement = this;
        this.body = [];
        this.hasClassDeclared = false;
        this.isScriptProgram = parentStack.isJSXElement && parentStack.jsxRootElement === parentStack && parentStack.parentStack.isProgram;
        if (!this.compilation.JSX) {
          this.error(1109);
        }
        this.openingElement = this.createTokenStack(compilation, node.openingElement, scope, node, this);
        this.closingElement = this.createTokenStack(compilation, node.closingElement, scope, node, this);
        if (!this.isScriptProgram) {
          node.children.forEach((item2) => {
            const stack2 = this.createTokenStack(compilation, item2, this.scope, node, this);
            this.body.push(stack2);
          });
        } else {
          const annotations = [];
          const metatypes = [];
          const imports = [];
          node.children.forEach((item2) => {
            const stack2 = this.createTokenStack(compilation, item2, this.scope, node, this);
            if (stack2) {
              if (stack2.isMetatypeDeclaration) {
                metatypes.push(stack2);
              } else if (stack2.isAnnotationDeclaration) {
                const _stack = this.interceptAnnotation(stack2);
                if (_stack) {
                  annotations.push(_stack);
                }
              } else if (stack2.isImportDeclaration) {
                imports.push(stack2);
              } else {
                stack2.annotations = annotations.splice(0, annotations.length);
                stack2.metatypes = metatypes.splice(0, metatypes.length);
                if (stack2.isClassDeclaration) {
                  this.hasClassDeclared = true;
                  this.module = stack2.module;
                  stack2.imports = imports.splice(0, imports.length);
                }
                this.body.push(stack2);
              }
            }
          });
          this.imports = imports;
          if (annotations.length > 0) {
            annotations.forEach((item2) => {
              item2.error(1093);
            });
          }
          if (metatypes.length > 0) {
            metatypes.forEach((item2) => {
              item2.error(1093);
            });
          }
          if (!this.hasClassDeclared) {
            this.compilation.addModuleStack(this.module, this);
          }
        }
      }
      async createCompleted() {
        if (this._createCompletedFlag)
          return;
        this._createCompletedFlag = true;
        if (!this.isScriptProgram)
          return;
        await this.allSettled(this.imports, async (stack2) => await stack2.addImport(this.module, this.parentStack.scope));
        await this.allSettled(this.body.filter((stack2) => stack2.isClassDeclaration).map((stack2) => stack2.createCompleted()));
        const host = this.hostComponentAnnotation;
        if (host) {
          const args = host.getArguments();
          if (args[0]) {
            this.hostComponentModule = await this.loadTypeAsync(args[0].value);
          }
        }
      }
      freeze() {
        super.freeze();
        super.freeze(this.scope);
        super.freeze(this.body);
        this.body.forEach((stack2) => stack2.freeze());
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.isScriptProgram) {
          this.imports.forEach((stack2) => {
            stack2.parser();
          });
          this.compilation.stack.scripts.push(this);
          if (this.hostComponentAnnotation) {
            const pDesc = this.parentStack.description();
            const declare = pDesc && pDesc.getModuleGenerics();
            const args = this.hostComponentAnnotation.getArguments();
            if (declare && args[0]) {
              const refsModule = this.hostComponentModule || this.getModuleById(args[0].value);
              if (refsModule) {
                if (declare[0].hasConstraint && !declare[0].check(refsModule)) {
                  args[0].stack.error(1003, refsModule.toString(), declare[0].toString());
                } else {
                  if (Utils2.checkDepend(this.module, refsModule)) {
                    args[0].stack.error(1024, args[0].value, this.module.getName(), refsModule.getName());
                  } else if (this.module && this.module.isModule) {
                    const stackModule = this.module.moduleStack;
                    if (stackModule) {
                      const ctx2 = stackModule.getContext();
                      ctx2.extractive(declare[0], refsModule);
                    }
                    this.parentStack.jsxRootElement.getContext().extractive(declare[0], refsModule);
                  }
                }
              }
            }
          }
        }
        this.body.forEach((item2) => {
          item2.parser();
        });
      }
    };
    module.exports = JSXScript;
  }
});

// lib/stacks/JSXSpreadAttribute.js
var require_JSXSpreadAttribute = __commonJS({
  "lib/stacks/JSXSpreadAttribute.js"(exports, module) {
    var Stack = require_Stack();
    var JSXSpreadAttribute = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isJSXSpreadAttribute = true;
        this.jsxElement = parentStack.jsxElement;
        this.argument = this.createTokenStack(compilation, node.argument, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.argument && this.argument.freeze();
      }
      definition() {
        return null;
      }
      getAttributeDescription(desc2, kind = "set") {
        return null;
      }
      reference() {
        return this.argument.reference();
      }
      referenceItems() {
        return this.argument.referenceItems();
      }
      description() {
        return this.argument.description();
      }
      type() {
        return this.argument.type();
      }
      parser() {
        if (this.argument) {
          this.argument.parser();
          this.argument.setRefBeUsed();
        }
      }
    };
    module.exports = JSXSpreadAttribute;
  }
});

// lib/stacks/JSXStyle.js
var require_JSXStyle = __commonJS({
  "lib/stacks/JSXStyle.js"(exports, module) {
    var Stack = require_Stack();
    var path = __require("path");
    var JSXStyle = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isJSXStyle = true;
        this.jsxElement = this;
        this.openingElement = this.createTokenStack(compilation, node.openingElement, scope, node, this);
        this.closingElement = this.createTokenStack(compilation, node.closingElement, scope, node, this);
        this.absoluteFile = null;
        this.attributeFile = this.openingElement.attributes.find((item2) => item2.name.value().toLowerCase() === "file");
        this.styleContent = node.children.map((item2) => item2.raw).join("");
        this.styleKey = compilation.jsxStyles.length + 1;
        compilation.jsxStyles.push(this);
      }
      get attributes() {
        if (this.isAttrClone) {
          return this._attributes;
        }
        return this.openingElement.attributes.slice(0);
      }
      description() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        const file = this.attributeFile;
        const target = this.module || this.compilation;
        if (file) {
          const url = file.value.value();
          const resolve = this.compiler.resolve(url, this.file);
          if (!resolve) {
            this.error(1118, url);
          } else {
            this.absoluteFile = resolve;
            if (!target.addAsset(resolve, url, null, path.extname(url), null, null, this)) {
              this.error(1107, url);
            }
          }
        } else {
          const content = this.styleContent.trim();
          if (content) {
            const key = this.styleKey;
            const attributes = {};
            this.openingElement.attributes.forEach((attr) => {
              const key2 = attr.name.value().toLowerCase();
              let value = attr.value ? attr.value.value() : true;
              if (value === "false" || value === "true") {
                value = Boolean(value);
              }
              attributes[key2] = value;
            });
            let format = "css";
            let lang = attributes.lang || attributes.type;
            if (lang) {
              format = String(lang).trim();
              if (format.includes(".")) {
                format = format.replace(/^\./, "");
              }
            }
            if (!target.addAsset(key + "." + format, null, content, "style", null, attributes, this)) {
              this.error(1107, key);
            }
          }
        }
      }
      value() {
        return this.styleContent;
      }
    };
    module.exports = JSXStyle;
  }
});

// lib/stacks/JSXText.js
var require_JSXText = __commonJS({
  "lib/stacks/JSXText.js"(exports, module) {
    var Literal = require_Literal();
    var JSXText = class extends Literal {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.jsxElement = this;
        this.isJSXText = true;
      }
    };
    module.exports = JSXText;
  }
});

// lib/stacks/LabeledStatement.js
var require_LabeledStatement = __commonJS({
  "lib/stacks/LabeledStatement.js"(exports, module) {
    var Stack = require_Stack();
    var LabeledStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isLabeledStatement = true;
        this.labelChildren = [];
        this.labelParent = null;
        this.label = this.createTokenStack(compilation, node.label, scope, node, this);
        this.body = this.createTokenStack(compilation, node.body, scope, node, this);
        const labelStack = parentStack && parentStack.getParentStack((stack2) => !!(stack2.isLabeledStatement || stack2.isFunctionExpression));
        if (labelStack && labelStack.isLabeledStatement) {
          this.labelParent = labelStack;
          labelStack.labelChildren.push(this);
        }
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.label);
        super.freeze(this.labelChildren);
        this.body.freeze();
      }
      definition() {
        return {
          comments: this.label.comments,
          expre: null,
          location: this.label.getLocation(),
          file: this.compilation.file
        };
      }
      parser() {
        return this.body.parser();
      }
    };
    module.exports = LabeledStatement;
  }
});

// lib/stacks/LogicalExpression.js
var require_LogicalExpression = __commonJS({
  "lib/stacks/LogicalExpression.js"(exports, module) {
    var MergeType = require_MergeType();
    var Expression = require_Expression();
    var LogicalExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isLogicalExpression = true;
        this.left = this.createTokenStack(compilation, node.left, scope, node, this);
        this.right = this.createTokenStack(compilation, node.right, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
      }
      definition() {
        return null;
      }
      description() {
        return this;
      }
      type() {
        return this.getAttribute("LogicalExpression.type", () => {
          const operator = this.node.operator;
          let isAnd = true;
          if (operator) {
            isAnd = this.node.operator.charCodeAt(0) === 38;
          }
          if (isAnd) {
            return this.right.type();
          }
          const left = this.left.type();
          if (left.isLiteralType) {
            if (!left.value) {
              return this.right.type();
            } else {
              return left;
            }
          }
          const mergeType = new MergeType();
          mergeType.keepOriginRefs = true;
          mergeType.add(left);
          mergeType.add(this.right.type());
          return mergeType.type();
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.left.parser();
        this.left.setRefBeUsed();
        this.right.parser();
        this.right.setRefBeUsed();
      }
    };
    module.exports = LogicalExpression;
  }
});

// lib/types/ComputeType.js
var require_ComputeType = __commonJS({
  "lib/types/ComputeType.js"(exports, module) {
    var Namespace2 = require_Namespace();
    var Utils2 = require_Utils();
    var Type = require_Type();
    var UnionType = require_UnionType();
    var ComputeType = class extends Type {
      constructor(target, object, property, keyName) {
        super("$ComputeType");
        this.isComputeType = true;
        this.isAnyType = true;
        this.target = target;
        this.object = object;
        this.property = property;
        this.originObject = object;
        this.originProperty = property;
        this.keyName = keyName;
        this.computed = true;
      }
      get hasGenericType() {
        return !!(this.object.type().hasGenericType || this.property.type().hasGenericType);
      }
      clone(inference) {
        if (!inference || !this.hasGenericType) {
          return this;
        }
        const target = this.getComputeType();
        if (target !== this) {
          return target.clone(inference);
        }
        let object = this.object.type().clone(inference);
        let property = this.property.type().clone(inference);
        if (property.isGenericType && property.hasConstraint) {
          const inherit = property.inherit.clone(inference);
          if (!inherit.hasGenericType) {
            property = inherit;
          }
        }
        if (object.hasGenericType || property.hasGenericType) {
          return this;
        }
        let result = new ComputeType(this.target, object, property, this.keyName);
        result.originObject = this.object;
        result.originProperty = this.property;
        return result;
      }
      isPropertyExists(keyStack) {
        const context = this.target && this.target.isStack ? this.target.getContext() : null;
        const inference = context && context.inference;
        let object = this.object.type();
        let property = this.property.type();
        if (inference) {
          object = object.hasGenericType ? inference(object) : object;
          property = property.hasGenericType ? inference(property) : property;
        }
        return !!this.getComputeValue(object, property, keyStack || this.property);
      }
      getComputeValue(object, property, keyStack) {
        const getProperty = (object2, propName, propertyType) => {
          let result = null;
          if (object2.isInstanceofType) {
            if (propName) {
              result = object2.inherit.getDescriptor(propName, (desc2, prev) => {
                if ((desc2.isPropertyDefinition || desc2.isMethodGetterDefinition) && Utils2.isModifierPublic(desc2)) {
                  return true;
                }
                return prev || desc2;
              });
            }
            if (!result) {
              result = object2.inherit.dynamicAttribute(propertyType);
            }
            if (result && result.isStack && !Utils2.isModifierPublic(result)) {
              return null;
            }
          } else if (object2.isLiteralObjectType) {
            result = propName && object2.attribute(propName) || object2.dynamicAttribute(propertyType);
          } else if (object2.isLiteralArrayType || object2.isTupleType) {
            const propIndex = propName === null ? -1 : parseInt(propName);
            if (propIndex >= 0 && propIndex < object2.elements.length) {
              result = object2.elements[propName];
            }
            if (!result) {
              result = object2.dynamicAttribute(propertyType);
            }
          } else {
            object2 = Utils2.getOriginType(object2);
            if (object2.isInterface && object2.isModule) {
              if (propName) {
                result = object2.getDescriptor(propName, (desc2, prev) => {
                  if ((desc2.isPropertyDefinition || desc2.isMethodGetterDefinition) && Utils2.isModifierPublic(desc2)) {
                    return true;
                  }
                  return prev || desc2;
                });
              }
              if (!result) {
                result = object2.dynamicAttribute(propertyType);
              }
            }
          }
          return result ? result.type() : null;
        };
        const getProperties = (object2, property2) => {
          if (property2.isUnionType || property2.isTupleType || property2.isLiteralArrayType) {
            const reduce = (accumulator, item2) => item2.isUnionType || item2.isTupleType ? item2.elements.reduce(reduce, accumulator) : accumulator.concat(item2.type());
            const keys = property2.elements.reduce(reduce, []).filter((item2) => item2.isLiteralType);
            const values = keys.map((item2) => {
              return getProperty(object2, item2.value, item2);
            }).filter((item2) => !!item2);
            if (values.length) {
              if (values.length === 1)
                return values[0];
              return new UnionType(values, this.target);
            }
          } else {
            return getProperty(object2, property2.isLiteralType ? property2.value : null, property2);
          }
          return null;
        };
        const defaultType = Namespace2.globals.get("any");
        const getDesc = (name, keyType) => {
          if (object.isLiteralArrayType || object.isLiteralObjectType || object.isGenericType && object.hasConstraint || object.isTupleType || object.isEnumType || object.isIntersectionType || object.isInstanceofType) {
            const desc2 = name ? object.attribute(name) : null;
            if (desc2) {
              return desc2.type();
            } else if (object.isLiteralObjectType || object.isLiteralArrayType || object.isTupleType) {
              return getProperties(object, keyType) || defaultType;
            } else if (object.isInstanceofType) {
              return getProperties(object, keyType) || defaultType;
            }
          } else if (name) {
            return getProperty(object, name, keyType) || defaultType;
          } else {
            return getProperties(object, keyType) || defaultType;
          }
        };
        let key = (property.isUnionType || property.isLiteralArrayType) && keyStack ? property.elements.find((ele) => ele.type().check(keyStack, {}, { toLiteralValue: true })) : property;
        if (key)
          key = key.type();
        return key && key.isLiteralType ? getDesc(key.value, key) : getDesc(null, key || property);
      }
      getComputeType(keyStack, context = {}) {
        const infer = (type2) => context && typeof context.inference === "function" ? context.inference(type2) : type2;
        const object = infer(this.object.type());
        const property = infer(this.property.type());
        if (object && object.isThisType) {
          return this;
        }
        if (object && property && !(object.isGenericType || property.isGenericType)) {
          const result = this.getComputeValue(object, property, keyStack);
          return result ? result : Namespace2.globals.get("any");
        }
        return this;
      }
      getResult(keyStack) {
        const object = this.object.type();
        const property = this.property.type();
        if (!(object.isGenericType || property.isGenericType)) {
          const result = this.getComputeValue(object, property, keyStack);
          if (result)
            return result;
        }
        return Namespace2.globals.get("any");
      }
      type() {
        return this.getComputeType();
      }
      definition() {
        return {
          expre: `(type) ${this.toString()}`
        };
      }
      is(type2, context = {}, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.getWrapAssignType(type2);
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        let object = this.inferType(this.object.type(), context);
        let property = this.inferType(this.property.type(), context);
        if (!(object.isGenericType || property.isGenericType)) {
          return this.inferType(this.getComputeValue(object, property), context).is(type2, context, options);
        }
        return !(type2.isTupleType || type2.isLiteralArrayType);
      }
      toString(context, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        const result = this.getComputeType(null, context);
        if (result !== this) {
          return result.toString(context, options);
        }
        let object = this.object.type();
        let property = this.property.type();
        if (!(object.isGenericType || property.isGenericType)) {
          if (object.isThisType) {
            let labels = "";
            if (property.isLiteralArrayType) {
              labels = property.elements.map((item2) => {
                return item2.type().toString(context, { toLiteralValue: true });
              }).join(" | ");
            } else {
              labels = property.toString(context, Object.assign(options, { toLiteralValue: true }));
            }
            return `${object.toString()}[${labels}]`;
          } else {
            return this.getComputeValue(object, property).toString(context, options);
          }
        }
        return `${this.originObject.type().toString(context, options)}[${this.originProperty.type().toString(context, options)}]`;
      }
    };
    module.exports = ComputeType;
  }
});

// lib/stacks/MemberExpression.js
var require_MemberExpression = __commonJS({
  "lib/stacks/MemberExpression.js"(exports, module) {
    var Stack = require_Stack();
    var Utils2 = require_Utils();
    var Expression = require_Expression();
    var ComputeType = require_ComputeType();
    var Namespace2 = require_Namespace();
    var keySymbol = Symbol("key");
    var MemberExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isMemberExpression = true;
        this.object = this.createTokenStack(compilation, node.object, scope, node, this);
        this.property = this.createTokenStack(compilation, node.property, scope, node, this);
        this._accessor = null;
        this.computed = !!node.computed;
        this[keySymbol] = {};
        this.addHook();
      }
      addHook() {
        if (!this.isJSXForContext()) {
          const id = this.value();
          const maybe = this.parentStack.isCallExpression || this.parentStack.isNewExpression || this.parentStack.isAssignmentPattern && this.parentStack.node.right === this.node || this.parentStack.isAssignmentExpression && this.parentStack.node.right === this.node || this.parentStack.isVariableDeclarator && this.parentStack.node.init === this.node || this.parentStack.isMemberExpression && this.parentStack.node.object === this.node || this.parentStack.isProperty && this.parentStack.node.value === this.node;
          if (maybe && this.checkNeedToLoadTypeById(id)) {
            this.compilation.hookAsync("compilation.create.after", async () => {
              const desc2 = await this.loadTypeAsync(id);
              if (desc2 && desc2.isModule) {
                this.compilation.addDependency(desc2, this.module);
              }
            });
          }
        }
      }
      freeze() {
        super.freeze();
        this.object.freeze();
        this.property.freeze();
      }
      reference(called) {
        const description = this.getDescription();
        if (description !== this && description instanceof Stack) {
          return description.reference(called);
        }
        return this;
      }
      referenceItems(called) {
        const description = this.getDescription();
        if (description !== this && description instanceof Stack) {
          return description.referenceItems(called);
        }
        return [this];
      }
      definition(context) {
        const pStack = this.getParentStack((stack2) => !stack2.isMemberExpression);
        if (pStack && pStack.isPackageDeclaration) {
          return pStack.definition(context);
        }
        if (pStack && pStack.isAnnotationExpression) {
          return pStack.definition(context);
        }
        if (this.isTypeDefinitionStack(pStack)) {
          return pStack.definition(context);
        }
        if (this.parentStack.isCallExpression || this.parentStack.isNewExpression) {
          if (this.parentStack.callee === this) {
            return this.parentStack.definition(context);
          }
        }
        context = context || this.getContext();
        const desc2 = this.computed ? this.property.description() : this.description();
        if (!desc2)
          return null;
        if (desc2.isAnyType) {
          const object = this.object.type();
          if (object.isLiteralObjectType && object.target && object.target.isObjectExpression) {
            const type2 = this.parentStack.isAssignmentExpression ? this.parentStack.right.type().toString(this.parentStack.right.getContext()) : "any";
            return {
              expre: `(property) ${this.property.value()}: ${type2}`
            };
          }
        }
        if (desc2.isType && !desc2.isModule && desc2.target && desc2.target.isStack && desc2.target.compilation) {
          const target = desc2.target;
          return {
            expre: `(property) ${this.property.value()}: ${desc2.type().toString(context)}`,
            location: target.getLocation(),
            file: target.compilation.file,
            comments: target.comments
          };
        }
        if (desc2.isNamespace) {
          if (desc2.stack && desc2.stack.isStack) {
            const def2 = desc2.stack.definition(context);
            if (def2) {
              def2.range = this.node.loc;
              return def2;
            }
          }
          return null;
        }
        const def = desc2.definition(context);
        return def;
      }
      set accessor(val) {
        this._accessor = val;
      }
      getDescription() {
        let property = this.property.value();
        let description = this.object.description();
        if (description && description instanceof Namespace2) {
          return this.getMatchDescriptor(property, description) || description.children.get(property);
        }
        if (this.computed) {
          if (this.property.isIdentifier) {
            const refs = this.property.reference();
            const desc2 = this.property.description();
            if (refs === this.property && desc2 && !(desc2.isDeclarator && desc2 instanceof Stack)) {
              this.computed = false;
            }
          }
          if (this.computed) {
            return new ComputeType(this, this.object, this.property);
          }
        }
        let objectType = this.object.type();
        if (objectType instanceof Namespace2) {
          return this.getMatchDescriptor(property, objectType) || objectType.children.get(property);
        }
        const isStatic = Utils2.isClassType(objectType) && objectType === this.object.description();
        return this.getObjectDescriptor(objectType, property, isStatic);
      }
      description() {
        return this.getAttribute("MemberExpression.description", () => {
          if (this.parentStack.isImportDeclaration) {
            return this.getModuleById(this.value());
          } else if (this.parentStack) {
            const pStack = this.getParentStack((stack2) => !stack2.isMemberExpression);
            if (pStack && pStack.isImportDeclaration) {
              return Namespace2.fetch(this.value(), null, true);
            }
          }
          let desc2 = this.getDescription();
          if (!desc2) {
            const module2 = this.module;
            desc2 = this.getModuleById(this.value()) || null;
            if (desc2 && Utils2.isClassType(desc2) && desc2 !== module2) {
              this.compilation.addDependency(desc2, this.module);
            }
          }
          return desc2;
        });
      }
      type() {
        return this.getAttribute("MemberExpression.type", () => {
          const description = this.description();
          if (description) {
            if (description.isNamespace) {
              return description;
            }
            let type2 = description.type();
            if (!this.parentStack.isCallExpression) {
              const ctx2 = this.getContext();
              if (type2.isGenericType) {
                type2 = ctx2.fetch(type2, true);
              } else {
                ctx2.make(type2);
              }
            }
            if (description.isDeclaratorVariable && this.parentStack.isNewExpression) {
              return description.declarations[0].type();
            }
            return type2;
          }
          return Namespace2.globals.get("any");
        });
      }
      isProtectedAccessible(target) {
        if (target === this.module) {
          return true;
        }
        let parent = this.module;
        while (parent = parent.extends[0]) {
          if (parent === target)
            return true;
        }
        return false;
      }
      getFirstMemberStack() {
        if (this.object.isMemberExpression) {
          return this.object.getFirstMemberStack();
        } else {
          return this.object;
        }
      }
      getContext() {
        const ctx2 = super.getContext();
        ctx2.make(this.object.type());
        return ctx2;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.object.parser();
        let desc2 = this.object.description();
        this.object.setRefBeUsed(desc2);
        const description = this.description();
        if (description) {
          this.parserDescriptor(description);
          if ((description.isGenericTypeDeclaration || description.isTypeStatement) && !this.scope.isDirective) {
            const parent = this.parentStack;
            if (!parent.isTypeTransformExpression && !(parent.isTypeDefinition || parent.isTypeTupleRestDefinition || parent.isTypeTupleDefinition || parent.isGenericTypeDeclaration || parent.isGenericDeclaration || parent.isTypeObjectDefinition || parent.isTypeObjectPropertyDefinition || parent.isTypeFunctionDefinition || parent.isTypeUnionDefinition)) {
              this.error(1059, this.value());
            }
          }
          if (description.isNamespace && !this.parentStack.isMemberExpression) {
            this.error(1059, this.value());
          }
        }
        if (this.computed) {
          this.property.parser();
          this.property.setRefBeUsed();
          const propertyType = this.property.type();
          if (propertyType.isTupleType || propertyType.isLiteralObjectType || propertyType.isLiteralArrayType) {
            this.property.error(1150, propertyType.toString());
          }
        }
        if (!description) {
          this.property.error(1060, this.raw());
        } else if (description.isMethodDefinition || description.isPropertyDefinition) {
          let object = Utils2.getOriginType(this.object.type());
          if (object.isModule) {
            if (object.isRemoved(this.property.value(), description)) {
              this.error(1181, this.raw());
            }
            if (object.isDeprecated(this.property.value(), description)) {
              object.getDescriptor(this.property.value(), (desc3) => {
                if (desc3.isDeprecated) {
                  const deprecatedAnnotation = desc3.annotations.find((item2) => item2.name.toLowerCase() === "deprecated");
                  if (deprecatedAnnotation) {
                    const args = deprecatedAnnotation.getArguments();
                    const message = args[0] ? args[0].value : "";
                    this.deprecated(1182, this.raw(), message);
                  }
                }
              });
            }
          }
          const modifier = description.modifier ? description.modifier.value() : "public";
          if (modifier !== "public" && this.scope.type("top")) {
            this.property.error(1061, this.raw());
          } else if (modifier === "private" && description.module !== this.module) {
            this.property.error(1061, this.raw());
          } else if (modifier === "protected" && !this.isProtectedAccessible(description.module)) {
            this.property.error(1061, this.raw());
          }
        }
      }
      raw() {
        if (this.computed) {
          return `${this.object.raw()}[${this.property.raw()}]`;
        }
        return `${this.object.raw()}.${this.property.raw()}`;
      }
      value() {
        if (this.computed) {
          return `${this.object.value()}[${this.property.raw()}]`;
        }
        return `${this.object.value()}.${this.property.value()}`;
      }
    };
    module.exports = MemberExpression;
  }
});

// lib/scope/BlankScope.js
var require_BlankScope = __commonJS({
  "lib/scope/BlankScope.js"(exports, module) {
    var Scope = require_Scope();
    module.exports = class BlankScope extends Scope {
      constructor(parentScope) {
        super(parentScope);
      }
      type(name) {
        return name === "blank";
      }
    };
  }
});

// lib/stacks/MetatypeDeclaration.js
var require_MetatypeDeclaration = __commonJS({
  "lib/stacks/MetatypeDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var BlankScope = require_BlankScope();
    var MetatypeDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        scope = new BlankScope(null);
        super(compilation, node, scope, parentNode, parentStack);
        this.isMetatypeDeclaration = true;
        this.body = (node.body || []).map((item2) => {
          return this.createTokenStack(compilation, item2, scope, node, this);
        });
      }
      freeze() {
        super.freeze();
        super.freeze(this.body);
        (this.body || []).forEach((stack2) => stack2.freeze());
      }
      get name() {
        return this.node.name;
      }
      description() {
        return this;
      }
      getArguments() {
        const target = [];
        this.body.map((item2, index) => {
          if (item2.isAssignmentPattern) {
            const key = item2.left.value();
            const value = item2.right.value();
            const assigned = true;
            target.push({ key, value, assigned, stack: item2 });
          } else {
            const key = index;
            const value = item2.value();
            const assigned = false;
            target.push({ key, value, assigned, stack: item2 });
          }
        });
        return target;
      }
    };
    module.exports = MetatypeDeclaration;
  }
});

// lib/stacks/MethodDefinition.js
var require_MethodDefinition = __commonJS({
  "lib/stacks/MethodDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var Constant = require_Constant();
    var InstanceofType = require_InstanceofType();
    var Utils2 = require_Utils();
    var keySymbol = Symbol("key");
    var MethodDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isMethodDefinition = true;
        this._metatypes = [];
        this._annotations = [];
        this.isMethod = true;
        this.static = this.createTokenStack(compilation, node.static, scope, node, this);
        this.key = this.createTokenStack(compilation, node.key, scope, node, this);
        this.dynamicMethod = false;
        if (node.dynamic && node.key.acceptType) {
          this.dynamicMethod = true;
          this.dynamicType = this.createTokenStack(compilation, node.key.acceptType, scope, node, this);
        }
        const name = this.key.value();
        if (name === "constructor" || name === this.module.id) {
          this.isConstructor = true;
          this.callable = false;
          if (node.genericity) {
            this.key.error(1062);
          }
        } else {
          this.callable = true;
        }
        this.expression = this.createTokenStack(compilation, node.value, scope, node, this);
        this.modifier = this.createTokenStack(compilation, node.modifier, scope, node, this);
        this.override = false;
        this.isFinal = false;
        this.isRemoved = false;
        this.isDeprecated = false;
        this.isNoop = false;
        this.expression.key = this.key;
        this.scope = this.expression.scope;
        this.kind = node.kind;
        if (!this.static) {
          this.expression.scope.define("this", new InstanceofType(this.module, this, null, true));
        } else {
          this.scope.isStatic = true;
        }
        if (!this.parentStack.isUseExtendStatement) {
          if (!this.dynamicMethod) {
            this.module.addMember(name, this);
          }
        }
        this.isEnterMethod = false;
        this[keySymbol] = {};
        this.policy = Constant.POLICY_NONE;
      }
      freeze() {
        this.key.freeze();
        super.freeze();
        super.freeze(this.scope);
        super.freeze(this.static);
        super.freeze(this._metatypes);
        super.freeze(this._annotations);
        super.freeze(this.modifier);
        super.freeze(this.override);
        super.freeze(this._annotations);
        super.freeze(this.useRefItems);
        this.expression.freeze();
      }
      definition(ctx2) {
        const type2 = this.getReturnedType();
        let complete = false;
        if (!ctx2 || ctx2.stack && (ctx2.stack === this.key || ctx2.stack === this || ctx2.stack.isMemberExpression)) {
          complete = true;
          ctx2 = {};
        }
        const identifier = this.key.value();
        const context = this;
        const params = this.params.map((item2) => {
          if (item2.isObjectPattern) {
            const properties = item2.properties.map((property) => {
              const name = property.key.value();
              const acceptType = property.type().toString(ctx2);
              const init = property.init;
              if (init && init.isAssignmentPattern) {
                return `${init.left.value()}:${acceptType} = ${init.right.raw()}`;
              }
              return `${name}:${acceptType}`;
            });
            return `{${properties.join(",")}}`;
          } else if (item2.isArrayPattern) {
            const properties = item2.elements.map((property) => {
              const acceptType = property.type().toString(ctx2);
              if (property.isAssignmentPattern) {
                return `${property.left.value()}:${acceptType} = ${property.right.raw()}`;
              }
              const name = property.value();
              return `${name}:${acceptType}`;
            });
            return `[${properties.join(",")}]`;
          } else {
            const name = item2.value();
            const type3 = item2.type().toString(ctx2);
            const rest = item2.isRestElement ? "..." : "";
            const question = item2.question ? "?" : "";
            if (item2.isAssignmentPattern && item2.right) {
              const initial = item2.right.value();
              return `${rest}${name}${question}: ${type3}=${initial}`;
            }
            return `${rest}${name}${question}: ${type3}`;
          }
        });
        const modifier = this.modifier ? this.modifier.value() : "public";
        const _static = this.static ? "static " : "";
        const generics = (this.genericity ? this.genericity.elements : []).map((item2) => {
          return item2.type().toString(ctx2, { complete });
        });
        const kind = this.isConstructor ? "constructor" : "method";
        const strGenerics = generics.length > 0 ? `<${generics.join(", ")}>` : "";
        let owner = this.module.getName();
        if (!this.isConstructor) {
          if (this.dynamicType) {
            owner = `${owner}[${identifier}:${this.dynamicType.type().toString(ctx2)}]`;
          } else {
            owner = `${owner}.${identifier}`;
          }
        }
        let location = this.key.getLocation();
        const returnType = type2 ? type2.type().toString(ctx2) : this.isConstructor ? owner : "void";
        return {
          comments: context.comments,
          expre: `(${kind}) ${_static}${modifier} ${owner}${strGenerics}(${params.join(", ")}): ${returnType}`,
          location,
          file: this.compilation.file
        };
      }
      set metatypes(value) {
        this._metatypes = value;
        if (this.isConstructor) {
          if (!this.callable) {
            this.callable = value.some((metatype) => {
              metatype.additional = this;
              return metatype.name.toLowerCase() === "callable";
            });
          }
          if (this.callable) {
            this.module.callable = this;
          }
        }
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value) {
        this._annotations = value;
        value.forEach((annotation) => {
          annotation.additional = this;
          switch (annotation.name.toLowerCase()) {
            case "override":
              this.override = true;
              break;
            case "callable":
              this.callable = !!this.isConstructor;
              if (this.callable) {
                this.module.addDescriptor("#" + this.module.id, this);
              }
              break;
            case "main":
              this.isEnterMethod = true;
              break;
            case "final":
              this.isFinal = true;
              break;
            case "deprecated":
              this.isDeprecated = true;
              break;
            case "removed":
              this.isRemoved = true;
            case "noop":
              this.isNoop = true;
              break;
          }
        });
      }
      get annotations() {
        return this._annotations;
      }
      get params() {
        return this.expression.params;
      }
      get body() {
        return this.expression.body;
      }
      get genericity() {
        return this.expression.genericity;
      }
      get question() {
        return !!this.key.node.question;
      }
      reference(called) {
        return this.expression.reference(called);
      }
      referenceItems(called) {
        return this.expression.referenceItems(called);
      }
      description() {
        return this;
      }
      error(code, ...args) {
        this.key.error(code, ...args);
      }
      warn(code, ...args) {
        this.key.warn(code, ...args);
      }
      getFunType() {
        return this.expression.getFunType();
      }
      inferReturnType(context) {
        return this.expression.inferReturnType(context);
      }
      getReturnedType(context) {
        if (this.isConstructor) {
          return this.expression._returnType;
        }
        return this.expression.getReturnedType(context);
      }
      getContext() {
        return this.expression.getContext();
      }
      type() {
        const expr = this.expression;
        const name = this.key.value();
        if ((name === "constructor" || name === this.module.id) && !expr._returnType) {
          return this.module;
        }
        return expr.type();
      }
      get returnType() {
        const expr = this.expression;
        const name = this.key.value();
        if ((name === "constructor" || name === this.module.id) && !expr._returnType) {
          return this.module;
        }
        return expr.returnType;
      }
      value() {
        return this.key.value();
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.dynamicType) {
          this.dynamicType.parser();
          this.module.addMember(this.dynamicType.type(), this);
        }
        if (this.parentStack.isUseExtendStatement) {
          this.expression.parser();
          return true;
        }
        const metatypes = this.metatypes;
        const annotations = this.annotations;
        if (metatypes) {
          metatypes.forEach((item2) => item2.parser());
        }
        if (annotations) {
          annotations.forEach((item2) => item2.parser());
        }
        if (this.module && !this.module.isDeclaratorModule) {
          const kind = this.isAccessor ? "accessor" : "method";
          const accessor = this.isMethodGetterDefinition ? "get" : this.isMethodSetterDefinition ? "set" : null;
          const parent = this.module.extends[0];
          if (this.override && !this.static) {
            const pMethod = parent && parent.getMember(this.key.value(), accessor);
            if (!parent || !pMethod) {
              this.key.error(1063, this.key.value(), kind);
            } else if (pMethod.isAccessor !== this.isAccessor) {
              this.key.error(1136, this.key.value(), kind);
            } else if (this.params.length !== pMethod.params.length) {
              if (this.isAccessor) {
                this.key.error(1089, this.key.value());
              } else {
                const isRest = this.params.length === 1 && this.params[0].isRestElement;
                if (!isRest && pMethod.params.length >= this.params.length) {
                  if (!pMethod.params.every((item2, index) => {
                    if (item2.question)
                      return true;
                    return !!this.params[index];
                  })) {
                    this.key.error(1088, this.key.value());
                  }
                }
              }
            }
            if (pMethod && pMethod.isFinal) {
              this.key.error(1148, this.key.value());
            }
          } else if (parent && !this.static) {
            const parentMethod = parent.getMember(this.key.value(), accessor);
            if (parentMethod && Utils2.getModifierValue(parentMethod) !== "private") {
              this.key.error(1064, this.key.value(), kind);
            }
          }
        }
        this.expression.parser();
      }
    };
    module.exports = MethodDefinition;
  }
});

// lib/stacks/MethodGetterDefinition.js
var require_MethodGetterDefinition = __commonJS({
  "lib/stacks/MethodGetterDefinition.js"(exports, module) {
    var MethodDefinition = require_MethodDefinition();
    var MethodGetterDefinition = class extends MethodDefinition {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isMethodGetterDefinition = true;
        this.callable = false;
        this.isAccessor = true;
      }
      definition(ctx2) {
        let complete = false;
        if (!ctx2 || ctx2.stack && (ctx2.stack === this.key || ctx2.stack === this)) {
          complete = true;
          ctx2 = {};
        }
        const type2 = this.type();
        const identifier = this.key.value();
        const context = this;
        const modifier = this.modifier ? this.modifier.value() : "public";
        let owner = this.module.getName();
        const _static = this.static ? "static " : "";
        const declareGenerics = this.module.getModuleGenerics();
        if (declareGenerics) {
          owner = [owner, "<", declareGenerics.map((type3) => type3.toString(ctx2, { complete })).join(", "), ">"].join("");
        }
        return {
          comments: context.comments,
          expre: `(propery) ${_static}${modifier} get ${owner}.${identifier}(): ${type2.toString(ctx2)}`,
          location: this.key.getLocation(),
          file: this.compilation.file
        };
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.expression.params.length != 0) {
          this.error(1065, this.key.value());
        }
        const isInterface = this.module && (this.module.isDeclaratorModule || this.module.isInterface);
        if (this.scope.returnItems.length < 1 && !isInterface) {
          this.error(1066, this.key.value());
        }
      }
      type() {
        const result = super.getReturnedType();
        let type2 = null;
        if (result) {
          type2 = result.type();
        }
        return type2 || this.getGlobalTypeById("any");
      }
      referenceItems() {
        return super.referenceItems(true);
      }
      reference() {
        return super.reference(true);
      }
      getFunType() {
        return null;
      }
    };
    module.exports = MethodGetterDefinition;
  }
});

// lib/stacks/MethodSetterDefinition.js
var require_MethodSetterDefinition = __commonJS({
  "lib/stacks/MethodSetterDefinition.js"(exports, module) {
    var MethodDefinition = require_MethodDefinition();
    var MethodSetterDefinition = class extends MethodDefinition {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isMethodSetterDefinition = true;
        this.callable = false;
        this.assignValue = null;
        this.assignItems = /* @__PURE__ */ new Set();
        this.isAccessor = true;
      }
      freeze() {
        super.freeze();
        super.freeze(this.assignItems);
      }
      definition(ctx2) {
        let complete = false;
        if (!ctx2 || ctx2.stack && (ctx2.stack === this.key || ctx2.stack === this)) {
          complete = true;
          ctx2 = {};
        }
        const identifier = this.key.value();
        const context = this;
        const params = this.params.map((item2) => {
          let type2 = item2.type();
          type2 = type2 ? type2.toString(ctx2) : "unknown";
          return `${item2.value()}:${type2}`;
        });
        const modifier = this.modifier ? this.modifier.value() : "public";
        let owner = this.module.getName();
        const _static = this.static ? "static " : "";
        const declareGenerics = this.module.getModuleGenerics();
        if (declareGenerics) {
          owner = [owner, "<", declareGenerics.map((type2) => type2.toString(ctx2, { complete })).join(", "), ">"].join("");
        }
        return {
          comments: context.comments,
          expre: `(propery) ${_static}${modifier} set ${owner}.${identifier}(${params.join(",")}):void`,
          location: this.key.getLocation(),
          file: this.compilation.file
        };
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.expression.params.length != 1) {
          this.error(1067, this.key.value());
        }
        const param = this.expression.params[0];
        if (param.acceptType) {
          let has = false;
          const type2 = param.acceptType.type();
          const desc2 = this.module.getDescriptor(this.key.value(), (desc3) => {
            if (desc3 && desc3.isMethodGetterDefinition) {
              has = true;
              return type2 && type2.check(desc3);
            }
          });
          if (has) {
            if (!desc2) {
              this.error(1068, this.key.raw());
            }
          }
        }
      }
      type() {
        return this.getGlobalTypeById("void");
      }
      getFunType() {
        return null;
      }
      referenceItems() {
        return [];
      }
      reference() {
        return null;
      }
      assignment(value, stack2 = null) {
        if (this.assignValue !== value) {
          const param = this.expression.params[0];
          let acceptType = param.acceptType ? param.acceptType.type() : null;
          if (!acceptType) {
            const desc2 = this.compilation.getReference(this.key.value(), this.module, !!this.static, "get");
            acceptType = desc2 ? desc2.type() : null;
          }
          const result = this.checkExpressionType(acceptType, value, stack2 || this);
          if (result) {
            this.assignItems.add(value);
            this.assignValue = value;
          }
          if (value && value.isStack) {
            this.setRefBeUsed(value.description());
          }
        }
      }
    };
    module.exports = MethodSetterDefinition;
  }
});

// lib/stacks/ModifierDeclaration.js
var require_ModifierDeclaration = __commonJS({
  "lib/stacks/ModifierDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var ModifierDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isModifierDeclaration = true;
      }
    };
    module.exports = ModifierDeclaration;
  }
});

// lib/stacks/ModuleDeclaration.js
var require_ModuleDeclaration = __commonJS({
  "lib/stacks/ModuleDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var ModuleDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isModuleDeclaration = true;
        this._metatypes = [];
        this._annotations = [];
        this.id = this.createTokenStack(compilation, node.id, scope, node, this);
        this.body = [];
        this.exports = [];
        this.externals = [];
        this.imports = [];
        this.annotations = [];
        if (!parentStack.isProgram) {
          this.id.error(1180, this.id.value());
        }
        const annotations = this.annotations;
        const metatypes = this.metatypes;
        const imports = this.imports;
        const exports2 = this.exports;
        const externals = this.externals;
        node.body.forEach((item2, index) => {
          const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          if (stack2.isAnnotationDeclaration) {
            const annotationStack = this.interceptAnnotation(stack2);
            if (annotationStack) {
              annotations.push(annotationStack);
            }
            this.body.push(stack2);
          } else if (stack2.isImportDeclaration) {
            imports.push(stack2);
            this.body.push(stack2);
          } else if (stack2.isExportAllDeclaration || stack2.isExportDefaultDeclaration || stack2.isExportNamedDeclaration) {
            exports2.push(stack2);
            this.body.push(stack2);
          } else {
            stack2.metatypes = metatypes.splice(0, metatypes.length);
            stack2.annotations = annotations.splice(0, annotations.length);
            if (stack2.isClassDeclaration || stack2.isEnumDeclaration || stack2.isInterfaceDeclaration || stack2.isStructTableDeclaration || stack2.isDeclaratorDeclaration || stack2.isDeclaratorVariable || stack2.isDeclaratorFunction || stack2.isTypeStatement || stack2.isDeclaratorTypeAlias) {
              stack2.imports = imports.splice(0, imports.length);
              if (stack2.imports.length > 0 && !(stack2.isClassDeclaration || stack2.isEnumDeclaration || stack2.isInterfaceDeclaration || stack2.isDeclaratorDeclaration || stack2.isStructTableDeclaration)) {
                stack2.imports.forEach((item3) => !item3.source.isLiteral && item3.error(1094));
              }
              this.body.push(stack2);
            } else {
              externals.push(stack2);
            }
          }
        });
      }
      set metatypes(value) {
        value.forEach((item2) => {
          item2.additional = this;
        });
        this._metatypes = value;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value) {
        value.some((annotation) => {
          annotation.additional = this;
        });
        this._annotations = value;
      }
      get annotations() {
        return this._annotations;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.id);
        super.freeze(this.body);
        this.body.forEach((stack2) => stack2.freeze());
      }
      async createCompleted() {
        await Promise.allSettled(this.body.map((item2) => item2.createCompleted()));
      }
      checkDepend(module2, depModule) {
        return depModule.extends.concat(depModule.implements).some((depModule2) => {
          if (depModule2 === module2)
            return true;
          return this.checkDepend(module2, depModule2);
        });
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.metatypes.forEach((item2) => {
          item2.parser();
        });
        this.annotations.forEach((item2) => {
          item2.parser();
        });
        this.body.forEach((item2) => {
          item2.parser();
        });
      }
    };
    module.exports = ModuleDeclaration;
  }
});

// lib/stacks/NewDefinition.js
var require_NewDefinition = __commonJS({
  "lib/stacks/NewDefinition.js"(exports, module) {
    var FunctionExpression = require_FunctionExpression();
    var NewDefinition = class extends FunctionExpression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isNewDefinition = true;
        this.module.addDescriptor("constructor", this);
        this.callable = false;
      }
    };
    module.exports = NewDefinition;
  }
});

// lib/stacks/NewExpression.js
var require_NewExpression = __commonJS({
  "lib/stacks/NewExpression.js"(exports, module) {
    var Utils2 = require_Utils();
    var Expression = require_Expression();
    var Stack = require_Stack();
    var InstanceofType = require_InstanceofType();
    var Namespace2 = require_Namespace();
    var keySymbol = Symbol("key");
    var NewExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isNewExpression = true;
        this.callee = this.createTokenStack(compilation, node.callee, scope, node, this);
        this.arguments = node.arguments.map((item2) => {
          return this.createTokenStack(compilation, item2, scope, node, this);
        });
        this.genericity = null;
        if (node.genericity) {
          this.genericity = node.genericity.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
        }
        this[keySymbol] = {};
      }
      freeze() {
        super.freeze();
        super.freeze(this.arguments);
        super.freeze(this.genericity);
        this.callee.freeze();
        this.arguments.forEach((stack2) => stack2.freeze());
        (this.genericity || []).forEach((stack2) => stack2.freeze());
      }
      definition() {
        const ctx2 = this.getContext();
        const desc2 = this.description();
        const [classModule, methodConstructor] = this.getConstructMethod(this.callee.type());
        if (methodConstructor) {
          const result = methodConstructor.definition(ctx2);
          if (desc2.isDeclaratorVariable && result.expre.startsWith("(constructor)")) {
            result.expre = `(alias ${desc2.id})${result.expre.slice(13)}`;
          }
          return result;
        }
        if (classModule && classModule.isModule) {
          const stack2 = classModule.moduleStack;
          if (stack2) {
            const typeString = classModule.toString(ctx2);
            return {
              comments: classModule.comments,
              expre: `(constructor) ${typeString}(): ${typeString}`,
              location: stack2.id.getLocation(),
              file: stack2.file
            };
          }
        }
        return null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      description() {
        let desc2 = this.callee.description();
        if (!desc2) {
          return null;
        }
        if (desc2.isDeclarator && desc2 instanceof Stack) {
          desc2 = desc2.description();
        }
        return desc2;
      }
      doGetConstructMethod(type2, assigmentGenerics) {
        let result = [];
        if (!type2 || type2.isAnyType) {
          return result;
        }
        if (type2.isClassGenericType && type2.isClassType) {
          return this.doGetConstructMethod(type2.types[0].type(), assigmentGenerics);
        } else if (type2.isClassGenericType) {
          return this.doGetConstructMethod(type2.inherit.type(), type2.types);
        } else if (Utils2.isTypeModule(type2) && (type2.isClass || type2.isInterface)) {
          this.compilation.addDependency(type2, this.module);
          result = [type2, this.getMatchDescriptor("constructor", type2), assigmentGenerics];
        } else {
          result = [type2, null, assigmentGenerics];
        }
        return result;
      }
      getConstructMethod(type2) {
        const records = this.__records || (this.__records = /* @__PURE__ */ new Map());
        if (records.has(type2)) {
          return records.get(type2);
        }
        let res = this.doGetConstructMethod(type2);
        records.set(type2, res);
        return res;
      }
      getInstanceType() {
        return this.getAttribute("NewExpression.getInstanceType", () => {
          const ctx2 = super.getContext();
          const anyType = Namespace2.globals.get("any");
          let type2 = ctx2.inferValue(this.callee.type());
          if (!type2 || type2.isAnyType)
            return anyType;
          let [classModule, method, assigns] = this.getConstructMethod(type2);
          let origin = classModule;
          if (method) {
            const result = method.getReturnedType();
            if (result) {
              const [_type, _method, _assigns] = this.getConstructMethod(result.type());
              if (_type) {
                classModule = _type.type();
              }
              if (_assigns)
                assigns = _assigns;
            }
          }
          if (this.genericity && origin === classModule) {
            assigns = this.genericity.map((item2) => item2.type());
          } else {
            if (!assigns || !assigns.length) {
              let [, declareGenerics] = this.getDeclareGenerics(classModule);
              if (declareGenerics && declareGenerics.length) {
                assigns = declareGenerics.map((decl) => ctx2.inferValue(decl.type()) || anyType);
              }
            } else {
              assigns = assigns.map((item2) => ctx2.inferValue(item2.type()) || anyType);
            }
          }
          return new InstanceofType(classModule, this, assigns || [], false);
        });
      }
      getContext() {
        const ctx2 = super.getContext();
        const type2 = this.getInstanceType();
        ctx2.make(type2);
        return ctx2;
      }
      getRawType() {
        return this.getInstanceType();
      }
      type() {
        return this.getInstanceType();
      }
      parserArguments() {
        this.arguments.forEach((item2) => {
          item2.parser();
          item2.setRefBeUsed();
        });
      }
      getFunDeclareParams() {
        const type2 = this.callee.type();
        const [classModule, methodConstructor] = this.getConstructMethod(type2);
        return methodConstructor && methodConstructor.params || [];
      }
      getDeclareGenerics(classModule, methodConstructor) {
        if (methodConstructor && (methodConstructor.isMethodDefinition || methodConstructor.isNewDefinition) && methodConstructor.genericity) {
          return [methodConstructor, methodConstructor.genericity.elements];
        }
        if (classModule.isModule && (classModule.isClass || classModule.isInterface)) {
          return classModule.getModuleDeclareGenerics(false, false, true);
        }
        return [classModule.moduleStack, []];
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.genericity && this.genericity.length > 0) {
          this.genericity.forEach((item2) => {
            item2.parser();
          });
        }
        this.callee.parser();
        this.callee.setRefBeUsed();
        const description = this.description();
        if (!description) {
          this.parserArguments();
          return true;
        }
        const type2 = this.callee.type();
        if (!type2 || type2.isAnyType) {
          this.parserArguments();
          return true;
        }
        const [classModule, methodConstructor, assigmentGenerics] = this.getConstructMethod(type2);
        if (!classModule) {
          this.callee.error(1069, this.callee.value());
          this.parserArguments();
          return true;
        }
        if (classModule.abstract) {
          this.callee.error(1070, this.callee.value());
        }
        const args = this.arguments;
        var argsLength = args.length;
        var requireCount = 0;
        var length = 0;
        var hasRest = false;
        const context = super.getContext();
        const [moduleStack, declareGenerics] = this.getDeclareGenerics(classModule, methodConstructor);
        const hasDeclareGenerics = declareGenerics && declareGenerics.length > 0;
        if (moduleStack && hasDeclareGenerics) {
          context.merge(moduleStack.getContext());
          if (classModule.isModule && classModule.isClass) {
            classModule.getStacks().forEach((stack2) => {
              if (stack2 !== moduleStack) {
                context.merge(stack2.getContext());
              }
            });
          }
        }
        if (methodConstructor) {
          const declareParams = methodConstructor.params || [];
          const declareTypeParams = declareParams;
          const requireParams = declareParams.filter((item2) => !(item2.question || item2.isAssignmentPattern || item2.isRestElement));
          length = declareParams.length;
          requireCount = requireParams.length;
          const _assigmentGenerics = this.genericity || assigmentGenerics;
          if (_assigmentGenerics && _assigmentGenerics.length > 0) {
            const lastStack = _assigmentGenerics[_assigmentGenerics.length - 1];
            if (declareGenerics.length < 1) {
              lastStack.error(1004, 0, _assigmentGenerics.length);
            }
            const requires = declareGenerics.filter((item2) => !item2.isGenericTypeAssignmentDeclaration);
            if (requires.length > _assigmentGenerics.length) {
              if (requires.length === declareGenerics.length) {
                lastStack.error(1004, requires.length, _assigmentGenerics.length);
              } else {
                lastStack.error(1005, requires.length, declareGenerics.length, _assigmentGenerics.length);
              }
            }
            _assigmentGenerics.forEach((item2, index) => {
              const declareType = declareGenerics[index] && declareGenerics[index].type();
              if (declareType) {
                context.setValue(declareType, item2);
                if (declareType.hasConstraint) {
                  const constraint = declareType.inherit.type();
                  if (!constraint.check(item2, context)) {
                    item2.error(1003, item2.type().toString(context), constraint.toString(context));
                  }
                }
              }
            });
            this.parserArguments();
          } else {
            context.extracts(declareParams, args, declareGenerics, true);
          }
          if (length > 0) {
            const checkArguments = (index, args2, declareParams2, declareTypes, top = false) => {
              let checkResult = true;
              for (; index < args2.length; index++) {
                const argument = args2[index];
                const argumentType = argument.type();
                const declareParamType = declareTypes[index];
                const declareParamItem = declareParams2[index];
                if (!(declareParamType && declareParamItem))
                  continue;
                let acceptType = declareParamType.type();
                if (this.isGenericsRelationValue(acceptType, declareGenerics, _assigmentGenerics)) {
                  continue;
                }
                if (acceptType && acceptType.isGenericType) {
                  acceptType = context.fetch(acceptType, true);
                }
                let _ctx = context;
                if (acceptType && acceptType.isClassGenericType) {
                  _ctx = context.createChild(argument);
                  _ctx.assignment(acceptType);
                }
                if (argument.isSpreadElement) {
                  if (top)
                    hasRest = true;
                  if (!argumentType.isAnyType) {
                    if (!(argumentType.isTupleType || argumentType.isLiteralArrayType || Namespace2.globals.get("array").is(argumentType))) {
                      argument.error(1154);
                      return false;
                    } else {
                      if (declareParamItem.isRestElement) {
                        checkResult = this.checkArgumentItemType(argument, declareParamItem, acceptType, _ctx);
                      } else {
                        return checkArguments(index, argumentType.elements, declareParams2, declareTypes);
                      }
                    }
                  }
                } else {
                  const isRest = acceptType && acceptType.target && acceptType.target.isTypeTupleRestDefinition;
                  if (isRest || declareParamItem.isRestElement) {
                    if (top)
                      hasRest = true;
                    let restParamType = acceptType;
                    let result = true;
                    for (; index < args2; index++) {
                      let argument2 = args2[index];
                      const res = restParamType.elements.some((declare) => {
                        const acceptType2 = declare.type();
                        if (acceptType2.isTupleType && argument2.isArrayExpression || argument2.isObjectExpression) {
                          return this.checkArgumentItemType(argument2, declare, acceptType2, _ctx);
                        } else {
                          return acceptType2.check(argument2, ctx);
                        }
                      });
                      if (!res) {
                        argument2.error(1002, argument2.type().toString(_ctx), restParamType.toString(_ctx));
                        result = false;
                      }
                    }
                    return result;
                  } else {
                    if (!this.checkArgumentItemType(argument, declareParamItem, acceptType, _ctx)) {
                      checkResult = false;
                    }
                  }
                }
              }
              return checkResult;
            };
            checkArguments(0, args, declareParams, declareTypeParams, true);
          }
        } else {
          this.parserArguments();
        }
        const insType = this.getInstanceType();
        let inherit = insType.inherit;
        let newType = context.apply(inherit);
        if (newType !== inherit) {
          insType.extends = newType;
        }
        if (!hasRest) {
          if (requireCount > 0 && argsLength < requireCount || length < argsLength) {
            this.callee.error(1e3, requireCount, argsLength);
          }
        }
      }
      value() {
        return this.callee.value();
      }
    };
    module.exports = NewExpression;
  }
});

// lib/stacks/ObjectExpression.js
var require_ObjectExpression = __commonJS({
  "lib/stacks/ObjectExpression.js"(exports, module) {
    var Expression = require_Expression();
    var LiteralObjectType = require_LiteralObjectType();
    var keySymbol = Symbol("key");
    var ObjectExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isObjectExpression = true;
        this.attributes = /* @__PURE__ */ new Map();
        this.dynamicProperties = null;
        this.properties = node.properties.map((item2) => {
          const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          if (!stack2.isSpreadElement) {
            const name = stack2.value();
            if (this.attributes.has(name)) {
              stack2.error(1045, name);
            } else {
              this.attributes.set(stack2.value(), stack2);
            }
            this.hasChildComputed = this.hasChildComputed || stack2.computed;
          }
          return stack2;
        });
        this[keySymbol] = {};
      }
      freeze() {
        super.freeze();
        super.freeze(this.properties);
        (this.properties || []).forEach((stack2) => stack2.freeze());
      }
      definition(ctx2) {
        const context = this.parentStack.isProperty && this.parentStack.parentStack.isObjectExpression ? this.parentStack : this;
        return {
          comments: context.comments,
          expre: this.type().toString(ctx2 || this.getContext()),
          location: context.getLocation(),
          file: context.compilation.file
        };
      }
      attribute(name, value) {
        if (value !== void 0) {
          this.attributes.set(name, value);
          return value;
        }
        return this.attributes.get(name) || null;
      }
      hasAttribute(name) {
        return this.attributes.has(name);
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      description() {
        return this;
      }
      type() {
        return this[keySymbol]._type || (this[keySymbol]._type = new LiteralObjectType(this.getGlobalTypeById("object"), this));
      }
      parser() {
        if (super.parser() === false)
          return false;
        let cache = {};
        this.properties.forEach((item2) => {
          item2.parser();
          if (item2.isSpreadElement) {
            const propertyType = item2.type();
            if (propertyType && !propertyType.isAnyType) {
              if (propertyType.isLiteralObjectType) {
                const attributes = propertyType.attributes;
                const dynamicProperties = propertyType.dynamicProperties;
                if (attributes) {
                  attributes.forEach((value, key) => {
                    const property = cache[key];
                    let result = true;
                    if (property) {
                      result = this.checkExpressionType(property.type(), value, item2);
                    }
                    if (result)
                      this.attributes.set(key, value);
                  });
                }
                if (dynamicProperties) {
                  if (!this.dynamicProperties) {
                    this.dynamicProperties = /* @__PURE__ */ new Map();
                  }
                  dynamicProperties.forEach((value, key) => {
                    const property = this.dynamicProperties.get(key);
                    let result = true;
                    if (property) {
                      result = this.checkExpressionType(property.type(), value, item2);
                    }
                    if (result)
                      this.dynamicProperties.set(key, value);
                  });
                }
              }
            }
          } else {
            cache[item2.value()] = item2;
          }
        });
      }
      value() {
        return `{${this.properties.map((item2) => item2.value()).join(", ")}}`;
      }
    };
    module.exports = ObjectExpression;
  }
});

// lib/stacks/ObjectPattern.js
var require_ObjectPattern = __commonJS({
  "lib/stacks/ObjectPattern.js"(exports, module) {
    var Stack = require_Stack();
    var LiteralObjectType = require_LiteralObjectType();
    var ObjectPattern = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isObjectPattern = true;
        this.properties = node.properties.map((item2) => {
          const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          if (stack2.isProperty) {
            if (!stack2.hasAssignmentPattern) {
              const context = parentStack.parentStack.kind === "var" ? "function" : "block";
              const name = stack2.init.value();
              if (this.parentStack.isVariableDeclarator || this.parentStack.isFunctionExpression) {
                if (scope.isDefine(name, context)) {
                  this.error(1007, name);
                }
                scope.define(name, stack2.init);
              }
            }
          }
          return stack2;
        });
        if (node.acceptType) {
          this.acceptType = this.createTokenStack(compilation, node.acceptType, scope, node, this);
        }
      }
      freeze() {
        super.freeze();
        super.freeze(this.properties);
        (this.properties || []).forEach((stack2) => stack2.freeze());
      }
      definition() {
        return null;
      }
      setKind(value) {
        this.properties.forEach((item2) => {
          item2.kind = value;
        });
      }
      attribute(name, value) {
        if (value !== void 0) {
          return value;
        }
        return this.properties.find((property) => property.key.value() === name);
      }
      hasAttribute(name) {
        return this.properties.some((property) => property.key.value() === name);
      }
      type() {
        if (this.acceptType) {
          return this.acceptType.type();
        } else {
          return this.getAttribute("type", () => {
            return new LiteralObjectType(this.getGlobalTypeById("object"), this);
          });
        }
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.acceptType) {
          this.acceptType.parser();
        }
        if (this.parentStack.isVariableDeclarator) {
          const init = this.parentStack.init;
          if (init) {
            const type2 = init.type();
            const base = this.getGlobalTypeById("Object");
            if (base && !base.check(type2) || type2.isNullableType) {
              init.error(1074, init.raw());
            }
          } else {
            this.error(1081);
          }
        } else if (this.parentStack.isFunctionExpression) {
          if (this.parentStack.parentStack.isCallExpression || this.parentStack.parentStack.isNewExpression) {
            const call = this.parentStack.parentStack;
            const declareParams = call.isCallExpression ? call.getFunDeclareParams(call.getDeclareFunctionType(call.description())) : call.getFunDeclareParams();
            const index = call.arguments.indexOf(this.parentStack);
            if (declareParams[index]) {
              const type2 = declareParams[index].type();
              const base = this.getGlobalTypeById("Object");
              if (base && !base.check(type2) || type2.isNullableType) {
                this.properties.forEach((item2) => item2.key.error(1074, item2.key.value()));
              }
            } else {
              this.properties.forEach((item2) => item2.key.error(1081, item2.key.value()));
            }
          }
        }
        this.properties.forEach((item2) => item2.parser());
      }
      value() {
        return this.properties.map((item2) => {
          return item2.value();
        }).join(",");
      }
    };
    module.exports = ObjectPattern;
  }
});

// lib/stacks/PackageDeclaration.js
var require_PackageDeclaration = __commonJS({
  "lib/stacks/PackageDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var Namespace2 = require_Namespace();
    var PackageDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isPackageDeclaration = true;
        this._metatypes = [];
        this._annotations = [];
        this.id = this.createTokenStack(compilation, node.id, scope, node, this);
        this.namespace = compilation.namespace = Namespace2.create(this.id ? this.id.value() : null);
        this.namespace.stack = this;
        const metatypes = [];
        const annotations = [];
        const imports = [];
        this.body = [];
        const externals = parentStack.externals || [];
        const exports2 = parentStack.exports || [];
        node.body.forEach((item2, index) => {
          const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          if (stack2.isMetatypeDeclaration) {
            metatypes.push(stack2);
            this.body.push(stack2);
          } else if (stack2.isAnnotationDeclaration) {
            const annotationStack = this.interceptAnnotation(stack2);
            if (annotationStack) {
              annotations.push(annotationStack);
            }
            this.body.push(stack2);
          } else if (stack2.isImportDeclaration) {
            imports.push(stack2);
            this.body.push(stack2);
          } else if (stack2.isExportAllDeclaration || stack2.isExportDefaultDeclaration || stack2.isExportNamedDeclaration) {
            exports2.push(stack2);
            this.body.push(stack2);
          } else {
            stack2.metatypes = metatypes.splice(0, metatypes.length);
            stack2.annotations = annotations.splice(0, annotations.length);
            if (stack2.isClassDeclaration || stack2.isEnumDeclaration || stack2.isInterfaceDeclaration || stack2.isStructTableDeclaration || stack2.isDeclaratorDeclaration || stack2.isDeclaratorVariable || stack2.isDeclaratorFunction || stack2.isTypeStatement || stack2.isDeclaratorTypeAlias) {
              stack2.imports = imports.splice(0, imports.length);
              if (stack2.imports.length > 0 && !(stack2.isClassDeclaration || stack2.isEnumDeclaration || stack2.isInterfaceDeclaration || stack2.isDeclaratorDeclaration || stack2.isStructTableDeclaration)) {
                stack2.imports.forEach((item3) => !item3.source.isLiteral && item3.error(1094));
              }
              this.body.push(stack2);
            } else {
              externals.push(stack2);
            }
          }
        });
        if (imports.length > 0) {
          parentStack.imports.push(...imports);
        }
      }
      set metatypes(value) {
        value.forEach((item2) => {
          item2.additional = this;
        });
        this._metatypes = value;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value) {
        value.some((annotation) => {
          annotation.additional = this;
        });
        this._annotations = value;
      }
      get annotations() {
        return this._annotations;
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.id);
        super.freeze(this.body);
        this.body.forEach((stack2) => stack2.freeze());
      }
      async createCompleted() {
        await Promise.allSettled(this.body.map((item2) => item2.createCompleted()));
      }
      checkDepend(module2, depModule) {
        return depModule.extends.concat(depModule.implements).some((depModule2) => {
          if (depModule2 === module2)
            return true;
          return this.checkDepend(module2, depModule2);
        });
      }
      definition() {
        return {
          comments: this.comments,
          expre: `(namesapce) ${this.id.value()}`
        };
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.metatypes.forEach((item2) => {
          item2.parser();
        });
        this.annotations.forEach((item2) => {
          item2.parser();
        });
        this.body.forEach((item2) => {
          item2.parser();
        });
      }
    };
    module.exports = PackageDeclaration;
  }
});

// lib/stacks/ParenthesizedExpression.js
var require_ParenthesizedExpression = __commonJS({
  "lib/stacks/ParenthesizedExpression.js"(exports, module) {
    var Stack = require_Stack();
    var ParenthesizedExpression = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isParenthesizedExpression = true;
        this.expression = this.createTokenStack(compilation, node.expression, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.expression.freeze();
      }
      definition(context) {
        return this.expression.definition(context);
      }
      reference() {
        return this.expression.reference();
      }
      referenceItems() {
        return this.expression.referenceItems();
      }
      type() {
        return this.expression.type();
      }
      description() {
        return this.expression.description();
      }
      getContext() {
        return this.expression.getContext();
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (!this.expression) {
          this.error(1079);
        } else {
          this.expression.parser();
          this.expression.setRefBeUsed();
        }
      }
      value() {
        return this.expression.value();
      }
      raw() {
        return this.expression.raw();
      }
    };
    module.exports = ParenthesizedExpression;
  }
});

// lib/stacks/Program.js
var require_Program = __commonJS({
  "lib/stacks/Program.js"(exports, module) {
    var Stack = require_Stack();
    var ClassScope = require_ClassScope();
    var Namespace2 = require_Namespace();
    var Program = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isProgram = true;
        this.externals = [];
        this.exports = [];
        this.imports = [];
        this.annotations = [];
        this.metatypes = [];
        this.scripts = [];
        this.body = [];
        this.isJSXProgram = false;
        const first = node.body[0];
        if (first && first.type === "ExpressionStatement" && first.expression.type === "JSXElement") {
          this.compilation.JSX = true;
          this.isJSXProgram = true;
          this.createJsx(node.body);
        } else {
          this.create(node.body);
        }
      }
      createJsx(body) {
        const originId = this.compilation.originId;
        const segments = originId ? originId.split(".") : null;
        let className = null;
        if (segments) {
          className = segments.pop();
          this.namespace = Namespace2.create(segments.join("."));
        } else {
          className = this.compiler.getFileClassName(this.file);
          this.namespace = Namespace2.create(this.compiler.getFileNamespace(this.file));
        }
        this.module = this.compilation.createModule(this.namespace, className);
        this.module.isClass = true;
        this.module.isLocalModule = true;
        this.module.jsxDeclaredSlots = /* @__PURE__ */ new Map();
        this.scope = new ClassScope(this.scope);
        this.compilation.addModuleStack(this.module, this);
        body.forEach((item2) => {
          if (item2.type === "ExpressionStatement") {
            const stack2 = this.createTokenStack(this.compilation, item2.expression, this.scope, this.node, this);
            if (stack2 && stack2.jsxElement) {
              this.body.push(stack2);
            }
          } else {
            this.compilation.error(item2, 1110);
          }
        });
        if (this.body.length != 1) {
          this.error(1123);
        }
      }
      create(body) {
        const annotations = [];
        const metatypes = [];
        const imports = [];
        const importExternals = [];
        body.forEach((item2) => {
          const stack2 = this.createTokenStack(this.compilation, item2, this.scope, this.node, this);
          if (stack2) {
            if (stack2.isMetatypeDeclaration) {
              metatypes.push(stack2);
              this.body.push(stack2);
            } else if (stack2.isAnnotationDeclaration) {
              const annotationStack = this.interceptAnnotation(stack2);
              if (annotationStack) {
                annotations.push(annotationStack);
              }
              this.body.push(stack2);
            } else if (stack2.isImportDeclaration) {
              imports.push(stack2);
              this.body.push(stack2);
            } else if (stack2.isExportAllDeclaration || stack2.isExportDefaultDeclaration || stack2.isExportNamedDeclaration) {
              this.exports.push(stack2);
              this.body.push(stack2);
            } else if (stack2.isPackageDeclaration || stack2.isClassDeclaration || stack2.isDeclaratorDeclaration || stack2.isEnumDeclaration || stack2.isInterfaceDeclaration || stack2.isStructTableDeclaration || stack2.isDeclaratorVariable || stack2.isDeclaratorFunction || stack2.isTypeStatement || stack2.isDeclaratorTypeAlias) {
              stack2.annotations = annotations.splice(0, annotations.length);
              stack2.metatypes = metatypes.splice(0, metatypes.length);
              stack2.imports = imports.splice(0, imports.length);
              if (stack2.imports.length > 0 && !(stack2.isClassDeclaration || stack2.isEnumDeclaration || stack2.isInterfaceDeclaration || stack2.isDeclaratorDeclaration || stack2.isStructTableDeclaration)) {
                stack2.imports.forEach((item3) => !item3.source.isLiteral && item3.error(1094));
              }
              this.body.push(stack2);
            } else {
              const imps = imports.splice(0, imports.length);
              importExternals.push(...imps);
              this.externals.push(stack2);
            }
          }
        });
        if (importExternals.length > 0) {
          this.externals.unshift(...importExternals);
        }
        if (imports.length > 0) {
          this.imports.push(...imports.splice(0, imports.length));
        }
        this.annotations = annotations.splice(0, annotations.length);
        this.annotations.forEach((item2) => {
          item2.additional = this;
        });
        this.metatypes = metatypes.splice(0, metatypes.length);
        this.metatypes.forEach((item2) => {
          item2.additional = this;
        });
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.scope);
        super.freeze(this.body);
        this.body.forEach((stack2) => stack2.freeze());
        this.externals.forEach((stack2) => stack2.freeze());
      }
      async createCompleted() {
        if (this._createCompletedFlag)
          return;
        this._createCompletedFlag = true;
        await this.allSettled(this.body, async (stack2) => await stack2.createCompleted());
        const asyncImports = [];
        this.imports.map((stack2) => {
          if (stack2.isImportDeclaration) {
            asyncImports.push(stack2.addImport());
          }
        });
        this.externals.forEach((stack2) => {
          if (stack2.isImportDeclaration) {
            asyncImports.push(stack2.addImport());
          }
        });
        await this.allSettled(asyncImports, async (promise) => await promise);
      }
      async parserAsync() {
        if (this.parser() === false)
          return false;
        this.metatypes.forEach((item2) => {
          item2.parser();
        });
        this.annotations.forEach((item2) => {
          item2.parser();
        });
        if (this.exports.length > 0 && this.compilation.modules.size > 0) {
          this.exports.forEach((item2) => item2.warn(1160));
        }
        this.imports.forEach((item2) => {
          item2.parser();
        });
        await Promise.allSettled(this.body.map(async (item2) => {
          try {
            if (item2.isAnnotationDeclaration) {
              const name = item2.name.toLowerCase();
              if (name === "reference") {
                return await item2.parserAsync();
              }
            }
            item2.parser();
          } catch (e) {
            console.error(e);
          }
        }));
        this.externals.forEach((item2) => {
          item2.parser();
        });
        this.exports.forEach((item2) => {
          item2.parser();
        });
      }
    };
    module.exports = Program;
  }
});

// lib/stacks/Property.js
var require_Property = __commonJS({
  "lib/stacks/Property.js"(exports, module) {
    var Stack = require_Stack();
    var AliasType = require_AliasType();
    var Declarator = require_Declarator();
    var Property = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isProperty = true;
        this.hasAssignmentPattern = false;
        this.assignValue = null;
        this._assignItems = /* @__PURE__ */ new Set();
        this.isParamDeclarator = false;
        this.hasInit = node.value && node.key !== node.value;
        if (node && parentStack) {
          this.key = this.createTokenStack(compilation, node.key, scope, node, this);
          if (parentStack.isObjectPattern) {
            if (node.value.type == "Identifier") {
              this.init = new Declarator(compilation, node.value, scope, node, this);
            } else {
              this.init = this.createTokenStack(compilation, node.value, scope, node, this);
            }
          } else {
            this.init = this.createTokenStack(compilation, node.value, scope, node, this);
            this.assignValue = this.init;
            this._assignItems.add(this.init);
          }
          if (this.init.isAssignmentPattern) {
            this.hasAssignmentPattern = true;
          }
          this._kind = node.kind;
          this.computed = !!node.computed;
          if (parentStack.isObjectPattern && parentStack && parentStack.parentStack) {
            const p = parentStack.parentStack;
            if (p.isFunctionExpression || p.isTypeFunctionDefinition) {
              this.isParamDeclarator = true;
            }
          }
        }
      }
      get acceptType() {
        const parent = this.parentStack;
        if (parent && parent.isObjectPattern) {
          if (parent.acceptType && parent.acceptType.isTypeObjectDefinition) {
            return parent.acceptType.attribute(this.value()) || null;
          }
        }
        return null;
      }
      freeze() {
        super.freeze();
        this.key && this.key.freeze();
        this.init && this.init.freeze();
        this.acceptType && this.acceptType.freeze();
      }
      definition(ctx2) {
        if (this.parentStack.isObjectPattern) {
          const desc2 = this.getObjectPatternDescription();
          if (desc2) {
            return desc2.definition(ctx2 || this.getContext());
          } else {
            const type3 = this.type().toString();
            return {
              expre: `(property) ${this.value()}: ${type3}`
            };
          }
        }
        const relate = this.getRelateDescription();
        const identifier = this.value();
        const type2 = this.type().toString();
        let location = this.key.getLocation();
        let comments = this.comments;
        let file = this.compilation.file;
        if (relate && relate.isStack) {
          location = relate.key.getLocation();
          comments = relate.comments;
          file = relate.compilation.file;
        }
        return {
          comments,
          expre: `(property) ${identifier}: ${type2}`,
          location,
          file
        };
      }
      set kind(value) {
        if (this.hasAssignmentPattern) {
          this.init.kind = value;
        } else {
          this._kind = value;
        }
      }
      get kind() {
        if (this.hasAssignmentPattern) {
          return this.init.kind;
        } else {
          return this._kind;
        }
      }
      value() {
        return this.key.value();
      }
      reference() {
        const desc2 = this.getObjectPatternDescription();
        if (desc2) {
          return desc2.reference();
        }
        if (this.hasAssignmentPattern) {
          return this.init.reference();
        }
        return this.assignValue ? this.assignValue.reference() : null;
      }
      referenceItems() {
        if (this.hasAssignmentPattern) {
          return this.init.referenceItems();
        }
        let items = [];
        this.assignItems.forEach((item2) => {
          items = items.concat(item2.referenceItems());
        });
        return items;
      }
      get assignItems() {
        if (this.hasAssignmentPattern) {
          return this.init.assignItems;
        }
        return this._assignItems;
      }
      assignment(value, stack2) {
        if (this.parentStack.isObjectPattern) {
          this.init.assignment(value, stack2);
        } else if (this.assignValue !== value) {
          const first = this.assignValue;
          let acceptType = this.acceptType;
          let isNull = false;
          if (!acceptType && first) {
            const _type = first.type();
            if (_type) {
              isNull = _type.isNullableType || _type.isVoidType;
              if (!isNull) {
                acceptType = _type;
              }
            }
          }
          if (acceptType) {
            this.checkExpressionType(acceptType, value, stack2);
          }
          if (!first || isNull) {
            this.assignValue = value;
          }
          this._assignItems.add(value);
          if (value && value.isStack) {
            this.setRefBeUsed(value.description());
          }
        }
      }
      type() {
        const acceptType = this.acceptType;
        if (acceptType) {
          return acceptType.type();
        }
        const desc2 = this.getObjectPatternDescription();
        if (desc2) {
          const declare = this.parentStack.parentStack;
          if (declare && declare.isVariableDeclarator && declare.init) {
            const ctx2 = declare.init.getContext();
            return ctx2.apply(desc2.type());
          } else if (declare && declare.isFunctionExpression && (declare.parentStack.isCallExpression || declare.parentStack.isNewExpression)) {
            const ctx2 = declare.parentStack.getContext();
            return ctx2.apply(desc2.type());
          }
          return desc2.type();
        }
        if (this.assignValue) {
          if (this.parentStack.isObjectExpression && this.parentStack.parentStack.isVariableDeclarator) {
            if (this.parentStack.parentStack === this.assignValue.description()) {
              return new AliasType(this.parentStack.parentStack.type(), this.parentStack.parentStack.acceptType || this.parentStack.parentStack);
            }
          }
          return this.assignValue.type();
        }
        return this.getGlobalTypeById("any");
      }
      getObjectPatternDescription() {
        if (this.parentStack.isObjectPattern) {
          const argument = this.parentStack.parentStack;
          if (argument && argument.isVariableDeclarator && argument.init) {
            const object = argument.init.type();
            if (object) {
              return argument.init.getObjectDescriptor(object, this.key.value());
            }
          } else if (argument && argument.isFunctionExpression) {
            const exp = argument.parentStack;
            if (exp.isCallExpression || exp.isNewExpression) {
              let declareParams = [];
              if (exp.isCallExpression) {
                const description = exp.getDeclareFunctionType(exp.description());
                declareParams = exp.getFunDeclareParams(description);
              } else {
                declareParams = exp.getFunDeclareParams();
              }
              const pos = argument.params.indexOf(this.parentStack);
              const index = exp.arguments.indexOf(argument);
              if (declareParams[index]) {
                const fun = declareParams[index].type();
                if (fun.isFunctionType && fun.params[pos]) {
                  const object = fun.params[pos].type();
                  return exp.getObjectDescriptor(object, this.key.value());
                }
              }
            } else if (exp.isAssignmentExpression) {
              const fun = exp.left.type();
              const pos = argument.params.indexOf(this.parentStack);
              if (fun.isFunctionType && fun.params[pos]) {
                const object = fun.params[pos].type();
                return exp.left.getObjectDescriptor(object, this.key.value());
              }
            }
          }
        }
        return null;
      }
      getRelateDescription() {
        let parent = this.parentStack;
        let properties = [this];
        let argument = null;
        while (parent && parent.isObjectExpression) {
          argument = parent;
          parent = parent.parentStack;
          if (parent && parent.isProperty) {
            properties.push(parent);
            parent = parent.parentStack;
          }
        }
        if (parent && (parent.isCallExpression || parent.isNewExpression)) {
          const index = parent.arguments.indexOf(argument);
          if (index >= 0) {
            let declareParams = [];
            if (parent.isCallExpression) {
              const description = parent.getDeclareFunctionType(parent.description());
              declareParams = parent.getFunDeclareParams(description);
            } else {
              declareParams = parent.getFunDeclareParams();
            }
            const declare = declareParams[index];
            if (declare) {
              let desc2 = declare.type();
              while (desc2 && properties.length > 0) {
                desc2 = parent.getObjectDescriptorForAuxiliary(desc2, properties.pop().value());
                if (desc2 && properties.length > 0) {
                  desc2 = desc2.type();
                }
              }
              return desc2;
            }
          }
        }
        return null;
      }
      description() {
        return this;
      }
      getContext() {
        if (this.parentStack.isObjectPattern) {
          const declare = this.parentStack.parentStack;
          if (declare && declare.isVariableDeclarator && declare.init) {
            return declare.init.getContext().createChild(this);
          } else if (this.hasAssignmentPattern) {
            return this.init.right.getContext().createChild(this);
          } else {
            return super.getContext();
          }
        }
        let init = this.init;
        if (init && init.isStack && init instanceof Stack) {
          if (!(init.isFunctionExpression || init.isArrayExpression || init.isObjectExpression)) {
            return init.getContext().createChild(this);
          }
        }
        return this.parentStack.getContext().createChild(this);
      }
      parser() {
        if (super.parser() === false)
          return false;
        const acceptType = this.acceptType;
        if (acceptType) {
          acceptType.parser();
          this.getContext().make(acceptType.type());
        }
        if (this.init) {
          this.init.parser();
          this.init.setRefBeUsed();
        }
        if (this.kind === "dynamic") {
          return true;
        }
        const name = this.value();
        if (!this.parentStack.isObjectPattern) {
          if (this.computed) {
            const refs = this.scope.define(name);
            if (this.key.isIdentifier && !refs) {
              this.error(1013, name);
            } else {
              this.setRefBeUsed(refs);
            }
          }
          return true;
        }
        ;
        if (this.parentStack.parentStack.isFunctionExpression) {
          const argument = this.parentStack.parentStack;
          const exp = argument.parentStack;
          if (exp.isCallExpression || exp.isNewExpression || exp.isAssignmentExpression) {
            const desc2 = this.getObjectPatternDescription();
            if (!desc2) {
              this.error(1080, name);
            }
          }
          return true;
        } else if (this.parentStack.parentStack.isVariableDeclarator) {
          const desc2 = this.scope.define(name);
          const target = this.parentStack.parentStack.init;
          if (!target)
            return true;
          if (target.isObjectExpression || target.isArrayExpression) {
            const init = target.attribute(name);
            if (!init) {
              this.error(1080, name);
            }
            desc2 && desc2.assignment(init, this.key);
          } else {
            let type2 = target.type();
            if (!type2 || type2.isAnyType) {
              return true;
            }
            if (type2.isLiteralObjectType || type2.isLiteralArrayType || type2.isGenericType) {
              const propertyValue = type2.attribute(name);
              if (!propertyValue) {
              } else {
                desc2 && desc2.assignment(propertyValue, this.key);
              }
            } else if (type2.isModule) {
              const desc3 = target.getObjectDescriptor(type2, name);
              if (!desc3) {
                this.error(1080, name);
              }
            }
          }
        }
      }
      raw() {
        if (this.hasAssignmentPattern) {
          return this.init.raw();
        }
        return super.raw();
      }
      error(code, ...args) {
        this.key.error(code, ...args);
      }
      warn(code, ...args) {
        this.key.warn(code, ...args);
      }
    };
    module.exports = Property;
  }
});

// lib/stacks/PropertyDefinition.js
var require_PropertyDefinition = __commonJS({
  "lib/stacks/PropertyDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var Utils2 = require_Utils();
    var PropertyDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isPropertyDefinition = true;
        this._metatypes = [];
        this._annotations = [];
        this.kind = node.kind;
        this.isReadonly = this.kind === "const";
        this.modifier = this.createTokenStack(compilation, node.modifier, scope, node, this);
        this.static = this.createTokenStack(compilation, node.static, scope, node, this);
        this.declarations = node.declarations.map((item2) => {
          return this.createTokenStack(compilation, item2, scope, node, this);
        });
        this.isFinal = false;
        this.isRemoved = false;
        this.isDeprecated = false;
        this.isNoop = false;
        if (this.declarations[0].dynamic) {
          this.module.dynamic = true;
        } else {
          if (!this.parentStack.isUseStatement) {
            this.module.addMember(this.declarations[0].id.value(), this);
          }
        }
      }
      freeze() {
        super.freeze();
        super.freeze(this.declarations);
        this.modifier && this.modifier.freeze();
        this.static && this.static.freeze();
        this.declarations.forEach((stack2) => stack2.freeze());
      }
      definition(ctx2) {
        const identifier = this.value();
        const context = this;
        const modifier = this.modifier ? this.modifier.value() : "public";
        const _static = this.static ? "static " : "";
        const def = this.declarations[0].definition(ctx2);
        return {
          kind: "property",
          comments: context.comments,
          identifier,
          expre: `(property) ${_static}${modifier} ${def.expre}`,
          location: this.declarations[0].getLocation(),
          file: this.compilation.file
        };
      }
      set metatypes(value) {
        value.forEach((metatype) => {
          metatype.additional = this;
        });
        this._metatypes = value;
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value) {
        value.forEach((annotation) => {
          annotation.additional = this;
          switch (annotation.name.toLowerCase()) {
            case "override":
              this.override = true;
              break;
            case "final":
              this.isFinal = true;
              break;
            case "deprecated":
              this.isDeprecated = true;
              break;
            case "removed":
              this.isRemoved = true;
            case "noop":
              this.isNoop = true;
              break;
          }
        });
        this._annotations = value;
      }
      get annotations() {
        return this._annotations;
      }
      get init() {
        return this.declarations[0].init;
      }
      get dynamic() {
        return !!this.declarations[0].dynamic;
      }
      get question() {
        return !!this.declarations[0].question;
      }
      get id() {
        return this.declarations[0].id;
      }
      get key() {
        return this.declarations[0].id;
      }
      get acceptType() {
        return this.declarations[0].acceptType;
      }
      get dynamicKeyType() {
        return this.declarations[0].dynamicKeyType;
      }
      get assignItems() {
        return this.declarations[0].assignItems;
      }
      get useRefItems() {
        return this.declarations[0].useRefItems;
      }
      addUseRef(stack2) {
        this.declarations[0].addUseRef(stack2);
      }
      assignment(value, stack2 = null) {
        this.declarations[0].assignment(value, stack2);
      }
      reference() {
        return this.declarations[0].reference();
      }
      referenceItems() {
        return this.declarations[0].referenceItems();
      }
      description() {
        return this.declarations[0].description();
      }
      type() {
        return this.declarations[0].type();
      }
      parser() {
        if (super.parser() === false)
          return false;
        this._annotations.forEach((item2) => item2.parser());
        this._metatypes.forEach((item2) => item2.parser());
        this.declarations[0].parser();
        if (this.parentStack.isUseStatement) {
          return true;
        }
        if (this.dynamic) {
          const acceptType = this.dynamicKeyType ? this.dynamicKeyType.type() : this.getGlobalTypeById("string");
          const result = acceptType && ["string", "number"].some((type2) => acceptType.check(this.getGlobalTypeById(type2)));
          if (!result) {
            this.acceptType.error(1139, this.id.value());
          } else {
            this.module.dynamicProperties.set(Utils2.getOriginType(acceptType), this);
          }
        } else if (this.module && !this.module.isDeclaratorModule) {
          const parent = this.module && this.module.extends[0];
          if (parent) {
            const modifier = Utils2.getModifierValue(this);
            if (modifier !== "private") {
              const parentProperty = parent.getMember(this.id.value());
              if (parentProperty && Utils2.getModifierValue(parentProperty) !== "private") {
                if (!parentProperty.isPropertyDefinition) {
                  this.id.error(1082, this.value());
                }
              }
              if (parentProperty && parentProperty.isFinal) {
                this.id.error(1149, this.id.value());
              }
            }
          }
        }
      }
      error(code, ...args) {
        this.declarations[0].error(code, ...args);
      }
      warn(code, ...args) {
        this.declarations[0].warn(code, ...args);
      }
      value() {
        return this.declarations[0].value();
      }
      raw() {
        return this.declarations[0].raw();
      }
    };
    module.exports = PropertyDefinition;
  }
});

// lib/stacks/RestElement.js
var require_RestElement = __commonJS({
  "lib/stacks/RestElement.js"(exports, module) {
    var Declarator = require_Declarator();
    var TupleType = require_TupleType();
    var MergeType = require_MergeType();
    var LiteralObjectType = require_LiteralObjectType();
    var Namespace2 = require_Namespace();
    var RestElement = class extends Declarator {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node.argument, scope, parentNode, parentStack);
        this.isRestElement = true;
        scope.define(this.value(), this);
      }
      definition(ctx2) {
        const type2 = this.type().toString(ctx2);
        const identifier = this.value();
        const context = this;
        let kind = this.parentStack.isFunctionExpression || this.parentStack.isTypeFunctionDefinition ? "(parameter)" : this.kind;
        if (this.parentStack.isObjectPattern && this.parentStack.parentStack.isVariableDeclarator) {
          kind = `(local ${kind})`;
        }
        return {
          kind,
          comments: context.comments,
          identifier,
          expre: `${kind} ...${identifier}:${type2}`,
          location: this.getLocation(),
          file: this.compilation.file,
          context
        };
      }
      type() {
        return this.getAttribute("type", () => {
          let type2 = Namespace2.globals.get("any");
          if (this.parentStack.isObjectPattern) {
            const pStack = this.parentStack.parentStack;
            if (pStack && pStack.isVariableDeclarator && pStack.init) {
              const _type = pStack.init.type();
              if (_type) {
                const patternProperties = this.parentStack.properties.filter((item2) => {
                  return !item2.isRestElement;
                });
                if (patternProperties.length === 0) {
                  type2 = _type;
                } else {
                  if (_type.isLiteralObjectType) {
                    const properties = new Map(_type.properties);
                    patternProperties.forEach((property) => {
                      if (property.isProperty) {
                        properties.delete(property.key.value());
                      }
                    });
                    type2 = new LiteralObjectType(_type.inherit, _type.target, properties, _type.dynamicProperties, _type.questionProperties);
                  } else if (_type.isInstanceofType) {
                    type2 = _type;
                  }
                }
              }
            }
          } else {
            type2 = this.acceptType ? this.acceptType.type() : type2;
            if (!type2.isTupleType) {
              type2 = new TupleType(Namespace2.globals.get("Array"), type2, this, true);
            } else {
              type2.rest = true;
            }
          }
          return type2;
        });
      }
      getItemType() {
        return this.getAttribute("item-type", () => {
          return MergeType.forOfItem(this.type());
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.acceptType) {
          this.acceptType.parser();
          this.acceptType.setRefBeUsed();
          const type2 = this.acceptType.type();
          if (!type2.isTupleType) {
            this.error(1071);
          }
        }
      }
    };
    module.exports = RestElement;
  }
});

// lib/stacks/ReturnStatement.js
var require_ReturnStatement = __commonJS({
  "lib/stacks/ReturnStatement.js"(exports, module) {
    var Stack = require_Stack();
    var Utils2 = require_Utils();
    var keySymbol = Symbol("key");
    var ReturnStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isReturnStatement = true;
        this.hasReturnStatement = true;
        this.argument = this.createTokenStack(compilation, node.argument, scope, node, this);
        const fnScope = scope.getScopeByType("function");
        this.returnIndex = fnScope.returnItems.length;
        if (this.argument) {
          fnScope.returnItems.push(this);
        }
        this[keySymbol] = {};
        this.fnScope = fnScope;
        if (parentStack) {
          let statement = parentStack.isBlockStatement ? parentStack.parentStack : parentStack;
          if (statement) {
            if (statement.isIfStatement) {
              parentStack.hasReturnStatement = true;
            } else if (statement.isSwitchCase) {
              statement.hasReturnStatement = true;
            }
          }
        }
      }
      freeze() {
        super.freeze();
        this.argument && this.argument.freeze();
      }
      definition() {
        return null;
      }
      reference() {
        if (this.argument) {
          return this.argument.reference();
        }
        return null;
      }
      referenceItems() {
        return this.argument ? this.argument.referenceItems() : [];
      }
      description() {
        if (this.argument) {
          return this.argument.description();
        }
        return null;
      }
      type() {
        if (!this.argument) {
          return this.getGlobalTypeById("void");
        }
        return this.argument.type();
      }
      getParentFunction() {
        return this.getAttribute("ReturnStatement.getParentFunction", () => {
          let parent = this.getParentStack((parent2) => {
            return !!parent2.isFunctionExpression;
          });
          if (parent && (parent.isFunctionExpression || parent.isMethodDefinition)) {
            return parent;
          }
          return null;
        });
      }
      getContext() {
        let parent = this.getParentFunction();
        if (parent) {
          return parent.getContext();
        }
        return super.getContext();
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.argument) {
          this.argument.parser();
          this.argument.setRefBeUsed();
          let parent = this.getParentFunction();
          if (!parent || !parent.isFunctionExpression) {
            return this.error(1072);
          }
          if (parent.async) {
            let returnType = parent.getReturnedType();
            const origin = Utils2.getOriginType(returnType);
            const PromiseType = this.getGlobalTypeById("Promise");
            if (origin && PromiseType && PromiseType.is(origin)) {
              let acceptType = null;
              if (returnType.isInstanceofType && returnType.generics[0]) {
                acceptType = returnType.generics[0].type();
              } else if (returnType.isClassGenericType && returnType.types[0]) {
                acceptType = returnType.types[0].type();
              }
              if (acceptType) {
                this.checkExpressionType(acceptType, this.argument);
                return true;
              }
            }
          }
          if (this.argument) {
            const rType = this.argument.type();
            if (rType && rType.isNullableType) {
              return true;
            }
            let returnType = parent && parent.returnType;
            if (returnType) {
              let declareGenerics = parent.genericity ? parent.genericity.elements : [];
              let assigments = [];
              if (parent.parentStack && parent.parentStack.isCallExpression) {
                assigments = parent.parentStack.genericity || assigments;
                const [_declareGenerics, _classGenerics] = parent.parentStack.getDeclareGenerics(parent.parentStack.description());
                declareGenerics = _declareGenerics;
              }
              if (!this.isGenericsRelationValue(returnType, declareGenerics, assigments)) {
                this.checkExpressionType(returnType, this.argument);
              }
            }
          }
        }
      }
      value() {
        return this.argument ? this.argument.value() : "";
      }
      raw() {
        return this.argument ? this.argument.raw() : "";
      }
    };
    module.exports = ReturnStatement;
  }
});

// lib/stacks/SequenceExpression.js
var require_SequenceExpression = __commonJS({
  "lib/stacks/SequenceExpression.js"(exports, module) {
    var Expression = require_Expression();
    var SequenceExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isSequenceExpression = true;
        this.expressions = node.expressions.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
      }
      freeze() {
        super.freeze();
        super.freeze(this.expressions);
        (this.expressions || []).forEach((stack2) => stack2.freeze());
      }
      definition() {
        return null;
      }
      description() {
        return this.expressions.length > 0 ? this.expressions[this.expressions.length - 1] : this;
      }
      reference() {
        const description = this.description();
        return description !== this ? description.reference() : this;
      }
      referenceItems() {
        const description = this.description();
        return description !== this ? description.referenceItems() : [this];
      }
      type(ctx2) {
        return this.expressions.length > 0 && this.expressions[this.expressions.length - 1].type(ctx2);
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.expressions.forEach((item2) => {
          item2.parser();
          item2.setRefBeUsed();
        });
      }
    };
    module.exports = SequenceExpression;
  }
});

// lib/stacks/SpreadElement.js
var require_SpreadElement = __commonJS({
  "lib/stacks/SpreadElement.js"(exports, module) {
    var Stack = require_Stack();
    var SpreadElement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isSpreadElement = true;
        this.argument = this.createTokenStack(compilation, node.argument, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
      }
      definition() {
        return null;
      }
      description() {
        return this.argument.description();
      }
      reference() {
        return this.argument.reference();
      }
      referenceItems() {
        return this.argument.referenceItems();
      }
      key() {
        return this.argument.key();
      }
      type(ctx2) {
        return this.argument.type(ctx2);
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.argument.parser();
        this.argument.setRefBeUsed();
        const type2 = this.type();
        if (this.parentStack.isArrayExpression) {
          const arrayType = this.getGlobalTypeById("array");
          const iteratorType = this.getGlobalTypeById("Iterator");
          if (!(arrayType.is(type2) || type2.is(iteratorType))) {
            this.error(1073, this.argument.value());
          }
        } else if (this.parentStack.isObjectExpression) {
          const objectType = this.getGlobalTypeById("object");
          if (!objectType.is(type2)) {
            this.error(1074, this.argument.value());
          }
        }
      }
      value() {
        return this.argument.value();
      }
      raw() {
        return this.argument.raw();
      }
      error(code, ...args) {
        this.argument.error(code, ...args);
      }
      warn(code, ...args) {
        this.argument.warn(code, ...args);
      }
    };
    module.exports = SpreadElement;
  }
});

// lib/stacks/StructTableColumnDefinition.js
var require_StructTableColumnDefinition = __commonJS({
  "lib/stacks/StructTableColumnDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var StructTableColumnDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isStructTableColumnDefinition = true;
        this.isPropertyDefinition = true;
        this.isProperty = true;
        this.question = !!node.question;
        this.key = this.createTokenStack(compilation, node.key, scope, node, this);
        this.typename = this.createTokenStack(compilation, node.typename, scope, node, this);
        this.unsigned = node.typename ? !!node.typename.unsigned : false;
        this.properties = node.properties.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
        this.module.addMember(this.key.value(), this);
        this.assignItems = /* @__PURE__ */ new Set();
        this.assignValue = null;
      }
      definition(ctx2) {
        const location = this.key.getLocation();
        const question = this.question ? "?" : "";
        return {
          comments: this.comments,
          expre: `(struct) column ${this.key.value()}${question}: ${this.type().toString(ctx2)}`,
          location,
          file: this.compilation.file
        };
      }
      get kind() {
        return "init";
      }
      assignment(value, stack2 = null) {
        if (this.assignValue !== value) {
          let assignDesc = null;
          if (value && value.isStack) {
            assignDesc = value.description();
          }
          if (assignDesc) {
            if (assignDesc === this || assignDesc.isStack && assignDesc.description() === this) {
              this.setRefBeUsed(assignDesc);
              return;
            }
          }
          this.checkExpressionType(this.type(), value, stack2);
          this.assignItems.add(value);
          if (!this.assignValue) {
            this.assignValue = value;
          }
          if (assignDesc) {
            this.setRefBeUsed(assignDesc);
          }
        }
      }
      reference() {
        return this.assignValue ? this.assignValue.reference() : null;
      }
      referenceItems() {
        let items = [];
        this.assignItems.forEach((item2) => {
          items = items.concat(item2.referenceItems());
        });
        return items;
      }
      get acceptType() {
        return null;
      }
      get id() {
        return this.key;
      }
      get dynamic() {
        return false;
      }
      description() {
        return this;
      }
      type() {
        const desc2 = this.typename && this.typename.description();
        if (!desc2)
          return this.getGlobalTypeById("string");
        return desc2.type();
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.typename) {
          this.typename.parser();
        }
        this.properties.forEach((item2) => {
          if (!(item2.isIdentifier || item2.isMemberExpression)) {
            if (item2.isStructTablePropertyDefinition && item2.key.value().toLowerCase() === "default") {
              if (this.typename) {
                const desc2 = this.typename.description();
                if (desc2) {
                  this.checkExpressionType(desc2, item2.init);
                }
              }
            }
            item2.parser();
          }
        });
      }
      value() {
        return this.key.value();
      }
    };
    module.exports = StructTableColumnDefinition;
  }
});

// lib/stacks/StructTableDeclaration.js
var require_StructTableDeclaration = __commonJS({
  "lib/stacks/StructTableDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var Utils2 = require_Utils();
    var ClassScope = require_ClassScope();
    var StructTableDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        scope = new ClassScope(scope);
        super(compilation, node, scope, parentNode, parentStack);
        this.isStructTableDeclaration = true;
        this._metatypes = [];
        this._annotations = [];
        this.body = [];
        this.imports = [];
        this.id = this.createTokenStack(compilation, node.id, scope, node, this);
        const module2 = this.module = compilation.createModule(this.namespace, this.id.value(), false);
        this.id.module = module2;
        this.extends = (node.extends || []).map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
        module2.comments = this.comments;
        module2.isInterface = true;
        module2.isStructTable = true;
        module2.isDeclaratorModule = true;
        compilation.addModuleStack(module2, this);
      }
      set metatypes(value) {
        value.forEach((item2) => {
          item2.additional = this;
        });
        if (value.length > 0) {
          this._metatypes = value;
        }
      }
      get metatypes() {
        return this._metatypes;
      }
      set annotations(value) {
        value.forEach((annotation) => {
          annotation.additional = this;
        });
        if (value.length > 0) {
          this._annotations = value;
        }
      }
      get annotations() {
        return this._annotations;
      }
      definition(ctx2) {
        const any = this.getGlobalTypeById("any").toString();
        const columns = this.body.filter((item2) => item2.isStructTableColumnDefinition).map((item2) => {
          const name = item2.key.value();
          const desc2 = item2.description();
          let type2 = any;
          if (desc2)
            type2 = desc2.type().toString();
          if (item2.question) {
            return `${name}?:${type2}`;
          }
          return `${name}:${type2}`;
        });
        return {
          comments: this.comments,
          expre: `(struct) ${this.module.getName()}:{\r
	${columns.join("\r\n	")}\r
}`,
          location: this.id.getLocation(),
          file: this.compilation.file
        };
      }
      async createCompleted() {
        const compilation = this.compilation;
        this.imports.forEach((stack2) => {
          stack2.parser();
          stack2.addImport(this.module, this.parentStack.scope);
        });
        this.module.extends = this.extends.map((inherit) => {
          const module2 = this.getModuleById(inherit.value());
          if (module2) {
            if (Utils2.checkDepend(this.module, module2)) {
              inherit.error(1024, inherit.value(), this.module.getName(), module2.getName());
            } else {
              module2.used = true;
              this.compilation.addDependency(module2, this.module);
              return module2;
            }
          } else {
            inherit.error(1027, inherit.value());
          }
        }).filter((item2) => !!item2);
        this.node.body.map((item2) => {
          const stack2 = this.createTokenStack(compilation, item2, this.scope, this.node, this);
          if (stack2) {
            this.body.push(stack2);
          }
        });
      }
      type() {
        return this.module;
      }
      description() {
        return this;
      }
      parser() {
        if (super.parser() === false)
          return false;
        const cache = {};
        this.body.forEach((item2) => {
          item2.parser();
          if (!(item2.isIdentifier || item2.isMemberExpression)) {
            if (item2.isStructTableKeyDefinition && item2.local.isStructTableMethodDefinition) {
              const key = item2.local.key.value();
              if (cache[key]) {
                cache[key].error(1168);
                item2.local.key.error(1168);
              }
              cache[key] = item2.local.key;
            }
          }
        });
      }
      value() {
        return this.id.value();
      }
    };
    module.exports = StructTableDeclaration;
  }
});

// lib/stacks/StructTableKeyDefinition.js
var require_StructTableKeyDefinition = __commonJS({
  "lib/stacks/StructTableKeyDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var StructTableKeyDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isStructTableKeyDefinition = true;
        this.key = this.createTokenStack(compilation, node.key, scope, node, this);
        this.local = this.createTokenStack(compilation, node.local, scope, node, this);
        this.properties = node.properties.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
      }
      definition(context) {
        return null;
      }
      value() {
        return this.key.value();
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.local.parser();
        this.properties.forEach((item2) => {
          if (!(item2.isIdentifier || item2.isMemberExpression)) {
            item2.parser();
          }
        });
      }
    };
    module.exports = StructTableKeyDefinition;
  }
});

// lib/stacks/StructTableMethodDefinition.js
var require_StructTableMethodDefinition = __commonJS({
  "lib/stacks/StructTableMethodDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var mapType = {
      "tinyint": "int",
      "smallint": "int",
      "mediumint": "int",
      "int": "int",
      "bigint": "int",
      "double": "float",
      "float": "float",
      "decimal": "float",
      "numberic": "number",
      "time": "number",
      "timestamp": "string",
      "datetime": "string",
      "year": "string",
      "real": "string",
      "bit": "string",
      "char": "string",
      "varchar": "string",
      "varbinary": "string",
      "text": "string",
      "tinytext": "string",
      "mediumtext": "string",
      "longtext": "string",
      "binary": "string",
      "tinyblob": "string",
      "blob": "string",
      "mediumblob": "string",
      "longblob": "string",
      "geometry": "string",
      "point": "string",
      "linestring": "string",
      "polygon": "string",
      "multipoint": "string",
      "multilinestring": "string",
      "multipolygon": "string",
      "geometrycollectic": "string",
      "set": "string",
      "enum": "string"
    };
    var StructTableMethodDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isStructTableMethodDefinition = true;
        this.key = this.createTokenStack(compilation, node.key, scope, node, this);
        this.params = node.params.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
      }
      definition(context) {
        return null;
      }
      description() {
        if (!this.parentStack.isStructTableColumnDefinition)
          return null;
        const key = this.key.value();
        const local2 = key.toLowerCase();
        if (Object.prototype.hasOwnProperty.call(mapType, local2)) {
          return this.getGlobalTypeById(mapType[local2]);
        } else {
          const desc2 = this.getModuleById(key);
          if (desc2 && desc2.isModule) {
            this.compilation.addDependency(desc2, this.module);
          }
          return desc2 ? desc2 : null;
        }
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.parentStack.isStructTableKeyDefinition) {
          if (this.params.length > 0) {
            this.params.forEach((item2) => {
              if (!this.module.hasMember(item2.value())) {
                item2.error(1166, item2.value());
              }
            });
          } else {
            this.key.error(1167);
          }
        }
      }
      value() {
        return this.key.value();
      }
    };
    module.exports = StructTableMethodDefinition;
  }
});

// lib/stacks/StructTablePropertyDefinition.js
var require_StructTablePropertyDefinition = __commonJS({
  "lib/stacks/StructTablePropertyDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var StructTablePropertyDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isStructTablePropertyDefinition = true;
        this.assignment = !!node.assignment;
        this.key = this.createTokenStack(compilation, node.key, scope, node, this);
        this.init = this.createTokenStack(compilation, node.init, scope, node, this);
      }
      definition(context) {
        return null;
      }
      value() {
        return this.key.value();
      }
    };
    module.exports = StructTablePropertyDefinition;
  }
});

// lib/stacks/SuperExpression.js
var require_SuperExpression = __commonJS({
  "lib/stacks/SuperExpression.js"(exports, module) {
    var Expression = require_Expression();
    var SuperExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isSuperExpression = true;
        const fnScope = scope.getScopeByType("function");
        if (fnScope.isMethod && fnScope.isConstructor && !fnScope.hasSuper) {
          fnScope.firstSuperIndex = parentStack.childrenStack.length;
          fnScope.hasSuper = true;
        }
      }
      definition(ctx2) {
        let parent = this.module.extends[0];
        if (parent)
          parent = parent.type();
        const methodConstructor = parent && parent.getConstructMethod();
        if (methodConstructor) {
          parent = methodConstructor;
        }
        return parent && parent.definition(ctx2);
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      description() {
        if (!this.parentStack.isMemberExpression) {
          let parent = this.module.extends[0];
          if (parent)
            parent = parent.type();
          const methodConstructor = parent && parent.getConstructMethod();
          if (methodConstructor) {
            return methodConstructor;
          } else if (parent) {
            return parent;
          }
        }
        return this;
      }
      getContext() {
        let ctx2 = this.getAttribute("getContext");
        if (ctx2)
          return ctx2;
        const module2 = this.module;
        const moduleStack = module2.moduleStack;
        const parent = moduleStack.getContext();
        return this.setAttribute("getContext", parent.createChild(this));
      }
      type() {
        const inherit = this.module.extends[0];
        if (inherit) {
          return inherit;
        }
        return this.getGlobalTypeById("never");
      }
      parser() {
        if (super.parser() === false)
          return false;
        const stack2 = this.getParentStack((stack3) => {
          return !!stack3.isFunctionExpression;
        });
        if (!stack2 || !stack2.parentStack.isMethodDefinition || stack2.parentStack.static) {
          this.error(1076);
        }
        const parent = this.module && this.module.extends[0];
        if (!parent) {
          this.error(1075);
        }
      }
      value() {
        return `super`;
      }
      raw() {
        return `super`;
      }
    };
    module.exports = SuperExpression;
  }
});

// lib/stacks/SwitchCase.js
var require_SwitchCase = __commonJS({
  "lib/stacks/SwitchCase.js"(exports, module) {
    var Stack = require_Stack();
    var SwitchCase = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isSwitchCase = true;
        this.hasReturnStatement = false;
        this.condition = this.createTokenStack(compilation, node.test, scope, node, this);
        this.consequent = node.consequent.map((item2) => this.createTokenStack(compilation, item2, scope, node, this)).filter((item2) => {
          if (item2) {
            if (!this.hasReturnStatement) {
              this.hasReturnStatement = !!(item2.hasReturnStatement || item2.hasThrowStatement);
            }
            return true;
          }
          return false;
        });
      }
      freeze() {
        super.freeze();
        super.freeze(this.consequent);
        this.condition.freeze();
        this.consequent.forEach((stack2) => stack2.freeze());
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.condition) {
          this.condition.parser();
          this.condition.setRefBeUsed();
        }
        this.consequent.forEach((item2) => item2.parser());
      }
    };
    module.exports = SwitchCase;
  }
});

// lib/stacks/SwitchStatement.js
var require_SwitchStatement = __commonJS({
  "lib/stacks/SwitchStatement.js"(exports, module) {
    var Stack = require_Stack();
    var BlockScope = require_BlockScope();
    var SwitchStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isSwitchStatement = true;
        this.condition = this.createTokenStack(compilation, node.discriminant, scope, node, this);
        scope = new BlockScope(scope);
        this.cases = node.cases.map((item2) => {
          return this.createTokenStack(compilation, item2, scope, node, this);
        });
        this.hasReturnStatement = this.cases.every((item2) => !!(item2.hasReturnStatement || item2.hasThrowStatement));
      }
      freeze() {
        super.freeze();
        super.freeze(this.cases);
        super.freeze(this.scope);
        this.condition.freeze();
        this.cases.forEach((stack2) => stack2.freeze());
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.condition.parser();
        this.condition.setRefBeUsed();
        this.cases.forEach((item2) => item2.parser());
      }
    };
    module.exports = SwitchStatement;
  }
});

// lib/stacks/TemplateElement.js
var require_TemplateElement = __commonJS({
  "lib/stacks/TemplateElement.js"(exports, module) {
    var Stack = require_Stack();
    var TemplateElement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTemplateElement = true;
      }
      definition() {
        return null;
      }
      reference() {
        return this;
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type() {
        return this.getGlobalTypeById("string");
      }
      value() {
        return this.node.value.cooked;
      }
      raw() {
        return this.node.value.raw;
      }
    };
    module.exports = TemplateElement;
  }
});

// lib/stacks/TemplateLiteral.js
var require_TemplateLiteral = __commonJS({
  "lib/stacks/TemplateLiteral.js"(exports, module) {
    var Stack = require_Stack();
    var TemplateLiteral = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.expressions = node.expressions.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
        this.quasis = node.quasis.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
        this.isTemplateLiteral = true;
      }
      freeze() {
        super.freeze();
        super.freeze(this.quasis);
        super.freeze(this.expressions);
        this.quasis.forEach((stack2) => stack2.freeze());
        this.expressions.forEach((stack2) => stack2.freeze());
      }
      definition() {
        return null;
      }
      reference() {
        return this;
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type() {
        return this.getModuleById("string");
      }
      value() {
        return this.node.raw;
      }
      raw() {
        return this.node.raw;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.expressions.forEach((item2) => {
          item2.parser();
          item2.setRefBeUsed();
        });
      }
    };
    module.exports = TemplateLiteral;
  }
});

// lib/stacks/ThisExpression.js
var require_ThisExpression = __commonJS({
  "lib/stacks/ThisExpression.js"(exports, module) {
    var Expression = require_Expression();
    var ThisExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isThisExpression = true;
      }
      definition() {
        const identifier = this.value();
        const context = this;
        return {
          kind: "this",
          identifier,
          expre: `this: this`,
          location: this.getLocation(),
          file: this.compilation.file,
          context
        };
      }
      getContext() {
        return this.getAttribute("getContext", () => {
          const module2 = this.module;
          if (module2) {
            const moduleStack = module2.moduleStack;
            const parent = moduleStack.getContext();
            return parent.createChild(this);
          }
          return super.getContext();
        });
      }
      reference() {
        return this;
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type() {
        return this.scope.define(this.value());
      }
      value() {
        return `this`;
      }
      raw() {
        return `this`;
      }
      parser() {
        if (super.parser() === false)
          return false;
        const desc2 = this.type();
        if (!desc2) {
          this.error(1013, this.raw());
        }
      }
    };
    module.exports = ThisExpression;
  }
});

// lib/stacks/ThrowStatement.js
var require_ThrowStatement = __commonJS({
  "lib/stacks/ThrowStatement.js"(exports, module) {
    var Stack = require_Stack();
    var ThrowStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isThrowStatement = true;
        this.hasThrowStatement = true;
        this.argument = this.createTokenStack(compilation, node.argument, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
      }
      definition() {
        return null;
      }
      error(code, ...args) {
        this.argument.error(code, ...args);
      }
      warn(code, ...args) {
        this.argument.warn(code, ...args);
      }
      reference() {
        return null;
      }
      referenceItems() {
        return [];
      }
      description() {
        return null;
      }
      parser() {
        return this.argument.parser();
      }
      value() {
        return this.argument.value();
      }
      raw() {
        return this.argument.raw();
      }
    };
    module.exports = ThrowStatement;
  }
});

// lib/stacks/TryStatement.js
var require_TryStatement = __commonJS({
  "lib/stacks/TryStatement.js"(exports, module) {
    var Stack = require_Stack();
    var Declarator = require_Declarator();
    var TryStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTryStatement = true;
        this.param = new Declarator(compilation, node.handler.param, scope, node, this);
        if (node.handler.param) {
          scope.define(this.param.value(), this.param);
        }
        this.handler = this.createTokenStack(compilation, node.handler.body, scope, node, this);
        this.block = this.createTokenStack(compilation, node.block, scope, node, this);
        this.finalizer = this.createTokenStack(compilation, node.finalizer, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.block.freeze();
        this.param && this.param.freeze();
        this.handler && this.handler.freeze();
        this.finalizer && this.finalizer.freeze();
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.block.parser();
        this.param && this.param.parser();
        this.handler && this.handler.parser();
        this.finalizer && this.finalizer.parser();
      }
    };
    module.exports = TryStatement;
  }
});

// lib/stacks/TypeAssertExpression.js
var require_TypeAssertExpression = __commonJS({
  "lib/stacks/TypeAssertExpression.js"(exports, module) {
    var Expression = require_Expression();
    var TypeAssertExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTypeAssertExpression = true;
        this.left = this.createTokenStack(compilation, node.left, scope, node, this);
        this.right = this.createTokenStack(compilation, node.right, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
      }
      definition(ctx2) {
        return this.left.definition(ctx2);
      }
      description() {
        return this.left.description();
      }
      reference() {
        return this.left.reference();
      }
      referenceItems() {
        return this.left.referenceItems();
      }
      type() {
        const type2 = this.right.type();
        const ctx2 = this.getContext();
        ctx2.make(type2);
        return type2;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.right.parser();
        this.left.parser();
      }
    };
    module.exports = TypeAssertExpression;
  }
});

// lib/stacks/TypeComputeDefinition.js
var require_TypeComputeDefinition = __commonJS({
  "lib/stacks/TypeComputeDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var ComputeType = require_ComputeType();
    var keySymbol = Symbol("key");
    var TypeComputeDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTypeComputeDefinition = true;
        this.object = this.createTokenStack(compilation, node.object, scope, node, this);
        this.property = this.createTokenStack(compilation, node.property, scope, node, this);
        this[keySymbol] = {};
      }
      freeze() {
        super.freeze();
        this.object.freeze();
        this.property.freeze();
      }
      definition() {
        const type2 = this.type();
        return {
          kind: this.kind,
          comments: this.comments,
          expre: `(type) ${type2.toString()}`,
          location: (this.prefix || this).getLocation(),
          file: this.compilation.file,
          context: this
        };
      }
      description() {
        return this;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type(ctx2) {
        if (!this[keySymbol]._type) {
          this[keySymbol]._type = new ComputeType(this, this.object.type(), this.property);
        }
        return this[keySymbol]._type.type();
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.object.parser();
        this.property.parser();
      }
    };
    module.exports = TypeComputeDefinition;
  }
});

// lib/types/CircularType.js
var require_CircularType = __commonJS({
  "lib/types/CircularType.js"(exports, module) {
    var Type = require_Type();
    var CircularType = class extends Type {
      constructor(inherit, target, typeName) {
        super("$CircularType", inherit);
        this.isCircularType = true;
        this.target = target;
        this.typeName = typeName;
      }
      get id() {
        return this.typeName;
      }
      get hasGenericType() {
        return this.inherit.hasGenericType;
      }
      definition(ctx2) {
        return this.inherit.definition(ctx2);
      }
      clone(inference) {
        if (inference) {
          return new CircularType(inference(this.inherit), this.target, this.typeName);
        }
        return this;
      }
      check(stack2, context = {}, options = {}) {
        return this.inherit.check(stack2, context, options);
      }
      is(type2, context, options = {}) {
        const acceptType = this.inherit;
        if (acceptType.isLiteralObjectType) {
          return acceptType.constraint(type2, context, options);
        }
        return acceptType.is(type2, context, options);
      }
      toString(context, options = {}) {
        return this.typeName;
      }
    };
    module.exports = CircularType;
  }
});

// lib/stacks/TypeDefinition.js
var require_TypeDefinition = __commonJS({
  "lib/stacks/TypeDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var Utils2 = require_Utils();
    var InstanceofType = require_InstanceofType();
    var Type = require_Type();
    var Namespace2 = require_Namespace();
    var CircularType = require_CircularType();
    var TypeDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTypeDefinition = true;
        this.argument = this.createTokenStack(compilation, node.value, scope, node, this);
        this.isThisType = this.argument.value() === "this";
        this.addHook();
      }
      addHook() {
        if (this.argument.isLiteral || this.isThisType) {
          return;
        }
        const id = this.argument.value();
        if (this.checkNeedToLoadTypeById(id)) {
          this.compilation.hookAsync("compilation.create.after", async () => {
            const desc2 = await this.loadTypeAsync(id);
            if (desc2 && desc2.isModule) {
              this.compilation.addDependency(desc2, this.module);
            }
          });
        } else {
          const desc2 = this.scope.define(id);
          if (desc2 && desc2.isModule) {
            this.compilation.addDependency(desc2, this.module);
          }
        }
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
      }
      definition(ctx2) {
        if (!this.isThisType) {
          let id = this.argument.value();
          let desc2 = this.getLocalReferenceType(id);
          if (desc2 && (desc2.isType || desc2.isStack)) {
            return desc2.definition(ctx2);
          }
        }
        const type2 = this.type();
        if (!type2) {
          return null;
        }
        return type2.definition(ctx2);
      }
      error(code, ...args) {
        this.argument.error(code, ...args);
      }
      warn(code, ...args) {
        this.argument.warn(code, ...args);
      }
      description() {
        return this;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          if (this.argument.isLiteral) {
            return this.argument.type();
          } else {
            if (this.isThisType) {
              return this.module && this.module.isModule ? new InstanceofType(this.module, this, null, true) : this.getGlobalTypeById("never");
            } else {
              let id = this.argument.value();
              let type2 = this.getLocalReferenceType(id);
              if (type2) {
                if (this.checkNestedRefs()) {
                  return new CircularType(type2.type(), this, id);
                } else {
                  return type2.type();
                }
              }
            }
          }
          return this.getGlobalTypeById("never");
        });
      }
      checkCircular(type2) {
        if (this.checkedCircular !== void 0) {
          return this.checkedCircular;
        }
        this.checkedCircular = false;
        if (type2) {
          this.getParentStack((stack2) => {
            if (stack2.isTypeGenericDefinition || stack2.isGenericTypeDeclaration || stack2.isTypeDefinition || stack2.isTypeStatement) {
              if (stack2 === type2) {
                this.checkedCircular = true;
                this.argument.error(1141, this.value());
              }
              return true;
            } else {
              return false;
            }
          });
        }
        return this.checkedCircular;
      }
      getTypeDefinitionBeginStack(stack2) {
        if (!stack2.parentStack)
          return stack2;
        if (this.isTypeDefinitionStack(stack2)) {
          return this.getTypeDefinitionBeginStack(stack2.parentStack);
        }
        return stack2;
      }
      checkNestedRefs() {
        if (this.isThisType || this.argument.isLiteral)
          return false;
        const begin = this.getTypeDefinitionBeginStack(this.parentStack);
        if (begin !== this.parentStack) {
          let id = this.argument.value();
          if (begin.isTypeStatement) {
            return begin === this.scope.define(id);
          } else if (begin.isDeclaratorTypeAlias) {
            return begin === Namespace2.globals.raw(id);
          }
        }
        return false;
      }
      parser() {
        if (super.parser() === false)
          return false;
        let type2 = this.type();
        if (type2 && (type2.isNeverType && this.value() !== "never") || type2 && !type2.isType) {
          type2 = null;
        }
        if (!type2) {
          type2 = this.getModuleById(this.argument.value());
          if (type2) {
            type2 = type2.type();
            this.setAttribute("type", type2);
          }
        }
        if (type2) {
          if (type2.isModule || type2.isDeclaratorTypeAlias) {
            this.parserDescriptor(type2);
          }
          this.argument.setRefBeUsed(type2);
        }
        if (!type2) {
          this.argument.error(1083, this.argument.value());
        } else if (!this.parentStack.isDeclaratorTypeAlias) {
          if (!type2 || !(type2 instanceof Type)) {
            this.argument.error(1083, this.value());
          } else if (!this.isThisType) {
            let declareGgenerics = null;
            if (type2.isAliasType && type2.target && type2.target.genericity && type2.target.genericity.isGenericDeclaration) {
              declareGgenerics = type2.target.genericity;
            } else if (Utils2.isTypeModule(type2)) {
              const stackModule = type2.moduleStack;
              if (stackModule && stackModule.genericity && stackModule.genericity.isGenericDeclaration) {
                declareGgenerics = stackModule.genericity;
              }
            }
            if (declareGgenerics) {
              const requires = declareGgenerics.elements.filter((item2) => !item2.isGenericTypeAssignmentDeclaration);
              const len = requires.length;
              if (len > 0) {
                this.argument.error(1030, type2.toString(), len);
              }
            }
          }
        }
      }
      value() {
        return this.argument.value();
      }
      raw() {
        return this.argument.raw();
      }
    };
    module.exports = TypeDefinition;
  }
});

// lib/stacks/TypeFunctionDefinition.js
var require_TypeFunctionDefinition = __commonJS({
  "lib/stacks/TypeFunctionDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var FunctionType = require_FunctionType();
    var UnionType = require_UnionType();
    var FunctionScope = require_FunctionScope();
    var Declarator = require_Declarator();
    var keySymbol = Symbol("key");
    var TypeFunctionDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.scope = scope = new FunctionScope(scope);
        this.isTypeFunctionDefinition = true;
        this._returnType = this.createTokenStack(compilation, node.value, scope, node, this);
        let assignment = null;
        let hasRest = null;
        this.genericity = this.createTokenStack(compilation, node.genericity, scope, node, this);
        this.params = node.params.map((item2) => {
          if (item2.type == "Identifier") {
            const stack2 = new Declarator(compilation, item2, scope, node, this);
            if (assignment) {
              assignment.error(1050, assignment.value());
            }
            scope.define(stack2.value(), stack2);
            return stack2;
          } else {
            const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
            if (stack2.isRestElement) {
              hasRest = stack2;
            }
            assignment = stack2;
            return stack2;
          }
        });
        if (hasRest && this.params[this.params.length - 1] !== hasRest) {
          hasRest.error(1051, hasRest.value());
        }
        this[keySymbol] = {};
      }
      freeze() {
        super.freeze();
        super.freeze(this.params);
        this.returnType && this.returnType.freeze();
        this.params.forEach((stack2) => stack2.freeze());
      }
      definition(ctx2) {
        ctx2 = ctx2 || this.getContext();
        return this.type().definition(ctx2);
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type() {
        return this.getFunType();
      }
      setRefBeUsed() {
      }
      get returnType() {
        return this.getAttribute("returnType", () => {
          return this._returnType ? this.normalization(this._returnType.type()) : this.getGlobalTypeById("void");
        });
      }
      normalization(type2) {
        if (type2 && type2.isUnionType) {
          if (type2.elements.some((type3) => type3.type().isAnyType)) {
            return this.getGlobalTypeById("any");
          }
          const elements = type2.elements.filter((type3) => !type3.type().isNullableType);
          if (elements.length === 1) {
            return type2.elements[0].type();
          } else if (!elements.length) {
            return type2.elements[0];
          }
          if (elements.length !== type2.elements.length) {
            return new UnionType(elements, type2.target);
          }
        }
        return type2;
      }
      getReturnedType() {
        return this.returnType;
      }
      getFunType() {
        return this.getAttribute("getFunType", () => {
          return new FunctionType(this.getGlobalTypeById("Function"), this);
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.genericity) {
          this.genericity.parser();
        }
        this.params.forEach((item2) => item2.parser());
        if (this._returnType) {
          this._returnType.parser();
          if (!this._returnType.type()) {
            this._returnType.error(1083, this._returnType.value());
          }
        }
      }
    };
    module.exports = TypeFunctionDefinition;
  }
});

// lib/stacks/TypeGenericDefinition.js
var require_TypeGenericDefinition = __commonJS({
  "lib/stacks/TypeGenericDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var Utils2 = require_Utils();
    var ClassGenericType = require_ClassGenericType();
    var TypeGenericDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTypeGenericDefinition = true;
        this.argument = this.createTokenStack(compilation, node.value, scope, node, this);
        this.elements = node.typeElements.map((item2) => {
          return this.createTokenStack(compilation, item2, scope, node, this);
        });
        this.isThisType = this.argument && this.argument.value() === "this";
        this.addHook();
      }
      addHook() {
        if (this.isThisType) {
          return;
        }
        const id = this.argument.value();
        if (this.checkNeedToLoadTypeById(id)) {
          this.compilation.hookAsync("compilation.create.after", async () => {
            const desc2 = await this.loadTypeAsync(id);
            if (desc2 && desc2.isModule) {
              this.compilation.addDependency(desc2, this.module);
            }
          });
        } else {
          const desc2 = this.scope.define(id);
          if (desc2 && desc2.isModule) {
            this.compilation.addDependency(desc2, this.module);
          }
        }
      }
      freeze() {
        super.freeze();
        super.freeze(this.elements);
        this.argument.freeze();
        this.elements.forEach((stack2) => stack2.freeze());
      }
      definition(ctx2) {
        const type2 = this.type();
        if (!type2)
          return null;
        ctx2 = ctx2 || this.getContext();
        if (!this.isThisType) {
          let rawType = this.isThisType ? this.module : this.getLocalReferenceType(this.argument.value());
          if (rawType && rawType.isAliasType) {
            const result = rawType.definition(ctx2);
            if (!result)
              return null;
            return {
              comments: result.comments,
              expre: `(type) ${type2.toString(ctx2)}`,
              location: result.location,
              file: result.file
            };
          }
          let [stack2] = this.getDeclareGenerics();
          if (stack2) {
            stack2 = (stack2.isClassDeclaration || stack2.isInterfaceDeclaration) && stack2.id ? stack2.id : stack2;
            if (stack2 && stack2.isStack) {
              return {
                comments: this.comments,
                expre: `(type) ${type2.toString(ctx2)}`,
                location: stack2.getLocation(),
                file: stack2.compilation.file
              };
            }
          }
        }
        return type2.definition(ctx2);
      }
      error(code, ...args) {
        this.argument.error(code, ...args);
      }
      warn(code, ...args) {
        this.argument.warn(code, ...args);
      }
      description() {
        return this;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      makeType(type2) {
        if (type2) {
          type2 = type2.type();
          const classType = this.getGlobalTypeById("Class");
          const isClass = type2 === classType || type2.extends && type2.extends[0] === classType;
          type2 = new ClassGenericType(
            this.elements,
            isClass ? classType : type2,
            isClass,
            this
          );
          this.setAttribute("type", type2);
          this.getContext().make(type2);
        }
        return type2;
      }
      type() {
        return this.getAttribute("type", () => {
          let type2 = this.isThisType ? this.module : this.getLocalReferenceType(this.argument.value());
          return this.makeType(type2) || this.getGlobalTypeById("never");
        });
      }
      getDeclareGenerics(type2 = null) {
        if (!type2) {
          type2 = this.isThisType ? this.module : this.getLocalReferenceType(this.argument.value());
        }
        if (type2) {
          type2 = type2.type();
          const originType = Utils2.getOriginType(type2);
          if (originType) {
            if (originType.isModule && (originType.isClass || originType.isInterface)) {
              const statcks = originType.getStacks().filter((stack2) => !!stack2.genericity).sort((a, b) => {
                return a.genericity.elements.length - b.genericity.elements.length;
              });
              if (statcks.length > 0) {
                return [statcks[0], statcks[0].genericity.elements];
              }
            }
            if (type2.isAliasType && type2.target && type2.target.genericity) {
              return [type2.target, type2.target.genericity.elements];
            }
          }
        }
        return [];
      }
      parser() {
        if (super.parser() === false)
          return false;
        const value = this.argument.value();
        let type2 = this.isThisType ? this.module : this.getLocalReferenceType(value);
        if (this.type() === this.getGlobalTypeById("never")) {
          this.makeType(this.getModuleById(this.argument.value()));
        }
        if (type2 && !type2.isAnyType) {
          const [stack2, declareGenerics = []] = this.getDeclareGenerics(type2);
          if (stack2) {
            this.parserDescriptor(type2.isAliasType ? type2.target : stack2);
            stack2.addUseRef(this.argument);
          }
          const requires = declareGenerics.filter((item2) => {
            return !item2.isGenericTypeAssignmentDeclaration;
          });
          if (requires.length > this.elements.length || this.elements.length > declareGenerics.length) {
            if (requires.length === declareGenerics.length) {
              this.argument.error(1030, type2.toString(), requires.length);
            } else {
              this.argument.error(1031, type2.toString(), requires.length, declareGenerics.length);
            }
          }
          const sameType = type2.type();
          this.elements.forEach((item2, index) => {
            item2.parser();
            const declareType = declareGenerics[index] && declareGenerics[index].type();
            let type3 = item2.type();
            if (type3 === sameType) {
              this.item.error(1177, item2.value());
            } else {
              if (declareType && declareType.hasConstraint) {
                if (type3.isGenericType && type3.assignType) {
                  type3 = type3.assignType;
                }
                if (!type3.isGenericType) {
                  this.checkExpressionType(declareType.inherit, type3, item2);
                }
              }
            }
          });
        } else {
          this.argument.error(1083, this.value());
        }
      }
      value() {
        return this.argument.value();
      }
    };
    module.exports = TypeGenericDefinition;
  }
});

// lib/types/IntersectionType.js
var require_IntersectionType = __commonJS({
  "lib/types/IntersectionType.js"(exports, module) {
    var Type = require_Type();
    var Utils2 = require_Utils();
    var MergeType = require_MergeType();
    var Namespace2 = require_Namespace();
    var IntersectionType = class extends Type {
      constructor(target, left, right) {
        super("Intersection");
        this.isIntersectionType = true;
        this.target = target;
        this.left = left;
        this.right = right;
        this.hasGenericType = left.hasGenericType || right.hasGenericType;
      }
      clone(inference) {
        if (!inference || !this.hasGenericType) {
          return this;
        }
        return new IntersectionType(this.target, this.left.clone(inference), this.right.clone(inference));
      }
      getProperty(object, property) {
        if (object.isLiteralArrayType || object.isLiteralObjectType || object.isGenericType || object.isEnumType || object.isIntersectionType) {
          return object.attribute(property);
        } else if (object.isModule) {
          const prop = object.getMember(property, "get");
          if (prop && Utils2.isModifierPublic(prop)) {
            return prop;
          }
        }
        return null;
      }
      attribute(property) {
        return this.getProperty(this.left.type(), property) || this.getProperty(this.right.type(), property);
      }
      get attributes() {
        return this.getProperties();
      }
      getProperties(propertyMap) {
        propertyMap = propertyMap || /* @__PURE__ */ new Map();
        if (this.left.isIntersectionType) {
          this.left.getProperties(propertyMap);
        }
        const getTypeProps = (type2) => {
          if (type2.isLiteralObjectType || type2.isEnumType) {
            type2.attributes.forEach((value, key) => {
              propertyMap.set(key, value);
            });
          } else if (type2.isModule) {
            type2.getProperties(propertyMap);
          }
        };
        getTypeProps(this.left.type());
        getTypeProps(this.right.type());
        return propertyMap;
      }
      getTypeKeys() {
        return Array.from(this.getProperties().keys());
      }
      check(stack2, context, options = {}) {
        const left = this.left;
        const right = this.right;
        return left.type().check(stack2, context, options) && right.type().check(stack2, context, options);
      }
      checkType(acceptType, assignment, context, options) {
        if (acceptType.isLiteralObjectType) {
          return acceptType.constraint(assignment, context, options);
        }
        return acceptType.is(assignment, context, options);
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.getWrapAssignType(type2);
        if (!this.isNeedCheckType(type2))
          return true;
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        const left = this.left;
        const right = this.right;
        return this.checkType(left.type(), type2, context, options) && this.checkType(right.type(), type2, context, options);
      }
      toString(context, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        const left = this.left.type();
        const right = this.right.type();
        const infer = (type2) => Utils2.inferTypeValue(type2, context.inference);
        const isObject = (type2) => {
          return type2.isLiteralObjectType || type2.isGenericType && type2.hasConstraint;
        };
        const checkNeedMerge = (left2, right2) => {
          if (left2.isGenericType) {
            left2 = infer(left2);
          }
          if (right2.isGenericType) {
            right2 = infer(right2);
          }
          if (isObject(left2) && isObject(right2)) {
            return true;
          }
          if (left2.isIntersectionType) {
            return checkNeedMerge(left2.left.type(), left2.right.type());
          } else if (right2.isIntersectionType) {
            return checkNeedMerge(right2.left.type(), right2.right.type());
          }
          return false;
        };
        if (checkNeedMerge(left, right)) {
          const origin = Namespace2.globals.get("Object");
          const merge = new MergeType(origin);
          const dataset = {};
          const add = (name, type2) => {
            if (type2.isIntersectionType) {
              create(type2.left.type(), type2.right.type());
            } else {
              if (dataset[name]) {
                dataset[name].push(type2);
              } else {
                dataset[name] = [type2];
              }
            }
          };
          const create = (...args) => {
            let len = args.length;
            for (let i = 0; i < len; i++) {
              let type2 = args[i];
              if (type2.isGenericType) {
                type2 = infer(type2);
              }
              if (type2.isGenericType && type2.hasConstraint) {
                type2 = type2.inherit;
              }
              if (type2.isLiteralObjectType) {
                type2.properties.forEach((value, prop) => {
                  add(prop, value.type());
                });
              } else if (type2.isIntersectionType) {
                create(type2.left.type(), type2.right.type());
              }
            }
          };
          create(left, right);
          Object.keys(dataset).forEach((key) => {
            const types = dataset[key];
            if (types.length > 1) {
              const group = new MergeType();
              types.forEach((item2) => {
                group.add(item2);
              });
              merge.types.set(key, group.type());
            } else {
              merge.types.set(key, types[0]);
            }
          });
          return merge.type().toString(context);
        }
        if (this.target.parentStack.isTypeIntersectionDefinition) {
          return `(${left.toString(context, options)} & ${right.toString(context, options)})`;
        } else {
          return `${left.toString(context, options)} & ${right.toString(context, options)}`;
        }
      }
    };
    module.exports = IntersectionType;
  }
});

// lib/stacks/TypeIntersectionDefinition.js
var require_TypeIntersectionDefinition = __commonJS({
  "lib/stacks/TypeIntersectionDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var IntersectionType = require_IntersectionType();
    var TypeIntersectionDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTypeIntersectionDefinition = true;
        this.left = this.createTokenStack(compilation, node.left, scope, node, this);
        this.right = this.createTokenStack(compilation, node.right, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.left.freeze();
        this.right.freeze();
      }
      definition(ctx2) {
        ctx2 = ctx2 || this.getContext();
        return this.type().definition(ctx2);
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          return new IntersectionType(this, this.left.type(), this.right.type());
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.left.parser();
        this.right.parser();
      }
      value() {
        if (this.parentStack.isTypeIntersectionDefinition || !this.parentStack.isTypeUnionDefinition) {
          return `${this.left.value()} & ${this.right.value()}`;
        } else {
          return `(${this.left.value()} & ${this.right.value()})`;
        }
      }
      raw() {
        return this.value();
      }
    };
    module.exports = TypeIntersectionDefinition;
  }
});

// lib/types/KeyofType.js
var require_KeyofType = __commonJS({
  "lib/types/KeyofType.js"(exports, module) {
    var UnionType = require_UnionType();
    var LiteralType = require_LiteralType();
    var Type = require_Type();
    var Namespace2 = require_Namespace();
    var KeyofType = class extends UnionType {
      constructor(target, referenceType) {
        super([], target);
        this.id = "$KeyofType";
        this.isKeyofType = true;
        this.referenceType = referenceType;
        this.hasGenericType = !!referenceType.hasGenericType;
        this.elements = this.getTypeKeys(referenceType);
      }
      clone(inference) {
        if (!inference || !this.hasGenericType) {
          return this;
        }
        const type2 = this.referenceType.type().clone(inference);
        if (type2 !== this.referenceType) {
          return new KeyofType(this.target, type2);
        }
        return this;
      }
      getTypeKeys(type2) {
        type2 = type2 || this.referenceType;
        if (type2.isGenericType) {
          return [];
        }
        const properties = /* @__PURE__ */ new Set();
        if (type2) {
          const push = (name, type3) => {
            properties.add(new LiteralType(Namespace2.globals.get(type3), this.target, name));
          };
          switch (true) {
            case type2.isLiteralObjectType:
            case type2.isEnumType:
              type2.attributes.forEach((value, key) => {
                push(key, "string");
              });
              break;
            case type2.isLiteralArrayType:
            case type2.isTupleUnion:
              type2.elements.forEach((value, key) => {
                push(key, "number");
              });
              break;
            case type2.isIntersectionType:
            case type2.isModule:
            case type2.isInstanceofType:
              type2.getTypeKeys().forEach((key) => {
                push(key, "string");
              });
              break;
          }
        }
        return Array.from(properties.values());
      }
      check(stack2, context = {}, options = {}) {
        return this.is(stack2 && stack2.type(), context, options);
      }
      is(type2, context, options = {}) {
        if (!type2 || !(type2 instanceof Type))
          return false;
        type2 = this.inferType(type2, context);
        type2 = this.getWrapAssignType(type2);
        options.toLiteralValue = true;
        if (type2.isUnionType) {
          return type2.elements.every((item2) => this.is(item2.type(), context, options));
        }
        if (type2.isAliasType) {
          return this.is(type2.inherit.type(), context, options);
        }
        if (!this.isNeedCheckType(type2))
          return true;
        const infer = (type3) => {
          if (context && context.inference) {
            return context.inference(type3);
          }
          return type3;
        };
        const elements = this.getTypeKeys(infer(this.referenceType));
        if (!elements.length)
          return false;
        if (type2.isUnionType || type2.isLiteralArrayType) {
          return type2.elements.every((item2) => {
            const base = item2.type();
            return elements.some((child) => {
              return base.is(child.type(), context, options);
            });
          });
        }
        return elements.some((base) => base.type().is(type2, context, options));
      }
      toString(context = {}, options = {}) {
        options = Object.assign({}, options);
        context = this.pushToStringChain(context, options);
        options.toLiteralValue = true;
        if (!options.complete) {
          let infer = (type2) => typeof context.inference === "function" ? context.inference(type2) : type2;
          let refType = infer(this.referenceType.type());
          if (refType.hasGenericType) {
            if (refType.isGenericType && refType.hasConstraint) {
              return `keyof ${refType.inherit.toString(context, options)}`;
            }
          }
          let elements = this.getTypeKeys(refType);
          if (!elements.length) {
            return "keyof never";
          }
          let need = elements.length > 1;
          return elements.map((item2) => {
            if (item2.type().isFunctionType && need) {
              return `(${item2.type().toString(context, options)})`;
            }
            return item2.type().toString(context, options);
          }).join(" | ");
        }
        options = Object.create(options);
        options.onlyTypeName = true;
        return `keyof ${this.referenceType.type().toString(context, options)}`;
      }
    };
    module.exports = KeyofType;
  }
});

// lib/stacks/TypeKeyofDefinition.js
var require_TypeKeyofDefinition = __commonJS({
  "lib/stacks/TypeKeyofDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var KeyofType = require_KeyofType();
    var TypeKeyofDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTypeKeyofDefinition = true;
        this.argument = this.createTokenStack(compilation, node.value, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
      }
      definition(ctx2) {
        ctx2 = ctx2 || this.getContext();
        return this.type().definition(ctx2);
      }
      description() {
        return this.argument.argument.description();
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          let type2 = this.argument.type();
          if (type2) {
            return new KeyofType(this, type2);
          } else {
            return this.getGlobalTypeById("never");
          }
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.argument.parser();
        if (!this.argument.isTypeTypeofDefinition) {
          const target = this.argument.isTypeDefinition ? this.argument.argument : this.argument;
          const desc2 = target.description();
          if (!desc2 || !(desc2.isTypeDefinition || desc2.isGenericTypeDeclaration || desc2.isTypeStatement || desc2.isModule)) {
            target.error(1083, target.value());
          }
        }
      }
      value() {
        return this.argument.value();
      }
      raw() {
        return this.argument.value();
      }
    };
    module.exports = TypeKeyofDefinition;
  }
});

// lib/stacks/TypeObjectDefinition.js
var require_TypeObjectDefinition = __commonJS({
  "lib/stacks/TypeObjectDefinition.js"(exports, module) {
    var LiteralObjectType = require_LiteralObjectType();
    var Expression = require_Expression();
    var keySymbol = Symbol("key");
    var TypeObjectDefinition = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTypeObjectDefinition = true;
        this.attributes = /* @__PURE__ */ new Map();
        this.dynamicProperties = /* @__PURE__ */ new Map();
        const dynamicProperties = [];
        this.properties = node.properties.map((item2) => {
          const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          if (!stack2.dynamic) {
            const name = stack2.value();
            if (this.attributes.has(name)) {
              stack2.error(1045, name);
            } else {
              this.attributes.set(stack2.value(), stack2);
            }
          } else {
            dynamicProperties.push(stack2);
          }
          return stack2;
        });
        if (dynamicProperties.length > 0) {
          this.compilation.hookAsync("compilation.create.after", () => {
            dynamicProperties.forEach((item2) => {
              if (item2.acceptType) {
                this.dynamicProperties.set(item2.acceptType.type(), item2);
              } else {
                const type2 = this.getGlobalTypeById("string");
                if (type2) {
                  this.dynamicProperties.set(type2, item2);
                }
              }
            });
          });
        }
        this[keySymbol] = {};
      }
      freeze() {
        super.freeze();
        super.freeze(this.attributes);
        this.properties.forEach((stack2) => stack2.freeze());
      }
      attribute(name) {
        return this.attributes.get(name) || null;
      }
      hasAttribute(name, type2) {
        return this.attributes.has(name);
      }
      dynamicAttribute(propertyType) {
        const properties = this.dynamicProperties;
        if (properties) {
          for (let [key, value] of properties) {
            if (key.check(propertyType)) {
              return value;
            }
          }
        }
        return null;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      definition(ctx2) {
        ctx2 = ctx2 || this.getContext();
        return this.type().definition(ctx2);
      }
      description() {
        return this;
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          return new LiteralObjectType(this.getGlobalTypeById("object"), this);
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.properties.forEach((item2) => {
          item2.parser();
        });
      }
      value() {
        return super.raw();
      }
    };
    module.exports = TypeObjectDefinition;
  }
});

// lib/stacks/TypeObjectPropertyDefinition.js
var require_TypeObjectPropertyDefinition = __commonJS({
  "lib/stacks/TypeObjectPropertyDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var AliasType = require_AliasType();
    var TypeObjectPropertyDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTypeObjectPropertyDefinition = true;
        this.key = this.createTokenStack(compilation, node.key, scope, node, this);
        this.key.acceptType = this.createTokenStack(compilation, node.key.acceptType, scope, node, this);
        this.dynamic = !!node.key.computed;
        this.init = this.createTokenStack(compilation, node.value, scope, node, this);
        this.question = !!node.key.question;
        this.isProperty = true;
      }
      freeze() {
        super.freeze();
        this.key.freeze();
        this.init.freeze();
      }
      get acceptType() {
        const acceptType = this.key.acceptType ? this.key.acceptType.type() : this.getGlobalTypeById("string");
        return acceptType;
      }
      definition(ctx2) {
        const question = this.question ? "?" : "";
        let key = this.key.value();
        if (this.dynamic) {
          key = `[${key}:${this.acceptType.toString(ctx2)}]`;
        }
        ctx2 = ctx2 || this.getContext();
        return {
          comments: this.parentStack.comments,
          expre: `(property) ${key}${question}:${this.type().toString(ctx2)}`,
          location: this.key.getLocation(),
          file: this.compilation.file
        };
      }
      value() {
        return this.key.value();
      }
      description() {
        return this;
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          if (this.parentStack.parentStack.isTypeStatement && this.init && this.init.isTypeDefinition && this.init.argument) {
            if (this.parentStack.parentStack === this.init.argument.description()) {
              return new AliasType(this.parentStack.parentStack.type(), this.parentStack.parentStack);
            }
          }
          if (this.init) {
            return this.init.type();
          }
          return this.getGlobalTypeById("any");
        });
      }
      assignment(value) {
        if (this.init) {
          this.checkExpressionType(this.init.type(), value);
        }
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.dynamic) {
          this.key.acceptType && this.key.acceptType.parser();
          const acceptType = this.key.acceptType ? this.key.acceptType.type() : this.getGlobalTypeById("string");
          const result = acceptType && ["string", "number"].some((type2) => acceptType.check(this.getGlobalTypeById(type2)));
          if (!result) {
            this.key.error(1139, this.key.value());
          }
        }
        if (this.init) {
          if (this.parentStack.parentStack.isTypeStatement && this.init.isTypeDefinition && this.init.argument) {
            if (this.parentStack.parentStack === this.init.argument.description()) {
              return true;
            }
          }
          this.init.parser();
        } else {
        }
      }
      error(code, ...args) {
        this.key.error(code, ...args);
      }
      warn(code, ...args) {
        this.key.warn(code, ...args);
      }
    };
    module.exports = TypeObjectPropertyDefinition;
  }
});

// lib/stacks/TypeStatement.js
var require_TypeStatement = __commonJS({
  "lib/stacks/TypeStatement.js"(exports, module) {
    var Stack = require_Stack();
    var TypeStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTypeStatement = true;
        this.id = this.createTokenStack(compilation, node.id, scope, node, this);
        this.init = this.createTokenStack(compilation, node.init, scope, node, this);
        if (this.scope.isDefine(this.id.value())) {
          this.id.error(1078, this.id.value());
        } else if (this.getTypeById(this.id.value())) {
          this.id.error(1078, this.id.value());
        } else {
          this.scope.define(this.id.value(), this);
        }
      }
      freeze() {
        super.freeze();
        this.id.freeze();
        this.init.freeze();
      }
      type() {
        return this.init.type();
      }
      setRefBeUsed() {
      }
      definition(ctx2) {
        ctx2 = ctx2 || this.getContext();
        let type2 = this.init.type();
        let typeStr = type2.toString(ctx2);
        const identifier = this.id.value();
        const expre = `(type) ${identifier} = ${typeStr}`;
        return {
          comments: this.comments,
          expre,
          location: this.id.getLocation(),
          file: this.compilation.file
        };
      }
      parser() {
        return this.init.parser();
      }
      value() {
        return this.id.value();
      }
      raw() {
        return this.id.raw();
      }
    };
    module.exports = TypeStatement;
  }
});

// lib/stacks/TypeTransformExpression.js
var require_TypeTransformExpression = __commonJS({
  "lib/stacks/TypeTransformExpression.js"(exports, module) {
    var AliasType = require_AliasType();
    var Expression = require_Expression();
    var TypeTransformExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTypeTransformExpression = true;
        this.argument = this.createTokenStack(compilation, node.expression, scope, node, this);
        this.expression = this.createTokenStack(compilation, node.value, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.ktypeExpressioney.freeze();
        this.expression.freeze();
      }
      definition(ctx2) {
        return this.expression.definition(ctx2);
      }
      description() {
        return this.expression.description();
      }
      reference() {
        return this.expression.reference();
      }
      referenceItems() {
        return this.expression.referenceItems();
      }
      type() {
        return this.getAttribute("type", () => {
          let type2 = this.expression.type();
          if (!type2 || this.isLiteralType(type2) || type2.isAnyType || type2.isNullableType || type2.isNeverType) {
            type2 = this.argument.type();
          }
          if (type2.isLiteralArrayType || type2.isLiteralObjectType || type2.isTupleType) {
            type2 = new AliasType(type2, type2.target);
            type2.isForceTransformType = true;
          } else if (type2.isAliasType) {
            type2 = new AliasType(type2.inherit, type2.target);
            type2.isForceTransformType = true;
          }
          return type2;
        });
      }
      isLiteralType(type2) {
        if (!type2)
          return false;
        if (type2.isLiteralType)
          return true;
        if (!type2.isAliasType)
          return false;
        const val = type2.toString();
        if (val === "string" || val === "boolean" || val === "regexp" || val === "uint" || val === "int" || val === "float" || val === "number")
          return true;
        return false;
      }
      getContext(ctx2) {
        return this.argument.getContext(ctx2);
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.argument.parser();
        this.expression.parser();
        this.expression.setRefBeUsed();
      }
    };
    module.exports = TypeTransformExpression;
  }
});

// lib/stacks/TypeTupleDefinition.js
var require_TypeTupleDefinition = __commonJS({
  "lib/stacks/TypeTupleDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var LiteralArrayType = require_LiteralArrayType();
    var TupleType = require_TupleType();
    var TypeTupleDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTypeTupleDefinition = true;
        this.prefix = this.createTokenStack(compilation, node.prefix, scope, node, this);
        this.elements = (node.elements || []).map((item2) => {
          const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          return stack2;
        });
      }
      freeze() {
        super.freeze();
        super.freeze(this.elements);
        this.prefix && this.prefix.freeze();
        this.elements.forEach((stack2) => stack2.freeze());
      }
      definition(ctx2) {
        const type2 = this.type();
        ctx2 = ctx2 || this.getContext();
        return {
          comments: this.comments,
          expre: `(type) ${type2.toString(ctx2)}`,
          location: (this.prefix || this).getLocation(),
          file: this.compilation.file
        };
      }
      description() {
        return this;
      }
      reference() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          const elem = this.prefix ? [this.prefix] : this.elements;
          if (elem.length > 0) {
            return new TupleType(
              this.getGlobalTypeById("Array"),
              elem,
              this
            );
          } else {
            return new LiteralArrayType(this.getGlobalTypeById("Array"), this, []);
          }
        });
      }
      async parser() {
        if (super.parser() === false)
          return false;
        if (this.prefix && this.elements.length > 0) {
          this.error(1086, this.prefix.raw());
        }
        this.prefix && await this.prefix.parser();
        this.allSettled(this.elements, async (item2) => await item2.parser());
        const restElement = this.elements.find((item2) => item2.restElement);
        if (restElement && restElement !== this.elements[this.elements.length - 1]) {
          this.error(1077);
        }
      }
    };
    module.exports = TypeTupleDefinition;
  }
});

// lib/stacks/TypeTupleRestDefinition.js
var require_TypeTupleRestDefinition = __commonJS({
  "lib/stacks/TypeTupleRestDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var TupleType = require_TupleType();
    var TypeTupleRestDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTypeTupleRestDefinition = true;
        this.argument = this.createTokenStack(compilation, node.value, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
      }
      definition(ctx2) {
        const type2 = this.type();
        ctx2 = ctx2 || this.getContext();
        if (type2.isModule) {
          return type2.definition(ctx2);
        }
        return {
          comments: this.comments,
          expre: `(type) ${type2.toString(ctx2)}`,
          location: this.argument.getLocation(),
          file: this.compilation.file
        };
      }
      error(code, ...args) {
        this.argument.error(code, ...args);
      }
      warn(code, ...args) {
        this.argument.warn(code, ...args);
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          return new TupleType(this.getGlobalTypeById("array"), this.argument.type(), this, true);
        });
      }
      parser() {
        return this.argument.parser();
      }
      value() {
        return this.argument.value();
      }
      raw() {
        return `...` + this.argument.raw();
      }
    };
    module.exports = TypeTupleRestDefinition;
  }
});

// lib/stacks/TypeTupleUnionDefinition.js
var require_TypeTupleUnionDefinition = __commonJS({
  "lib/stacks/TypeTupleUnionDefinition.js"(exports, module) {
    var TypeTupleDefinition = require_TypeTupleDefinition();
    var TypeTupleUnionDefinition = class extends TypeTupleDefinition {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTypeTupleUnionDefinition = true;
      }
      value() {
        return this.raw();
      }
      raw() {
        const elems = this.elements.map((item2) => item2.raw());
        return `(${elems.join(" | ")})[]`;
      }
    };
    module.exports = TypeTupleUnionDefinition;
  }
});

// lib/stacks/TypeTypeofDefinition.js
var require_TypeTypeofDefinition = __commonJS({
  "lib/stacks/TypeTypeofDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var TypeTypeofDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTypeTypeofDefinition = true;
        this.expression = this.createTokenStack(compilation, node.value, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.expression.freeze();
      }
      definition(ctx2) {
        ctx2 = ctx2 || this.getContext();
        return this.type().definition(ctx2);
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      type() {
        return this.getAttribute("type", () => {
          let type2 = this.expression.type();
          let origin = type2;
          type2 = Object.create(type2);
          type2.toString = function toString(ctx2, options) {
            if (ctx2) {
              return `typeof ${origin.toString(ctx2, options)}`;
            }
            return origin.toString(ctx2, options);
          };
          return type2;
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.expression.parser();
        const desc2 = this.expression.description();
        if (!desc2 || (desc2.isTypeDefinition || desc2.isGenericTypeDeclaration || desc2.isTypeStatement)) {
          this.expression.error(1083, this.expression.value());
        }
      }
      value() {
        return this.expression.value();
      }
      raw() {
        return this.expression.value();
      }
    };
    module.exports = TypeTypeofDefinition;
  }
});

// lib/stacks/TypeUnionDefinition.js
var require_TypeUnionDefinition = __commonJS({
  "lib/stacks/TypeUnionDefinition.js"(exports, module) {
    var Stack = require_Stack();
    var UnionType = require_UnionType();
    var TypeUnionDefinition = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isTypeUnionDefinition = true;
        this.elements = node.elements.map((item2) => {
          const stack2 = this.createTokenStack(compilation, item2, scope, node, this);
          return stack2;
        });
      }
      freeze() {
        super.freeze();
        super.freeze(this.elements);
        this.elements.forEach((stack2) => stack2.freeze());
      }
      definition(ctx2) {
        ctx2 = ctx2 || this.getContext();
        return this.type().definition(ctx2);
      }
      description() {
        return this;
      }
      referenceItems() {
        return [this];
      }
      setRefBeUsed() {
      }
      type() {
        return this.getAttribute("type", () => {
          if (this.elements.length > 1) {
            if (this.elements.some((stack2) => stack2.isTypeDefinition && stack2.argument.isIdentifier && stack2.argument.value() === "any")) {
              return this.getGlobalTypeById("any");
            } else {
              return new UnionType(this.elements, this);
            }
          } else {
            return this.elements[0].type();
          }
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.elements.forEach((item2) => item2.parser());
      }
      value() {
        const elements = this.elements.map((item2) => {
          return item2.value();
        });
        return `${elements.join("|")}`;
      }
      raw() {
        return this.value();
      }
    };
    module.exports = TypeUnionDefinition;
  }
});

// lib/stacks/UnaryExpression.js
var require_UnaryExpression = __commonJS({
  "lib/stacks/UnaryExpression.js"(exports, module) {
    var Expression = require_Expression();
    var UnaryExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isUnaryExpression = true;
        this.argument = this.createTokenStack(compilation, node.argument, scope, node, this);
        this.operator = node.operator;
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
      }
      definition() {
        return null;
      }
      description() {
        return this;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.argument.parser();
        this.argument.setRefBeUsed();
        const operator = this.node.operator;
        const code = operator.charCodeAt(0);
        if (code === 45 || code === 43) {
          const numberType = this.getGlobalTypeById("Number");
          const type2 = this.argument.type();
          if (type2 && !type2.isAnyType && !numberType.is(type2)) {
            this.error(1087, this.argument.raw());
          }
          return type2;
        }
      }
      value() {
        return super.raw();
      }
      type() {
        const operator = this.node.operator;
        const code = operator.charCodeAt(0);
        if (code === 33) {
          return this.getGlobalTypeById("boolean");
        }
        if (code === 45 || code === 43) {
          const numberType = this.getGlobalTypeById("Number");
          const type2 = this.argument.type();
          if (type2.isAnyType || !numberType.is(type2)) {
            return this.getGlobalTypeById("int");
          }
          return type2;
        }
        if (operator === "typeof") {
          return this.getGlobalTypeById("string");
        } else if (operator === "void") {
          return this.getGlobalTypeById("any");
        }
        return this.argument.type();
      }
    };
    module.exports = UnaryExpression;
  }
});

// lib/stacks/UpdateExpression.js
var require_UpdateExpression = __commonJS({
  "lib/stacks/UpdateExpression.js"(exports, module) {
    var Expression = require_Expression();
    var UpdateExpression = class extends Expression {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isUpdateExpression = true;
        this.argument = this.createTokenStack(compilation, node.argument, scope, node, this);
      }
      freeze() {
        super.freeze();
        this.argument.freeze();
      }
      definition() {
        return null;
      }
      description() {
        return this;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.argument.parser();
        this.argument.setRefBeUsed();
        const type2 = this.argument.type();
        const numberType = this.getGlobalTypeById("Number");
        if (type2 && !type2.isAnyType && !numberType.is(type2)) {
          this.error(1087, this.argument.raw());
        }
      }
      type(ctx2) {
        const numberType = this.getGlobalTypeById("Number");
        const type2 = this.argument.type(ctx2);
        if (type2.isAnyType || !numberType.is(type2)) {
          return this.getGlobalTypeById("int");
        }
        return this.argument.type(ctx2);
      }
    };
    module.exports = UpdateExpression;
  }
});

// lib/stacks/UseExtendSpecifier.js
var require_UseExtendSpecifier = __commonJS({
  "lib/stacks/UseExtendSpecifier.js"(exports, module) {
    var Namespace2 = require_Namespace();
    var Stack = require_Stack();
    var UseExtendSpecifier = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isUseExtendSpecifier = true;
        this.id = this.createTokenStack(compilation, node.id, scope, node, this);
        this.modifier = node.modifier.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
        this.genericity = null;
        if (node.genericity) {
          this.genericity = node.genericity.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
        }
        const id = this.id.value();
        if (id && !this.scope.isDefine(id) && !this.hasModuleById(id)) {
          if (this.compilation.hasManifestResource(id, Namespace2.dataset)) {
            this.compilation.hookAsync("compilation.create.after", async () => {
              await this.loadTypeAsync(id);
            });
          }
        }
      }
      freeze() {
        super.freeze(this);
        super.freeze(this.id);
        (this.genericity || []).forEach((stack2) => stack2.freeze());
        this.modifier.forEach((stack2) => stack2.freeze());
      }
      definition(context) {
        return null;
      }
      description() {
        return this.getModuleById(this.id.value());
      }
      value() {
        return this.id.value();
      }
      parser() {
        if (super.parser() === false)
          return false;
        const classType = this.getModuleById(this.id.value());
        if (classType) {
          this.parserDescriptor(classType);
          const assignments = this.genericity;
          if (assignments && assignments.length > 0) {
            this.parentStack.parentStack.genericsCheck(classType, assignments, this.id);
          }
        } else {
          this.error(1026, this.id.value());
        }
      }
    };
    module.exports = UseExtendSpecifier;
  }
});

// lib/stacks/UseExtendStatement.js
var require_UseExtendStatement = __commonJS({
  "lib/stacks/UseExtendStatement.js"(exports, module) {
    var Stack = require_Stack();
    var UseExtendStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isUseExtendStatement = true;
        this.isUseStatement = true;
        this.body = node.body.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
        this.keywords = node.keywords.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
        this.extends = node.extends.map((item2) => this.createTokenStack(compilation, item2, scope, node, this));
      }
      freeze() {
        super.freeze(this);
        this.body.forEach((stack2) => stack2.freeze());
        this.keywords.forEach((stack2) => stack2.freeze());
        this.extends.forEach((stack2) => stack2.freeze());
      }
      definition(context) {
        return null;
      }
      description() {
        return null;
      }
      async createCompleted() {
        const methods = {};
        const dynamic = [];
        const methodItems = [];
        await Promise.allSettled(this.extends.map((stack2) => this.loadTypeAsync(stack2.id.value())));
        this.body.forEach((item2) => {
          if (item2.isMethodDefinition) {
            if (item2.dynamicType) {
              dynamic.push(item2);
            } else {
              methods[item2.key.value()] = item2;
            }
          } else if (item2.isPropertyDefinition) {
            if (item2.dynamic) {
              dynamic.push(item2);
            } else {
              methods[item2.key.value()] = item2;
            }
          }
          methodItems.push(item2);
        });
        const _extends = [];
        this.extends.forEach((item2) => {
          const modifier = item2.modifier.map((item3) => item3.value().toLowerCase());
          _extends.push({
            module: item2.description(),
            mode: modifier.find((item3) => item3 === "prototype" || item3 === "class"),
            modifier: modifier.filter((item3) => !(item3 === "prototype" || item3 === "class"))
          });
        });
        this.keywords.forEach((item2) => {
          const isStatic = item2.value().toLowerCase() === "static";
          const target = isStatic ? this.module.callMethods : this.module.callMembers;
          if (isStatic) {
            methodItems.forEach((item3) => {
              item3.callableStatic = true;
            });
          }
          target.push({
            isUseExtendStatement: true,
            extends: _extends,
            callableStatic: isStatic,
            dynamic,
            methods
          });
        });
        methodItems.forEach((item2) => {
          this.module.addDescriptor(item2.value(), item2);
        });
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.extends.forEach((item2) => {
          item2.parser();
        });
        this.body.forEach((item2) => {
          item2.parser();
        });
      }
      value() {
        return this.classType.value();
      }
    };
    module.exports = UseExtendStatement;
  }
});

// lib/stacks/VariableDeclaration.js
var require_VariableDeclaration = __commonJS({
  "lib/stacks/VariableDeclaration.js"(exports, module) {
    var Stack = require_Stack();
    var VariableDeclaration = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isVariableDeclaration = true;
        this.kind = node.kind;
        this.declarations = node.declarations.map((item2) => {
          return this.createTokenStack(compilation, item2, scope, node, this);
        });
        this.flag = false;
        switch (parentNode && parentNode.type) {
          case "ForStatement":
          case "ForInStatement":
          case "ForOfStatement":
            this.flag = true;
            break;
        }
        if (!(this.parentStack.isExportNamedDeclaration || this.parentStack.isExportDefaultDeclaration)) {
          this.compilation.hookAsync("compilation.parser.after", async () => {
            this.declarations.forEach((decl) => {
              if (decl.id.isObjectPattern) {
                decl.id.properties.forEach((decl2) => {
                  if (!decl2.init.useRefItems.size) {
                    decl2.init.unnecessary(1183, decl2.init.value());
                  }
                });
              } else if (decl.id.isArrayPattern) {
                decl.id.elements.forEach((decl2) => {
                  if (!decl2.useRefItems.size) {
                    decl2.unnecessary(1183, decl2.value());
                  }
                });
              } else if (!decl.useRefItems.size) {
                decl.id.unnecessary(1183, decl.value());
              }
            });
          });
        }
      }
      freeze() {
        super.freeze();
        super.freeze(this.declarations);
        this.declarations.forEach((stack2) => stack2.freeze());
      }
      definition() {
        return null;
      }
      reference() {
        return this.declarations[0].reference();
      }
      referenceItems() {
        return this.declarations[0].referenceItems();
      }
      value() {
        return this.declarations[0].value();
      }
      raw() {
        return this.declarations[0].raw();
      }
      warn(code, ...args) {
        this.declarations[0].warn(code, ...args);
      }
      error(code, ...args) {
        this.declarations[0].error(code, ...args);
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.declarations.forEach((item2) => item2.parser());
      }
    };
    module.exports = VariableDeclaration;
  }
});

// lib/stacks/VariableDeclarator.js
var require_VariableDeclarator = __commonJS({
  "lib/stacks/VariableDeclarator.js"(exports, module) {
    var Declarator = require_Declarator();
    var VariableDeclarator = class extends Declarator {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isVariableDeclarator = true;
        this.kind = parentNode.kind;
        this.id = this.createTokenStack(compilation, node.id, scope, node, this);
        const init = this.createTokenStack(compilation, node.init, scope, node, this);
        this.dynamic = !!node.dynamic;
        this.init = init;
        this._acceptType = this.createTokenStack(compilation, node.acceptType, scope, node, this);
        if (this.dynamic && this.parentStack.isPropertyDefinition) {
          this.dynamicKeyType = this.createTokenStack(compilation, node.id.acceptType, scope, node, this) || this.getGlobalTypeById("string");
        }
        this.question = !!node.question;
        this.isPattern = false;
        if (parentStack && !parentStack.isDeclaratorProperty) {
          if (this.id.isIdentifier) {
            if (this.init) {
              this.assignItems.add(this.init);
              this.assignValue = this.init;
              this.assignFirstValue = this.init;
            }
            if (!parentStack.isDeclaratorVariable && !parentStack.isPropertyDefinition) {
              const context = this.kind === "var" ? "function" : "block";
              const name = this.id.value();
              if (scope.isDefine(name, context)) {
                this.error(1007, this.value());
              }
              scope.define(name, this);
            }
          } else if (this.id.isObjectPattern || this.id.isArrayPattern) {
            this.isPattern = true;
            this.id.setKind(this.kind);
          }
        }
      }
      freeze() {
        super.freeze();
        this.id.freeze();
        this.acceptType && this.acceptType.freeze();
        this.init && this.init.freeze();
      }
      type() {
        const type2 = super.type();
        if (this.parentStack.flag && type2 === this.getGlobalTypeById("any")) {
          if (this.parentStack.parentStack.isForInStatement) {
            return this.getGlobalTypeById("string");
          } else if (this.parentStack.parentStack.isForOfStatement) {
            return this.parentStack.parentStack.forOfType();
          }
        }
        return type2;
      }
      definition(ctx2) {
        if (!ctx2 || !ctx2.isContext) {
          if (this.parentStack.parentStack.isForOfStatement) {
            ctx2 = this.getContext();
          } else {
            ctx2 = this.getContext();
          }
        }
        const type2 = this.type().toString(ctx2);
        const identifier = this.id.value();
        var token = this.parentStack.isPropertyDefinition ? `${this.module.id}.${identifier}` : identifier;
        if (this.dynamic && this.parentStack.isPropertyDefinition) {
          if (this.init && this.init.isTypeDefinition) {
            token = `${this.module.id}[${identifier}:${this.acceptType.type().toString(ctx2)}]`;
          } else {
            token = `${this.module.id}[${identifier}]`;
          }
        }
        const expre = this.parentStack.isPropertyDefinition ? `${this.kind || ""} ${token}:${type2}` : `(local ${this.kind}) ${token}:${type2}`;
        return {
          comments: this.parentStack.comments,
          expre,
          location: this.id.getLocation(),
          file: this.compilation.file
        };
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.init) {
          this.init.parser();
          if (!(this.init.isNewExpression || this.init.isCallExpression)) {
            this.init.setRefBeUsed();
          }
        }
        if (this.id.isObjectPattern || this.id.isArrayPattern) {
          this.id.parser();
        }
        if (!this.dynamic) {
          if (this.module && this.module.id === this.value()) {
            this.id.error(1008, this.id.value());
          }
          if (this.init) {
            if (!(this.init.isLiteral && this.init.value() === null)) {
              const acceptType = this.acceptType;
              if (acceptType) {
                const atype = acceptType.type();
                if (atype) {
                  const isEmptyObject = atype.isLiteralObjectType && this.init.isObjectExpression && this.init.properties.length === 0 || atype.isLiteralArrayType && this.init.isArrayExpression && this.init.elements.length === 0;
                  if (!isEmptyObject) {
                    this.checkExpressionType(acceptType, this.init, null, this.getContext());
                  }
                }
              }
              const description = this.init.description();
              if (this === description) {
                this.error(1010, this.init.value());
              }
            }
          }
        } else if (!this.parentStack.isPropertyDefinition) {
          this.id.parser();
        }
      }
      value() {
        return this.id.value();
      }
      raw() {
        return this.id.raw();
      }
      error(code, ...args) {
        this.id.error(code, ...args);
      }
      warn(code, ...args) {
        this.id.warn(code, ...args);
      }
    };
    module.exports = VariableDeclarator;
  }
});

// lib/stacks/WhenStatement.js
var require_WhenStatement = __commonJS({
  "lib/stacks/WhenStatement.js"(exports, module) {
    var Stack = require_Stack();
    var BlockScope = require_BlockScope();
    var WhenStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isWhenStatement = true;
        this.condition = this.createTokenStack(compilation, node.test, scope, node, this);
        this.consequent = this.createTokenStack(compilation, node.consequent, new BlockScope(scope), node, this);
        this.alternate = this.createTokenStack(compilation, node.alternate, new BlockScope(scope), node, this);
      }
      freeze() {
        super.freeze();
        this.condition.freeze();
        this.consequent.freeze();
        this.alternate.freeze();
      }
      definition() {
        return null;
      }
      parser() {
        if (super.parser() === false)
          return false;
        this.consequent.parser();
        this.consequent.setRefBeUsed();
        this.alternate && this.alternate.parser();
        if (this.condition && this.condition.isCallExpression) {
          const name = this.condition.callee.value();
          const methods = this.compiler.options.metaStatementMethods || [];
          if (methods.length > 0 && !methods.includes(name)) {
            this.condition.error(1165, name, methods.join(","));
          }
        } else {
          this.condition.error(1006, this.condition.value());
        }
      }
    };
    module.exports = WhenStatement;
  }
});

// lib/stacks/WhileStatement.js
var require_WhileStatement = __commonJS({
  "lib/stacks/WhileStatement.js"(exports, module) {
    var Stack = require_Stack();
    var WhileStatement = class extends Stack {
      constructor(compilation, node, scope, parentNode, parentStack) {
        super(compilation, node, scope, parentNode, parentStack);
        this.isWhileStatement = true;
        this.condition = this.createTokenStack(compilation, node.test, scope, node, this);
        this.body = this.createTokenStack(compilation, node.body, scope, node, this);
      }
      definition() {
        return null;
      }
      freeze() {
        super.freeze();
        this.condition.freeze();
        this.body.freeze();
      }
      parser() {
        if (super.parser() === false)
          return false;
        if (this.condition) {
          this.condition.parser();
          this.condition.setRefBeUsed();
          const desc2 = this.condition.description();
          if (desc2.isLiteral && desc2.value()) {
            const find = (body) => {
              if (!body)
                return false;
              return body.some((item2) => {
                if (item2.isReturnStatement || item2.isBreakStatement) {
                  return true;
                }
                if (item2.isIfStatement || item2.isWhenStatement) {
                  if (item2.consequent)
                    return find(item2.consequent.body);
                  if (item2.alternate)
                    return find(item2.alternate.body);
                } else if (item2.isSwitchStatement) {
                  return find(item2.cases);
                } else if (item2.isSwitchCase) {
                  return find(item2.consequent);
                } else if (item2.isWhileStatement) {
                  return find(item2.body.body);
                } else if (item2.isForInStatement || item2.isForOfStatement || item2.isForStatement) {
                  return find(item2.body.body);
                }
                return false;
              });
            };
            if (!find(this.body.body)) {
              this.condition.warn(1042);
            }
          }
        } else {
          return this.error(1041);
        }
        this.body && this.body.parser();
      }
    };
    module.exports = WhileStatement;
  }
});

// lib/tokens.js
var require_tokens = __commonJS({
  "lib/tokens.js"(exports, module) {
    var tokens = {};
    var Stack = require_Stack();
    var create = function(compilation, node, scope, parentNode, parentStack) {
      if (!node) {
        return null;
      }
      switch (node.type) {
        case "MethodDefinition":
          if (node.kind === "get") {
            return new tokens.MethodGetterDefinition(compilation, node, scope, parentNode, parentStack);
          } else if (node.kind === "set") {
            return new tokens.MethodSetterDefinition(compilation, node, scope, parentNode, parentStack);
          }
          return new tokens.MethodDefinition(compilation, node, scope, parentNode, parentStack);
        case "Super":
          return new tokens.SuperExpression(compilation, node, scope, parentNode, parentStack);
        default:
          const stackClass = tokens[node.type];
          if (stackClass) {
            return new stackClass(compilation, node, scope, parentNode, parentStack);
          } else {
            throw new Error(`Unrecognized token '${node.type}'`);
          }
      }
    };
    tokens.AnnotationDeclaration = require_AnnotationDeclaration();
    tokens.AnnotationExpression = require_AnnotationExpression();
    tokens.ArrayExpression = require_ArrayExpression();
    tokens.ArrayPattern = require_ArrayPattern();
    tokens.ArrowFunctionExpression = require_ArrowFunctionExpression();
    tokens.AssignmentExpression = require_AssignmentExpression();
    tokens.AssignmentPattern = require_AssignmentPattern();
    tokens.AwaitExpression = require_AwaitExpression();
    tokens.BinaryExpression = require_BinaryExpression();
    tokens.BlockStatement = require_BlockStatement();
    tokens.BreakStatement = require_BreakStatement();
    tokens.CallDefinition = require_CallDefinition();
    tokens.CallExpression = require_CallExpression();
    tokens.ClassDeclaration = require_ClassDeclaration();
    tokens.ConditionalExpression = require_ConditionalExpression();
    tokens.ContinueStatement = require_ContinueStatement();
    tokens.Declarator = require_Declarator();
    tokens.DeclaratorDeclaration = require_DeclaratorDeclaration();
    tokens.DeclaratorFunction = require_DeclaratorFunction();
    tokens.DeclaratorTypeAlias = require_DeclaratorTypeAlias();
    tokens.DeclaratorVariable = require_DeclaratorVariable();
    tokens.DoWhileStatement = require_DoWhileStatement();
    tokens.EmptyStatement = require_EmptyStatement();
    tokens.EnumDeclaration = require_EnumDeclaration();
    tokens.EnumProperty = require_EnumProperty();
    tokens.ExportAllDeclaration = require_ExportAllDeclaration();
    tokens.ExportDefaultDeclaration = require_ExportDefaultDeclaration();
    tokens.ExportNamedDeclaration = require_ExportNamedDeclaration();
    tokens.ExportSpecifier = require_ExportSpecifier();
    tokens.Expression = require_Expression();
    tokens.ExpressionStatement = require_ExpressionStatement();
    tokens.ForInStatement = require_ForInStatement();
    tokens.ForOfStatement = require_ForOfStatement();
    tokens.ForStatement = require_ForStatement();
    tokens.FunctionDeclaration = require_FunctionDeclaration();
    tokens.FunctionExpression = require_FunctionExpression();
    tokens.GenericDeclaration = require_GenericDeclaration();
    tokens.GenericTypeAssignmentDeclaration = require_GenericTypeAssignmentDeclaration();
    tokens.GenericTypeDeclaration = require_GenericTypeDeclaration();
    tokens.Identifier = require_Identifier();
    tokens.IfStatement = require_IfStatement();
    tokens.ImportDeclaration = require_ImportDeclaration();
    tokens.ImportDefaultSpecifier = require_ImportDefaultSpecifier();
    tokens.ImportExpression = require_ImportExpression();
    tokens.ImportNamespaceSpecifier = require_ImportNamespaceSpecifier();
    tokens.ImportSpecifier = require_ImportSpecifier();
    tokens.InterfaceDeclaration = require_InterfaceDeclaration();
    tokens.JSXAttribute = require_JSXAttribute();
    tokens.JSXCdata = require_JSXCdata();
    tokens.JSXClosingElement = require_JSXClosingElement();
    tokens.JSXClosingFragment = require_JSXClosingFragment();
    tokens.JSXElement = require_JSXElement();
    tokens.JSXEmptyExpression = require_JSXEmptyExpression();
    tokens.JSXExpressionContainer = require_JSXExpressionContainer();
    tokens.JSXFragment = require_JSXFragment();
    tokens.JSXIdentifier = require_JSXIdentifier();
    tokens.JSXMemberExpression = require_JSXMemberExpression();
    tokens.JSXNamespacedName = require_JSXNamespacedName();
    tokens.JSXOpeningElement = require_JSXOpeningElement();
    tokens.JSXOpeningFragment = require_JSXOpeningFragment();
    tokens.JSXScript = require_JSXScript();
    tokens.JSXSpreadAttribute = require_JSXSpreadAttribute();
    tokens.JSXStyle = require_JSXStyle();
    tokens.JSXText = require_JSXText();
    tokens.LabeledStatement = require_LabeledStatement();
    tokens.Literal = require_Literal();
    tokens.LogicalExpression = require_LogicalExpression();
    tokens.MemberExpression = require_MemberExpression();
    tokens.MetatypeDeclaration = require_MetatypeDeclaration();
    tokens.MethodDefinition = require_MethodDefinition();
    tokens.MethodGetterDefinition = require_MethodGetterDefinition();
    tokens.MethodSetterDefinition = require_MethodSetterDefinition();
    tokens.ModifierDeclaration = require_ModifierDeclaration();
    tokens.ModuleDeclaration = require_ModuleDeclaration();
    tokens.NewDefinition = require_NewDefinition();
    tokens.NewExpression = require_NewExpression();
    tokens.ObjectExpression = require_ObjectExpression();
    tokens.ObjectPattern = require_ObjectPattern();
    tokens.PackageDeclaration = require_PackageDeclaration();
    tokens.ParenthesizedExpression = require_ParenthesizedExpression();
    tokens.Program = require_Program();
    tokens.Property = require_Property();
    tokens.PropertyDefinition = require_PropertyDefinition();
    tokens.RestElement = require_RestElement();
    tokens.ReturnStatement = require_ReturnStatement();
    tokens.SequenceExpression = require_SequenceExpression();
    tokens.SpreadElement = require_SpreadElement();
    tokens.StructTableColumnDefinition = require_StructTableColumnDefinition();
    tokens.StructTableDeclaration = require_StructTableDeclaration();
    tokens.StructTableKeyDefinition = require_StructTableKeyDefinition();
    tokens.StructTableMethodDefinition = require_StructTableMethodDefinition();
    tokens.StructTablePropertyDefinition = require_StructTablePropertyDefinition();
    tokens.SuperExpression = require_SuperExpression();
    tokens.SwitchCase = require_SwitchCase();
    tokens.SwitchStatement = require_SwitchStatement();
    tokens.TemplateElement = require_TemplateElement();
    tokens.TemplateLiteral = require_TemplateLiteral();
    tokens.ThisExpression = require_ThisExpression();
    tokens.ThrowStatement = require_ThrowStatement();
    tokens.TryStatement = require_TryStatement();
    tokens.TypeAssertExpression = require_TypeAssertExpression();
    tokens.TypeComputeDefinition = require_TypeComputeDefinition();
    tokens.TypeDefinition = require_TypeDefinition();
    tokens.TypeFunctionDefinition = require_TypeFunctionDefinition();
    tokens.TypeGenericDefinition = require_TypeGenericDefinition();
    tokens.TypeIntersectionDefinition = require_TypeIntersectionDefinition();
    tokens.TypeKeyofDefinition = require_TypeKeyofDefinition();
    tokens.TypeObjectDefinition = require_TypeObjectDefinition();
    tokens.TypeObjectPropertyDefinition = require_TypeObjectPropertyDefinition();
    tokens.TypeStatement = require_TypeStatement();
    tokens.TypeTransformExpression = require_TypeTransformExpression();
    tokens.TypeTupleDefinition = require_TypeTupleDefinition();
    tokens.TypeTupleRestDefinition = require_TypeTupleRestDefinition();
    tokens.TypeTupleUnionDefinition = require_TypeTupleUnionDefinition();
    tokens.TypeTypeofDefinition = require_TypeTypeofDefinition();
    tokens.TypeUnionDefinition = require_TypeUnionDefinition();
    tokens.UnaryExpression = require_UnaryExpression();
    tokens.UpdateExpression = require_UpdateExpression();
    tokens.UseExtendSpecifier = require_UseExtendSpecifier();
    tokens.UseExtendStatement = require_UseExtendStatement();
    tokens.VariableDeclaration = require_VariableDeclaration();
    tokens.VariableDeclarator = require_VariableDeclarator();
    tokens.WhenStatement = require_WhenStatement();
    tokens.WhileStatement = require_WhileStatement();
    for (name in tokens) {
      tokens[name].prototype.toString = function(name2) {
        return function() {
          return name2;
        };
      }(name);
    }
    var name;
    Stack.create = create;
    module.exports = { "tokens": tokens, "create": create };
  }
});

// lib/core/Compilation.js
var require_Compilation = __commonJS({
  "lib/core/Compilation.js"(exports, module) {
    var fs = __require("fs");
    var path = __require("path");
    var TopScope = require_TopScope();
    var Parser = require_Parser();
    var Namespace2 = require_Namespace();
    var Module = require_Module();
    var Lang = require_Lang();
    var Utils2 = require_Utils();
    var Diagnostic = require_Diagnostic();
    var Range = require_Range();
    var EventDispatcher = require_EventDispatcher();
    var Constant = require_Constant();
    var Tokens = require_tokens();
    var symbolKey = Symbol("key");
    var PARSER_TAG_REGEXP = /(?<=(?:[\s\r\n]+|^)\/\/\/)<(scope|reference)\s+(.*?)\/\>/ig;
    var PARSER_TAG_ATTR_REGEXP = /\b(name|inherits|file|isDir)[\s+]?=[\s+]?([\'\"])([^\2]*?)\2/g;
    var SortedMap = {
      "manifest": -5,
      "reference": -5,
      "scans": -5
    };
    var Compilation = class extends EventDispatcher {
      constructor(compiler, file) {
        super();
        this.compiler = compiler;
        this.modules = /* @__PURE__ */ new Map();
        this.stacks = /* @__PURE__ */ new Map();
        this._namespace = null;
        this.namespaceSets = /* @__PURE__ */ new Set();
        this.children = [];
        this.parent = null;
        this.scope = new TopScope(null);
        this.stack = null;
        this.ast = null;
        this.isMain = false;
        this.errors = [];
        this.mtime = null;
        this.file = file;
        this.import = null;
        this.dependencies = /* @__PURE__ */ new Set();
        this.dependencyCompilations = /* @__PURE__ */ new Set();
        this.assets = /* @__PURE__ */ new Map();
        this.requires = /* @__PURE__ */ new Map();
        this.originId = null;
        this.originFile = null;
        this.source = "";
        this.JSX = false;
        this.stackCreating = false;
        this.mainModule = null;
        this[symbolKey] = {
          policy: Constant.POLICY_NONE,
          building: false,
          waitCallback: [],
          waiting: [],
          completed: {},
          hooks: {},
          parserDoneFlag: false
        };
        this.jsxStyles = [];
        this.jsxElements = [];
        this.pluginScopes = /* @__PURE__ */ Object.create(null);
        this.referenceStacks = /* @__PURE__ */ new Set();
        this.referenceCompilations = /* @__PURE__ */ new Set();
        this.namespace = Namespace2.dataset;
        this.loadDependencies = /* @__PURE__ */ new Set();
        this.isGlobalFlag = false;
        this.isDestroyed = false;
        this.emitComments = [];
      }
      hookAsync(name, callback) {
        const hooks = this[symbolKey].hooks;
        const items = hooks[name] || (hooks[name] = []);
        items.push(callback);
      }
      async callHookAsync(name) {
        const hooks = this[symbolKey].hooks;
        const queues = hooks[name] || (hooks[name] = []);
        try {
          const items = queues.splice(0, queues.length);
          await Promise.allSettled(items.map((callback) => callback()));
        } catch (e) {
          console.error(e);
        }
      }
      get isDescriptionType() {
        return this.isDescriptorDocument();
      }
      setPluginScopes(scopes) {
        if (!this.pluginScopes.scope) {
          this.pluginScopes.scope = scopes.scope;
        }
        if (scopes.inherits && Array.isArray(scopes.inherits) && scopes.inherits.length > 0) {
          const old = this.pluginScopes.inherits;
          if (!old) {
            this.pluginScopes.inherits = scopes.inherits.slice(0);
          } else {
            scopes.inherits.forEach((name) => {
              if (!old.includes(name)) {
                old.push(name);
              }
            });
          }
        }
      }
      isDescriptorDocument(isGlobal) {
        if (this[symbolKey].isDescriptorFlag != null) {
          return this[symbolKey].isDescriptorFlag;
        }
        let result = false;
        if (this.file) {
          if (isGlobal && this.pluginScopes.scope !== "global") {
            result = false;
          } else {
            let pattern = this.compiler.options.describePattern;
            if (!pattern) {
              pattern = /(\.d\.es)$/;
            }
            result = pattern.test(this.file);
          }
        }
        return this[symbolKey].isDescriptorFlag = result;
      }
      isLocalDocument() {
        if (this.pluginScopes.scope === "local") {
          return true;
        }
        if (this[symbolKey].isLocalFlag == null) {
          return this[symbolKey].isLocalFlag = String(this.file).toLowerCase().includes(String(this.compiler.workspace).toLowerCase());
        }
        return this[symbolKey].isLocalFlag;
      }
      isGlobalDocument() {
        return this.compiler.globals.has(this);
      }
      addReferenceStack(stack2) {
        if (stack2 && stack2.isStack && stack2.compilation !== this) {
          this.referenceStacks.add(stack2);
        }
      }
      set namespace(value) {
        this.namespaceSets.add(value);
        this._namespace = value;
      }
      get namespace() {
        return this._namespace;
      }
      completed(plugin, value) {
        if (!plugin || typeof plugin.platform !== "string") {
          throw new Error("Invalid plugin instanced.");
        }
        const key = plugin.name + ":" + plugin.platform;
        if (value !== void 0) {
          this[symbolKey].completed[key] = value;
        }
        return !!this[symbolKey].completed[key];
      }
      get policy() {
        return this[symbolKey].policy;
      }
      setPolicy(policy, module2) {
        if ((Constant.POLICY_ALL & policy) === policy) {
          if (module2) {
            module2.policy = policy;
          } else {
            this[symbolKey].policy = policy;
            this.modules.forEach((module3) => {
              module3.policy = policy;
            });
          }
        }
      }
      isPolicy(policy, module2) {
        const value = module2 ? module2.policy : this.policy;
        return (value & policy) === value;
      }
      isServerPolicy(module2, explicit = false) {
        if (!module2)
          return false;
        if (module2 && !module2.isModule)
          return !explicit;
        const value = module2 ? module2.policy : this.policy;
        if (value === Constant.POLICY_ALL) {
          return true;
        } else if (!explicit && value === Constant.POLICY_NONE) {
          if (module2 && module2.inherit) {
            return this.isServerPolicy(module2.inherit);
          } else {
            return true;
          }
        }
        return (value & Constant.POLICY_SERVER) === value;
      }
      setServerPolicy(module2) {
        this.setPolicy(Constant.POLICY_SERVER, module2);
      }
      isClientPolicy(module2, explicit = false) {
        if (!module2)
          return false;
        const value = module2 ? module2.policy : this.policy;
        if (module2 && !module2.isModule)
          return !explicit;
        if (value === Constant.POLICY_ALL) {
          return true;
        } else if (!explicit && value === Constant.POLICY_NONE) {
          if (module2 && module2.inherit) {
            return this.isClientPolicy(module2.inherit);
          } else {
            return true;
          }
        }
        return (value & Constant.POLICY_CLIENT) === value;
      }
      setClientPolicy(module2) {
        this.setPolicy(Constant.POLICY_CLIENT, module2);
      }
      addStack(stack2) {
        if (stack2.node.start > 0) {
          this.stacks.set(stack2.node.start, stack2);
        }
      }
      checkDescriptor(descriptor, document) {
        if (desc && desc.compilation) {
          const ctx2 = module || this;
          if (desc.compilation === this || desc === module)
            return true;
          const scopes = desc.compilation.pluginScopes;
          if (scopes && scopes.scope !== "global") {
            const plugin = this.compiler.pluginInstances.find((plugin2) => this.compiler.isMatchPluginNameOf(plugin2.name, scopes));
            if (plugin) {
              return this.compiler.isPluginInContext(plugin, ctx2);
            }
          }
        }
        return true;
      }
      addDependency(dep, module2) {
        if (dep && dep !== this) {
          if (module2 && module2.isModule) {
            module2.addDepend(dep);
            if (dep.isModule && dep.compilation && dep.compilation !== this) {
              dep.compilation.referenceCompilations.add(this);
              this.dependencyCompilations.add(dep.compilation);
            } else if (dep instanceof Compilation) {
              dep.referenceCompilations.add(this);
              this.dependencyCompilations.add(dep);
            }
          } else {
            dep.used = true;
            this.dependencies.add(dep);
            if (dep.isModule && dep.compilation && dep.compilation !== this) {
              dep.compilation.referenceCompilations.add(this);
              this.dependencyCompilations.add(dep.compilation);
            } else if (dep instanceof Compilation) {
              dep.referenceCompilations.add(this);
              this.dependencyCompilations.add(dep);
            }
          }
        }
      }
      addAsset(resolve, file, content, type2, assign, attrs = null, stack2 = null) {
        if (!this.assets.has(resolve)) {
          this.assets.set(resolve, { file, resolve, content, type: type2, assign, id: null, index: this.assets.size, attrs, stack: stack2 });
          return true;
        }
        return false;
      }
      addRequire(key, name, from, resolve, extract, stack2 = null) {
        if (!this.requires.has(name)) {
          this.requires.set(name, { key, name, from, resolve, extract, stack: stack2, id: null, index: this.requires.size });
          return true;
        }
        return false;
      }
      getDependencies(module2) {
        if (module2 && module2.isModule) {
          return Array.from(module2.dependencies.values());
        }
        return Array.from(this.dependencies.values());
      }
      getCompilationsOfDependency() {
        return this.dependencyCompilations;
      }
      getStackByAt(startAt, tryNum = 3, both = 0) {
        let stack2 = this.stacks.get(startAt);
        if (!stack2) {
          let offset = 0;
          if (tryNum < 0) {
            tryNum = both === 0 ? this.stacks.size / 2 : this.stacks.size;
          }
          while (!stack2 && offset < tryNum) {
            offset++;
            if (both === 0) {
              stack2 = this.stacks.get(startAt - offset) || this.stacks.get(startAt + offset);
            } else if (both < 0) {
              stack2 = this.stacks.get(startAt - offset);
            } else if (both > 0) {
              stack2 = this.stacks.get(startAt + offset);
            }
          }
        }
        return stack2;
      }
      addModuleStack(module2, stack2) {
        if (module2 && module2.isModule) {
          module2.moduleStack = stack2;
        }
      }
      getStackByModule(module2) {
        if (module2 && module2.isModule) {
          return module2.moduleStack;
        }
        return null;
      }
      hasSameDiagnostic(node, code, range = null, kind = 0) {
        return this.errors.some((error) => {
          if (this.file === error.file && error.code === code && error.kind === kind) {
            if (range) {
              if (range.start.line === error.range.start.line && range.end.line === error.range.end.line) {
                return range.end.column === error.range.end.column;
              }
            } else if (node.loc && typeof node.loc.start === "object") {
              if (node.loc.start.line === error.range.start.line && node.loc.end.line === error.range.end.line) {
                return node.loc.start.column === error.range.end.column;
              }
            }
          }
        });
      }
      error(node, code, ...args) {
        const range = this.getRangeByNode(node);
        if (this.hasSameDiagnostic(node, code, range, 0)) {
          return;
        }
        const message = Diagnostic.getMessage(code, args);
        const error = new Diagnostic(this.file, message, range, Diagnostic.ERROR, node, code);
        if (this.compiler.options.debug) {
          Utils2.debug(error.toString());
          if (node instanceof Error) {
            console.log(node);
          }
        }
        if (this.compiler.options.diagnose) {
          this.errors.push(error);
          this.compiler.errors.push(error);
        } else if (!this.compiler.options.debug) {
          Utils2.error(error.toString());
        }
      }
      warn(node, code, ...args) {
        const range = this.getRangeByNode(node);
        if (this.hasSameDiagnostic(node, code, range, 1)) {
          return;
        }
        const message = Diagnostic.getMessage(code, args);
        const warn = new Diagnostic(this.file, message, range, Diagnostic.WARN, node, code);
        if (this.compiler.options.debug) {
          Utils2.debug(warn.toString());
          if (node instanceof Error) {
            console.log(node);
          }
        }
        if (this.compiler.options.diagnose) {
          this.errors.push(warn);
          this.compiler.errors.push(warn);
        } else if (!this.compiler.options.debug) {
          Utils2.warn(warn.toString());
        }
      }
      deprecated(node, code, ...args) {
        const range = this.getRangeByNode(node);
        if (this.hasSameDiagnostic(node, code, range, 2)) {
          return;
        }
        const message = Diagnostic.getMessage(code, args);
        const warn = new Diagnostic(this.file, message, range, Diagnostic.DEPRECATED, node, code);
        if (this.compiler.options.diagnose) {
          this.errors.push(warn);
          this.compiler.errors.push(warn);
        }
      }
      unnecessary(node, code, ...args) {
        const range = this.getRangeByNode(node);
        if (this.hasSameDiagnostic(node, code, range, Diagnostic.UNNECESSARY)) {
          return;
        }
        const message = Diagnostic.getMessage(code, args);
        const warn = new Diagnostic(this.file, message, range, Diagnostic.UNNECESSARY, node, code);
        if (this.compiler.options.diagnose) {
          this.errors.push(warn);
          this.compiler.errors.push(warn);
        }
      }
      getReference(key, target, isStatic, kind = null) {
        if (target && target instanceof Module) {
          if (isStatic) {
            return target.getMethod(key, kind);
          }
          return target.getMember(key, kind);
        } else if (target instanceof Namespace2) {
          return target.get(key);
        }
        return !target ? this.getModuleById(key) : null;
      }
      getDescriptor(key, target, filter) {
        if (target && target instanceof Module) {
          return target.getDescriptor(key, filter);
        } else if (target instanceof Namespace2) {
          return target.get(key);
        }
        return !target ? this.getModuleById(key) : null;
      }
      getRangeByNode(node) {
        if (node.loc) {
          if (node.loc.start && node.loc.end) {
            return new Range(node.loc.start, node.loc.end);
          } else {
            return new Range(node.loc, Object.assign({}, node.loc, { column: node.loc.column + (node.raisedAt - node.pos) }));
          }
        }
        const str = this.source.substring(0, node.start + 1);
        const lines = str.split(/\r\n/);
        const startLineText = lines.length > 0 ? lines[lines.length - 1] : str;
        const column = node.start - (str.length - startLineText.length);
        const start = { line: lines.length, column };
        const endStr = this.source.substring(node.start, node.end + 1);
        const endLines = endStr.split(/\r\n/);
        const endLineText = endLines.length > 0 ? endLines[endLines.length - 1] : endStr;
        const endColumn = node.end - (endStr.length - endLineText.length);
        const end = { line: endLines.length + lines.length, column: endColumn };
        return new Range(start, end);
      }
      getTypeValue(type2, isLoadDependency = false) {
        if (isLoadDependency && type2 && (type2.isType || type2.isStack)) {
          const compilation = type2.compilation;
          if (compilation instanceof Compilation && !compilation.parserDoneFlag) {
            this.loadDependencies.add(compilation);
          }
        }
        if (type2 && !type2.isType && type2.isStack) {
          if (type2.isDeclaratorFunction || type2.isDeclaratorVariable) {
            return type2;
          }
          return type2.type();
        }
        return type2;
      }
      getTypeById(id) {
        if (this.modules.has(id)) {
          return this.getTypeValue(this.modules.get(id));
        }
        return Namespace2.globals.get(id);
      }
      getGlobalTypeById(id) {
        return Namespace2.globals.get(id);
      }
      async createChildCompilation(file, context, originId = null, notLoadDescribeFile = false) {
        const compilation = await this.compiler.createCompilation(file, context, notLoadDescribeFile, false, this);
        if (compilation && !compilation.stack && !this.stackCreating) {
          compilation.originId = originId || file;
          Object.assign(compilation.pluginScopes, this.pluginScopes);
          compilation.createStack();
        }
        return compilation;
      }
      hasModuleById(id, context) {
        let scope = this.scope;
        if (context && context.isNamespace) {
          if (context.has(id)) {
            return true;
          }
        } else if (context && context.isModule) {
          if (context.imports.has(id) || context.namespace.has(id)) {
            return true;
          } else if (context.moduleStack && context.moduleStack.parentStack) {
            scope = context.moduleStack.parentStack.scope;
          }
        }
        if (scope.isDefine(id)) {
          return true;
        }
        if (this.modules.has(id)) {
          return true;
        }
        if (Namespace2.globals.has(id)) {
          return true;
        }
        return false;
      }
      getModuleById(id, context, flag = false) {
        let scope = this.scope;
        if (context && context.isNamespace) {
          if (context.has(id)) {
            return this.getTypeValue(context.get(id), true);
          }
        } else if (context && context.isModule) {
          const result = context.getImport(id) || context.namespace.get(id);
          if (result) {
            const aliasName = context.importAlias.get(result);
            if (aliasName && aliasName !== id) {
              return flag ? false : null;
            }
            return this.getTypeValue(result, true);
          } else if (context.moduleStack && context.moduleStack.parentStack) {
            scope = context.moduleStack.parentStack.scope;
          }
        }
        const type2 = scope.define(id);
        if (type2) {
          return this.getTypeValue(type2, true);
        }
        if (this.modules.has(id)) {
          return this.getTypeValue(this.modules.get(id), true);
        }
        if (Namespace2.globals.has(id)) {
          return this.getTypeValue(Namespace2.globals.get(id), true);
        }
        return null;
      }
      async loadTypeAsync(id, context, isImporter = false) {
        let type2 = this.getModuleById(id, context, true);
        if (type2 === false)
          return null;
        if (type2)
          return type2;
        let ns = this.namespace;
        if (context) {
          if (context.isNamespace) {
            ns = context;
          } else if (context.isModule) {
            ns = context.namespace;
          }
        }
        let idString = String(id);
        let file = null;
        if (idString.includes(".")) {
          file = path.resolve(this.compiler.workspace, idString.replaceAll(".", path.sep));
        } else {
          if (isImporter) {
            file = path.resolve(this.compiler.workspace, idString);
          } else {
            file = path.resolve(this.file ? path.dirname(this.file) : this.compiler.workspace, idString);
            if (this.file && !fs.existsSync(file + this.compiler.suffix)) {
              file = path.resolve(this.compiler.workspace, idString);
            }
          }
        }
        const compilation = await this.createChildCompilation(file, null, id);
        if (compilation) {
          if (!compilation.parserDoneFlag) {
            this.loadDependencies.add(compilation);
          }
          type2 = compilation.namespace.get(id) || Namespace2.globals.get(id);
        }
        if (!type2) {
          type2 = await this.loadManifest(id, ns);
        }
        return this.getTypeValue(type2);
      }
      checkNeedToLoadTypeById(id, context) {
        if (this.hasModuleById(id, context)) {
          return false;
        }
        if (this.hasManifestResource(id, context)) {
          return true;
        }
        id = String(id);
        if (this.file && !id.includes(".") && fs.existsSync(path.join(path.dirname(this.file), id + this.compiler.suffix))) {
          return true;
        }
        return fs.existsSync(path.join(this.compiler.workspace, id.replaceAll(".", path.sep) + this.compiler.suffix));
      }
      hasManifestResource(id, context) {
        let ns = this.namespace;
        if (context) {
          if (context.isNamespace) {
            ns = context;
          } else if (context.isModule) {
            ns = context.namespace;
          }
        }
        id = this.compiler.manifester.resolveId(id, ns);
        return this.compiler.manifester.hasResource(id);
      }
      async loadManifest(id, ns) {
        id = this.compiler.manifester.resolveId(id, ns);
        if (Namespace2.globals.has(id))
          return Namespace2.globals.get(id);
        const manifestInfo = this.compiler.manifester.getFileinfo(id, true);
        if (manifestInfo && !manifestInfo._loaded) {
          await Promise.allSettled(manifestInfo.files.map(async (file) => {
            const compilation = await this.compiler.createCompilation(file, null, true, false, this);
            if (compilation) {
              compilation.import = "manifest";
              compilation.pluginScopes.scope = manifestInfo.scope;
              compilation.pluginScopes.inherits = manifestInfo.inherits;
              compilation.createStack();
            }
          }));
          manifestInfo._loaded = true;
          return Namespace2.globals.get(id);
        }
        return null;
      }
      parseModuleIdByFile(file) {
        file = this.compiler.getFileAbsolute(file, this.file && path.dirname(this.file));
        if (file) {
          const ns = this.compiler.getFileNamespace(file);
          const name = this.compiler.getFileClassName(file);
          return ns ? `${ns}.${name}` : name;
        } else {
          return null;
        }
      }
      getAllModulesByPolicy(policy) {
        const modules = [];
        this.modules.forEach((module2) => {
          if (this.isPolicy(policy, module2)) {
            modules.push(module2);
          }
        });
        this.children.forEach((childCompilation) => {
          const result = childCompilation.getModulesByPolicy(policy);
          for (const item2 of result) {
            modules.push(item2);
          }
        });
        return modules;
      }
      getModulesByPolicy(policy) {
        const modules = [];
        this.modules.forEach((module2) => {
          if (this.isPolicy(policy, module2)) {
            modules.push(module2);
          }
        });
        this.children.forEach((childCompilation) => {
          childCompilation.modules.forEach((module2) => {
            if (childCompilation.isPolicy(policy, module2)) {
              modules.push(module2);
            }
          });
        });
        return modules;
      }
      getServerCompilations(explicit = false) {
        const compilations = [];
        const map = /* @__PURE__ */ new WeakSet();
        const push = (compilation) => {
          if (!map.has(compilation)) {
            map.add(compilation);
            compilations.push(compilation);
          }
        };
        this.modules.forEach((module2) => {
          if (this.isServerPolicy(module2, explicit)) {
            push(module2.compilation);
          }
        });
        this.children.forEach((child) => {
          child.getServerCompilations(explicit).forEach((compilation) => {
            push(compilation);
          });
        });
        return compilations;
      }
      getClientCompilations(explicit = false) {
        const compilations = [];
        const map = /* @__PURE__ */ new WeakSet();
        const push = (compilation) => {
          if (!map.has(compilation)) {
            map.add(compilation);
            compilations.push(compilation);
          }
        };
        this.modules.forEach((module2) => {
          if (this.isClientPolicy(module2, explicit)) {
            push(module2.compilation);
          }
        });
        this.children.forEach((child) => {
          child.getClientCompilations(explicit).forEach((compilation) => {
            push(compilation);
          });
        });
        return compilations;
      }
      readSibling(flag = false, context = "") {
        const dir = this.file && path.dirname(this.file);
        if (dir) {
          const files = (Utils2.readdir(path.join(dir, context.replace(".", "/")), true) || []).map((filename) => {
            const stat = fs.statSync(filename);
            const folder = stat ? stat.isDirectory() : false;
            const name = path.basename(filename, this.compiler.suffix);
            return { name, folder, filename };
          });
          if (flag) {
            const uniqueNs = /* @__PURE__ */ new Set();
            Array.from(this.modules.values()).forEach((module2) => {
              uniqueNs.add(module2.namespace);
            });
            const list = [];
            uniqueNs.forEach((ns) => {
              files.forEach((item2) => {
                item2.name = ns.getChain().concat(item2.name).join(".");
                list.push(item2);
              });
            });
            return list;
          }
          return files;
        }
        return [];
      }
      parseAst(source) {
        try {
          const matchedResult = source.matchAll(PARSER_TAG_REGEXP);
          if (matchedResult) {
            for (let result of matchedResult) {
              const [, name, attrs] = result;
              const props = attrs.matchAll(PARSER_TAG_ATTR_REGEXP);
              if (props) {
                const data = {};
                for (let item2 of props) {
                  let [, key, , value] = item2;
                  data[key.trim()] = value.trim();
                }
                if (name === "scope") {
                  if (data.name) {
                    this.pluginScopes.scope = data.name;
                  }
                  if (data.inherits) {
                    const inherits = this.pluginScopes.inherits || (this.pluginScopes.inherits = []);
                    const items = data.inherits.split(",").map((val) => val.trim());
                    inherits.push(...items);
                  }
                } else if (name === "reference" && data.file) {
                  const context = this.file ? path.dirname(this.file) : null;
                  if (data.isDir === "true") {
                    const dataset = /* @__PURE__ */ new Set();
                    this.readReferenceFiles(dataset, data.file, context, true);
                    if (dataset.size > 0) {
                      this.hookAsync("compilation.create.before", async () => {
                        const files = Array.from(dataset).map((file) => this.createChildCompilation(file, context));
                        const items = await Promise.allSettled(files);
                        const compilations = items.map((result2) => result2.value).filter((val) => !!val);
                        await Promise.allSettled(compilations.map((compilation) => {
                          if (!compilation.import) {
                            compilation.import = "reference";
                          }
                          return compilation.createCompleted();
                        }));
                      });
                    }
                  } else {
                    let file = this.compiler.getFileAbsolute(data.file, context);
                    if (file) {
                      this.hookAsync("compilation.create.before", async () => {
                        const compilation = await this.createChildCompilation(file, context);
                        if (!compilation.import) {
                          compilation.import = "reference";
                        }
                        await compilation.createCompleted();
                      });
                    }
                  }
                }
              }
            }
          }
          const options = this.compiler.options;
          if (options.enableComments) {
            this.emitComments = [];
            options.parser.onComment = (block, text, start, end, startLoc, endLoc) => {
              this.emitComments.push({
                type: block ? "Block" : "Line",
                value: text,
                start,
                end,
                startLoc,
                endLoc
              });
            };
          }
          return Parser.Parser.parse(source, options.parser);
        } catch (e) {
          if (this.compiler.options.throwParseError)
            console.error(e);
          this.error(e, 1085, e.message);
        }
      }
      readReferenceFiles(dataset, file, context) {
        const describePattern = this.compiler.options.describePattern;
        file = this.compiler.getFileAbsolute(file, context, false);
        dataset = dataset || /* @__PURE__ */ new Set();
        if (!file)
          return dataset;
        if (Utils2.existsSync(file)) {
          const stat = Utils2.getFileStatSync(file);
          if (stat.isDirectory()) {
            const list = Utils2.readdir(file);
            if (list) {
              list.forEach((filename) => {
                this.readReferenceFiles(dataset, filename, file);
              });
            }
          } else if (stat.isFile() && describePattern.test(file)) {
            dataset.add(file);
          }
        }
        return dataset;
      }
      createAst(source) {
        if (!this.ast) {
          this.mtime = this.file ? fs.statSync(this.file).mtimeMs : null;
          this.source = (source || fs.readFileSync(this.file, "utf-8")).toString();
          this.ast = this.parseAst(this.source);
        }
        return this.ast;
      }
      createModule(namespace, id, isInternal = false, isStructModule = false) {
        let name = id;
        let module2 = null;
        if (!namespace) {
          namespace = this.namespace;
        }
        if (namespace.has(id)) {
          module2 = namespace.get(id);
        } else if (namespace !== Namespace2.dataset) {
          name = namespace.getChain().concat(name).join(".");
        }
        if (module2 && module2.namespace !== namespace) {
          module2 = null;
        }
        if (!module2) {
          module2 = new Module(this);
          module2.id = id;
          module2.file = this.file;
          module2.fullname = name;
          module2.namespace = namespace;
          this.compiler.dispatcher("onCreatedModule", module2);
        }
        module2.file = this.file;
        module2.files.push(this.file);
        module2.policy = this.policy;
        module2.isValid = true;
        module2.mtime = this.mtime;
        if (namespace) {
          namespace.set(id, module2);
        }
        if (!isStructModule) {
          this.modules.set(name, module2);
        }
        return module2;
      }
      isValid(source = null) {
        if (!this.ast)
          return true;
        for (let [, module2] of this.modules) {
          if (!module2.isValid)
            return false;
        }
        if (source == null && this.file) {
          const mtime = fs.statSync(this.file).mtimeMs;
          if (mtime === this.mtime) {
            return true;
          }
          if (this.source) {
            source = fs.readFileSync(this.file, "utf-8").toString();
          } else {
            return true;
          }
        }
        const removeblank = /[\r\n\s\t]/g;
        let astr = this.source.replace(removeblank, "");
        let bstr = source.replace(removeblank, "");
        if (astr.charCodeAt(0) === 65279)
          astr = astr.slice(1);
        if (bstr.charCodeAt(0) === 65279)
          bstr = astr.slice(1);
        return astr === bstr;
      }
      destory() {
        delete this.scope;
        delete this.errors;
        delete this.namespaceSets;
        delete this.assets;
        delete this.requires;
        delete this.modules;
        delete this.stacks;
        delete this.dependencies;
        delete this.dependencyCompilations;
        delete this[symbolKey];
        delete this.stack;
        delete this.ast;
        delete this.referenceStacks;
        delete this.jsxStyles;
        delete this.jsxElements;
        this.isDestroyed = true;
        this.dispatcher("onCompilationDestory", this);
      }
      clear(cache) {
        cache = cache || /* @__PURE__ */ new WeakSet();
        cache.add(this);
        this.modules.forEach((module2) => {
          module2.clear(this);
          module2.getStacks().forEach((stack2) => {
            if (stack2.compilation && !cache.has(stack2.compilation)) {
              stack2.compilation.clear(cache);
            }
          });
        });
        this.errors.forEach((error) => {
          const index = this.compiler.errors.indexOf(error);
          if (index >= 0) {
            this.compiler.errors.splice(index, 1);
          }
        });
        this.assets.clear();
        this.requires.clear();
        this.modules.clear();
        this.stacks.clear();
        this.dependencies.clear();
        this.dependencyCompilations.clear();
        this.children.splice(0, this.children.length);
        this.JSX = false;
        this.stackCreating = false;
        this.namespaceSets.forEach((namespace) => namespace.clear(this));
        this.jsxStyles.splice(0, this.jsxStyles.length);
        this.jsxElements.splice(0, this.jsxElements.length);
        this.namespace = Namespace2.dataset;
        this.referenceStacks.forEach((stack2) => {
          const useRefItems = stack2._useRefItems;
          if (useRefItems) {
            Array.from(useRefItems.values()).forEach((stack3) => {
              if (stack3.compilation === this) {
                useRefItems.delete(stack3);
              }
            });
          }
        });
        const data = this[symbolKey];
        data.completed = {};
        data.policy = Constant.POLICY_NONE;
        data.hooks = {};
        data.waiting = [];
        data.parserDoneFlag = false;
        data.createCompletedFlag = false;
        this.changed = !!this.ast;
        this.errors = [];
        this.stack = null;
        this.ast = null;
        this.hasParsed = false;
        this.hasChecked = false;
        this.hasFreezed = false;
        this.scope = new TopScope(null);
        this.referenceStacks.clear();
        this.dispatcher("onCompilationClear", this);
        return true;
      }
      get parserDoneFlag() {
        return this[symbolKey].parserDoneFlag;
      }
      get createDoneFlag() {
        return this[symbolKey].createDoneFlag;
      }
      parser() {
        throw new Error("Compilation.parser is deprecated, please use parserAsync.");
      }
      createStack(source = null, ast = null) {
        try {
          if (!this.stack && !this.stackCreating) {
            this.stackCreating = true;
            const old = this.ast;
            if (!ast) {
              ast = this.createAst(source);
            }
            if (old !== ast) {
              this.namespace = Namespace2.dataset;
              this.stack = Tokens.create(this, ast, this.scope, null);
            }
            this.stackCreating = false;
          }
          return this.stack;
        } catch (e) {
          console.error(e);
          this.error(e, 1085, e.message);
        }
      }
      async createCompleted() {
        if (this[symbolKey].createCompletedFlag)
          return;
        this[symbolKey].createCompletedFlag = true;
        const stack2 = this.stack;
        if (stack2) {
          this[symbolKey].createDoneFlag = false;
          await this.callHookAsync("compilation.create.before");
          await stack2.createCompleted();
          const getOrder = (module2) => {
            const base = module2.isDeclaratorModule ? 4 : 0;
            if (module2.isClass) {
              return 1 + base;
            } else if (module2.isInterface) {
              return 2 + base;
            } else if (module2.isEnum) {
              return 3 + base;
            } else if (module2.isStructTable) {
              return 4 + base;
            }
            return 5 + base;
          };
          let modules = Array.from(this.modules.values());
          let relatedness = /* @__PURE__ */ new Set();
          modules.forEach((module2) => {
            module2.getStacks().forEach((stack3) => {
              if (stack3.compilation !== this && stack3.compilation) {
                relatedness.add(stack3.compilation);
              }
            });
          });
          if (relatedness.size > 0) {
            await Promise.allSettled(Array.from(relatedness.values()).map((child) => child.createCompleted()));
          }
          if (modules.length > 1) {
            modules = modules.sort((a, b) => {
              let a1 = getOrder(a);
              let b1 = getOrder(b);
              if (a1 === b1)
                return 0;
              return a1 < b1 ? -1 : 1;
            });
          }
          this.mainModule = modules[0];
          await this.callHookAsync("compilation.create.after");
          const compilations = this.getCompilationsOfDependency();
          await Promise.allSettled(this.children.map((child) => child.createCompleted()));
          if (compilations.size > 0) {
            const dependencies = [];
            compilations.forEach((dep) => {
              if (!this.children.includes(dep)) {
                dependencies.push(dep);
              }
            });
            if (dependencies.length > 0) {
              await Promise.allSettled(dependencies.map((child) => child.createCompleted()));
            }
          }
          this[symbolKey].createDoneFlag = true;
        } else {
          throw new Error("Compilation.createCompleted failed. ast is not created.");
        }
      }
      getUnparseCompilationDependencies(dataset, cache) {
        dataset = dataset || /* @__PURE__ */ new Set();
        cache = cache || /* @__PURE__ */ new WeakSet();
        this.children.forEach((dep) => {
          if (!dep.hasParsed) {
            dep.hasParsed = "lock";
            if (!cache.has(dep)) {
              cache.add(dep);
              dep.getUnparseCompilationDependencies(dataset, cache);
            }
            dataset.add(dep);
          }
        });
        this.getCompilationsOfDependency().forEach((dep) => {
          if (!dep.hasParsed) {
            dep.hasParsed = "lock";
            if (!cache.has(dep)) {
              cache.add(dep);
              dep.getUnparseCompilationDependencies(dataset, cache);
            }
            dataset.add(dep);
          }
        });
        return dataset;
      }
      async parserAsync(source = null) {
        if (this.hasParsed !== true) {
          this.hasParsed = true;
          this.createStack(source);
          if (this.stack) {
            this[symbolKey].parserDoneFlag = false;
            await this.createCompleted();
            this.compiler.dispatcher("onParseStart", this);
            await this.callHookAsync("compilation.parser.before");
            const dependencies = Array.from(this.getUnparseCompilationDependencies().values());
            dependencies.sort((a, b) => {
              let a1 = SortedMap[a.import] || (a.isDescriptorDocument() ? -3 : 0);
              let b1 = SortedMap[b.import] || (b.isDescriptorDocument() ? -3 : 0);
              return a1 - b1;
            });
            await Promise.allSettled(dependencies.map((child) => child.parserAsync()));
            await this.stack.parserAsync();
            await this.callHookAsync("compilation.parser.after");
            this[symbolKey].parserDoneFlag = true;
            this.compiler.dispatcher("onParseDone", this);
          } else {
            throw new Error("Not create ast.");
          }
        }
      }
      checker() {
        if (!this.hasChecked) {
          this.hasChecked = true;
          if (this.stack) {
            this.children.forEach((child) => child.checker());
            this.stack.checker();
          }
        }
      }
      freeze() {
        if (!this.hasFreezed) {
          this.hasFreezed = true;
          if (this.stack && this.compiler.options.freeze) {
            this.stack.freeze();
            this.children.forEach((child) => child.freeze());
          }
        }
      }
      async batch(plugins, completed) {
        var task = plugins.length;
        const errors = [];
        plugins.forEach((plugin) => {
          process.nextTick((plugin2) => {
            const done = (error) => {
              task--;
              if (error) {
                errors.push(error);
              }
              if (task < 1) {
                if (completed && typeof completed === "function") {
                  completed(errors.length > 0 ? errors : null, this, plugins);
                }
              }
            };
            this.build(plugin2, done, true);
          }, plugin);
        });
      }
      async build(plugin, completed, flag = false) {
        if (typeof completed === "function") {
          this[symbolKey].waitCallback.push(completed);
        }
        if (!this[symbolKey].building) {
          this[symbolKey].building = true;
          const compilation = this;
          const done = (error, builder) => {
            this[symbolKey].building = false;
            this.compiler.dispatcher("onBuildDone", { error, plugin, builder, compilation });
            let callback = null;
            while (callback = this[symbolKey].waitCallback.shift()) {
              if (error && error instanceof Error) {
                callback(error, this, plugin, builder);
              } else {
                callback(null, this, plugin, builder);
              }
            }
          };
          try {
            await this.parserAsync();
            if (this.stack) {
              this.compiler.dispatcher("onBuildStart", { plugin, compilation });
              if (flag === true) {
                plugin.start(this, done);
              } else {
                plugin.build(this, done);
              }
            } else {
              done(new Error("Parser error. no stack."));
            }
          } catch (error) {
            done(error);
          }
        }
      }
      ready() {
        return new Promise((resolve, reject) => {
          const execute = async () => {
            if (!this.compiler.options.service && !this.isValid()) {
              this.clear();
            }
            if (this.parserDoneFlag) {
              resolve(this);
            } else {
              const queues = TaskCache.queues;
              queues.push(async () => {
                try {
                  await this.parserAsync();
                  resolve(this);
                  if (queues.length > 0) {
                    const task = queues.shift();
                    await task();
                  } else {
                    TaskCache.waiting = false;
                  }
                } catch (e) {
                  reject(e);
                }
              });
              if (!TaskCache.waiting) {
                TaskCache.waiting = true;
                const task = queues.shift();
                await task();
              }
            }
          };
          if (this.compiler.restartuping) {
            this.compiler.once("onRestartupDone", execute);
          } else {
            execute();
          }
        });
      }
    };
    var TaskCache = {
      queues: [],
      waiting: false
    };
    module.exports = Compilation;
  }
});

// lib/core/CompilationGroup.js
var require_CompilationGroup = __commonJS({
  "lib/core/CompilationGroup.js"(exports, module) {
    var fs = __require("fs");
    var Utils2 = require_Utils();
    var Compilation = require_Compilation();
    var CompilationGroup = class extends Compilation {
      constructor(compiler, file) {
        super(compiler, file);
        const suffix = String(this.compiler.options.suffix || ".es");
        this.suffix = new RegExp(suffix.replace(".", "\\.") + "$", "i");
        this.isCompilationGroup = true;
        this._resolveCompilations = null;
        this._resolveFiles = null;
      }
      createAst() {
        throw new TypeError(`Invalid methods for 'createModule'.`);
      }
      createModule() {
        throw new TypeError(`Invalid methods for 'createModule'.`);
      }
      createStack() {
        throw new TypeError(`Invalid methods for 'createStack'.`);
      }
      isValid() {
        return true;
      }
      clear(destroy = false) {
        if (this._resolveCompilations) {
          this._resolveCompilations.forEach((compilation) => compilation.clear(destroy));
        }
        this._resolveCompilations = null;
        this._resolveFiles = null;
        this._createCompletedFlag = false;
        this._parserAsyncFlag = false;
        this.hasParsed = false;
      }
      resolveFiles() {
        if (this._resolveFiles)
          return this._resolveFiles;
        const files = this._resolveFiles = [];
        const resolve = (file) => {
          if (!file)
            return;
          if (!fs.existsSync(file))
            return;
          const stat = fs.statSync(file);
          if (stat.isDirectory()) {
            (Utils2.readdir(file, true) || []).forEach((file2) => {
              resolve(file2);
            });
          } else if (stat.isFile() && this.suffix.test(file)) {
            files.push(file);
          }
        };
        resolve(this.file);
        return files;
      }
      async resolveCompilations() {
        if (this._resolveCompilations)
          return this._resolveCompilations;
        const compilations = this._resolveCompilations = [];
        const files = this.resolveFiles();
        const results = await Promise.allSettled(files.map((file) => this.compiler.createCompilation(file, this.file, true, false, this)));
        const items = results.map((result) => result.value);
        await Promise.allSettled(items.map(async (compilation) => {
          if (compilation) {
            compilation.import = this.import;
            Object.assign(compilation.pluginScopes, this.pluginScopes);
            compilation.createStack();
            compilations.push(compilation);
          }
        }));
        return compilations;
      }
      parser() {
        throw new Error("CompilationGroup.parser is deprecated, please use parserAsync.");
      }
      async createCompleted() {
        if (this._createCompletedFlag)
          return;
        this._createCompletedFlag = true;
        const compilations = await this.resolveCompilations();
        await Promise.allSettled(compilations.map((compilation) => compilation.createCompleted()));
      }
      async parserAsync() {
        if (!this._parserAsyncFlag) {
          this._parserAsyncFlag = true;
          const compilations = await this.resolveCompilations();
          await Promise.allSettled(compilations.map((compilation) => compilation.createCompleted()));
          await Promise.allSettled(compilations.map((compilation) => compilation.parserAsync()));
        }
      }
      checker() {
        if (!this.hasChecked) {
          this.hasChecked = true;
          this.children.forEach((compilation) => compilation.checker());
        }
      }
      freeze() {
        if (!this.hasFreezed) {
          this.hasFreezed = true;
          this.children.forEach((compilation) => compilation.freeze());
        }
      }
    };
    module.exports = CompilationGroup;
  }
});

// lib/core/Manifester.js
var require_Manifester = __commonJS({
  "lib/core/Manifester.js"(exports, module) {
    var path = __require("path");
    var Namespace2 = require_Namespace();
    var Manifester = class {
      dataset = /* @__PURE__ */ Object.create(null);
      datamap = /* @__PURE__ */ new Map();
      cache = /* @__PURE__ */ new Map();
      clear() {
        this.datamap.clear();
        this.cache.clear();
        this.dataset = /* @__PURE__ */ Object.create(null);
      }
      add(manifest, context) {
        if (context && manifest.types && Array.isArray(manifest.files) && manifest.files.length > 0) {
          context = path.normalize(context);
          if (!this.datamap.has(context)) {
            this.datamap.set(context, manifest);
            const dataset = this.dataset;
            const value = [manifest, context];
            Object.keys(manifest.types).forEach((key) => {
              if (dataset[key]) {
                const records = dataset[key][0].types[key];
                const merges = records.merges || (records.merges = []);
                merges.push(value);
              } else {
                dataset[key] = value;
              }
            });
          }
        } else {
          throw new Error(`Add manifest is invalid. in folders the "${context}".`);
        }
      }
      getFileinfo(id, recordsFlag = false) {
        let records = this.cache.get(id);
        if (records)
          return records;
        const value = this.dataset[id];
        if (value) {
          const [manifest, context] = value;
          if (manifest) {
            const inherits = [];
            const scope = manifest.scope.name;
            const files = this.getFiles(id, manifest, context, inherits);
            if (scope) {
              const index = inherits.indexOf(scope);
              if (index >= 0) {
                inherits.splice(index, 1);
              }
            }
            records = { files, scope, inherits };
            if (recordsFlag) {
              this.cache.set(id, records);
            }
            return records;
          }
        }
        return null;
      }
      hasResource(id) {
        return !!this.dataset[id];
      }
      getFiles(id, manifest, context, scopes = []) {
        const records = manifest.types[id];
        if (records) {
          if (manifest.scope) {
            const names = [];
            if (manifest.scope.name)
              names.push(manifest.scope.name);
            if (manifest.scope.inherits && Array.isArray(manifest.scope.inherits)) {
              names.push(...manifest.scope.inherits);
            }
            names.forEach((name) => {
              if (!scopes.includes(name)) {
                scopes.push(name);
              }
            });
          }
          const files = records.indexers.map((index) => {
            const file = manifest.files[index];
            return path.isAbsolute(file) ? file : path.join(context, file);
          });
          if (records.merges) {
            const merges = records.merges.map(([manifest2, context2]) => this.getFiles(id, manifest2, context2, scopes));
            files.push(...merges);
          }
          return files;
        } else {
          return [];
        }
      }
      resolveId(id, namespace) {
        if (Namespace2.dataset === namespace)
          return id;
        if (this.dataset[id])
          return id;
        if (namespace && namespace.fullName) {
          if (String(id).includes("."))
            return id;
          const key = namespace.fullName + "." + id;
          if (this.dataset[key])
            return key;
        }
        return id;
      }
      hasRecords(id) {
        return this.cache.has(id);
      }
      deleteRecords(id) {
        this.cache.delete(id);
      }
    };
    module.exports = Manifester;
  }
});

// lib/core/Cache.js
var require_Cache = __commonJS({
  "lib/core/Cache.js"(exports, module) {
    var groups = /* @__PURE__ */ new Map();
    var Cache = class {
      static clearAll() {
        groups.forEach((cache) => {
          cache.clear();
        });
      }
      static group(name) {
        let cache = groups.get(name);
        if (!cache) {
          cache = new Cache(name);
        }
        return cache;
      }
      static global() {
        return this.group("global");
      }
      static each(finder) {
        groups.forEach((cache) => {
          cache.keys().forEach((key) => finder(key, cache));
        });
      }
      static keys(finder) {
        const dataset = /* @__PURE__ */ new Map();
        groups.forEach((cache) => {
          if (finder) {
            dataset.set(cache, cache.keys().filter((key) => {
              return finder(key, cache);
            }));
          } else {
            dataset.set(cache, cache.keys());
          }
        });
        return dataset;
      }
      static all() {
        return Array.from(groups.values());
      }
      constructor(name) {
        this.name = name;
        this.dataset = /* @__PURE__ */ new Map();
        groups.set(name, this);
      }
      get(name) {
        if (this.has(name)) {
          return this.dataset.get(name);
        }
        return void 0;
      }
      set(name, value) {
        this.dataset.set(name, value);
        return this;
      }
      has(name) {
        return this.dataset.has(name);
      }
      records(name, initValue = true, flag = true) {
        if (!name)
          return flag;
        if (!this.has(name)) {
          this.set(name, initValue);
          return false;
        } else {
          return true;
        }
      }
      clear(name) {
        if (name) {
          delete this.dataset.delete(name);
        } else {
          this.dataset.clear();
        }
      }
      values() {
        this.dataset.values();
      }
      keys() {
        return Array.from(this.dataset.keys());
      }
    };
    module.exports = Cache;
  }
});

// lib/core/PluginScopeManager.js
var require_PluginScopeManager = __commonJS({
  "lib/core/PluginScopeManager.js"(exports, module) {
    var merge = __require("lodash/merge");
    var PluginScopeManager = class {
      constructor(compiler) {
        this.compiler = compiler;
        this.configItems = [];
        this.configMaps = {};
        this.relationMaps = {};
        this.initConfig();
      }
      clear() {
        this.configItems.splice(0, this.configItems.length);
        const clear = (target) => {
          Object.keys(target).forEach((key) => {
            delete target[key];
          });
        };
        clear(this.configMaps);
        clear(this.relationMaps);
      }
      reset() {
        this.clear();
        this.initConfig();
      }
      initConfig() {
        const configs = this.compiler.options.scopes || [];
        const configMaps = this.configMaps;
        const inheritMaps = this.relationMaps;
        configs.forEach((config) => {
          configMaps[config.name] = config;
          if (Array.isArray(config.inherits)) {
            config.inherits.forEach((name) => {
              if (!inheritMaps[name]) {
                inheritMaps[name] = config.name;
              }
            });
          }
        });
        this.configItems.push(...configs);
        const plugins = this.compiler.options.plugins || [];
        plugins.forEach((plugin) => {
          if (plugin && plugin.options && plugin.options.context) {
            const context = plugin.options.context;
            const name = (plugin.name || plugin.plugin).toString();
            if (!context.name)
              context.name = name;
            if (configMaps[name]) {
              const clone = Object.assign({}, context);
              delete clone.name;
              merge(configMaps[name], clone);
            } else {
              configMaps[context.name] = context;
              this.configItems.push(context);
            }
            if (Array.isArray(context.inherits)) {
              context.inherits.forEach((name2) => {
                if (!inheritMaps[name2]) {
                  inheritMaps[name2] = context.name;
                }
              });
            }
          }
        });
      }
      getScopesByDocument(document) {
        const scopes = [];
        if (!document)
          return scopes;
        this.configItems.forEach((config) => {
          if (this.checkByConfig(config, document) === true) {
            scopes.push(config.name);
            if (config.inherits && Array.isArray(config.inherits)) {
              config.inherits.forEach((name) => {
                scopes.push(name);
              });
            }
          }
        });
        return scopes;
      }
      getScopeName(name) {
        const _name = this.relationMaps[name];
        if (_name) {
          return this.getScopeName(_name);
        }
        return name;
      }
      getConfigsByScope(name, results = []) {
        const config = this.configMaps[name];
        if (config) {
          results.push(config);
        } else if (this.relationMaps[name]) {
          return this.getConfigsByScope(this.relationMaps[name], results);
        }
        return results;
      }
      checkByConfig(config, context) {
        if (!context)
          return false;
        if (this.checkByRule(config.exclude, context.file))
          return false;
        const res = this.checkByRule(config.include, context.file, null);
        if (res)
          return true;
        if (context.isModule) {
          if (this.checkByRule(config.exclude, context.getName("/")))
            return false;
          if (this.checkByRule(config.include, context.getName("/")))
            return true;
        }
        return res;
      }
      isMatchNamedScopes(name, scopeScheme) {
        if (scopeScheme.scope === name || scopeScheme.name === name)
          return true;
        if (scopeScheme.inherits && Array.isArray(scopeScheme.inherits) && scopeScheme.inherits.includes(name)) {
          return true;
        }
        return false;
      }
      checkByScope(scope, context) {
        if (!scope)
          return false;
        if (!context)
          return false;
        const compilation = context.compilation || context;
        if (!compilation)
          return false;
        const ctxScopes = compilation.pluginScopes;
        const origin = scope;
        if (this.isMatchNamedScopes(scope, ctxScopes))
          return true;
        scope = this.getScopeName(scope);
        if (scope !== origin && this.isMatchNamedScopes(scope, ctxScopes))
          return true;
        const includeRules = this.getConfigsByScope(scope);
        if (includeRules.length > 0) {
          let hasSpecific = false;
          const result = includeRules.some((config) => {
            const res = this.checkByConfig(config, context);
            if (res === true)
              hasSpecific = true;
            return res !== false;
          });
          if (!result)
            return false;
          if (hasSpecific)
            return true;
        }
        const excludeRules = includeRules.length > 0 ? this.configItems.filter((rule) => !includeRules.includes(rule)) : this.configItems;
        if (excludeRules.some((config) => this.checkByRule(config.include, context.file))) {
          return false;
        }
        return true;
      }
      checkByDescriptor(descriptor, context, globalResult = true) {
        if (this.configItems.length < 1) {
          return true;
        }
        if (!descriptor || !descriptor.compilation)
          return true;
        const descScopes = descriptor.compilation.pluginScopes;
        if (descScopes.scope === "global")
          return globalResult;
        const current = descScopes.scope || "local";
        const locals = [];
        if (current === "local") {
          locals.push(...this.getScopesByDocument(descriptor));
        }
        if (current === "local") {
          return locals.length > 0 ? locals.some((scope) => this.checkByScope(scope, context)) : true;
        }
        return this.checkByScope(current, context);
      }
      checkByPlugin(plugin, context, globalResult = true) {
        if (this.configItems.length < 1) {
          return true;
        }
        if (!plugin || !context)
          return true;
        const compilation = context.compilation || context;
        if (!compilation)
          return false;
        const ctxScopes = compilation.pluginScopes || {};
        if (ctxScopes.scope === "global")
          return globalResult;
        if (this.isMatchNamedScopes(plugin.name, ctxScopes))
          return true;
        return this.checkByScope(plugin.name, context);
      }
      checkByRule(rule, value, defaultValue = false) {
        if (rule) {
          if (Array.isArray(rule) && rule.length > 0) {
            return rule.some((rule2) => this.checkByRule(rule2, value, defaultValue));
          } else if (rule instanceof RegExp) {
            return rule.test(value);
          } else if (typeof rule === "string") {
            return rule === value;
          }
        }
        return defaultValue;
      }
    };
    module.exports = PluginScopeManager;
  }
});

// lib/core/Compiler.js
var require_Compiler = __commonJS({
  "lib/core/Compiler.js"(exports, module) {
    var Compilation = require_Compilation();
    var CompilationGroup = require_CompilationGroup();
    var mergeWith = __require("lodash/mergeWith");
    var path = __require("path");
    var cwd = process.cwd();
    var fs = __require("fs");
    var chokidar = __require("chokidar");
    var Utils2 = require_Utils();
    var Lang = require_Lang();
    var Manifester = require_Manifester();
    var dirname = __dirname;
    var compilations = /* @__PURE__ */ new Map();
    var EventDispatcher = require_EventDispatcher();
    var Diagnostic = require_Diagnostic();
    var Namespace2 = require_Namespace();
    var Cache = require_Cache();
    var PluginScopeManager = require_PluginScopeManager();
    var pluginInterfaces = [
      { name: "name", type: ["string"] },
      { name: "platform", type: ["string"] },
      { name: "version", type: ["string", "number"] },
      { name: "start", type: ["function"] },
      { name: "build", type: ["function"] },
      { name: "getGeneratedCodeByFile", type: ["function"] },
      { name: "getGeneratedSourceMapByFile", type: ["function"] },
      { name: "getTokenNode", type: ["function"] }
    ];
    var InitializeProgress = [];
    var SharedInstances = [];
    var globalCompilations = /* @__PURE__ */ new Set();
    var cacheHandle = {
      pkg: Cache.group("pkg"),
      create: Cache.group("create"),
      load: Cache.group("load"),
      folder: Cache.group("folder"),
      appoint: Cache.group("appoint")
    };
    function merge(...args) {
      return mergeWith(...args, (objValue, srcValue) => {
        if (Array.isArray(objValue) && Array.isArray(srcValue)) {
          if (srcValue[0] === null)
            return srcValue.slice(1);
          srcValue.forEach((value) => {
            if (!objValue.includes(value)) {
              objValue.push(value);
            }
          });
          return objValue;
        }
      });
    }
    var Compiler = class extends EventDispatcher {
      static getCompilations() {
        return compilations;
      }
      constructor(options = {}) {
        super();
        this.rawOptions = options;
        this.compilations = compilations;
        this.globals = globalCompilations;
        this.main = [];
        this.regexpSuffix = /\.[a-zA-Z]+$/;
        this.filesystem = /* @__PURE__ */ new Map();
        this.grammar = /* @__PURE__ */ new Map();
        this.errors = [];
        this.utils = Utils2;
        this.restartuping = false;
        this.configFileRecords = null;
        this.resolveConfigFile = null;
        this.diagnostic = Diagnostic;
        this.pluginInstances = [];
        this.parseOptions(options || {});
        this.pluginScopeManager = new PluginScopeManager(this);
        this.manifester = new Manifester();
        this.watchers = [];
        this.disconnected = false;
        if (this.options.service || this.options.watch) {
          this.addWatch();
        }
        SharedInstances.push(this);
        process.on("exit", () => {
          this.dispose();
        });
      }
      clearAddDirFileCache(file) {
        Cache.each((key, cache) => {
          if (cache.name === "global") {
            return;
          }
          key = key.toLowerCase();
          if (key.includes(file)) {
            cache.clear(key);
          }
        });
      }
      addWatch() {
        let fsWatcher = this.fsWatcher;
        if (!fsWatcher) {
          fsWatcher = this.createWatcher(merge(
            {},
            this.options.watchOptions,
            { depth: 0 }
          ));
          if (!fsWatcher) {
            throw new Error("Watcher create failed.");
          } else {
            this.fsWatcher = fsWatcher;
          }
        }
        const cache = {};
        const resolvePath = (dir, wfs2) => {
          return path.isAbsolute(dir) ? dir : path.join(wfs2.options.cwd, dir);
        };
        let watchFolders = [];
        let workspacePath = this.normalizePath(this.options.cwd);
        if (Array.isArray(this.options.watchFolders)) {
          watchFolders.push(...this.options.watchFolders);
        }
        const addDir = (wfs2) => (dir) => {
          if (dir) {
            if (cache[dir])
              return;
            cache[dir] = true;
            dir = resolvePath(dir, wfs2);
            dir = this.normalizePath(dir).toLowerCase();
            this.clearAddDirFileCache(dir);
            if (dir.includes("/node_modules/")) {
              this.scanTypings(dir).then(async (dataset) => {
                const result = await this.doLoadPluginTypes(dataset);
                if (result && Array.isArray(result) && result.length > 0) {
                  this.dispatcher("onAddDirCompilationDone", result.flat(), true);
                }
              });
            } else {
            }
          }
        };
        const unlinkDir = (wfs2) => (dir) => {
          if (dir) {
            delete cache[dir];
            dir = resolvePath(dir, wfs2);
            dir = this.normalizePath(dir).toLowerCase();
            const removed = [];
            let check = false;
            this.compilations.forEach((compilation) => {
              if (String(compilation.file).toLowerCase().includes(dir)) {
                if (!check) {
                  check = compilation.isDescriptorDocument();
                }
                this.removeCompilation(compilation);
                removed.push(compilation);
              }
            });
            if (removed.length > 0) {
              this.dispatcher("onUnlinkDirCompilationDone", removed, check);
            }
          }
        };
        fsWatcher.on("unlink", (file2) => {
          file2 = resolvePath(file2, fsWatcher);
          const compi = this.removeCompilation(file2);
          if (compi) {
            this.dispatcher("onUnlinkCompilationDone", compi);
          }
        });
        if (watchFolders.length > 0) {
          watchFolders = Array.from(new Set(watchFolders.map((dir) => {
            if (!path.isAbsolute(dir)) {
              dir = path.join(process.cwd(), dir);
            }
            return this.normalizePath(dir);
          })).values());
          fsWatcher.add(watchFolders.filter((folder) => workspacePath !== folder)).on("addDir", addDir(fsWatcher)).on("unlinkDir", unlinkDir(fsWatcher));
        }
        const wfs = this.createWatcher(null, 4);
        wfs.add(workspacePath).on("addDir", addDir(wfs)).on("unlinkDir", unlinkDir(wfs));
        let file = this.resolveConfigFile;
        if (file) {
          let timerId = null;
          file = this.normalizePath(file);
          fsWatcher.add(file).on("change", (changed) => {
            if (!changed.includes(this.options.configFileName)) {
              return;
            }
            changed = this.normalizePath(resolvePath(changed, fsWatcher));
            if (file !== changed) {
              return;
            }
            if (timerId) {
              clearTimeout(timerId);
            }
            timerId = setTimeout(() => {
              if (!this.disconnected) {
                this.onConfigFileChanged(file);
              }
              timerId = null;
            }, 1e3);
          });
        }
      }
      createWatcher(options, depth = 0) {
        options = options || {
          persistent: true,
          ignoreInitial: true,
          ignored: /(^|[\/\\])\../,
          depth
        };
        const wfs = new chokidar.FSWatcher(options);
        this.watchers.push(wfs);
        return wfs;
      }
      dispose() {
        this.disconnected = true;
        this.watchers.forEach((wfs) => {
          wfs.close();
        });
        this.clear();
      }
      callUtils(name, ...args) {
        const fun = Utils2[name];
        return fun ? fun.apply(Utils2, args) : false;
      }
      getEscOptions(options = {}) {
        const loaders = {};
        const loaderConfig = {
          text: [".html", ".xml", ".txt", ".svg", ".svgz"],
          json: [".json"],
          file: [".eot", ".ttf", ".woff", ".woff2"],
          js: [".js", ".mjs", ".cjs"],
          css: [".css", ".less", ".sass", ".scss"],
          dataurl: [".png", ".gif", ".jpeg", ".jpg", ".bmp", ".webp"]
        };
        Object.keys(loaderConfig).forEach((name) => {
          const extensions = loaderConfig[name];
          extensions.forEach((ext) => {
            loaders[ext] = name;
          });
        });
        const base64Suffixes = {};
        [".gif", ".png", ".jpg", ".jpeg", ".bmp"].forEach((key) => {
          base64Suffixes[key] = true;
        });
        return merge({
          watch: false,
          treeShaking: true,
          assets: {
            base64Suffixes,
            base64Callback: (file, extname = null) => {
              if (file) {
                const suffixes = this.options.esc.assets.base64Suffixes || {};
                return !!suffixes[(extname || path.extname(file)).toLowerCase()];
              }
              return false;
            }
          },
          resolve: {
            alias: {},
            extensions: [".es", ".mjs", ".cjs", ".js", ".jsx"],
            paths: []
          },
          styles: {
            preprocess: {}
          },
          loaders,
          define: {},
          splitting: false
        }, options);
      }
      defaultOptions() {
        return {
          throwError: false,
          debug: false,
          diagnose: false,
          workspace: "src",
          service: false,
          enableStackMap: false,
          enableComments: false,
          lang: "zh-CN",
          watch: false,
          suffix: ".es",
          plugins: [],
          types: [],
          scanFolders: [],
          cwd,
          scopes: [],
          metadata: {
            http: {
              responseField: null
            }
          },
          literalObjectStrict: false,
          freeze: false,
          watchFolders: [],
          watchOptions: {
            persistent: true,
            ignoreInitial: true,
            ignored: /(^|[\/\\])\../,
            depth: 0
          },
          esc: null,
          annotations: [
            "Provider",
            "Callable",
            "Runtime",
            "Syntax",
            "Env",
            "Router",
            "Post",
            "Get",
            "Delete",
            "Put",
            "Option",
            "Deprecated",
            "Define",
            "Internal",
            "Alias",
            "Override",
            "Dynamic",
            "Embed",
            "SkinClass",
            "Abstract",
            "WebComponent",
            "HostComponent",
            "Require",
            "Required",
            "Import",
            "Main",
            "Reference",
            "DOMAttribute",
            "Injector",
            "Reactive",
            "Hook",
            "URL",
            "Http",
            "Version",
            "Removed",
            "Noop"
          ],
          jsx: {
            componentClass: "web.components.Component",
            skinClass: "web.components.Skin",
            slot: {
              "scopeName": "scope",
              "scopeValue": "scope"
            },
            xmlns: {
              sections: {
                "@directives": ["if", "elseif", "else", "for", "each", "show", "custom"],
                "@events": ["*"],
                "@natives": ["*"],
                "@slots": ["*"],
                "@binding": ["*"]
              },
              context: ["for", "each"],
              default: {
                "e": "@events",
                "s": "@slots",
                "d": "@directives",
                "b": "@binding",
                "n": "@natives",
                "on": "@events",
                "slot": "@slots",
                "bind": "@binding",
                "native": "@natives",
                "direct": "@directives"
              }
            }
          },
          metaStatementMethods: ["Runtime", "Syntax", "Env", "Version"],
          excludeDescribeFile: [],
          require: {},
          commandLineEntrance: false,
          loadGlobalDescribeFile: true,
          scanTypings: true,
          autoLoadDescribeFile: true,
          describePattern: /(\.d\.es)$/,
          resolvePaths: [],
          configFileName: "es.config.js",
          manifestFileName: "typings.json",
          globalTypes: [path.resolve(dirname, "../typing")],
          fileQueryParamFieldMap: {
            "id": "id",
            "type": "type",
            "file": "file"
          },
          parser: {
            sourceType: "module",
            locations: false,
            preserveParens: true,
            ecmaVersion: 11,
            reserved: ["global"]
          }
        };
      }
      parseOptions(options = {}) {
        const defaultOptions = this.defaultOptions();
        options = merge({}, defaultOptions, options);
        let _cwd = options.cwd;
        if (options.configFileName) {
          const configFile = path.join(_cwd, options.configFileName);
          const configData = this.loadConfigFile(configFile);
          if (configData) {
            options = merge(options, configData);
            _cwd = options.cwd;
          }
        }
        if (!fs.existsSync(_cwd)) {
          _cwd = process.cwd();
          Utils2.error(`options.cwd dirname is not exists.`);
        }
        if (options.output) {
          options.output = this.pathAbsolute(options.output);
        } else {
          options.output = path.resolve(_cwd, "build");
        }
        Lang.setLangId(String(options.lang).toLowerCase() === "zh-cn" ? 0 : 1);
        options.workspace = path.isAbsolute(options.workspace) ? options.workspace : path.resolve(_cwd, options.workspace);
        if (!fs.existsSync(options.workspace)) {
          Utils2.error(`options.workspace dirname is not exists.`);
          if (!path.isAbsolute(options.workspace)) {
            const tries = [options.workspace, ...options.workspace.split(/[\\\/]+/), "src"];
            let resolvePath = null;
            for (let i = 0; i < tries.length; i++) {
              if (!tries[i])
                continue;
              resolvePath = this.getWorkspaceFolder(_cwd, tries[i]);
              if (resolvePath) {
                console.warn(`Resolved workspace path '${resolvePath}' successfully.`);
                break;
              } else {
                console.warn(`Resolved workspace path '${path.join(_cwd, tries[i])}' failed.`);
              }
            }
            if (!resolvePath) {
              options.workspace = _cwd;
            }
          }
        }
        options.workspace = this.normalizePath(options.workspace);
        if (options.service) {
          options.enableComments = true;
        } else {
          options.esc = this.getEscOptions(options.esc);
        }
        this.options = options;
        this.suffix = options.suffix;
        this.workspace = options.workspace;
        return options;
      }
      setWorkspace(dist) {
        this.workspace = this.normalizePath(path.isAbsolute(dist) ? dist : path.resolve(this.options.cwd || cwd, dist));
        this.options.workspace = this.workspace;
        return this;
      }
      getWorkspaceFolder(context, name, depth = 1) {
        const exclude = ["/node_modules/"];
        const files = (Utils2.readdir(context) || []).map((file) => {
          return file.charCodeAt(0) !== 46 && !exclude.includes(file) && fs.statSync(path.join(context, file)).isDirectory();
        });
        const absolutes = files.map((file) => path.join(context, file));
        var i = 0;
        for (; i < absolutes.length; i++) {
          const dirname2 = path.join(absolutes[i], name);
          if (fs.existsSync(dirname2)) {
            return dirname2;
          }
        }
        if (depth < 3) {
          i = 0;
          for (i = 0; i < absolutes.length; i++) {
            const dirname2 = this.getWorkspaceFolder(absolutes[i], name, depth++);
            if (dirname2) {
              return dirname2;
            }
          }
        }
        return null;
      }
      async restartup() {
        this.restartuping = true;
        this.dispatcher("onRestartupBefore");
        await this.clear();
        await this.__loadGlobalTypes();
        await this.__loadPluginTypes();
        this.restartuping = false;
        this.dispatcher("onRestartupAfter");
      }
      async clear() {
        Namespace2.clearAll();
        Cache.clearAll();
        this.errors.splice(0, this.errors.length);
        this.manifester.clear();
        this.pluginScopeManager.reset();
        this.compilations.forEach((compi) => {
          compi.destory();
        });
        this.compilations.clear();
        this.globals.clear();
      }
      compareChanged(oldValue, newValue) {
        const hasOwn = Object.prototype.hasOwnProperty;
        const compare = (oldValue2, newValue2) => {
          const oldType = Array.isArray(oldValue2) ? "array" : typeof oldValue2;
          const newType = Array.isArray(newValue2) ? "array" : typeof newValue2;
          if (oldValue2 && oldType === "object") {
            if (newType !== "object")
              return true;
            return Object.keys(oldValue2).some((key) => {
              if (!hasOwn.call(newValue2, key))
                return true;
              return compare(oldValue2[key], newValue2[key]);
            });
          } else if (oldValue2 && oldType === "array") {
            if (newType !== "array")
              return true;
            if (oldValue2.length !== newValue2.length)
              return true;
            const _oldValue = oldValue2.slice(0).sort();
            const _newValue = newValue2.slice(0).sort();
            return _oldValue.some((old) => {
              return !_newValue.some((value) => !compare(old, value));
            });
          } else {
            if (newType !== oldType)
              return true;
            if (newType === "function") {
              return false;
            }
            return String(oldValue2) != String(newValue2);
          }
        };
        return compare(oldValue, newValue);
      }
      onConfigFileChanged(file) {
        const records = this.configFileRecords;
        const oldSource = records.source;
        const newSource = fs.readFileSync(file, { encoding: "utf-8" }).toString();
        if (oldSource === newSource)
          return;
        if (oldSource.replace(/[\r\n\s\t]+/g, "") === newSource.replace(/[\r\n\s\t]+/g, ""))
          return;
        records.source = newSource;
        const old = this.options;
        this.parseOptions(this.rawOptions);
        if (this.options.service || this.options.watch) {
          if (this.compareChanged(old, this.options)) {
            this.restartup();
          }
        }
      }
      loadConfigFile(file) {
        if (fs.existsSync(file)) {
          try {
            const records = this.configFileRecords;
            const id = __require.resolve(file);
            delete __require.cache[id];
            const config = __require(id);
            let data = config === "function" ? config(this) : config;
            this.resolveConfigFile = file;
            if (Object.prototype.toString.call(data) !== "[object Object]") {
              data = {};
              console.error(`config file export data type can only is object. in '${file}'`);
            }
            if (records) {
              records.data = data;
            } else {
              const source = fs.readFileSync(file, { encoding: "utf-8" }).toString();
              this.configFileRecords = {
                file,
                data,
                source
              };
            }
            return data;
          } catch (e) {
            console.error(`${e.message} in '${file}'`);
          }
        }
        return null;
      }
      getOutputFileSystem(syntax) {
        if (this.options.service)
          return;
        return {};
      }
      getInputFileSystem() {
        if (this.options.service)
          return;
        return {};
      }
      resolve(file, context) {
        let isLocal = file.charCodeAt(0) === 64;
        if (isLocal)
          file = file.substr(1);
        if (isLocal) {
          file = this.getFileAbsolute(file, context);
          if (fs.existsSync(file)) {
            return file;
          }
          return null;
        }
        const load = (file2, options) => {
          try {
            return __require.resolve(file2, options);
          } catch {
          }
          return null;
        };
        const _file = file;
        file = this.getFileAbsolute(file, context);
        if (!fs.existsSync(file)) {
          file = load(_file, {
            paths: [context].concat(
              this.options.cwd,
              this.options.resolvePaths
            )
          });
        }
        if (file) {
          file = this.normalizePath(file);
        }
        return file;
      }
      normalizeModuleFile(moduleOrCompilation, id, type2, resolveFile, attrs = null) {
        const file = this.normalizePath(moduleOrCompilation.file);
        const isModule = moduleOrCompilation.isModule && moduleOrCompilation.isType;
        if (moduleOrCompilation.require && isModule) {
          return file;
        }
        const segments = [];
        const compilation = isModule ? moduleOrCompilation.compilation : moduleOrCompilation;
        if (!id && isModule && compilation.modules && compilation.modules.size > 1) {
          if (compilation.isDescriptorDocument()) {
            id = moduleOrCompilation.getName();
          } else {
            const modules = Array.from(compilation.modules.values()).filter((module2) => !module2.isDeclaratorModule);
            if (modules.length > 1) {
              id = moduleOrCompilation.getName();
            }
          }
        }
        const map = this.options.fileQueryParamFieldMap || {};
        if (attrs && typeof attrs === "object") {
          const excludes = { id, type: type2, file: resolveFile };
          Object.keys(attrs).forEach((key) => {
            if (excludes[key])
              return;
            if (attrs[key]) {
              segments.push(`${key}=${attrs[key]}`);
            } else {
              segments.push(key);
            }
          });
        }
        if (id)
          segments.push(`${map.id || "id"}=${id}`);
        if (type2)
          segments.push(`${map.type || "type"}=${type2}`);
        segments.sort((a, b) => {
          if (!a.includes("=") && b.includes("="))
            return -1;
          if (!b.includes("=") && a.includes("="))
            return 1;
          return a.localeCompare(b);
        });
        if (resolveFile)
          segments.push(`${map.file || "file"}=${resolveFile}`);
        return segments.length > 0 ? `${file}?${segments.join("&")}` : file;
      }
      normalizePath(file) {
        if (!file)
          return file;
        return path.sep === "\\" ? file.replace(/\\/g, "/") : file;
      }
      getFileAbsolute(file, context, flagSuffix = true, checkNodeModules = true) {
        if (typeof file !== "string")
          return null;
        if (flagSuffix && !this.regexpSuffix.test(file)) {
          file = file + this.suffix;
        }
        if (path.isAbsolute(file)) {
          file = path.resolve(file);
        } else {
          if (context) {
            context = context.replace(/\\/g, "/");
            const resolve = (root2, name2) => {
              let file2 = path.join(root2, name2);
              if (fs.existsSync(file2))
                return file2;
              if (checkNodeModules) {
                file2 = path.join(root2, "node_modules", name2);
                if (fs.existsSync(file2))
                  return file2;
              }
              return null;
            };
            const section = context.split("/");
            let root = context;
            let name = file;
            while (root && !(file = resolve(root, name)) && section.pop()) {
              root = section.join("/");
            }
          } else {
            file = path.resolve(this.workspace, file);
          }
        }
        return this.normalizePath(file);
      }
      getRelativeWorkspace(file) {
        if (file) {
          file = this.normalizePath(file);
          if (file.includes(this.normalizePath(this.workspace))) {
            return path.relative(this.workspace, file);
          }
        }
        return "";
      }
      getFileNamespace(file) {
        if (path.isAbsolute(file)) {
          file = this.getRelativeWorkspace(file);
          return path.dirname(file).split(/[\\\/]+/).filter((val) => !!(val && !(val === "." || val === ".."))).join(".");
        } else {
          throw new Error(`Invalid file '${file}'`);
        }
      }
      getFileClassName(file) {
        return path.basename(file, this.suffix);
      }
      pathAbsolute(file) {
        return this.normalizePath(path.isAbsolute(file) ? path.resolve(file) : path.resolve(cwd, file));
      }
      removeCompilation(file) {
        if (!file)
          return false;
        let compilation = file;
        let id = null;
        if (typeof compilation === "string") {
          file = this.getFileAbsolute(file);
          if (file) {
            id = this.getResourceId(file);
            compilation = this.compilations.get(id);
          }
        } else if (compilation && compilation.file) {
          id = this.getResourceId(compilation.file);
        }
        if (compilation) {
          compilation.isDestroyed = true;
          compilation.clear();
          if (id) {
            this.compilations.delete(id);
          }
          return compilation;
        }
        return false;
      }
      getResourceId(resourcePath) {
        if (!resourcePath) {
          throw new TypeError("resourcePath is null");
        }
        resourcePath = String(resourcePath).toLowerCase();
        return resourcePath.split("/node_modules/").pop();
      }
      getCompilation(file, context) {
        file = this.getFileAbsolute(file, context);
        if (file) {
          const resourceId = this.getResourceId(file);
          if (this.compilations.has(resourceId)) {
            return this.compilations.get(resourceId);
          }
        }
        return null;
      }
      hasCompilation(file, context) {
        file = this.getFileAbsolute(file, context);
        if (file) {
          const resourceId = this.getResourceId(file);
          return this.compilations.has(resourceId);
        }
        return false;
      }
      async createCompilation(file, context = null, flag = false, isRoot = false, parentCompilation = null) {
        const originFile = file;
        file = this.getFileAbsolute(file, context, isRoot !== true);
        if (file) {
          const resourceId = this.getResourceId(file);
          if (this.compilations.has(resourceId)) {
            return this.compilations.get(resourceId);
          }
          if (fs.existsSync(file)) {
            const isGroup = isRoot ? fs.statSync(file).isDirectory() : false;
            const compilation = isGroup ? new CompilationGroup(this, file) : new Compilation(this, file);
            this.compilations.set(resourceId, compilation);
            compilation.originFile = originFile;
            if (!file.includes("/node_modules/")) {
              const last = path.basename(this.workspace);
              if (file.includes("/" + last + "/")) {
                compilation.pluginScopes.scope = "local";
                compilation.pluginScopes.inherits = [];
              }
              if (this.options.service || this.options.watch) {
                if (this.fsWatcher) {
                  this.fsWatcher.add(file);
                }
              }
            }
            if (!flag && !isGroup && this.options.autoLoadDescribeFile && !compilation.isDescriptionType) {
              await this.loadDescriptorFiles(path.dirname(file));
            }
            if (parentCompilation) {
              compilation.parent = parentCompilation;
              parentCompilation.children.push(compilation);
            }
            this.dispatcher("onCreatedCompilation", compilation);
            return compilation;
          }
        }
        return null;
      }
      async loadDescriptorFiles(dirname2) {
        const descFile = this.resolveAppointFile("index", "index.d.es", dirname2);
        if (!cacheHandle.load.records(descFile)) {
          await this.loadTypes([descFile], { scope: "local", inherits: [] });
        } else if (!descFile) {
          const file = this.resolveAppointFile("package", "package.json", dirname2);
          if (file) {
            const data = this.resolveTypingsFromPackage(file);
            if (data && data.size > 0) {
              await Promise.allSettled(Array.from(data.values()).map(this.loadTypes(item.files, item.esconfig)));
            }
          }
        }
      }
      readFolderTypings(data, file, context, esconfig, scopeFile, isRoot = false) {
        const suffix = this.options.describePattern;
        file = path.isAbsolute(file) ? file : path.join(context, file);
        file = this.normalizePath(file);
        if (cacheHandle.folder.records(file) || !fs.existsSync(file))
          return;
        const stat = fs.statSync(file);
        if (stat.isDirectory()) {
          const result = Utils2.readdir(file);
          if (result) {
            result.forEach((name) => {
              this.readFolderTypings(data, path.join(file, name), file, esconfig, scopeFile, false);
            });
          }
        } else if (stat.isFile() && (suffix.test(file) || isRoot && file.endsWith(this.suffix))) {
          let dataset = data.get(scopeFile);
          if (!dataset) {
            dataset = {
              esconfig,
              context,
              files: [file]
            };
            data.set(scopeFile, dataset);
          } else {
            dataset.files.push(file);
          }
        }
      }
      normalizePkgTypings(value) {
        if (value) {
          if (typeof value === "string") {
            return value.split(",").map((item2) => item2.trim());
          } else if (Array.isArray(value)) {
            return value.map((item2) => item2.trim());
          }
        }
        return [];
      }
      resolveTypingsFromPackage(jsonFile, dataset = null, typings = null) {
        if (cacheHandle.pkg.records(jsonFile)) {
          return null;
        }
        if (!fs.existsSync(jsonFile))
          return null;
        dataset = dataset || /* @__PURE__ */ new Map();
        const pkg = __require(jsonFile);
        const folder = path.dirname(jsonFile);
        let pkgName = String(pkg.name || "").trim();
        let esconfig = pkg.esconfig || {
          inherits: [],
          scope: pkgName
        };
        if (esconfig.typings && Array.isArray(esconfig.typings)) {
          esconfig.typings.forEach((file) => {
            this.readFolderTypings(dataset, file, folder, esconfig, jsonFile, true);
          });
        }
        const _typings = typings || this.normalizePkgTypings(pkg.typings);
        if (_typings) {
          if (!esconfig.scope) {
            esconfig.scope = pkgName;
          }
          _typings.forEach((file) => {
            file = path.isAbsolute(file) ? file : path.join(folder, file);
            if (/\.json$/.test(file) && fs.existsSync(file)) {
              try {
                this.manifester.add(__require(file), path.dirname(file));
              } catch (e) {
                throw e;
              }
            } else {
              this.readFolderTypings(dataset, file, folder, esconfig, jsonFile, true);
            }
          });
        }
        return dataset;
      }
      resolveAppointFile(prefix, filename, folder, entry = null, prevs = [], ctx2 = null) {
        if (!folder)
          return null;
        if (!fs.existsSync(folder))
          return null;
        folder = this.normalizePath(folder);
        entry = entry || folder;
        const key = prefix + ":" + folder;
        const value = cacheHandle.appoint.get(key);
        if (value !== void 0) {
          return value;
        }
        if (ctx2 === null) {
          ctx2 = this.normalizePath(path.normalize(this.options.cwd || process.cwd()));
        }
        if (!folder.includes(ctx2)) {
          return null;
        }
        prevs.push(folder);
        let file = path.join(folder, filename);
        if (fs.existsSync(file)) {
          file = this.normalizePath(file);
          prevs.forEach((folder2) => {
            const key2 = prefix + ":" + folder2;
            cacheHandle.appoint.set(key2, file);
          });
          return file;
        } else {
          const result = this.resolveAppointFile(prefix, filename, path.dirname(folder), entry, prevs, ctx2);
          if (!result && entry === folder) {
            prevs.forEach((folder2) => {
              const key2 = prefix + ":" + folder2;
              cacheHandle.appoint.set(key2, null);
            });
          }
          return result;
        }
      }
      async scanTypings(folders, scanDependencyFlag = true, dataset = null) {
        if (!Array.isArray(folders)) {
          folders = [folders];
        }
        dataset = dataset || /* @__PURE__ */ new Map();
        folders.forEach((folder) => {
          const file = this.resolveAppointFile("package", "package.json", folder);
          if (!cacheHandle.pkg.has(file)) {
            this.resolveTypingsFromPackage(file, dataset);
            if (scanDependencyFlag) {
              const context = path.join(path.dirname(file), "node_modules");
              const deps = Utils2.readdir(context, true) || [];
              deps.forEach((dep) => {
                this.resolveTypingsFromPackage(this.normalizePath(path.join(dep, "package.json")), dataset);
              });
            }
          }
        });
        return dataset;
      }
      async __loadPluginTypes() {
        const options = this.options;
        const cwd2 = path.normalize(options.cwd || process.cwd());
        let dataset = /* @__PURE__ */ new Map();
        if (options.scanTypings) {
          const scanFolders = (options.scanFolders || []).map((item2) => path.normalize(item2));
          if (!scanFolders.includes(cwd2)) {
            scanFolders.push(cwd2);
          }
          await this.scanTypings(scanFolders, true, dataset);
        }
        if (options.types && options.types.length > 0) {
          const suffix = this.options.describePattern;
          const needScanTasks = [];
          options.types.forEach((file) => {
            file = path.isAbsolute(file) ? file : path.join(cwd2, file);
            if (fs.existsSync(file) && fs.statSync(file).isFile()) {
              if (suffix.test(file)) {
                let folder = path.dirname(file);
                if (!path.isAbsolute(folder)) {
                  folder = path.join(cwd2, folder);
                }
                const json = this.resolveAppointFile("package", "package.json", folder);
                if (json) {
                  dataset = this.resolveTypingsFromPackage(json, dataset, [file]);
                } else if (!dataset.has(file)) {
                  dataset.set(file, {
                    esconfig: {
                      scope: "global",
                      inherits: []
                    },
                    folder,
                    files: [file]
                  });
                }
              }
            } else {
              if (!path.isAbsolute(file) && !String(file).endsWith("node_modules")) {
                file = path.join(cwd2, "node_modules", file);
              }
              needScanTasks.push([file, false, dataset]);
            }
          });
          await Promise.allSettled(needScanTasks.map((args) => this.scanTypings(...args)));
        }
        await this.doLoadPluginTypes(dataset);
      }
      async __loadGlobalTypes() {
        const globalTypes = this.options.globalTypes || [];
        const items = [];
        globalTypes.forEach((filepath) => {
          const types = Utils2.readdir(filepath, true);
          if (types) {
            items.push(...types);
          } else if (filepath) {
            items.push(filepath);
          }
        });
        if (items.length > 0) {
          await this.loadTypes(items, {
            scope: "global",
            inherits: []
          }, true);
        }
      }
      initializeDone() {
        return !!InitializeProgress.__done;
      }
      initialize() {
        return new Promise(async (resolve) => {
          if (InitializeProgress.__done) {
            resolve(true);
          } else {
            InitializeProgress.push(resolve);
            if (!InitializeProgress.__waiting) {
              InitializeProgress.__waiting = true;
              InitializeProgress.__done = false;
              await this.__loadGlobalTypes();
              await this.__loadPluginTypes();
              InitializeProgress.__waiting = false;
              InitializeProgress.__done = true;
              let progress = null;
              while (progress = InitializeProgress.shift()) {
                progress(true);
              }
              this.dispatcher("initialized");
            }
          }
        });
      }
      async doLoadPluginTypes(dataset) {
        if (dataset && dataset.size > 0) {
          const pluginTypes = Array.from(dataset.values());
          pluginTypes.sort((a, b) => {
            const a1 = a.esconfig.inherits;
            const b1 = b.esconfig.inherits;
            let aa = a1.length;
            let bb = b1.length;
            if (b1.includes(a1.scope)) {
              bb++;
            } else if (a1.includes(b1.scope)) {
              aa++;
            }
            return aa - bb;
          });
          return await this.callSequential(pluginTypes.map((item2) => async () => await this.loadTypes(item2.files, item2.esconfig)));
        }
      }
      async callSequential(asyncQueues) {
        return await new Promise((resolve) => {
          const tasks = asyncQueues.slice(0);
          const items = [];
          const next = (res) => {
            items.push(res);
            execute();
          };
          const execute = () => {
            const callback = tasks.shift();
            if (callback) {
              if (typeof callback === "function") {
                callback().then(next).catch(next);
              } else if (callback instanceof Promise) {
                callback.then(next).catch(next);
              } else {
                throw new TypeError("Compiler.callSequential called an non-promise object.");
              }
            } else {
              resolve(items);
            }
          };
          execute();
        });
      }
      async loadTypes(types, pluginScope, isGlobal = false) {
        if (!pluginScope || typeof pluginScope !== "object") {
          throw new Error("Invalid pluginScope");
        } else if (!pluginScope.scope || typeof pluginScope.scope !== "string") {
          throw new Error("Invalid pluginScope.scope");
        }
        if (typeof types === "string") {
          types = [types];
        }
        if (!Array.isArray(types)) {
          const message = Diagnostic.getMessage(this.options.lang, 1095, [types]);
          throw new Error(message);
        }
        const exclude = (Array.isArray(this.options.excludeDescribeFile) ? this.options.excludeDescribeFile : []).map((file) => this.pathAbsolute(file));
        const compilations2 = [];
        const createAsync = async (file) => {
          const aFile = this.pathAbsolute(file);
          if (exclude.includes(aFile) || cacheHandle.create.records(aFile)) {
            return;
          }
          const compilation = await this.createCompilation(aFile, null, true);
          if (compilation && !compilation.stack && !compilation.stackCreating) {
            compilation.pluginScopes = pluginScope;
            compilation.import = "scans";
            compilation.isGlobalFlag = isGlobal;
            compilation.createStack();
            compilations2.push(compilation);
          }
          if (compilation && pluginScope.scope === "global") {
            this.globals.add(compilation);
          }
        };
        await Promise.allSettled(types.map((file) => createAsync(file)));
        await Promise.allSettled(compilations2.map((compilation) => compilation.createCompleted()));
        await Promise.allSettled(compilations2.map((compilation) => compilation.parserAsync()));
        return compilations2;
      }
      checkPlugin(plugin) {
        const result = pluginInterfaces.find((item2) => {
          const value = plugin[item2.name];
          if (!value && item2.option !== true) {
            throw new Error(`Plugin interface '${item2.name}' not implemented.`);
          }
          return !item2.type.includes(typeof value);
        });
        if (result) {
          throw new Error(`Plugin interface '${result.name}' implemented members type not compatible. must is "${result.type.join(",")}"`);
        }
      }
      applyPlugin(plugin) {
        if (!plugin) {
          throw new Error(`Apply plugin invalid. give null`);
        }
        let pluginClass = plugin;
        let pluginOptions = null;
        if (Object.prototype.toString.call(plugin) === "[object Object]") {
          if (Object.prototype.hasOwnProperty.call(plugin, "plugin")) {
            pluginClass = plugin.plugin;
            pluginOptions = plugin.options;
            if (typeof pluginClass === "string") {
              pluginClass = __require(pluginClass);
            }
          } else if (Object.prototype.hasOwnProperty.call(plugin, "name")) {
            pluginClass = __require(plugin.name);
            pluginOptions = plugin.options;
          } else {
            throw new Error(`Plugin config property the 'plugin' is not defined. correct as "{plugin:'plugin-name',options:{}}"`);
          }
        }
        if (typeof pluginClass !== "function") {
          throw new Error(`Plugin is not function.`);
        } else {
          const instance = new pluginClass(this, pluginOptions || {});
          this.checkPlugin(instance);
          this.pluginInstances.push(instance);
          return instance;
        }
      }
      isPluginInContext(plugin, context, globalResult = true) {
        return this.pluginScopeManager.checkByPlugin(plugin, context, globalResult);
      }
      checkContenxtDescriptor(descriptor, context, globalResult = true) {
        return this.pluginScopeManager.checkByDescriptor(descriptor, context, globalResult);
      }
      async start(plugins, done) {
        throw new Error("compiler.build is deprecated. use ready method.");
      }
      async build(file, plugin, done) {
        throw new Error("compiler.build is deprecated. use ready method.");
      }
      async ready(file) {
        if (!this.initializeDone()) {
          await this.initialize();
        }
        if (file) {
          let compilation = file;
          if (typeof file === "string") {
            file = file.trim();
            if (file.startsWith("esglobal:")) {
              file = file.slice(9);
            }
            compilation = Namespace2.globals.has(file) ? Namespace2.globals.get(file).compilation : await this.createCompilation(file);
          }
          if (compilation instanceof Compilation) {
            return await compilation.ready();
          } else {
            throw new Error(`The '${String(file)}' file was not resolved.`);
          }
        }
        return null;
      }
    };
    Compiler.start = (options, callback) => {
    };
    Compiler.buildTypesManifest = async (paths, scope = {}, output = null, options = {}) => {
      const inherits = [];
      const compiler = new Compiler(Object.assign({
        scanTypings: false
      }, options.compilerOptions || {}));
      await compiler.initialize();
      const resolveFilePath = (paths2) => {
        const items = [];
        paths2.forEach((file) => {
          const files2 = Utils2.readdir(file, true);
          if (files2) {
            items.push(...files2);
          } else if (file) {
            items.push(file);
          }
        });
        return items;
      };
      const resolvePkgFile = (name) => {
        try {
          return __require.resolve(path.join(name, "package.json"), options.resolvePaths ? { paths: options.resolvePaths } : void 0);
        } catch (e) {
          return null;
        }
      };
      const inheritScopes = [];
      const _dataset = /* @__PURE__ */ new Map();
      const parseInherit = (name) => {
        const file = resolvePkgFile(name);
        if (file) {
          compiler.resolveTypingsFromPackage(file, _dataset);
        }
      };
      if (Array.isArray(options.additions) && options.additions.length > 0) {
        inherits.push(...resolveFilePath(options.additions));
      }
      if (Array.isArray(scope.inherits)) {
        scope.inherits.forEach(parseInherit);
      }
      _dataset.forEach((value) => {
        inheritScopes.push(value.esconfig.scope);
        inherits.push(...value.files);
      });
      if (inherits && inherits.length > 0) {
        await compiler.loadTypes(resolveFilePath(inherits), { scope: "unknown" });
      }
      paths = resolveFilePath(paths);
      await compiler.loadTypes(paths, { scope: "unknown" });
      const locals = /* @__PURE__ */ new Set();
      paths.forEach((file) => {
        const res = compiler.getCompilation(file);
        if (res) {
          locals.add(res);
        }
      });
      compiler.compilations.forEach((compilation) => {
        let flag = false;
        let com = compilation;
        while (com && !(flag = locals.has(com))) {
          com = com.parent;
        }
        if (flag) {
          locals.add(compilation);
        }
      });
      if (output) {
        output = path.isAbsolute(output) ? output : path.join(compiler.options.cwd, output);
        if (!/\.json/.test(output)) {
          output = path.join(output, compiler.options.manifestFileName);
        }
      } else {
        output = path.join(compiler.options.cwd, compiler.options.manifestFileName);
      }
      const dataset = {};
      const files = /* @__PURE__ */ new Set();
      const rootPath = path.dirname(output);
      const excludes = options.excludes || ["/node_modules/"];
      const exclude = (file) => {
        return Array.isArray(excludes) && excludes.some((name) => file.includes(name));
      };
      locals.forEach((compilation) => {
        if (compilation.isGlobalFlag)
          return;
        compilation.namespaceSets.forEach((ns) => {
          ns.modules.forEach((item2, name) => {
            if (exclude(compilation.file) || !item2.compilation)
              return;
            if (item2.compilation.isGlobalFlag)
              return;
            let isLocal = item2.compilation === compilation;
            if (item2.isModule) {
              isLocal = item2.files.includes(compilation.file);
            }
            if (isLocal && !inheritScopes.includes(compilation.pluginScopes.scope)) {
              const descFiles = item2.isModule ? item2.files : [item2.compilation.file];
              const key = ns.identifier ? `${ns.fullName}.${name}` : name;
              const data = dataset[key] || (dataset[key] = { indexers: [] });
              descFiles.forEach((file) => {
                if (!files.has(file)) {
                  files.add(file);
                }
                const index = files.size - 1;
                if (!data.indexers.includes(index)) {
                  data.indexers.push(index);
                }
              });
            }
          });
        });
      });
      const relativeModulePath = compiler.normalizePath(path.join(compiler.options.cwd, "node_modules"));
      const jsondata = {
        scope,
        files: Array.from(files.values()).map((file) => {
          if (file.includes(relativeModulePath)) {
            return compiler.normalizePath(path.join(path.relative(output, compiler.options.cwd), path.relative(relativeModulePath, file)));
          }
          return compiler.normalizePath(path.relative(rootPath, file));
        }),
        types: dataset
      };
      let dir = output;
      const segs = [];
      while (dir && !fs.existsSync(dir = path.dirname(dir))) {
        segs.push(dir);
      }
      while (segs.length > 0) {
        fs.mkdirSync(segs.pop());
      }
      fs.writeFileSync(output, JSON.stringify(jsondata));
      console.info(`build successful output: '${output}'`);
      return true;
    };
    Compiler.SharedInstances = SharedInstances;
    module.exports = Compiler;
  }
});

// lib/index.js
var import_Compiler = __toESM(require_Compiler());
var import_Compilation = __toESM(require_Compilation());
var import_Constant = __toESM(require_Constant());
var import_Namespace = __toESM(require_Namespace());
var import_Range = __toESM(require_Range());
var import_Utils = __toESM(require_Utils());
var export_Compilation = import_Compilation.default;
var export_Compiler = import_Compiler.default;
var export_Constant = import_Constant.default;
var export_Namespace = import_Namespace.default;
var export_Range = import_Range.default;
var export_Utils = import_Utils.default;
export {
  export_Compilation as Compilation,
  export_Compiler as Compiler,
  export_Constant as Constant,
  export_Namespace as Namespace,
  export_Range as Range,
  export_Utils as Utils
};
